[gd_scene load_steps=5 format=3 uid="uid://bdfqxy8t5wj7a"]

[ext_resource type="Script" path="res://core/UniversalBeing.gd" id="1_8m9ja"]
[ext_resource type="Script" path="res://beings/player/player_universal_being.gd" id="2_n5k9c"]

[sub_resource type="Environment" id="Environment_1_xm9ja"]
background_mode = 1
background_color = Color(0.02, 0.02, 0.08, 1)
ambient_light_source = 2
ambient_light_color = Color(0.1, 0.1, 0.3, 1)
ambient_light_energy = 0.3

[sub_resource type="GDScript" id="GDScript_1_ultimate"]
script/source = "# SPACE_GAME_ULTIMATE_V3.gd - Pentagon Architecture Compliant Space Game
# The \"best space game in existence\" with full 3D visual feedback and consciousness integration
extends UniversalBeing
class_name SpaceGameUltimateV3

# === PENTAGON ARCHITECTURE COMPLIANCE ===
# ALL Pentagon lifecycle methods properly implemented with super() calls

# === STELLAR COLOR PROGRESSION CONSTANTS ===
# Based on stellar evolution: black → dark brown → red → orange → yellow → white → light blue → blue → purple
const STELLAR_COLORS = [
	Color(0.0, 0.0, 0.0),      # 0: Black (void/space)
	Color(0.2, 0.1, 0.05),     # 1: Dark Brown (cooling dwarf)
	Color(0.8, 0.2, 0.1),      # 2: Red (red giant)
	Color(1.0, 0.4, 0.1),      # 3: Orange (cooling star)
	Color(1.0, 0.9, 0.2),      # 4: Yellow (sun-like)
	Color(1.0, 1.0, 1.0),      # 5: White (hot star)
	Color(0.7, 0.9, 1.0),      # 6: Light Blue (very hot)
	Color(0.4, 0.6, 1.0),      # 7: Blue (extremely hot)
	Color(0.6, 0.3, 1.0)       # 8: Purple (neutron star/exotic)
]

# === GAME STATE ===
var resources = {
	\"metal\": 100,
	\"energy\": 50,
	\"crystals\": 0,
	\"consciousness_shards\": 0  # New resource for consciousness evolution
}

var player_state = {
	\"in_mecha\": false,
	\"mecha_hp\": 100,
	\"mecha_energy\": 100,
	\"consciousness_level\": 2,  # Start at Aware (Blue)
	\"stellar_evolution_stage\": 4  # Start at Yellow (sun-like)
}

var mining_state = {
	\"is_mining\": false,
	\"target_asteroid\": null,
	\"mining_progress\": 0.0,
	\"beam_intensity\": 0.0
}

# === 3D VISUAL SYSTEMS ===
@onready var visual_feedback_system: Node3D = $VisualFeedbackSystem
@onready var stellar_hud: Control = $StellarHUD
@onready var consciousness_visualizer: Node3D = $ConsciousnessVisualizer
@onready var mining_beam_system: Node3D = $MiningBeamSystem
@onready var mecha_system: Node3D = $MechaSystem
@onready var space_environment: Node3D = $SpaceEnvironment

# === PENTAGON LIFECYCLE METHODS ===

func pentagon_init() -> void:
	super.pentagon_init()  # ALWAYS FIRST
	
	being_type = \"space_game_ultimate_v3\"
	being_name = \"Space Game Ultimate V3\"
	consciousness_level = 2  # Aware (Blue)
	
	# Initialize stellar color system
	_setup_stellar_color_system()
	
	# Create 3D visual feedback instead of print statements
	_create_startup_constellation()

func pentagon_ready() -> void:
	super.pentagon_ready()  # ALWAYS FIRST
	
	# Setup all game systems with 3D visuals
	_setup_space_environment()
	_setup_mining_systems()
	_setup_mecha_systems()
	_setup_consciousness_systems()
	_setup_stellar_hud()
	
	# Show startup message in 3D
	_show_stellar_message(\"🚀 SPACE GAME ULTIMATE V3 ONLINE\", \"All systems functional - Pentagon Architecture active\", STELLAR_COLORS[4])

func pentagon_process(delta: float) -> void:
	super.pentagon_process(delta)  # ALWAYS FIRST
	
	_update_mining_systems(delta)
	_update_consciousness_evolution(delta)
	_update_stellar_effects(delta)
	_update_resource_visualization(delta)

func pentagon_input(event: InputEvent) -> void:
	super.pentagon_input(event)  # ALWAYS FIRST
	
	if event.is_action_pressed(\"interact\"):  # E key - now exclusively for interaction
		_handle_interaction()
	elif event.is_action_pressed(\"move_down\"):  # F key - fixed from E key conflict
		_handle_move_down()
	elif event.is_action_pressed(\"jump\"):  # SPACE - toggle mining
		_toggle_mining_beam()
	elif event.is_action_pressed(\"key_q\"):  # Q - mecha toggle
		_toggle_mecha_mode()

func pentagon_sewers() -> void:
	# Clean up all visual systems
	_cleanup_visual_systems()
	super.pentagon_sewers()  # ALWAYS LAST

# === STELLAR COLOR SYSTEM ===

func _setup_stellar_color_system():
	# Initialize stellar evolution based visualization
	_update_consciousness_stellar_color()

func _get_stellar_color(stage: int) -> Color:
	return STELLAR_COLORS[clamp(stage, 0, STELLAR_COLORS.size() - 1)]

func _update_consciousness_stellar_color():
	var color = _get_stellar_color(player_state.stellar_evolution_stage)
	# Update consciousness glow color
	if has_method(\"set_consciousness_color\"):
		set_consciousness_color(color)

# === 3D VISUAL FEEDBACK FUNCTIONS (NO PRINT STATEMENTS) ===

func _create_startup_constellation():
	# Create constellation of lights that spell out startup message
	var constellation_parent = Node3D.new()
	constellation_parent.name = \"StartupConstellation\"
	add_child(constellation_parent)
	
	var message = \"SPACE GAME ULTIMATE V3\"
	var letter_spacing = 5.0
	var start_pos = Vector3(-message.length() * letter_spacing * 0.5, 50, 0)
	
	for i in range(message.length()):
		var light = OmniLight3D.new()
		light.light_color = _get_stellar_color(4)  # Yellow
		light.light_energy = 2.0
		light.omni_range = 10.0
		light.position = start_pos + Vector3(i * letter_spacing, sin(i * 0.5) * 2, 0)
		constellation_parent.add_child(light)
		
		# Animated twinkle
		var tween = create_tween()
		tween.set_loops()
		tween.tween_property(light, \"light_energy\", 0.5, 1.0)
		tween.tween_property(light, \"light_energy\", 2.0, 1.0)
	
	# Auto-cleanup after 5 seconds
	var cleanup_timer = Timer.new()
	cleanup_timer.timeout.connect(_cleanup_startup_constellation.bind(constellation_parent))
	cleanup_timer.wait_time = 5.0
	cleanup_timer.one_shot = true
	add_child(cleanup_timer)
	cleanup_timer.start()

func _cleanup_startup_constellation(constellation: Node3D):
	if constellation and is_instance_valid(constellation):
		constellation.queue_free()

func _show_stellar_message(title: String, subtitle: String, color: Color):
	# Create floating 3D text with stellar glow
	var text_node = Label3D.new()
	text_node.text = title
	text_node.billboard = BaseMaterial3D.BILLBOARD_ENABLED
	text_node.position = global_position + Vector3(0, 10, 0)
	text_node.modulate = color
	
	# Add glow effect
	var glow_light = OmniLight3D.new()
	glow_light.light_color = color
	glow_light.light_energy = 1.5
	glow_light.omni_range = 15.0
	text_node.add_child(glow_light)
	
	get_parent().add_child(text_node)
	
	# Subtitle
	if subtitle != \"\": 
		var subtitle_node = Label3D.new()
		subtitle_node.text = subtitle
		subtitle_node.billboard = BaseMaterial3D.BILLBOARD_ENABLED
		subtitle_node.position = Vector3(0, -2, 0)
		subtitle_node.modulate = color * 0.7
		text_node.add_child(subtitle_node)
	
	# Animated float up and fade
	var tween = create_tween()
	tween.parallel().tween_property(text_node, \"position\", text_node.position + Vector3(0, 20, 0), 3.0)
	tween.parallel().tween_property(text_node, \"modulate:a\", 0.0, 3.0)
	tween.tween_callback(text_node.queue_free)

func _show_resource_gain(resource_type: String, amount: int, pos: Vector3):
	# Create 3D particle effect for resource gain
	var particles = GPUParticles3D.new()
	particles.emitting = true
	particles.amount = amount * 5  # More particles for more resources
	particles.lifetime = 2.0
	particles.position = pos
	
	# Color based on resource type and stellar progression
	var color = Color.WHITE
	match resource_type:
		\"metal\": color = _get_stellar_color(2)  # Red
		\"energy\": color = _get_stellar_color(4)  # Yellow 
		\"crystals\": color = _get_stellar_color(6)  # Light Blue
		\"consciousness_shards\": color = _get_stellar_color(8)  # Purple
	
	var material = ParticleProcessMaterial.new()
	material.direction = Vector3(0, 1, 0)
	material.spread = 45.0
	material.initial_velocity_min = 5.0
	material.initial_velocity_max = 15.0
	material.gravity = Vector3(0, -2, 0)
	material.scale_min = 0.5
	material.scale_max = 1.5
	particles.process_material = material
	
	get_parent().add_child(particles)
	
	# Show floating text
	_show_stellar_message(\"+%d %s\" % [amount, resource_type.capitalize()], \"\", color)
	
	# Cleanup particles
	var cleanup_timer = Timer.new()
	cleanup_timer.timeout.connect(particles.queue_free)
	cleanup_timer.wait_time = 3.0
	cleanup_timer.one_shot = true
	add_child(cleanup_timer)
	cleanup_timer.start()

func _show_status_update(status_text: String, status_color: Color):
	# Create holographic status display
	var status_display = Node3D.new()
	status_display.position = global_position + Vector3(0, 5, 0)
	
	var status_label = Label3D.new()
	status_label.text = status_text
	status_label.billboard = BaseMaterial3D.BILLBOARD_ENABLED
	status_label.modulate = status_color
	status_display.add_child(status_label)
	
	# Holographic scan lines effect
	var scan_lines = MeshInstance3D.new()
	var quad_mesh = QuadMesh.new()
	quad_mesh.size = Vector2(10, 5)
	scan_lines.mesh = quad_mesh
	
	var scan_material = StandardMaterial3D.new()
	scan_material.albedo_color = status_color
	scan_material.emission_enabled = true
	scan_material.emission = status_color
	scan_material.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
	scan_material.albedo_color.a = 0.3
	scan_lines.material_override = scan_material
	
	status_display.add_child(scan_lines)
	get_parent().add_child(status_display)
	
	# Animate hologram effect
	var tween = create_tween()
	tween.set_loops(3)
	tween.tween_property(scan_material, \"albedo_color:a\", 0.1, 0.5)
	tween.tween_property(scan_material, \"albedo_color:a\", 0.3, 0.5)
	tween.tween_callback(status_display.queue_free)

# === SPACE ENVIRONMENT SETUP ===

func _setup_space_environment():
	# Create close-range space environment (everything within 100 units)
	_create_nearby_asteroids()
	_create_space_station()
	_create_planets()
	_create_background_stars()

func _create_nearby_asteroids():
	# Create 5-10 mineable asteroids nearby
	var asteroid_count = randi_range(5, 10)
	
	for i in range(asteroid_count):
		var asteroid = _create_asteroid(
			Vector3(randf_range(-80, 80), randf_range(-30, 30), randf_range(-80, 80)),
			randf_range(5, 15),
			randi_range(50, 200),  # metal
			randi_range(20, 100)   # energy
		)
		space_environment.add_child(asteroid)
	
	_show_stellar_message(\"⛏️ %d Asteroids Generated\" % asteroid_count, \"Close-range mining ready\", _get_stellar_color(3))

func _create_asteroid(pos: Vector3, size: float, metal: int, energy: int) -> RigidBody3D:
	var asteroid = RigidBody3D.new()
	asteroid.position = pos
	asteroid.set_meta(\"mineable\", true)
	asteroid.set_meta(\"metal_amount\", metal)
	asteroid.set_meta(\"energy_amount\", energy)
	asteroid.set_meta(\"original_metal\", metal)
	asteroid.set_meta(\"original_energy\", energy)
	
	# Visual mesh
	var mesh_instance = MeshInstance3D.new()
	var sphere = SphereMesh.new()
	sphere.radius = size
	mesh_instance.mesh = sphere
	asteroid.add_child(mesh_instance)
	
	# Collision
	var collision = CollisionShape3D.new()
	var shape = SphereShape3D.new()
	shape.radius = size
	collision.shape = shape
	asteroid.add_child(collision)
	
	# Stellar material based on resource content
	var material = StandardMaterial3D.new()
	var resource_ratio = float(metal) / (metal + energy)
	if resource_ratio > 0.7:
		material.albedo_color = _get_stellar_color(2)  # Red (metal-rich)
	elif resource_ratio < 0.3:
		material.albedo_color = _get_stellar_color(4)  # Yellow (energy-rich) 
	else:
		material.albedo_color = _get_stellar_color(1)  # Dark Brown (mixed)
		
	material.emission_enabled = true
	material.emission = material.albedo_color * 0.3
	mesh_instance.material_override = material
	
	# Resource indicator lights
	var indicator_light = OmniLight3D.new()
	indicator_light.light_color = material.albedo_color
	indicator_light.light_energy = 0.5
	indicator_light.omni_range = size * 3
	asteroid.add_child(indicator_light)
	
	return asteroid

func _create_space_station():
	var station = StaticBody3D.new()
	station.position = Vector3(60, 20, 40)
	station.set_meta(\"station_type\", \"trading\")
	
	# Station mesh
	var mesh_instance = MeshInstance3D.new()
	var box = BoxMesh.new()
	box.size = Vector3(15, 8, 15)
	mesh_instance.mesh = box
	station.add_child(mesh_instance)
	
	# Station material - white (advanced civilization)
	var material = StandardMaterial3D.new()
	material.albedo_color = _get_stellar_color(5)  # White
	material.emission_enabled = true
	material.emission = _get_stellar_color(5) * 0.4
	mesh_instance.material_override = material
	
	# Docking lights
	for i in range(4):
		var light = OmniLight3D.new()
		light.light_color = _get_stellar_color(6)  # Light Blue
		light.light_energy = 1.0
		light.omni_range = 25.0
		var angle = i * PI * 0.5
		light.position = Vector3(cos(angle) * 8, 0, sin(angle) * 8)
		station.add_child(light)
	
	space_environment.add_child(station)
	_show_stellar_message(\"🏭 Trading Station Online\", \"Docking available\", _get_stellar_color(5))

func _create_planets():
	# Create 2-3 nearby planets
	var planet_count = randi_range(2, 3)
	var planet_types = [\"desert\", \"ice\", \"lava\", \"forest\"]
	
	for i in range(planet_count):
		var planet_type = planet_types[randi() % planet_types.size()]
		var planet = _create_planet(
			Vector3(randf_range(-150, 150), randf_range(-50, 50), randf_range(-150, 150)),
			randf_range(20, 40),
			planet_type
		)
		space_environment.add_child(planet)
	
	_show_stellar_message(\"🌍 %d Planets Discovered\" % planet_count, \"Exploration ready\", _get_stellar_color(7))

func _create_planet(pos: Vector3, size: float, planet_type: String) -> StaticBody3D:
	var planet = StaticBody3D.new()
	planet.position = pos
	planet.set_meta(\"planet_type\", planet_type)
	planet.set_meta(\"landable\", true)
	
	# Planet mesh
	var mesh_instance = MeshInstance3D.new()
	var sphere = SphereMesh.new()
	sphere.radius = size
	mesh_instance.mesh = sphere
	planet.add_child(mesh_instance)
	
	# Planet material based on type and stellar colors
	var material = StandardMaterial3D.new()
	match planet_type:
		\"desert\": material.albedo_color = _get_stellar_color(3)  # Orange
		\"ice\": material.albedo_color = _get_stellar_color(6)     # Light Blue
		\"lava\": material.albedo_color = _get_stellar_color(2)    # Red  
		\"forest\": material.albedo_color = _get_stellar_color(1)  # Dark Brown
	
	material.emission_enabled = true
	material.emission = material.albedo_color * 0.2
	mesh_instance.material_override = material
	
	# Atmospheric glow
	var atmosphere = MeshInstance3D.new()
	var atmo_sphere = SphereMesh.new()
	atmo_sphere.radius = size * 1.1
	atmosphere.mesh = atmo_sphere
	
	var atmo_material = StandardMaterial3D.new()
	atmo_material.albedo_color = material.albedo_color
	atmo_material.albedo_color.a = 0.3
	atmo_material.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
	atmo_material.cull_mode = BaseMaterial3D.CULL_FRONT
	atmosphere.material_override = atmo_material
	planet.add_child(atmosphere)
	
	return planet

func _create_background_stars():
	# Create distant star field with stellar colors
	for i in range(200):
		var star = OmniLight3D.new()
		var stellar_stage = randi_range(2, 7)  # Various star types
		star.light_color = _get_stellar_color(stellar_stage)
		star.light_energy = randf_range(0.1, 0.5)
		star.omni_range = randf_range(10, 50)
		star.position = Vector3(
			randf_range(-500, 500),
			randf_range(-200, 200), 
			randf_range(-500, 500)
		)
		space_environment.add_child(star)

# === MINING SYSTEM ===

func _setup_mining_systems():
	mining_beam_system = Node3D.new()
	mining_beam_system.name = \"MiningBeamSystem\"
	add_child(mining_beam_system)

func _toggle_mining_beam():
	if mining_state.is_mining:
		_stop_mining()
	else:
		_start_mining()

func _start_mining():
	var target = _find_nearest_mineable_asteroid()
	if not target:
		_show_status_update(\"❌ No asteroid in mining range\", _get_stellar_color(2))
		return
	
	var distance = global_position.distance_to(target.global_position)
	if distance > 50.0:
		_show_status_update(\"❌ Too far from asteroid (%.0fm)\" % distance, _get_stellar_color(2))
		return
	
	mining_state.is_mining = true
	mining_state.target_asteroid = target
	mining_state.mining_progress = 0.0
	
	_create_mining_beam(target)
	_show_status_update(\"⛏️ Mining beam activated\", _get_stellar_color(4))

func _stop_mining():
	mining_state.is_mining = false
	mining_state.target_asteroid = null
	mining_state.mining_progress = 0.0
	mining_state.beam_intensity = 0.0
	
	_cleanup_mining_beam()
	_show_status_update(\"⛏️ Mining beam deactivated\", _get_stellar_color(1))

func _create_mining_beam(target: Node3D):
	# Create visual mining beam
	var beam = MeshInstance3D.new()
	beam.name = \"MiningBeam\"
	
	var beam_mesh = CylinderMesh.new()
	beam_mesh.top_radius = 0.2
	beam_mesh.bottom_radius = 0.5
	beam_mesh.height = global_position.distance_to(target.global_position)
	beam.mesh = beam_mesh
	
	# Position beam between player and target
	var beam_pos = (global_position + target.global_position) * 0.5
	beam.global_position = beam_pos
	beam.look_at(target.global_position, Vector3.UP)
	beam.rotate_x(PI * 0.5)  # Cylinder orientation fix
	
	# Stellar energy material
	var beam_material = StandardMaterial3D.new()
	beam_material.albedo_color = _get_stellar_color(4)  # Yellow energy
	beam_material.emission_enabled = true
	beam_material.emission = _get_stellar_color(4)
	beam_material.emission_energy = 2.0
	beam_material.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
	beam_material.albedo_color.a = 0.7
	beam.material_override = beam_material
	
	mining_beam_system.add_child(beam)
	
	# Mining particles at impact point
	var particles = GPUParticles3D.new()
	particles.position = target.global_position
	particles.emitting = true
	particles.amount = 100
	particles.lifetime = 1.0
	
	var particle_material = ParticleProcessMaterial.new()
	particle_material.direction = Vector3(0, 1, 0)
	particle_material.spread = 45.0
	particle_material.initial_velocity_min = 2.0
	particle_material.initial_velocity_max = 8.0
	particle_material.gravity = Vector3(0, -5, 0)
	particles.process_material = particle_material
	
	mining_beam_system.add_child(particles)

func _cleanup_mining_beam():
	for child in mining_beam_system.get_children():
		child.queue_free()

func _update_mining_systems(delta: float):
	if not mining_state.is_mining or not mining_state.target_asteroid:
		return
	
	# Update mining progress
	mining_state.mining_progress += delta * 20.0  # Mining speed
	mining_state.beam_intensity = sin(Time.get_time_from_start() * 10.0) * 0.5 + 0.5
	
	# Update beam intensity
	var beam = mining_beam_system.get_node_or_null(\"MiningBeam\")
	if beam and beam.material_override:
		beam.material_override.emission_energy = 1.0 + mining_state.beam_intensity * 2.0
	
	# Check for resource extraction
	if mining_state.mining_progress >= 100.0:
		_extract_resources_from_asteroid(mining_state.target_asteroid)
		mining_state.mining_progress = 0.0

func _extract_resources_from_asteroid(asteroid: Node3D):
	var metal_amount = asteroid.get_meta(\"metal_amount\", 0)
	var energy_amount = asteroid.get_meta(\"energy_amount\", 0)
	
	if metal_amount <= 0 and energy_amount <= 0:
		_show_status_update(\"⛏️ Asteroid depleted\", _get_stellar_color(1))
		_stop_mining()
		return
	
	# Extract resources
	var metal_extracted = min(10, metal_amount)
	var energy_extracted = min(5, energy_amount)
	
	resources.metal += metal_extracted
	resources.energy += energy_extracted
	
	# Update asteroid
	asteroid.set_meta(\"metal_amount\", metal_amount - metal_extracted)
	asteroid.set_meta(\"energy_amount\", energy_amount - energy_extracted)
	
	# Visual feedback
	_show_resource_gain(\"metal\", metal_extracted, asteroid.global_position)
	_show_resource_gain(\"energy\", energy_extracted, asteroid.global_position + Vector3(0, 2, 0))
	
	# Update resource HUD
	_update_stellar_hud()

func _find_nearest_mineable_asteroid() -> Node3D:
	var nearest = null
	var min_distance = 50.0  # Mining range
	
	for child in space_environment.get_children():
		if child.has_meta(\"mineable\") and child.get_meta(\"mineable\"):
			var distance = global_position.distance_to(child.global_position)
			if distance < min_distance:
				min_distance = distance
				nearest = child
	
	return nearest

# === MECHA SYSTEM ===

func _setup_mecha_systems():
	mecha_system = Node3D.new()
	mecha_system.name = \"MechaSystem\"
	add_child(mecha_system)
	
	_spawn_mecha_nearby()

func _spawn_mecha_nearby():
	var mecha = _create_mecha(global_position + Vector3(10, 0, 10))
	mecha_system.add_child(mecha)
	_show_stellar_message(\"🤖 Mecha deployed\", \"Ready for piloting\", _get_stellar_color(5))

func _create_mecha(pos: Vector3) -> Node3D:
	var mecha = Node3D.new()
	mecha.position = pos
	mecha.set_meta(\"mecha\", true)
	mecha.set_meta(\"hp\", 100)
	mecha.set_meta(\"energy\", 100)
	
	# Mecha body
	var body = MeshInstance3D.new()
	var box = BoxMesh.new()
	box.size = Vector3(3, 4, 2)
	body.mesh = box
	mecha.add_child(body)
	
	# Mecha material - advanced white metal
	var material = StandardMaterial3D.new()
	material.albedo_color = _get_stellar_color(5)  # White
	material.metallic = 0.8
	material.roughness = 0.2
	material.emission_enabled = true
	material.emission = _get_stellar_color(6) * 0.3  # Light Blue glow
	body.material_override = material
	
	# Status lights
	var status_light = OmniLight3D.new()
	status_light.light_color = _get_stellar_color(6)  # Light Blue
	status_light.light_energy = 1.0
	status_light.omni_range = 10.0
	status_light.position = Vector3(0, 2.5, 0)
	mecha.add_child(status_light)
	
	return mecha

func _toggle_mecha_mode():
	if player_state.in_mecha:
		_exit_mecha()
	else:
		_enter_mecha()

func _enter_mecha():
	var mecha = _find_nearest_mecha()
	if not mecha:
		_show_status_update(\"❌ No mecha nearby\", _get_stellar_color(2))
		return
	
	var distance = global_position.distance_to(mecha.global_position)
	if distance > 15.0:
		_show_status_update(\"❌ Too far from mecha (%.0fm)\" % distance, _get_stellar_color(2))
		return
	
	player_state.in_mecha = true
	player_state.mecha_hp = mecha.get_meta(\"hp\", 100)
	player_state.mecha_energy = mecha.get_meta(\"energy\", 100)
	
	# Move player to mecha position
	global_position = mecha.global_position + Vector3(0, 2, 0)
	
	# Visual feedback
	_show_status_update(\"🤖 Mecha pilot mode active\", _get_stellar_color(5))
	_update_consciousness_color_for_mecha()

func _exit_mecha():
	player_state.in_mecha = false
	
	# Move player next to mecha
	global_position += Vector3(5, 0, 0)
	
	_show_status_update(\"⚡ Returned to plasmoid form\", _get_stellar_color(4))
	_update_consciousness_stellar_color()  # Restore original color

func _find_nearest_mecha() -> Node3D:
	var nearest = null
	var min_distance = 15.0
	
	for child in mecha_system.get_children():
		if child.has_meta(\"mecha\"):
			var distance = global_position.distance_to(child.global_position)
			if distance < min_distance:
				min_distance = distance
				nearest = child
	
	return nearest

func _update_consciousness_color_for_mecha():
	# When in mecha, consciousness shifts to white (advanced tech)
	if has_method(\"set_consciousness_color\"):
		set_consciousness_color(_get_stellar_color(5))

# === INTERACTION SYSTEM ===

func _handle_interaction():
	var target = _find_nearest_interactable()
	if not target:
		_show_status_update(\"❌ Nothing to interact with\", _get_stellar_color(2))
		return
	
	var distance = global_position.distance_to(target.global_position)
	if distance > 20.0:
		_show_status_update(\"❌ Too far from target (%.0fm)\" % distance, _get_stellar_color(2))
		return
	
	# Handle different interaction types
	if target.has_meta(\"station_type\"):
		_handle_station_interaction(target)
	elif target.has_meta(\"planet_type\"):
		_handle_planet_interaction(target)
	elif target.has_meta(\"mecha\"):
		_toggle_mecha_mode()
	else:
		_show_status_update(\"❌ Cannot interact with this object\", _get_stellar_color(2))

func _handle_station_interaction(station: Node3D):
	var station_type = station.get_meta(\"station_type\")
	
	match station_type:
		\"trading\":
			_open_trading_interface()
		_:
			_show_status_update(\"🏭 Docked at station\", _get_stellar_color(5))

func _open_trading_interface():
	if resources.metal >= 10:
		var trade_amount = min(resources.metal / 10, 50)  # Convert metal to crystals
		resources.metal -= trade_amount * 10
		resources.crystals += trade_amount
		
		_show_resource_gain(\"crystals\", trade_amount, global_position + Vector3(0, 5, 0))
		_show_status_update(\"💰 Trade successful: -%d metal, +%d crystals\" % [trade_amount * 10, trade_amount], _get_stellar_color(6))
	else:
		_show_status_update(\"❌ Need at least 10 metal to trade\", _get_stellar_color(2))
	
	_update_stellar_hud()

func _handle_planet_interaction(planet: Node3D):
	var planet_type = planet.get_meta(\"planet_type\")
	
	# Landing gives energy based on planet type
	var energy_found = 0
	match planet_type:
		\"desert\": energy_found = 15
		\"ice\": energy_found = 10  
		\"lava\": energy_found = 25
		\"forest\": energy_found = 20
	
	resources.energy += energy_found
	_show_resource_gain(\"energy\", energy_found, planet.global_position)
	_show_status_update(\"🌍 Landed on %s planet\" % planet_type, _get_stellar_color(7))
	_update_stellar_hud()

func _find_nearest_interactable() -> Node3D:
	var nearest = null
	var min_distance = 20.0
	
	for child in space_environment.get_children():
		if child.has_meta(\"station_type\") or child.has_meta(\"planet_type\"):
			var distance = global_position.distance_to(child.global_position)
			if distance < min_distance:
				min_distance = distance
				nearest = child
	
	# Also check mechas
	for child in mecha_system.get_children():
		if child.has_meta(\"mecha\"):
			var distance = global_position.distance_to(child.global_position)
			if distance < min_distance:
				min_distance = distance
				nearest = child
	
	return nearest

func _handle_move_down():
	# F key - move down (fixed from E key conflict)
	if has_method(\"apply_movement_input\"):
		var input_vector = Vector3(0, -1, 0)
		apply_movement_input(input_vector)

# === CONSCIOUSNESS EVOLUTION ===

func _setup_consciousness_systems():
	consciousness_visualizer = Node3D.new()
	consciousness_visualizer.name = \"ConsciousnessVisualizer\" 
	add_child(consciousness_visualizer)

func _update_consciousness_evolution(delta: float):
	# Consciousness evolves based on activities and resources
	var evolution_rate = 0.0
	
	# Mining increases consciousness
	if mining_state.is_mining:
		evolution_rate += 1.0
	
	# Having resources increases consciousness
	evolution_rate += (resources.crystals * 0.1)
	evolution_rate += (resources.consciousness_shards * 0.5)
	
	# Being in mecha provides technological consciousness boost
	if player_state.in_mecha:
		evolution_rate += 2.0
	
	# Apply evolution
	if evolution_rate > 0:
		var evolution_progress = evolution_rate * delta
		if randf() < evolution_progress * 0.01:  # Chance to evolve
			_try_consciousness_evolution()

func _try_consciousness_evolution():
	if player_state.stellar_evolution_stage < STELLAR_COLORS.size() - 1:
		player_state.stellar_evolution_stage += 1
		player_state.consciousness_level += 1
		
		var new_color = _get_stellar_color(player_state.stellar_evolution_stage)
		_show_stellar_message(\"✨ Consciousness Evolved\", \"Stellar stage: %d\" % player_state.stellar_evolution_stage, new_color)
		
		# Grant consciousness shards as reward
		resources.consciousness_shards += 5
		_show_resource_gain(\"consciousness_shards\", 5, global_position + Vector3(0, 8, 0))
		
		_update_consciousness_stellar_color()
		_update_stellar_hud()

# === STELLAR HUD SYSTEM ===

func _setup_stellar_hud():
	stellar_hud = Control.new()
	stellar_hud.name = \"StellarHUD\"
	stellar_hud.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	add_child(stellar_hud)
	
	_create_resource_display()
	_create_status_display()

func _create_resource_display():
	var resource_panel = Panel.new()
	resource_panel.position = Vector2(20, 20)
	resource_panel.size = Vector2(300, 120)
	stellar_hud.add_child(resource_panel)
	
	var vbox = VBoxContainer.new()
	resource_panel.add_child(vbox)
	
	# Resource labels with stellar colors
	var metal_label = Label.new()
	metal_label.name = \"MetalLabel\"
	metal_label.text = \"Metal: %d\" % resources.metal
	vbox.add_child(metal_label)
	
	var energy_label = Label.new()
	energy_label.name = \"EnergyLabel\"  
	energy_label.text = \"Energy: %d\" % resources.energy
	vbox.add_child(energy_label)
	
	var crystals_label = Label.new()
	crystals_label.name = \"CrystalsLabel\"
	crystals_label.text = \"Crystals: %d\" % resources.crystals
	vbox.add_child(crystals_label)
	
	var shards_label = Label.new()
	shards_label.name = \"ShardsLabel\"
	shards_label.text = \"Consciousness Shards: %d\" % resources.consciousness_shards
	vbox.add_child(shards_label)

func _create_status_display():
	var status_panel = Panel.new()
	status_panel.position = Vector2(20, 160)
	status_panel.size = Vector2(300, 100)
	stellar_hud.add_child(status_panel)
	
	var vbox = VBoxContainer.new()
	status_panel.add_child(vbox)
	
	var consciousness_label = Label.new()
	consciousness_label.name = \"ConsciousnessLabel\"
	consciousness_label.text = \"Consciousness Level: %d\" % player_state.consciousness_level
	vbox.add_child(consciousness_label)
	
	var stellar_label = Label.new()
	stellar_label.name = \"StellarLabel\"
	stellar_label.text = \"Stellar Stage: %d\" % player_state.stellar_evolution_stage
	vbox.add_child(stellar_label)
	
	var mode_label = Label.new()
	mode_label.name = \"ModeLabel\"
	mode_label.text = \"Mode: %s\" % (\"Mecha\" if player_state.in_mecha else \"Plasmoid\")
	vbox.add_child(mode_label)

func _update_stellar_hud():
	if not stellar_hud:
		return
	
	# Update resource display
	var resource_panel = stellar_hud.get_node_or_null(\"Panel/VBoxContainer\")
	if resource_panel:
		resource_panel.get_node(\"MetalLabel\").text = \"Metal: %d\" % resources.metal
		resource_panel.get_node(\"EnergyLabel\").text = \"Energy: %d\" % resources.energy
		resource_panel.get_node(\"CrystalsLabel\").text = \"Crystals: %d\" % resources.crystals
		resource_panel.get_node(\"ShardsLabel\").text = \"Consciousness Shards: %d\" % resources.consciousness_shards
	
	# Update status display
	var status_panel = stellar_hud.get_node_or_null(\"Panel2/VBoxContainer\")
	if status_panel:
		status_panel.get_node(\"ConsciousnessLabel\").text = \"Consciousness Level: %d\" % player_state.consciousness_level
		status_panel.get_node(\"StellarLabel\").text = \"Stellar Stage: %d\" % player_state.stellar_evolution_stage
		status_panel.get_node(\"ModeLabel\").text = \"Mode: %s\" % (\"Mecha\" if player_state.in_mecha else \"Plasmoid\")

# === STELLAR EFFECTS ===

func _update_stellar_effects(delta: float):
	# Pulsing consciousness aura based on stellar stage
	if has_method(\"set_consciousness_pulse_rate\"):
		var pulse_rate = 1.0 + (player_state.stellar_evolution_stage * 0.2)
		set_consciousness_pulse_rate(pulse_rate)

func _update_resource_visualization(delta: float):
	# Visual indicators for resource levels
	pass

# === CLEANUP ===

func _cleanup_visual_systems():
	if mining_beam_system:
		mining_beam_system.queue_free()
	if stellar_hud:
		stellar_hud.queue_free()
	if consciousness_visualizer:
		consciousness_visualizer.queue_free()
"
script = SubResource("GDScript_1_ultimate")

[node name="SpaceGameUltimateV3" type="Node3D"]
script = SubResource("GDScript_1_ultimate")

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_1_xm9ja")

[node name="PlayerPlasmoid" type="CharacterBody3D" parent="."]
script = ExtResource("2_n5k9c")

[node name="MeshInstance3D" type="MeshInstance3D" parent="PlayerPlasmoid"]

[node name="CollisionShape3D" type="CollisionShape3D" parent="PlayerPlasmoid"]

[node name="VisualFeedbackSystem" type="Node3D" parent="."]

[node name="StellarHUD" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0

[node name="ConsciousnessVisualizer" type="Node3D" parent="."]

[node name="MiningBeamSystem" type="Node3D" parent="."]

[node name="MechaSystem" type="Node3D" parent="."]

[node name="SpaceEnvironment" type="Node3D" parent="."]