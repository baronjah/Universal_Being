# ==================================================
# SCRIPT NAME: akashic_compact_system.gd
# DESCRIPTION: Compact memory system for Universal Beings
# PURPOSE: Enable beings to compress, store, and evolve memories
# LOCATION: systems/akashic_compact_system.gd
# ==================================================

extends Node
class_name AkashicCompactSystem

## Compact Types
enum CompactType {
	MEMORY,        # Being's experience
	STATE,         # Consciousness snapshot  
	EVOLUTION,     # Transformation record
	SCENARIO,      # Game narrative
	KNOWLEDGE,     # Learned information
	RELATIONSHIP   # Connection to other beings
}

## Compact Resource
class Compact extends Resource:
	@export var id: String = ""
	@export var type: CompactType = CompactType.MEMORY
	@export var title: String = ""
	@export var timestamp: int = 0
	@export var being_uuid: String = ""
	@export var consciousness_level: int = 0
	@export var content: Dictionary = {}
	@export var parent_ids: Array[String] = []
	@export var child_ids: Array[String] = []
	@export var tags: Array[String] = []
	@export var compression_ratio: float = 1.0
	
	func _init():
		id = generate_compact_id()
		timestamp = Time.get_ticks_msec()
	
	func generate_compact_id() -> String:
		return "CMPCT_" + str(Time.get_ticks_msec()) + "_" + str(randi())
	
	func get_size_kb() -> float:
		return var_to_str(content).length() / 1024.0
	
	func to_akashic_record() -> Dictionary:
		"""Convert to format for Akashic Records storage"""
		return {
			"type": "compact",
			"data": {
				"id": id,
				"compact_type": CompactType.keys()[type],
				"title": title,
				"timestamp": timestamp,
				"being_uuid": being_uuid,
				"consciousness_level": consciousness_level,
				"content": content,
				"parent_ids": parent_ids,
				"tags": tags,
				"compression_ratio": compression_ratio
			}
		}

## Main System
signal compact_created(compact: Compact)
signal compact_merged(new_compact: Compact, source_ids: Array)
signal compact_evolved(parent: Compact, child: Compact)

var compacts: Dictionary = {}  # id -> Compact
var being_compacts: Dictionary = {}  # being_uuid -> Array[compact_ids]
var akashic_records: Node  # Reference to AkashicRecords system

func _ready():
	# Get AkashicRecords reference
	if SystemBootstrap and SystemBootstrap.has_method("get_akashic_records"):
		akashic_records = SystemBootstrap.get_akashic_records()
		print("ðŸ“š Akashic Compact System: Connected to Akashic Records")

# ===== COMPACT CREATION =====

func create_memory_compact(being: Node, experience: Dictionary) -> Compact:
	"""Create a compact from a being's experience"""
	var compact = Compact.new()
	compact.type = CompactType.MEMORY
	compact.being_uuid = being.get("being_uuid", "")
	compact.consciousness_level = being.get("consciousness_level", 0)
	compact.title = experience.get("title", "Memory")
	
	# Compress the experience
	compact.content = compress_experience(experience)
	compact.compression_ratio = calculate_compression_ratio(experience, compact.content)
	
	# Extract tags
	compact.tags = extract_tags_from_content(compact.content)
	
	# Store in system
	store_compact(compact)
	
	# Emit signal
	compact_created.emit(compact)
	
	return compact

func create_state_compact(being: Node) -> Compact:
	"""Create a snapshot of being's current state"""
	var compact = Compact.new()
	compact.type = CompactType.STATE
	compact.being_uuid = being.being_uuid
	compact.consciousness_level = being.consciousness_level
	compact.title = "State at Level %d" % being.consciousness_level
	
	# Capture state
	compact.content = {
		"properties": being.get_all_properties(),
		"components": being.get_component_list(),
		"relationships": being.get_relationships(),
		"position": being.global_position if being.has_method("get_global_position") else Vector3.ZERO,
		"scene_controlled": being.get("controlled_scene_path", "")
	}
	
	store_compact(compact)
	return compact

func create_scenario_compact(scenario_text: String, metadata: Dictionary = {}) -> Compact:
	"""Create a compact from scenario text"""
	var compact = Compact.new()
	compact.type = CompactType.SCENARIO
	compact.title = metadata.get("title", "Scenario")
	
	# Parse scenario
	var parsed = parse_scenario_text(scenario_text)
	compact.content = {
		"original_text": scenario_text,
		"parsed_elements": parsed,
		"metadata": metadata,
		"ai_model": metadata.get("ai_model", "unknown"),
		"complexity": calculate_scenario_complexity(parsed)
	}
	
	compact.tags = parsed.get("tags", [])
	
	store_compact(compact)
	return compact

# ===== COMPACT OPERATIONS =====

func merge_compacts(compact_ids: Array[String], merge_title: String = "") -> Compact:
	"""Merge multiple compacts into one"""
	if compact_ids.size() < 2:
		push_error("Need at least 2 compacts to merge")
		return null
	
	var source_compacts: Array[Compact] = []
	for id in compact_ids:
		if id in compacts:
			source_compacts.append(compacts[id])
	
	if source_compacts.is_empty():
		return null
	
	# Create merged compact
	var merged = Compact.new()
	merged.type = source_compacts[0].type  # Use first compact's type
	merged.title = merge_title if merge_title else "Merged Compact"
	merged.parent_ids = compact_ids
	
	# Merge content intelligently
	merged.content = merge_compact_contents(source_compacts)
	
	# Combine tags and remove duplicates
	var all_tags = []
	for compact in source_compacts:
		all_tags.append_array(compact.tags)
	merged.tags = remove_duplicates(all_tags)
	
	# Calculate average consciousness level
	var total_consciousness = 0
	for compact in source_compacts:
		total_consciousness += compact.consciousness_level
	merged.consciousness_level = total_consciousness / source_compacts.size()
	
	store_compact(merged)
	compact_merged.emit(merged, compact_ids)
	
	return merged

func evolve_compact(parent_id: String, evolution_data: Dictionary) -> Compact:
	"""Create an evolved version of a compact"""
	if not parent_id in compacts:
		push_error("Parent compact not found: " + parent_id)
		return null
	
	var parent = compacts[parent_id]
	var evolved = Compact.new()
	
	# Copy base data
	evolved.type = parent.type
	evolved.being_uuid = parent.being_uuid
	evolved.parent_ids = [parent_id]
	evolved.consciousness_level = evolution_data.get("new_consciousness", parent.consciousness_level + 1)
	
	# Evolve content
	evolved.content = evolve_content(parent.content, evolution_data)
	evolved.title = "Evolved: " + parent.title
	evolved.tags = parent.tags + ["evolved"]
	
	# Update parent-child relationships
	parent.child_ids.append(evolved.id)
	
	store_compact(evolved)
	compact_evolved.emit(parent, evolved)
	
	return evolved

# ===== COMPRESSION ALGORITHMS =====

func compress_experience(experience: Dictionary) -> Dictionary:
	"""Compress an experience into essential elements"""
	var compressed = {}
	
	# Extract key information
	compressed["summary"] = generate_summary(experience)
	compressed["key_decisions"] = extract_decisions(experience)
	compressed["entities_involved"] = extract_entities(experience)
	compressed["emotions"] = extract_emotions(experience)
	compressed["learned_patterns"] = extract_patterns(experience)
	
	# Remove redundant data
	if "raw_sensory_data" in experience:
		compressed["sensory_summary"] = summarize_sensory_data(experience["raw_sensory_data"])
	
	return compressed

func merge_compact_contents(source_compacts: Array) -> Dictionary:
	"""Intelligently merge multiple compact contents"""
	var merged_content = {}
	
	# Group by content keys
	var all_keys = {}
	for compact in source_compacts:
		for key in compact.content:
			if not key in all_keys:
				all_keys[key] = []
			all_keys[key].append(compact.content[key])
	
	# Merge each key's values
	for key in all_keys:
		var values = all_keys[key]
		
		match key:
			"summary":
				merged_content[key] = merge_summaries(values)
			"key_decisions":
				merged_content[key] = merge_and_deduplicate(values)
			"learned_patterns":
				merged_content[key] = synthesize_patterns(values)
			_:
				# Default: keep all unique values
				merged_content[key] = remove_duplicates(values)
	
	return merged_content

# ===== STORAGE & RETRIEVAL =====

func store_compact(compact: Compact) -> void:
	"""Store compact in memory and optionally in Akashic Records"""
	compacts[compact.id] = compact
	
	# Track by being
	if compact.being_uuid:
		if not compact.being_uuid in being_compacts:
			being_compacts[compact.being_uuid] = []
		being_compacts[compact.being_uuid].append(compact.id)
	
	# Store in Akashic Records if large enough
	if compact.get_size_kb() > 10.0 and akashic_records:
		save_to_akashic_records(compact)

func save_to_akashic_records(compact: Compact) -> void:
	"""Save compact to ZIP-based Akashic Records"""
	if not akashic_records:
		return
	
	var akashic_data = compact.to_akashic_record()
	var filename = "compacts/%s_%s.json" % [compact.being_uuid, compact.id]
	
	# This would interface with the actual AkashicRecords system
	# akashic_records.store_data(filename, akashic_data)
	print("ðŸ“€ Saved compact to Akashic Records: %s" % filename)

func get_being_compacts(being_uuid: String, type_filter: CompactType = -1) -> Array[Compact]:
	"""Get all compacts for a specific being"""
	var result: Array[Compact] = []
	
	if being_uuid in being_compacts:
		for compact_id in being_compacts[being_uuid]:
			var compact = compacts.get(compact_id)
			if compact and (type_filter == -1 or compact.type == type_filter):
				result.append(compact)
	
	return result

func search_compacts(query: String, tags: Array[String] = []) -> Array[Compact]:
	"""Search compacts by content and tags"""
	var results: Array[Compact] = []
	var query_lower = query.to_lower()
	
	for compact in compacts.values():
		var match = false
		
		# Search in title
		if query_lower in compact.title.to_lower():
			match = true
		
		# Search in tags
		if not match and tags.size() > 0:
			for tag in tags:
				if tag in compact.tags:
					match = true
					break
		
		# Search in content (expensive)
		if not match and query_lower in str(compact.content).to_lower():
			match = true
		
		if match:
			results.append(compact)
	
	return results

# ===== UTILITY FUNCTIONS =====

func extract_tags_from_content(content: Dictionary) -> Array[String]:
	"""Extract relevant tags from compact content"""
	var tags: Array[String] = []
	
	# Add type-based tags
	if "emotions" in content:
		tags.append_array(content["emotions"])
	
	if "entities_involved" in content:
		for entity in content["entities_involved"]:
			tags.append(str(entity).to_lower())
	
	# Add consciousness level tag
	if "consciousness_level" in content:
		tags.append("level_" + str(content["consciousness_level"]))
	
	return remove_duplicates(tags)

func remove_duplicates(array: Array) -> Array:
	"""Remove duplicate entries from array"""
	var unique = {}
	for item in array:
		unique[item] = true
	return unique.keys()

func calculate_compression_ratio(original: Dictionary, compressed: Dictionary) -> float:
	"""Calculate how much data was compressed"""
	var original_size = var_to_str(original).length()
	var compressed_size = var_to_str(compressed).length()
	
	if original_size == 0:
		return 1.0
	
	return float(compressed_size) / float(original_size)

# ===== SCENARIO PARSING =====

func parse_scenario_text(text: String) -> Dictionary:
	"""Parse scenario text into game elements"""
	return {
		"actors": extract_actors(text),
		"locations": extract_locations(text),
		"objectives": extract_objectives(text),
		"dialogue": extract_dialogue(text),
		"tags": extract_scenario_tags(text)
	}

func calculate_scenario_complexity(parsed: Dictionary) -> float:
	"""Calculate complexity score for a scenario"""
	var complexity = 0.0
	complexity += parsed.get("actors", []).size() * 0.2
	complexity += parsed.get("locations", []).size() * 0.15
	complexity += parsed.get("objectives", []).size() * 0.3
	complexity += parsed.get("dialogue", []).size() * 0.1
	return clamp(complexity, 0.0, 10.0)

# Placeholder functions for content extraction
func generate_summary(data: Dictionary) -> String:
	return "Summary of experience"

func extract_decisions(data: Dictionary) -> Array:
	return []

func extract_entities(data: Dictionary) -> Array:
	return []

func extract_emotions(data: Dictionary) -> Array:
	return []

func extract_patterns(data: Dictionary) -> Array:
	return []

func summarize_sensory_data(data) -> Dictionary:
	return {"summary": "sensory data"}

func merge_summaries(summaries: Array) -> String:
	return "Merged summary"

func merge_and_deduplicate(arrays: Array) -> Array:
	var result = []
	for arr in arrays:
		result.append_array(arr)
	return remove_duplicates(result)

func synthesize_patterns(patterns: Array) -> Array:
	return patterns  # TODO: Implement pattern synthesis

func evolve_content(old_content: Dictionary, evolution_data: Dictionary) -> Dictionary:
	var new_content = old_content.duplicate(true)
	# Apply evolution transformations
	return new_content

func extract_actors(text: String) -> Array:
	return []  # TODO: NLP implementation

func extract_locations(text: String) -> Array:
	return []  # TODO: NLP implementation

func extract_objectives(text: String) -> Array:
	return []  # TODO: NLP implementation

func extract_dialogue(text: String) -> Array:
	return []  # TODO: NLP implementation

func extract_scenario_tags(text: String) -> Array:
	return []  # TODO: NLP implementation