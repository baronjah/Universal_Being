# Evolution Game Claude - Development Prompt Plan

## Project Goals
- [ ] Create an adaptive evolution game that learns and grows through Claude AI
- [ ] Demonstrate emergent gameplay from simple evolutionary rules
- [ ] Build a foundation for AI-driven game development
- [ ] Integrate with existing akashic and turn-based systems

## Phase 1: Foundation & Core Engine (Current Phase)
- [ ] Design evolution algorithm framework
- [ ] Create basic game loop structure
- [ ] Implement Claude AI interface for decision making
- [ ] Set up project structure and development environment
- [ ] Create initial game entities and basic rules
- [ ] Design fitness functions for evolutionary selection

## Phase 2: Basic Evolution System
- [ ] Implement genetic algorithm for rule evolution
- [ ] Create mutation and crossover operators
- [ ] Build selection pressure mechanisms
- [ ] Add player influence on evolution
- [ ] Implement basic visualization of evolution
- [ ] Create simple terminal-based interface

## Phase 3: AI Integration & Adaptation
- [ ] Integrate Claude AI for real-time evolution decisions
- [ ] Implement adaptive game mechanics
- [ ] Create learning mechanisms for player behavior
- [ ] Add emergent behavior detection
- [ ] Build explanation system for AI decisions
- [ ] Implement evolution history tracking

## Phase 4: Advanced Features
- [ ] Multi-generational gameplay progression
- [ ] Complex emergent behaviors and interactions
- [ ] Advanced visualization and analytics
- [ ] Performance optimization for complex evolution
- [ ] Integration with akashic memory system
- [ ] Cross-session evolution persistence

## Phase 5: Multi-Platform Expansion
- [ ] Web interface for broader accessibility
- [ ] Godot desktop version with rich graphics
- [ ] Mobile compatibility considerations
- [ ] Real-time multiplayer evolution
- [ ] Cloud-based evolution sharing
- [ ] Community features and leaderboards

## Phase 6: Research & Innovation
- [ ] Document emergent patterns and behaviors
- [ ] Research paper on AI-driven game evolution
- [ ] Open source release and community building
- [ ] Advanced AI techniques (GPT integration, RL)
- [ ] Educational applications and tutorials
- [ ] Commercial viability assessment

## Immediate Tasks (Next 2-3 Sessions)
- [ ] Design core evolution data structures
- [ ] Implement basic game entity system
- [ ] Create evolution algorithm skeleton
- [ ] Set up Claude API integration
- [ ] Build minimal viable game loop
- [ ] Test basic evolution mechanics

## Research Questions to Explore
- [ ] How can player actions best influence evolutionary pressure?
- [ ] What makes evolved game mechanics feel meaningful?
- [ ] How to balance randomness vs. directed evolution?
- [ ] What metrics best capture "fun" for evolution?
- [ ] How to make AI decisions transparent and engaging?

## Technical Challenges
- [ ] Real-time evolution without performance issues
- [ ] Balancing exploration vs. exploitation in evolution
- [ ] Maintaining game playability during evolution
- [ ] Ensuring evolution leads to improvements
- [ ] Handling edge cases in evolved rules

## Success Metrics
- [ ] Game generates novel, playable mechanics
- [ ] Players can observe and influence evolution
- [ ] AI decisions enhance rather than hinder gameplay
- [ ] Evolution creates emergent, unexpected behaviors
- [ ] System demonstrates learning over time

## Integration Points
- [ ] Connect to existing akashic records system
- [ ] Integrate with 12 turns game framework
- [ ] Use dimensional color and visualization systems
- [ ] Leverage existing Claude integration patterns
- [ ] Build on terminal interface capabilities

## Documentation Goals
- [ ] Comprehensive API documentation
- [ ] Game design philosophy documentation
- [ ] Evolution algorithm explanations
- [ ] Player guide for understanding evolution
- [ ] Developer guide for extending the system

## Notes for Development
- Use `ultrathink` for complex evolutionary algorithm design
- Apply `think harder` for game balance and player experience
- Use `think hard` for AI integration and emergent behavior
- Document all emergent patterns and unexpected behaviors
- Maintain compatibility with existing system architecture