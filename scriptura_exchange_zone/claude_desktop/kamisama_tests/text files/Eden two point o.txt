There are also shaders with computing stuff and the fastnoise lite library for shaders to use noises to generate stuff i can see with my human eyes



// Switch between using floats or doubles for input position
#define FNLfloat float
//#define FNLfloat double

// Noise Type
#define FNL_NOISE_OPENSIMPLEX2 0
#define FNL_NOISE_OPENSIMPLEX2S 1
#define FNL_NOISE_CELLULAR 2
#define FNL_NOISE_PERLIN 3
#define FNL_NOISE_VALUE_CUBIC 4
#define FNL_NOISE_VALUE 5
#define fnl_noise_type int

// Rotation types
#define FNL_ROTATION_NONE 0
#define FNL_ROTATION_IMPROVE_XY_PLANES 1
#define FNL_ROTATION_IMPROVE_XZ_PLANES 2
#define fnl_rotation_type_3d int

// Fractal types
#define FNL_FRACTAL_NONE 0
#define FNL_FRACTAL_FBM 1
#define FNL_FRACTAL_RIDGED 2
#define FNL_FRACTAL_PINGPONG 3
#define FNL_FRACTAL_DOMAIN_WARP_PROGRESSIVE 4
#define FNL_FRACTAL_DOMAIN_WARP_INDEPENDENT 5
#define fnl_fractal_type int

#define FNL_CELLULAR_DISTANCE_EUCLIDEAN 0
#define FNL_CELLULAR_DISTANCE_EUCLIDEANSQ 1
#define FNL_CELLULAR_DISTANCE_MANHATTAN 2
#define FNL_CELLULAR_DISTANCE_HYBRID 3
#define fnl_cellular_distance_func int

#define FNL_CELLULAR_RETURN_TYPE_CELLVALUE 0
#define FNL_CELLULAR_RETURN_TYPE_DISTANCE 1
#define FNL_CELLULAR_RETURN_TYPE_DISTANCE2 2
#define FNL_CELLULAR_RETURN_TYPE_DISTANCE2ADD 3
#define FNL_CELLULAR_RETURN_TYPE_DISTANCE2SUB 4
#define FNL_CELLULAR_RETURN_TYPE_DISTANCE2MUL 5
#define FNL_CELLULAR_RETURN_TYPE_DISTANCE2DIV 6
#define fnl_cellular_return_type int

#define FNL_DOMAIN_WARP_OPENSIMPLEX2 0
#define FNL_DOMAIN_WARP_OPENSIMPLEX2_REDUCED 1
#define FNL_DOMAIN_WARP_BASICGRID 2
#define fnl_domain_warp_type int

// Structure containing entire noise system state.
// @note Must only be created using fnlCreateState(optional: seed). To ensure defaults are set.

struct fnl_state
{
    // Seed used for all noise types.
    // @remark Default: 1337
    int seed;

    // The frequency for all noise types.
    // @remark Default: 0.01
    float frequency;

    // The noise algorithm to be used by GetNoise(...).
    // @remark Default: FNL_NOISE_OPENSIMPLEX2
    fnl_noise_type noise_type;

    // Sets noise rotation type for 3D.
    // @remark Default: FNL_ROTATION_NONE
    fnl_rotation_type_3d rotation_type_3d;

    // The method used for combining octaves for all fractal noise types.
    // @remark Default: None
    // @remark FNL_FRACTAL_DOMAIN_WARP_... only effects fnlDomainWarp...
    fnl_fractal_type fractal_type;

    // The octave count for all fractal noise types.
    // @remark Default: 3
    int octaves;

    // The octave lacunarity for all fractal noise types.
    // @remark Default: 2.0
    float lacunarity;

    // The octave gain for all fractal noise types.
    // @remark Default: 0.5
    float gain;

    // The octave weighting for all none Domaain Warp fractal types.
    // @remark Default: 0.0
    // @remark 
    float weighted_strength;

    // The strength of the fractal ping pong effect.
    // @remark Default: 2.0
    float ping_pong_strength;

    // The distance function used in cellular noise calculations.
    // @remark Default: FNL_CELLULAR_DISTANCE_EUCLIDEANSQ
    fnl_cellular_distance_func cellular_distance_func;

    // The cellular return type from cellular noise calculations.
    // @remark Default: FNL_CELLULAR_RETURN_TYPE_DISTANCE
    fnl_cellular_return_type cellular_return_type;

    // The maximum distance a cellular point can move from it's grid position.
    // @remark Default: 1.0
    // @note Setting this higher than 1 will cause artifacts.
    float cellular_jitter_mod;

    // The warp algorithm when using fnlDomainWarp...
    // @remark Default: OpenSimplex2
    fnl_domain_warp_type domain_warp_type;

    // The maximum warp distance from original position when using fnlDomainWarp...
    // @remark Default: 1.0
    float domain_warp_amp;
};

// From here on, this is private implementation
// Constants
const float GRADIENTS_2D[] =
{
    0.130526192220052f, 0.99144486137381f, 0.38268343236509f, 0.923879532511287f, 0.608761429008721f, 0.793353340291235f, 0.793353340291235f, 0.608761429008721f,
    0.923879532511287f, 0.38268343236509f, 0.99144486137381f, 0.130526192220051f, 0.99144486137381f, -0.130526192220051f, 0.923879532511287f, -0.38268343236509f,
    0.793353340291235f, -0.60876142900872f, 0.608761429008721f, -0.793353340291235f, 0.38268343236509f, -0.923879532511287f, 0.130526192220052f, -0.99144486137381f,
    -0.130526192220052f, -0.99144486137381f, -0.38268343236509f, -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
    -0.923879532511287f, -0.38268343236509f, -0.99144486137381f, -0.130526192220052f, -0.99144486137381f, 0.130526192220051f, -0.923879532511287f, 0.38268343236509f,
    -0.793353340291235f, 0.608761429008721f, -0.608761429008721f, 0.793353340291235f, -0.38268343236509f, 0.923879532511287f, -0.130526192220052f, 0.99144486137381f,
    0.130526192220052f, 0.99144486137381f, 0.38268343236509f, 0.923879532511287f, 0.608761429008721f, 0.793353340291235f, 0.793353340291235f, 0.608761429008721f,
    0.923879532511287f, 0.38268343236509f, 0.99144486137381f, 0.130526192220051f, 0.99144486137381f, -0.130526192220051f, 0.923879532511287f, -0.38268343236509f,
    0.793353340291235f, -0.60876142900872f, 0.608761429008721f, -0.793353340291235f, 0.38268343236509f, -0.923879532511287f, 0.130526192220052f, -0.99144486137381f,
    -0.130526192220052f, -0.99144486137381f, -0.38268343236509f, -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
    -0.923879532511287f, -0.38268343236509f, -0.99144486137381f, -0.130526192220052f, -0.99144486137381f, 0.130526192220051f, -0.923879532511287f, 0.38268343236509f,
    -0.793353340291235f, 0.608761429008721f, -0.608761429008721f, 0.793353340291235f, -0.38268343236509f, 0.923879532511287f, -0.130526192220052f, 0.99144486137381f,
    0.130526192220052f, 0.99144486137381f, 0.38268343236509f, 0.923879532511287f, 0.608761429008721f, 0.793353340291235f, 0.793353340291235f, 0.608761429008721f,
    0.923879532511287f, 0.38268343236509f, 0.99144486137381f, 0.130526192220051f, 0.99144486137381f, -0.130526192220051f, 0.923879532511287f, -0.38268343236509f,
    0.793353340291235f, -0.60876142900872f, 0.608761429008721f, -0.793353340291235f, 0.38268343236509f, -0.923879532511287f, 0.130526192220052f, -0.99144486137381f,
    -0.130526192220052f, -0.99144486137381f, -0.38268343236509f, -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
    -0.923879532511287f, -0.38268343236509f, -0.99144486137381f, -0.130526192220052f, -0.99144486137381f, 0.130526192220051f, -0.923879532511287f, 0.38268343236509f,
    -0.793353340291235f, 0.608761429008721f, -0.608761429008721f, 0.793353340291235f, -0.38268343236509f, 0.923879532511287f, -0.130526192220052f, 0.99144486137381f,
    0.130526192220052f, 0.99144486137381f, 0.38268343236509f, 0.923879532511287f, 0.608761429008721f, 0.793353340291235f, 0.793353340291235f, 0.608761429008721f,
    0.923879532511287f, 0.38268343236509f, 0.99144486137381f, 0.130526192220051f, 0.99144486137381f, -0.130526192220051f, 0.923879532511287f, -0.38268343236509f,
    0.793353340291235f, -0.60876142900872f, 0.608761429008721f, -0.793353340291235f, 0.38268343236509f, -0.923879532511287f, 0.130526192220052f, -0.99144486137381f,
    -0.130526192220052f, -0.99144486137381f, -0.38268343236509f, -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
    -0.923879532511287f, -0.38268343236509f, -0.99144486137381f, -0.130526192220052f, -0.99144486137381f, 0.130526192220051f, -0.923879532511287f, 0.38268343236509f,
    -0.793353340291235f, 0.608761429008721f, -0.608761429008721f, 0.793353340291235f, -0.38268343236509f, 0.923879532511287f, -0.130526192220052f, 0.99144486137381f,
    0.130526192220052f, 0.99144486137381f, 0.38268343236509f, 0.923879532511287f, 0.608761429008721f, 0.793353340291235f, 0.793353340291235f, 0.608761429008721f,
    0.923879532511287f, 0.38268343236509f, 0.99144486137381f, 0.130526192220051f, 0.99144486137381f, -0.130526192220051f, 0.923879532511287f, -0.38268343236509f,
    0.793353340291235f, -0.60876142900872f, 0.608761429008721f, -0.793353340291235f, 0.38268343236509f, -0.923879532511287f, 0.130526192220052f, -0.99144486137381f,
    -0.130526192220052f, -0.99144486137381f, -0.38268343236509f, -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
    -0.923879532511287f, -0.38268343236509f, -0.99144486137381f, -0.130526192220052f, -0.99144486137381f, 0.130526192220051f, -0.923879532511287f, 0.38268343236509f,
    -0.793353340291235f, 0.608761429008721f, -0.608761429008721f, 0.793353340291235f, -0.38268343236509f, 0.923879532511287f, -0.130526192220052f, 0.99144486137381f,
    0.38268343236509f, 0.923879532511287f, 0.923879532511287f, 0.38268343236509f, 0.923879532511287f, -0.38268343236509f, 0.38268343236509f, -0.923879532511287f,
    -0.38268343236509f, -0.923879532511287f, -0.923879532511287f, -0.38268343236509f, -0.923879532511287f, 0.38268343236509f, -0.38268343236509f, 0.923879532511287f
};

const float RAND_VECS_2D[] = 
{
    -0.2700222198f, -0.9628540911f, 0.3863092627f, -0.9223693152f, 0.04444859006f, -0.999011673f, -0.5992523158f, -0.8005602176f, -0.7819280288f, 0.6233687174f, 0.9464672271f, 0.3227999196f, -0.6514146797f, -0.7587218957f, 0.9378472289f, 0.347048376f,
    -0.8497875957f, -0.5271252623f, -0.879042592f, 0.4767432447f, -0.892300288f, -0.4514423508f, -0.379844434f, -0.9250503802f, -0.9951650832f, 0.0982163789f, 0.7724397808f, -0.6350880136f, 0.7573283322f, -0.6530343002f, -0.9928004525f, -0.119780055f,
    -0.0532665713f, 0.9985803285f, 0.9754253726f, -0.2203300762f, -0.7665018163f, 0.6422421394f, 0.991636706f, 0.1290606184f, -0.994696838f, 0.1028503788f, -0.5379205513f, -0.84299554f, 0.5022815471f, -0.8647041387f, 0.4559821461f, -0.8899889226f,
    -0.8659131224f, -0.5001944266f, 0.0879458407f, -0.9961252577f, -0.5051684983f, 0.8630207346f, 0.7753185226f, -0.6315704146f, -0.6921944612f, 0.7217110418f, -0.5191659449f, -0.8546734591f, 0.8978622882f, -0.4402764035f, -0.1706774107f, 0.9853269617f,
    -0.9353430106f, -0.3537420705f, -0.9992404798f, 0.03896746794f, -0.2882064021f, -0.9575683108f, -0.9663811329f, 0.2571137995f, -0.8759714238f, -0.4823630009f, -0.8303123018f, -0.5572983775f, 0.05110133755f, -0.9986934731f, -0.8558373281f, -0.5172450752f,
    0.09887025282f, 0.9951003332f, 0.9189016087f, 0.3944867976f, -0.2439375892f, -0.9697909324f, -0.8121409387f, -0.5834613061f, -0.9910431363f, 0.1335421355f, 0.8492423985f, -0.5280031709f, -0.9717838994f, -0.2358729591f, 0.9949457207f, 0.1004142068f,
    0.6241065508f, -0.7813392434f, 0.662910307f, 0.7486988212f, -0.7197418176f, 0.6942418282f, -0.8143370775f, -0.5803922158f, 0.104521054f, -0.9945226741f, -0.1065926113f, -0.9943027784f, 0.445799684f, -0.8951327509f, 0.105547406f, 0.9944142724f,
    -0.992790267f, 0.1198644477f, -0.8334366408f, 0.552615025f, 0.9115561563f, -0.4111755999f, 0.8285544909f, -0.5599084351f, 0.7217097654f, -0.6921957921f, 0.4940492677f, -0.8694339084f, -0.3652321272f, -0.9309164803f, -0.9696606758f, 0.2444548501f,
    0.08925509731f, -0.996008799f, 0.5354071276f, -0.8445941083f, -0.1053576186f, 0.9944343981f, -0.9890284586f, 0.1477251101f, 0.004856104961f, 0.9999882091f, 0.9885598478f, 0.1508291331f, 0.9286129562f, -0.3710498316f, -0.5832393863f, -0.8123003252f,
    0.3015207509f, 0.9534596146f, -0.9575110528f, 0.2883965738f, 0.9715802154f, -0.2367105511f, 0.229981792f, 0.9731949318f, 0.955763816f, -0.2941352207f, 0.740956116f, 0.6715534485f, -0.9971513787f, -0.07542630764f, 0.6905710663f, -0.7232645452f,
    -0.290713703f, -0.9568100872f, 0.5912777791f, -0.8064679708f, -0.9454592212f, -0.325740481f, 0.6664455681f, 0.74555369f, 0.6236134912f, 0.7817328275f, 0.9126993851f, -0.4086316587f, -0.8191762011f, 0.5735419353f, -0.8812745759f, -0.4726046147f,
    0.9953313627f, 0.09651672651f, 0.9855650846f, -0.1692969699f, -0.8495980887f, 0.5274306472f, 0.6174853946f, -0.7865823463f, 0.8508156371f, 0.52546432f, 0.9985032451f, -0.05469249926f, 0.1971371563f, -0.9803759185f, 0.6607855748f, -0.7505747292f,
    -0.03097494063f, 0.9995201614f, -0.6731660801f, 0.739491331f, -0.7195018362f, -0.6944905383f, 0.9727511689f, 0.2318515979f, 0.9997059088f, -0.0242506907f, 0.4421787429f, -0.8969269532f, 0.9981350961f, -0.061043673f, -0.9173660799f, -0.3980445648f,
    -0.8150056635f, -0.5794529907f, -0.8789331304f, 0.4769450202f, 0.0158605829f, 0.999874213f, -0.8095464474f, 0.5870558317f, -0.9165898907f, -0.3998286786f, -0.8023542565f, 0.5968480938f, -0.5176737917f, 0.8555780767f, -0.8154407307f, -0.5788405779f,
    0.4022010347f, -0.9155513791f, -0.9052556868f, -0.4248672045f, 0.7317445619f, 0.6815789728f, -0.5647632201f, -0.8252529947f, -0.8403276335f, -0.5420788397f, -0.9314281527f, 0.363925262f, 0.5238198472f, 0.8518290719f, 0.7432803869f, -0.6689800195f,
    -0.985371561f, -0.1704197369f, 0.4601468731f, 0.88784281f, 0.825855404f, 0.5638819483f, 0.6182366099f, 0.7859920446f, 0.8331502863f, -0.553046653f, 0.1500307506f, 0.9886813308f, -0.662330369f, -0.7492119075f, -0.668598664f, 0.743623444f,
    0.7025606278f, 0.7116238924f, -0.5419389763f, -0.8404178401f, -0.3388616456f, 0.9408362159f, 0.8331530315f, 0.5530425174f, -0.2989720662f, -0.9542618632f, 0.2638522993f, 0.9645630949f, 0.124108739f, -0.9922686234f, -0.7282649308f, -0.6852956957f,
    0.6962500149f, 0.7177993569f, -0.9183535368f, 0.3957610156f, -0.6326102274f, -0.7744703352f, -0.9331891859f, -0.359385508f, -0.1153779357f, -0.9933216659f, 0.9514974788f, -0.3076565421f, -0.08987977445f, -0.9959526224f, 0.6678496916f, 0.7442961705f,
    0.7952400393f, -0.6062947138f, -0.6462007402f, -0.7631674805f, -0.2733598753f, 0.9619118351f, 0.9669590226f, -0.254931851f, -0.9792894595f, 0.2024651934f, -0.5369502995f, -0.8436138784f, -0.270036471f, -0.9628500944f, -0.6400277131f, 0.7683518247f,
    -0.7854537493f, -0.6189203566f, 0.06005905383f, -0.9981948257f, -0.02455770378f, 0.9996984141f, -0.65983623f, 0.751409442f, -0.6253894466f, -0.7803127835f, -0.6210408851f, -0.7837781695f, 0.8348888491f, 0.5504185768f, -0.1592275245f, 0.9872419133f,
    0.8367622488f, 0.5475663786f, -0.8675753916f, -0.4973056806f, -0.2022662628f, -0.9793305667f, 0.9399189937f, 0.3413975472f, 0.9877404807f, -0.1561049093f, -0.9034455656f, 0.4287028224f, 0.1269804218f, -0.9919052235f, -0.3819600854f, 0.924178821f,
    0.9754625894f, 0.2201652486f, -0.3204015856f, -0.9472818081f, -0.9874760884f, 0.1577687387f, 0.02535348474f, -0.9996785487f, 0.4835130794f, -0.8753371362f, -0.2850799925f, -0.9585037287f, -0.06805516006f, -0.99768156f, -0.7885244045f, -0.6150034663f,
    0.3185392127f, -0.9479096845f, 0.8880043089f, 0.4598351306f, 0.6476921488f, -0.7619021462f, 0.9820241299f, 0.1887554194f, 0.9357275128f, -0.3527237187f, -0.8894895414f, 0.4569555293f, 0.7922791302f, 0.6101588153f, 0.7483818261f, 0.6632681526f,
    -0.7288929755f, -0.6846276581f, 0.8729032783f, -0.4878932944f, 0.8288345784f, 0.5594937369f, 0.08074567077f, 0.9967347374f, 0.9799148216f, -0.1994165048f, -0.580730673f, -0.8140957471f, -0.4700049791f, -0.8826637636f, 0.2409492979f, 0.9705377045f,
    0.9437816757f, -0.3305694308f, -0.8927998638f, -0.4504535528f, -0.8069622304f, 0.5906030467f, 0.06258973166f, 0.9980393407f, -0.9312597469f, 0.3643559849f, 0.5777449785f, 0.8162173362f, -0.3360095855f, -0.941858566f, 0.697932075f, -0.7161639607f,
    -0.002008157227f, -0.9999979837f, -0.1827294312f, -0.9831632392f, -0.6523911722f, 0.7578824173f, -0.4302626911f, -0.9027037258f, -0.9985126289f, -0.05452091251f, -0.01028102172f, -0.9999471489f, -0.4946071129f, 0.8691166802f, -0.2999350194f, 0.9539596344f,
    0.8165471961f, 0.5772786819f, 0.2697460475f, 0.962931498f, -0.7306287391f, -0.6827749597f, -0.7590952064f, -0.6509796216f, -0.907053853f, 0.4210146171f, -0.5104861064f, -0.8598860013f, 0.8613350597f, 0.5080373165f, 0.5007881595f, -0.8655698812f,
    -0.654158152f, 0.7563577938f, -0.8382755311f, -0.545246856f, 0.6940070834f, 0.7199681717f, 0.06950936031f, 0.9975812994f, 0.1702942185f, -0.9853932612f, 0.2695973274f, 0.9629731466f, 0.5519612192f, -0.8338697815f, 0.225657487f, -0.9742067022f,
    0.4215262855f, -0.9068161835f, 0.4881873305f, -0.8727388672f, -0.3683854996f, -0.9296731273f, -0.9825390578f, 0.1860564427f, 0.81256471f, 0.5828709909f, 0.3196460933f, -0.9475370046f, 0.9570913859f, 0.2897862643f, -0.6876655497f, -0.7260276109f,
    -0.9988770922f, -0.047376731f, -0.1250179027f, 0.992154486f, -0.8280133617f, 0.560708367f, 0.9324863769f, -0.3612051451f, 0.6394653183f, 0.7688199442f, -0.01623847064f, -0.9998681473f, -0.9955014666f, -0.09474613458f, -0.81453315f, 0.580117012f,
    0.4037327978f, -0.9148769469f, 0.9944263371f, 0.1054336766f, -0.1624711654f, 0.9867132919f, -0.9949487814f, -0.100383875f, -0.6995302564f, 0.7146029809f, 0.5263414922f, -0.85027327f, -0.5395221479f, 0.841971408f, 0.6579370318f, 0.7530729462f,
    0.01426758847f, -0.9998982128f, -0.6734383991f, 0.7392433447f, 0.639412098f, -0.7688642071f, 0.9211571421f, 0.3891908523f, -0.146637214f, -0.9891903394f, -0.782318098f, 0.6228791163f, -0.5039610839f, -0.8637263605f, -0.7743120191f, -0.6328039957f
};

const float GRADIENTS_3D[] =
{
    0.f, 1.f, 1.f, 0.f,  0.f,-1.f, 1.f, 0.f,  0.f, 1.f,-1.f, 0.f,  0.f,-1.f,-1.f, 0.f,
    1.f, 0.f, 1.f, 0.f, -1.f, 0.f, 1.f, 0.f,  1.f, 0.f,-1.f, 0.f, -1.f, 0.f,-1.f, 0.f,
    1.f, 1.f, 0.f, 0.f, -1.f, 1.f, 0.f, 0.f,  1.f,-1.f, 0.f, 0.f, -1.f,-1.f, 0.f, 0.f,
    0.f, 1.f, 1.f, 0.f,  0.f,-1.f, 1.f, 0.f,  0.f, 1.f,-1.f, 0.f,  0.f,-1.f,-1.f, 0.f,
    1.f, 0.f, 1.f, 0.f, -1.f, 0.f, 1.f, 0.f,  1.f, 0.f,-1.f, 0.f, -1.f, 0.f,-1.f, 0.f,
    1.f, 1.f, 0.f, 0.f, -1.f, 1.f, 0.f, 0.f,  1.f,-1.f, 0.f, 0.f, -1.f,-1.f, 0.f, 0.f,
    0.f, 1.f, 1.f, 0.f,  0.f,-1.f, 1.f, 0.f,  0.f, 1.f,-1.f, 0.f,  0.f,-1.f,-1.f, 0.f,
    1.f, 0.f, 1.f, 0.f, -1.f, 0.f, 1.f, 0.f,  1.f, 0.f,-1.f, 0.f, -1.f, 0.f,-1.f, 0.f,
    1.f, 1.f, 0.f, 0.f, -1.f, 1.f, 0.f, 0.f,  1.f,-1.f, 0.f, 0.f, -1.f,-1.f, 0.f, 0.f,
    0.f, 1.f, 1.f, 0.f,  0.f,-1.f, 1.f, 0.f,  0.f, 1.f,-1.f, 0.f,  0.f,-1.f,-1.f, 0.f,
    1.f, 0.f, 1.f, 0.f, -1.f, 0.f, 1.f, 0.f,  1.f, 0.f,-1.f, 0.f, -1.f, 0.f,-1.f, 0.f,
    1.f, 1.f, 0.f, 0.f, -1.f, 1.f, 0.f, 0.f,  1.f,-1.f, 0.f, 0.f, -1.f,-1.f, 0.f, 0.f,
    0.f, 1.f, 1.f, 0.f,  0.f,-1.f, 1.f, 0.f,  0.f, 1.f,-1.f, 0.f,  0.f,-1.f,-1.f, 0.f,
    1.f, 0.f, 1.f, 0.f, -1.f, 0.f, 1.f, 0.f,  1.f, 0.f,-1.f, 0.f, -1.f, 0.f,-1.f, 0.f,
    1.f, 1.f, 0.f, 0.f, -1.f, 1.f, 0.f, 0.f,  1.f,-1.f, 0.f, 0.f, -1.f,-1.f, 0.f, 0.f,
    1.f, 1.f, 0.f, 0.f,  0.f,-1.f, 1.f, 0.f, -1.f, 1.f, 0.f, 0.f,  0.f,-1.f,-1.f, 0.f
};

const float RAND_VECS_3D[] = 
{
    -0.7292736885f, -0.6618439697f, 0.1735581948f, 0.f, 0.790292081f, -0.5480887466f, -0.2739291014f, 0.f, 0.7217578935f, 0.6226212466f, -0.3023380997f, 0.f, 0.565683137f, -0.8208298145f, -0.0790000257f, 0.f, 0.760049034f, -0.5555979497f, -0.3370999617f, 0.f, 0.3713945616f, 0.5011264475f, 0.7816254623f, 0.f, -0.1277062463f, -0.4254438999f, -0.8959289049f, 0.f, -0.2881560924f, -0.5815838982f, 0.7607405838f, 0.f,
    0.5849561111f, -0.662820239f, -0.4674352136f, 0.f, 0.3307171178f, 0.0391653737f, 0.94291689f, 0.f, 0.8712121778f, -0.4113374369f, -0.2679381538f, 0.f, 0.580981015f, 0.7021915846f, 0.4115677815f, 0.f, 0.503756873f, 0.6330056931f, -0.5878203852f, 0.f, 0.4493712205f, 0.601390195f, 0.6606022552f, 0.f, -0.6878403724f, 0.09018890807f, -0.7202371714f, 0.f, -0.5958956522f, -0.6469350577f, 0.475797649f, 0.f,
    -0.5127052122f, 0.1946921978f, -0.8361987284f, 0.f, -0.9911507142f, -0.05410276466f, -0.1212153153f, 0.f, -0.2149721042f, 0.9720882117f, -0.09397607749f, 0.f, -0.7518650936f, -0.5428057603f, 0.3742469607f, 0.f, 0.5237068895f, 0.8516377189f, -0.02107817834f, 0.f, 0.6333504779f, 0.1926167129f, -0.7495104896f, 0.f, -0.06788241606f, 0.3998305789f, 0.9140719259f, 0.f, -0.5538628599f, -0.4729896695f, -0.6852128902f, 0.f,
    -0.7261455366f, -0.5911990757f, 0.3509933228f, 0.f, -0.9229274737f, -0.1782808786f, 0.3412049336f, 0.f, -0.6968815002f, 0.6511274338f, 0.3006480328f, 0.f, 0.9608044783f, -0.2098363234f, -0.1811724921f, 0.f, 0.06817146062f, -0.9743405129f, 0.2145069156f, 0.f, -0.3577285196f, -0.6697087264f, -0.6507845481f, 0.f, -0.1868621131f, 0.7648617052f, -0.6164974636f, 0.f, -0.6541697588f, 0.3967914832f, 0.6439087246f, 0.f,
    0.6993340405f, -0.6164538506f, 0.3618239211f, 0.f, -0.1546665739f, 0.6291283928f, 0.7617583057f, 0.f, -0.6841612949f, -0.2580482182f, -0.6821542638f, 0.f, 0.5383980957f, 0.4258654885f, 0.7271630328f, 0.f, -0.5026987823f, -0.7939832935f, -0.3418836993f, 0.f, 0.3202971715f, 0.2834415347f, 0.9039195862f, 0.f, 0.8683227101f, -0.0003762656404f, -0.4959995258f, 0.f, 0.791120031f, -0.08511045745f, 0.6057105799f, 0.f,
    -0.04011016052f, -0.4397248749f, 0.8972364289f, 0.f, 0.9145119872f, 0.3579346169f, -0.1885487608f, 0.f, -0.9612039066f, -0.2756484276f, 0.01024666929f, 0.f, 0.6510361721f, -0.2877799159f, -0.7023778346f, 0.f, -0.2041786351f, 0.7365237271f, 0.644859585f, 0.f, -0.7718263711f, 0.3790626912f, 0.5104855816f, 0.f, -0.3060082741f, -0.7692987727f, 0.5608371729f, 0.f, 0.454007341f, -0.5024843065f, 0.7357899537f, 0.f,
    0.4816795475f, 0.6021208291f, -0.6367380315f, 0.f, 0.6961980369f, -0.3222197429f, 0.641469197f, 0.f, -0.6532160499f, -0.6781148932f, 0.3368515753f, 0.f, 0.5089301236f, -0.6154662304f, -0.6018234363f, 0.f, -0.1635919754f, -0.9133604627f, -0.372840892f, 0.f, 0.52408019f, -0.8437664109f, 0.1157505864f, 0.f, 0.5902587356f, 0.4983817807f, -0.6349883666f, 0.f, 0.5863227872f, 0.494764745f, 0.6414307729f, 0.f,
    0.6779335087f, 0.2341345225f, 0.6968408593f, 0.f, 0.7177054546f, -0.6858979348f, 0.120178631f, 0.f, -0.5328819713f, -0.5205125012f, 0.6671608058f, 0.f, -0.8654874251f, -0.0700727088f, -0.4960053754f, 0.f, -0.2861810166f, 0.7952089234f, 0.5345495242f, 0.f, -0.04849529634f, 0.9810836427f, -0.1874115585f, 0.f, -0.6358521667f, 0.6058348682f, 0.4781800233f, 0.f, 0.6254794696f, -0.2861619734f, 0.7258696564f, 0.f,
    -0.2585259868f, 0.5061949264f, -0.8227581726f, 0.f, 0.02136306781f, 0.5064016808f, -0.8620330371f, 0.f, 0.200111773f, 0.8599263484f, 0.4695550591f, 0.f, 0.4743561372f, 0.6014985084f, -0.6427953014f, 0.f, 0.6622993731f, -0.5202474575f, -0.5391679918f, 0.f, 0.08084972818f, -0.6532720452f, 0.7527940996f, 0.f, -0.6893687501f, 0.0592860349f, 0.7219805347f, 0.f, -0.1121887082f, -0.9673185067f, 0.2273952515f, 0.f,
    0.7344116094f, 0.5979668656f, -0.3210532909f, 0.f, 0.5789393465f, -0.2488849713f, 0.7764570201f, 0.f, 0.6988182827f, 0.3557169806f, -0.6205791146f, 0.f, -0.8636845529f, -0.2748771249f, -0.4224826141f, 0.f, -0.4247027957f, -0.4640880967f, 0.777335046f, 0.f, 0.5257722489f, -0.8427017621f, 0.1158329937f, 0.f, 0.9343830603f, 0.316302472f, -0.1639543925f, 0.f, -0.1016836419f, -0.8057303073f, -0.5834887393f, 0.f,
    -0.6529238969f, 0.50602126f, -0.5635892736f, 0.f, -0.2465286165f, -0.9668205684f, -0.06694497494f, 0.f, -0.9776897119f, -0.2099250524f, -0.007368825344f, 0.f, 0.7736893337f, 0.5734244712f, 0.2694238123f, 0.f, -0.6095087895f, 0.4995678998f, 0.6155736747f, 0.f, 0.5794535482f, 0.7434546771f, 0.3339292269f, 0.f, -0.8226211154f, 0.08142581855f, 0.5627293636f, 0.f, -0.510385483f, 0.4703667658f, 0.7199039967f, 0.f,
    -0.5764971849f, -0.07231656274f, -0.8138926898f, 0.f, 0.7250628871f, 0.3949971505f, -0.5641463116f, 0.f, -0.1525424005f, 0.4860840828f, -0.8604958341f, 0.f, -0.5550976208f, -0.4957820792f, 0.667882296f, 0.f, -0.1883614327f, 0.9145869398f, 0.357841725f, 0.f, 0.7625556724f, -0.5414408243f, -0.3540489801f, 0.f, -0.5870231946f, -0.3226498013f, -0.7424963803f, 0.f, 0.3051124198f, 0.2262544068f, -0.9250488391f, 0.f,
    0.6379576059f, 0.577242424f, -0.5097070502f, 0.f, -0.5966775796f, 0.1454852398f, -0.7891830656f, 0.f, -0.658330573f, 0.6555487542f, -0.3699414651f, 0.f, 0.7434892426f, 0.2351084581f, 0.6260573129f, 0.f, 0.5562114096f, 0.8264360377f, -0.0873632843f, 0.f, -0.3028940016f, -0.8251527185f, 0.4768419182f, 0.f, 0.1129343818f, -0.985888439f, -0.1235710781f, 0.f, 0.5937652891f, -0.5896813806f, 0.5474656618f, 0.f,
    0.6757964092f, -0.5835758614f, -0.4502648413f, 0.f, 0.7242302609f, -0.1152719764f, 0.6798550586f, 0.f, -0.9511914166f, 0.0753623979f, -0.2992580792f, 0.f, 0.2539470961f, -0.1886339355f, 0.9486454084f, 0.f, 0.571433621f, -0.1679450851f, -0.8032795685f, 0.f, -0.06778234979f, 0.3978269256f, 0.9149531629f, 0.f, 0.6074972649f, 0.733060024f, -0.3058922593f, 0.f, -0.5435478392f, 0.1675822484f, 0.8224791405f, 0.f,
    -0.5876678086f, -0.3380045064f, -0.7351186982f, 0.f, -0.7967562402f, 0.04097822706f, -0.6029098428f, 0.f, -0.1996350917f, 0.8706294745f, 0.4496111079f, 0.f, -0.02787660336f, -0.9106232682f, -0.4122962022f, 0.f, -0.7797625996f, -0.6257634692f, 0.01975775581f, 0.f, -0.5211232846f, 0.7401644346f, -0.4249554471f, 0.f, 0.8575424857f, 0.4053272873f, -0.3167501783f, 0.f, 0.1045223322f, 0.8390195772f, -0.5339674439f, 0.f,
    0.3501822831f, 0.9242524096f, -0.1520850155f, 0.f, 0.1987849858f, 0.07647613266f, 0.9770547224f, 0.f, 0.7845996363f, 0.6066256811f, -0.1280964233f, 0.f, 0.09006737436f, -0.9750989929f, -0.2026569073f, 0.f, -0.8274343547f, -0.542299559f, 0.1458203587f, 0.f, -0.3485797732f, -0.415802277f, 0.840000362f, 0.f, -0.2471778936f, -0.7304819962f, -0.6366310879f, 0.f, -0.3700154943f, 0.8577948156f, 0.3567584454f, 0.f,
    0.5913394901f, -0.548311967f, -0.5913303597f, 0.f, 0.1204873514f, -0.7626472379f, -0.6354935001f, 0.f, 0.616959265f, 0.03079647928f, 0.7863922953f, 0.f, 0.1258156836f, -0.6640829889f, -0.7369967419f, 0.f, -0.6477565124f, -0.1740147258f, -0.7417077429f, 0.f, 0.6217889313f, -0.7804430448f, -0.06547655076f, 0.f, 0.6589943422f, -0.6096987708f, 0.4404473475f, 0.f, -0.2689837504f, -0.6732403169f, -0.6887635427f, 0.f,
    -0.3849775103f, 0.5676542638f, 0.7277093879f, 0.f, 0.5754444408f, 0.8110471154f, -0.1051963504f, 0.f, 0.9141593684f, 0.3832947817f, 0.131900567f, 0.f, -0.107925319f, 0.9245493968f, 0.3654593525f, 0.f, 0.377977089f, 0.3043148782f, 0.8743716458f, 0.f, -0.2142885215f, -0.8259286236f, 0.5214617324f, 0.f, 0.5802544474f, 0.4148098596f, -0.7008834116f, 0.f, -0.1982660881f, 0.8567161266f, -0.4761596756f, 0.f,
    -0.03381553704f, 0.3773180787f, -0.9254661404f, 0.f, -0.6867922841f, -0.6656597827f, 0.2919133642f, 0.f, 0.7731742607f, -0.2875793547f, -0.5652430251f, 0.f, -0.09655941928f, 0.9193708367f, -0.3813575004f, 0.f, 0.2715702457f, -0.9577909544f, -0.09426605581f, 0.f, 0.2451015704f, -0.6917998565f, -0.6792188003f, 0.f, 0.977700782f, -0.1753855374f, 0.1155036542f, 0.f, -0.5224739938f, 0.8521606816f, 0.02903615945f, 0.f,
    -0.7734880599f, -0.5261292347f, 0.3534179531f, 0.f, -0.7134492443f, -0.269547243f, 0.6467878011f, 0.f, 0.1644037271f, 0.5105846203f, -0.8439637196f, 0.f, 0.6494635788f, 0.05585611296f, 0.7583384168f, 0.f, -0.4711970882f, 0.5017280509f, -0.7254255765f, 0.f, -0.6335764307f, -0.2381686273f, -0.7361091029f, 0.f, -0.9021533097f, -0.270947803f, -0.3357181763f, 0.f, -0.3793711033f, 0.872258117f, 0.3086152025f, 0.f,
    -0.6855598966f, -0.3250143309f, 0.6514394162f, 0.f, 0.2900942212f, -0.7799057743f, -0.5546100667f, 0.f, -0.2098319339f, 0.85037073f, 0.4825351604f, 0.f, -0.4592603758f, 0.6598504336f, -0.5947077538f, 0.f, 0.8715945488f, 0.09616365406f, -0.4807031248f, 0.f, -0.6776666319f, 0.7118504878f, -0.1844907016f, 0.f, 0.7044377633f, 0.312427597f, 0.637304036f, 0.f, -0.7052318886f, -0.2401093292f, -0.6670798253f, 0.f,
    0.081921007f, -0.7207336136f, -0.6883545647f, 0.f, -0.6993680906f, -0.5875763221f, -0.4069869034f, 0.f, -0.1281454481f, 0.6419895885f, 0.7559286424f, 0.f, -0.6337388239f, -0.6785471501f, -0.3714146849f, 0.f, 0.5565051903f, -0.2168887573f, -0.8020356851f, 0.f, -0.5791554484f, 0.7244372011f, -0.3738578718f, 0.f, 0.1175779076f, -0.7096451073f, 0.6946792478f, 0.f, -0.6134619607f, 0.1323631078f, 0.7785527795f, 0.f,
    0.6984635305f, -0.02980516237f, -0.715024719f, 0.f, 0.8318082963f, -0.3930171956f, 0.3919597455f, 0.f, 0.1469576422f, 0.05541651717f, -0.9875892167f, 0.f, 0.708868575f, -0.2690503865f, 0.6520101478f, 0.f, 0.2726053183f, 0.67369766f, -0.68688995f, 0.f, -0.6591295371f, 0.3035458599f, -0.6880466294f, 0.f, 0.4815131379f, -0.7528270071f, 0.4487723203f, 0.f, 0.9430009463f, 0.1675647412f, -0.2875261255f, 0.f,
    0.434802957f, 0.7695304522f, -0.4677277752f, 0.f, 0.3931996188f, 0.594473625f, 0.7014236729f, 0.f, 0.7254336655f, -0.603925654f, 0.3301814672f, 0.f, 0.7590235227f, -0.6506083235f, 0.02433313207f, 0.f, -0.8552768592f, -0.3430042733f, 0.3883935666f, 0.f, -0.6139746835f, 0.6981725247f, 0.3682257648f, 0.f, -0.7465905486f, -0.5752009504f, 0.3342849376f, 0.f, 0.5730065677f, 0.810555537f, -0.1210916791f, 0.f,
    -0.9225877367f, -0.3475211012f, -0.167514036f, 0.f, -0.7105816789f, -0.4719692027f, -0.5218416899f, 0.f, -0.08564609717f, 0.3583001386f, 0.929669703f, 0.f, -0.8279697606f, -0.2043157126f, 0.5222271202f, 0.f, 0.427944023f, 0.278165994f, 0.8599346446f, 0.f, 0.5399079671f, -0.7857120652f, -0.3019204161f, 0.f, 0.5678404253f, -0.5495413974f, -0.6128307303f, 0.f, -0.9896071041f, 0.1365639107f, -0.04503418428f, 0.f,
    -0.6154342638f, -0.6440875597f, 0.4543037336f, 0.f, 0.1074204368f, -0.7946340692f, 0.5975094525f, 0.f, -0.3595449969f, -0.8885529948f, 0.28495784f, 0.f, -0.2180405296f, 0.1529888965f, 0.9638738118f, 0.f, -0.7277432317f, -0.6164050508f, -0.3007234646f, 0.f, 0.7249729114f, -0.00669719484f, 0.6887448187f, 0.f, -0.5553659455f, -0.5336586252f, 0.6377908264f, 0.f, 0.5137558015f, 0.7976208196f, -0.3160000073f, 0.f,
    -0.3794024848f, 0.9245608561f, -0.03522751494f, 0.f, 0.8229248658f, 0.2745365933f, -0.4974176556f, 0.f, -0.5404114394f, 0.6091141441f, 0.5804613989f, 0.f, 0.8036581901f, -0.2703029469f, 0.5301601931f, 0.f, 0.6044318879f, 0.6832968393f, 0.4095943388f, 0.f, 0.06389988817f, 0.9658208605f, -0.2512108074f, 0.f, 0.1087113286f, 0.7402471173f, -0.6634877936f, 0.f, -0.713427712f, -0.6926784018f, 0.1059128479f, 0.f,
    0.6458897819f, -0.5724548511f, -0.5050958653f, 0.f, -0.6553931414f, 0.7381471625f, 0.159995615f, 0.f, 0.3910961323f, 0.9188871375f, -0.05186755998f, 0.f, -0.4879022471f, -0.5904376907f, 0.6429111375f, 0.f, 0.6014790094f, 0.7707441366f, -0.2101820095f, 0.f, -0.5677173047f, 0.7511360995f, 0.3368851762f, 0.f, 0.7858573506f, 0.226674665f, 0.5753666838f, 0.f, -0.4520345543f, -0.604222686f, -0.6561857263f, 0.f,
    0.002272116345f, 0.4132844051f, -0.9105991643f, 0.f, -0.5815751419f, -0.5162925989f, 0.6286591339f, 0.f, -0.03703704785f, 0.8273785755f, 0.5604221175f, 0.f, -0.5119692504f, 0.7953543429f, -0.3244980058f, 0.f, -0.2682417366f, -0.9572290247f, -0.1084387619f, 0.f, -0.2322482736f, -0.9679131102f, -0.09594243324f, 0.f, 0.3554328906f, -0.8881505545f, 0.2913006227f, 0.f, 0.7346520519f, -0.4371373164f, 0.5188422971f, 0.f,
    0.9985120116f, 0.04659011161f, -0.02833944577f, 0.f, -0.3727687496f, -0.9082481361f, 0.1900757285f, 0.f, 0.91737377f, -0.3483642108f, 0.1925298489f, 0.f, 0.2714911074f, 0.4147529736f, -0.8684886582f, 0.f, 0.5131763485f, -0.7116334161f, 0.4798207128f, 0.f, -0.8737353606f, 0.18886992f, -0.4482350644f, 0.f, 0.8460043821f, -0.3725217914f, 0.3814499973f, 0.f, 0.8978727456f, -0.1780209141f, -0.4026575304f, 0.f,
    0.2178065647f, -0.9698322841f, -0.1094789531f, 0.f, -0.1518031304f, -0.7788918132f, -0.6085091231f, 0.f, -0.2600384876f, -0.4755398075f, -0.8403819825f, 0.f, 0.572313509f, -0.7474340931f, -0.3373418503f, 0.f, -0.7174141009f, 0.1699017182f, -0.6756111411f, 0.f, -0.684180784f, 0.02145707593f, -0.7289967412f, 0.f, -0.2007447902f, 0.06555605789f, -0.9774476623f, 0.f, -0.1148803697f, -0.8044887315f, 0.5827524187f, 0.f,
    -0.7870349638f, 0.03447489231f, 0.6159443543f, 0.f, -0.2015596421f, 0.6859872284f, 0.6991389226f, 0.f, -0.08581082512f, -0.10920836f, -0.9903080513f, 0.f, 0.5532693395f, 0.7325250401f, -0.396610771f, 0.f, -0.1842489331f, -0.9777375055f, -0.1004076743f, 0.f, 0.0775473789f, -0.9111505856f, 0.4047110257f, 0.f, 0.1399838409f, 0.7601631212f, -0.6344734459f, 0.f, 0.4484419361f, -0.845289248f, 0.2904925424f, 0.f
};

// Utilities
float _fnlFastMin(float x, float y) { return min(x, y); }

float _fnlFastMax(float x, float y) { return max(x, y); }

float _fnlFastAbs(float f) { return abs(f); }

float _fnlFastSqrt(float a) { return sqrt(a); }

int _fnlFastFloor(FNLfloat f) { return int(floor(f)); }

int _fnlFastRound(FNLfloat f) { return int(round(f)); }

float _fnlLerp(float a, float b, float t) { return mix(a, b, t); }

float _fnlInterpHermite(float t) { return t * t * (3.f - 2.f * t); }

float _fnlInterpQuintic(float t) { return t * t * t * (t * (t * 6.f - 15.f) + 10.f); }

float _fnlCubicLerp(float a, float b, float c, float d, float t)
{
    float p = (d - c) - (a - b);
    return t * t * t * p + t * t * ((a - b) - p) + t * (c - a) + b;
}

float _fnlPingPong(float t)
{
    t -= float(int(t * 0.5f)) * 2.f;
    return t < 1.f ? t : 2.f - t;
}

float _fnlCalculateFractalBounding(fnl_state state)
{
    float gain = _fnlFastAbs(state.gain);
    float amp = gain;
    float ampFractal = 1.f;
    for (int i = 1; i < state.octaves; i++)
    {
        ampFractal += amp;
        amp *= gain;
    }
    return 1.f / ampFractal;
}

// Hashing
const int PRIME_X = 501125321;
const int PRIME_Y = 1136930381;
const int PRIME_Z = 1720413743;

int _fnlHash2D(int seed, int xPrimed, int yPrimed)
{
    int hash = seed ^ xPrimed ^ yPrimed;

    hash *= 0x27d4eb2d;
    return hash;
}

int _fnlHash3D(int seed, int xPrimed, int yPrimed, int zPrimed)
{
    int hash = seed ^ xPrimed ^ yPrimed ^ zPrimed;

    hash *= 0x27d4eb2d;
    return hash;
}

float _fnlValCoord2D(int seed, int xPrimed, int yPrimed)
{
    int hash = _fnlHash2D(seed, xPrimed, yPrimed);
    hash *= hash;
    hash ^= hash << 19;
    return float(hash) * (1.f / 2147483648.f);
}

float _fnlValCoord3D(int seed, int xPrimed, int yPrimed, int zPrimed)
{
    int hash = _fnlHash3D(seed, xPrimed, yPrimed, zPrimed);
    hash *= hash;
    hash ^= hash << 19;
    return float(hash) * (1.f / 2147483648.f);
}

float _fnlGradCoord2D(int seed, int xPrimed, int yPrimed, float xd, float yd)
{
    int hash = _fnlHash2D(seed, xPrimed, yPrimed);
    hash ^= hash >> 15;
    hash &= 127 << 1;
    return xd * GRADIENTS_2D[hash] + yd * GRADIENTS_2D[hash | 1];
}

float _fnlGradCoord3D(int seed, int xPrimed, int yPrimed, int zPrimed, float xd, float yd, float zd)
{
    int hash = _fnlHash3D(seed, xPrimed, yPrimed, zPrimed);
    hash ^= hash >> 15;
    hash &= 63 << 2;
    return xd * GRADIENTS_3D[hash] + yd * GRADIENTS_3D[hash | 1] + zd * GRADIENTS_3D[hash | 2];
}

void _fnlGradCoordOut2D(int seed, int xPrimed, int yPrimed, out float xo, out float yo)
{
    int hash = _fnlHash2D(seed, xPrimed, yPrimed) & (255 << 1);

    xo = RAND_VECS_2D[hash];
    yo = RAND_VECS_2D[hash | 1];
}

void _fnlGradCoordOut3D(int seed, int xPrimed, int yPrimed, int zPrimed, out float xo, out float yo, out float zo)
{
    int hash = _fnlHash3D(seed, xPrimed, yPrimed, zPrimed) & (255 << 2);

    xo = RAND_VECS_3D[hash];
    yo = RAND_VECS_3D[hash | 1];
    zo = RAND_VECS_3D[hash | 2];
}

void _fnlGradCoordDual2D(int seed, int xPrimed, int yPrimed, float xd, float yd, out float xo, out float yo)
{
    int hash = _fnlHash2D(seed, xPrimed, yPrimed);
    int index1 = hash & (127 << 1);
    int index2 = (hash >> 7) & (255 << 1);

    float xg = GRADIENTS_2D[index1];
    float yg = GRADIENTS_2D[index1 | 1];
    float value = xd * xg + yd * yg;

    float xgo = RAND_VECS_2D[index2];
    float ygo = RAND_VECS_2D[index2 | 1];

    xo = value * xgo;
    yo = value * ygo;
}

void _fnlGradCoordDual3D(int seed, int xPrimed, int yPrimed, int zPrimed, float xd, float yd, float zd, out float xo, out float yo, out float zo)
{
    int hash = _fnlHash3D(seed, xPrimed, yPrimed, zPrimed);
    int index1 = hash & (63 << 2);
    int index2 = (hash >> 6) & (255 << 2);

    float xg = GRADIENTS_3D[index1];
    float yg = GRADIENTS_3D[index1 | 1];
    float zg = GRADIENTS_3D[index1 | 2];
    float value = xd * xg + yd * yg + zd * zg;

    float xgo = RAND_VECS_3D[index2];
    float ygo = RAND_VECS_3D[index2 | 1];
    float zgo = RAND_VECS_3D[index2 | 2];

    xo = value * xgo;
    yo = value * ygo;
    zo = value * zgo;
}

// Noise Coordinate Transforms (frequency, and possible skew or rotation)
void _fnlTransformNoiseCoordinate2D(fnl_state state, inout FNLfloat x, inout FNLfloat y)
{
    x *= state.frequency;
    y *= state.frequency;

    switch (state.noise_type)
    {
        case FNL_NOISE_OPENSIMPLEX2:
        case FNL_NOISE_OPENSIMPLEX2S:
        {
            const FNLfloat SQRT3 = FNLfloat(1.7320508075688772935274463415059);
            const FNLfloat F2 = 0.5f * (SQRT3 - 1.f);
            FNLfloat t = (x + y) * F2;
            x += t;
            y += t;
        }
        break;
        default:
            break;
    }
}

void _fnlTransformNoiseCoordinate3D(fnl_state state, inout FNLfloat x, inout FNLfloat y, inout FNLfloat z)
{
    x *= state.frequency;
    y *= state.frequency;
    z *= state.frequency;

    switch (state.rotation_type_3d)
    {
        case FNL_ROTATION_IMPROVE_XY_PLANES:
        {
            FNLfloat xy = x + y;
            FNLfloat s2 = xy * -FNLfloat(0.211324865405187);
            z *= FNLfloat(0.577350269189626);
            x += s2 - z;
            y = y + s2 - z;
            z += xy * FNLfloat(0.577350269189626);
        }
        break;
        case FNL_ROTATION_IMPROVE_XZ_PLANES:
        {
            FNLfloat xz = x + z;
            FNLfloat s2 = xz * -FNLfloat(0.211324865405187);
            y *= FNLfloat(0.577350269189626);
            x += s2 - y;
            z += s2 - y;
            y += xz * FNLfloat(0.577350269189626);
        }
        break;
        default:
            switch (state.noise_type)
            {
            case FNL_NOISE_OPENSIMPLEX2:
            case FNL_NOISE_OPENSIMPLEX2S:
            {
                const FNLfloat R3 = FNLfloat(2.f / 3.f);
                FNLfloat r = (x + y + z) * R3; // Rotation, not skew
                x = r - x;
                y = r - y;
                z = r - z;
            }
            break;
            default:
                break;
            }
            break;
    }
}

// Domain Warp Coordinate Transforms
void _fnlTransformDomainWarpCoordinate2D(fnl_state state, inout FNLfloat x, inout FNLfloat y)
{
    switch (state.domain_warp_type)
    {
        case FNL_DOMAIN_WARP_OPENSIMPLEX2:
        case FNL_DOMAIN_WARP_OPENSIMPLEX2_REDUCED:
        {
            const FNLfloat SQRT3 = FNLfloat(1.7320508075688772935274463415059);
            const FNLfloat F2 = 0.5f * (SQRT3 - 1.f);
            FNLfloat t = (x + y) * F2;
            x += t;
            y += t;
        }
        break;
        default:
            break;
    }
}

void _fnlTransformDomainWarpCoordinate3D(fnl_state state, inout FNLfloat x, inout FNLfloat y, inout FNLfloat z)
{
    switch (state.rotation_type_3d)
    {
        case FNL_ROTATION_IMPROVE_XY_PLANES:
        {
            FNLfloat xy = x + y;
            FNLfloat s2 = xy * -FNLfloat(0.211324865405187);
            z *= FNLfloat(0.577350269189626);
            x += s2 - z;
            y = y + s2 - z;
            z += xy * FNLfloat(0.577350269189626);
        }
        break;
        case FNL_ROTATION_IMPROVE_XZ_PLANES:
        {
            FNLfloat xz = x + z;
            FNLfloat s2 = xz * -FNLfloat(0.211324865405187);
            y *= FNLfloat(0.577350269189626);
            x += s2 - y;
            z += s2 - y;
            y += xz * FNLfloat(0.577350269189626);
        }
        break;
        default:
            switch (state.domain_warp_type)
            {
            case FNL_DOMAIN_WARP_OPENSIMPLEX2:
            case FNL_DOMAIN_WARP_OPENSIMPLEX2_REDUCED:
            {
                const FNLfloat R3 = FNLfloat(2.f / 3.f);
                FNLfloat r = (x + y + z) * R3; // Rotation, not skew
                x = r - x;
                y = r - y;
                z = r - z;
            }
            break;
            default:
                break;
            }
        break;
    }
}

// Simplex/OpenSimplex2 Noise
float _fnlSingleSimplex2D(int seed, FNLfloat x, FNLfloat y)
{
    // 2D OpenSimplex2 case uses the same algorithm as ordinary Simplex.

    const float SQRT3 = 1.7320508075688772935274463415059;
    const float G2 = (3.f - SQRT3) / 6.f;

    // --- Skew moved to TransformNoiseCoordinate method ---
    // const FNLfloat F2 = 0.5f * (SQRT3 - 1);
    // FNLfloat s = (x + y) * F2;
    // x += s; y += s;


    int i = _fnlFastFloor(x);
    int j = _fnlFastFloor(y);
    float xi = x - float(i);
    float yi = y - float(j);

    float t = (xi + yi) * G2;
    float x0 = xi - t;
    float y0 = yi - t;

    i *= PRIME_X;
    j *= PRIME_Y;

    float n0, n1, n2;

    float a = 0.5f - x0 * x0 - y0 * y0;
    if (a <= 0.f)
	{
		n0 = 0.f;
	}
    else
	{
        n0 = (a * a) * (a * a) * _fnlGradCoord2D(seed, i, j, x0, y0);
	}

    float c = (2.f * (1.f - 2.f * G2) * (1.f / G2 - 2.f)) * t + ((-2.f * (1.f - 2.f * G2) * (1.f - 2.f * G2)) + a);
    if (c <= 0.f)
	{		
        n2 = 0.f;
	}
    else
    {
        float x2 = x0 + (2.f * G2 - 1.f);
        float y2 = y0 + (2.f * G2 - 1.f);
        n2 = (c * c) * (c * c) * _fnlGradCoord2D(seed, i + PRIME_X, j + PRIME_Y, x2, y2);
    }

    if (y0 > x0)
    {
        float x1 = x0 + G2;
        float y1 = y0 + G2 - 1.f;
        float b = 0.5f - x1 * x1 - y1 * y1;
        if (b <= 0.f)
		{			
            n1 = 0.f;
		}
        else
		{
            n1 = (b * b) * (b * b) * _fnlGradCoord2D(seed, i, j + PRIME_Y, x1, y1);
        }
    }
    else
    {
        float x1 = x0 + (G2 - 1.f);
        float y1 = y0 + G2;
        float b = 0.5f - x1 * x1 - y1 * y1;
        if (b <= 0.f)
		{			
            n1 = 0.f;
		}
        else
        {
            n1 = (b * b) * (b * b) * _fnlGradCoord2D(seed, i + PRIME_X, j, x1, y1);
        }
    }

    return (n0 + n1 + n2) * 99.83685446303647;
}

float _fnlSingleOpenSimplex23D(int seed, FNLfloat x, FNLfloat y, FNLfloat z)
{
    // 3D OpenSimplex2 case uses two offset rotated cube grids.

    // --- Rotation moved to TransformNoiseCoordinate method ---
    // const FNLfloat R3 = (FNLfloat)(2.f / 3.f);
    // FNLfloat r = (x + y + z) * R3; // Rotation, not skew
    // x = r - x; y = r - y; z = r - z;


    int i = _fnlFastRound(x);
    int j = _fnlFastRound(y);
    int k = _fnlFastRound(z);
    float x0 = x - float(i);
    float y0 = y - float(j);
    float z0 = z - float(k);

    int xNSign = int(-1.f - x0) | 1;
    int yNSign = int(-1.f - y0) | 1;
    int zNSign = int(-1.f - z0) | 1;

    float ax0 = float(xNSign) * -x0;
    float ay0 = float(yNSign) * -y0;
    float az0 = float(zNSign) * -z0;

    i *= PRIME_X;
    j *= PRIME_Y;
    k *= PRIME_Z;

    float value = 0.f;
    float a = (0.6f - x0 * x0) - (y0 * y0 + z0 * z0);

    for (int l = 0; ; l++)
    {
        if (a > 0.f)
        {
            value += (a * a) * (a * a) * _fnlGradCoord3D(seed, i, j, k, x0, y0, z0);
        }

        float b = a + 1.f;
        int i1 = i;
        int j1 = j;
        int k1 = k;
        float x1 = x0;
        float y1 = y0;
        float z1 = z0;
        if (ax0 >= ay0 && ax0 >= az0)
        {
            x1 += float(xNSign);
            b -= float(xNSign) * 2.f * x1;
            i1 -= xNSign * PRIME_X;
        }
        else if (ay0 > ax0 && ay0 >= az0)
        {
            y1 += float(yNSign);
            b -= float(yNSign) * 2.f * y1;
            j1 -= yNSign * PRIME_Y;
        }
        else
        {
            z1 += float(zNSign);
            b -= float(zNSign) * 2.f * z1;
            k1 -= zNSign * PRIME_Z;
        }

        if (b > 0.f)
        {
            value += (b * b) * (b * b) * _fnlGradCoord3D(seed, i1, j1, k1, x1, y1, z1);
        }

        if (l == 1) break;

        ax0 = 0.5f - ax0;
        ay0 = 0.5f - ay0;
        az0 = 0.5f - az0;

        x0 = float(xNSign) * ax0;
        y0 = float(yNSign) * ay0;
        z0 = float(zNSign) * az0;

        a += (0.75f - ax0) - (ay0 + az0);

        i += (xNSign >> 1) & PRIME_X;
        j += (yNSign >> 1) & PRIME_Y;
        k += (zNSign >> 1) & PRIME_Z;

        xNSign = -xNSign;
        yNSign = -yNSign;
        zNSign = -zNSign;

        seed = ~seed;
    }

    return value * 32.69428253173828125;
}

// OpenSimplex2S Noise
float _fnlSingleOpenSimplex2S2D(int seed, FNLfloat x, FNLfloat y)
{
    // 2D OpenSimplex2S case is a modified 2D simplex noise.

    const FNLfloat SQRT3 = FNLfloat(1.7320508075688772935274463415059);
    const FNLfloat G2 = (3.f - SQRT3) / 6.f;

    // --- Skew moved to TransformNoiseCoordinate method ---
    // const FNLfloat F2 = 0.5f * (SQRT3 - 1);
    // FNLfloat s = (x + y) * F2;
    // x += s; y += s;


    int i = _fnlFastFloor(x);
    int j = _fnlFastFloor(y);
    float xi = x - float(i);
    float yi = y - float(j);

    i *= PRIME_X;
    j *= PRIME_Y;
    int i1 = i + PRIME_X;
    int j1 = j + PRIME_Y;

    float t = (xi + yi) * G2;
    float x0 = xi - t;
    float y0 = yi - t;

    int aMask = int((xi + yi + 1.f) * -0.5f);
    int bMask = int((xi - (float(aMask) + 2.f)) * 0.5f - yi);
    int cMask = int((yi - (float(aMask) + 2.f)) * 0.5f - xi);

    float a0 = (2.f / 3.f) - x0 * x0 - y0 * y0;
    float value = (a0 * a0) * (a0 * a0) * _fnlGradCoord2D(seed, i, j, x0, y0);

    float a1 = (2.f * (1.f - 2.f * G2) * (1.f / G2 - 2.f)) * t + ((-2.f * (1.f - 2.f * G2) * (1.f - 2.f * G2)) + a0);
    float x1 = x0 - (1.f - 2.f * G2);
    float y1 = y0 - (1.f - 2.f * G2);
    value += (a1 * a1) * (a1 * a1) * _fnlGradCoord2D(seed, i1, j1, x1, y1);

    int di2 = ~(aMask | cMask) | 1;
    int ndj2 = (aMask & bMask) << 1;
    float t2 = float(di2 - ndj2) * G2;
    float x2 = x0 - float(di2) + t2;
    float y2 = y0 + float(ndj2) + t2;
    float a2 = (2.f / 3.f) - x2 * x2 - y2 * y2;
    if (a2 > 0.f)
    {
        value += (a2 * a2) * (a2 * a2) * _fnlGradCoord2D(seed, i1 + (di2 & (-PRIME_X << 1)), j + (ndj2 & (PRIME_Y << 1)), x2, y2);
    }

    int ndi3 = (aMask & cMask) << 1;
    int dj3 = ~(aMask | bMask) | 1;
    float t3 = float(dj3 - ndi3) * G2;
    float x3 = x0 + float(ndi3) + t3;
    float y3 = y0 - float(dj3) + t3;
    float a3 = (2.f / 3.f) - x3 * x3 - y3 * y3;
    if (a3 > 0.f)
    {
        value += (a3 * a3) * (a3 * a3) * _fnlGradCoord2D(seed, i + (ndi3 & (PRIME_X << 1)), j1 + (dj3 & (-PRIME_Y << 1)), x3, y3);
    }

    return value * 18.24196194486065;
}

float _fnlSingleOpenSimplex2S3D(int seed, FNLfloat x, FNLfloat y, FNLfloat z)
{
    // 3D OpenSimplex2S case uses two offset rotated cube grids.

    // --- Rotation moved to TransformNoiseCoordinate method ---
    // const FNLfloat R3 = (FNLfloat)(2.f / 3.f);
    // FNLfloat r = (x + y + z) * R3; // Rotation, not skew
    // x = r - x; y = r - y; z = r - z;


    int i = _fnlFastFloor(x);
    int j = _fnlFastFloor(y);
    int k = _fnlFastFloor(z);
    float xi = x - float(i);
    float yi = y - float(j);
    float zi = z - float(k);

    i *= PRIME_X;
    j *= PRIME_Y;
    k *= PRIME_Z;
    int seed2 = seed + 1293373;

    int xNMask = int(-0.5f - xi);
    int yNMask = int(-0.5f - yi);
    int zNMask = int(-0.5f - zi);

    float x0 = xi + float(xNMask);
    float y0 = yi + float(yNMask);
    float z0 = zi + float(zNMask);
    float a0 = 0.75f - x0 * x0 - y0 * y0 - z0 * z0;
    float value = (a0 * a0) * (a0 * a0) * _fnlGradCoord3D(seed,
                                                          i + (xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x0, y0, z0);

    float x1 = xi - 0.5f;
    float y1 = yi - 0.5f;
    float z1 = zi - 0.5f;
    float a1 = 0.75f - x1 * x1 - y1 * y1 - z1 * z1;
    value += (a1 * a1) * (a1 * a1) * _fnlGradCoord3D(seed2,
                                                     i + PRIME_X, j + PRIME_Y, k + PRIME_Z, x1, y1, z1);

    float xAFlipMask0 = float((xNMask | 1) << 1) * x1;
    float yAFlipMask0 = float((yNMask | 1) << 1) * y1;
    float zAFlipMask0 = float((zNMask | 1) << 1) * z1;
    float xAFlipMask1 = float(-2 - (xNMask << 2)) * x1 - 1.f;
    float yAFlipMask1 = float(-2 - (yNMask << 2)) * y1 - 1.f;
    float zAFlipMask1 = float(-2 - (zNMask << 2)) * z1 - 1.f;

    bool skip5 = false;
    float a2 = xAFlipMask0 + a0;
    if (a2 > 0.f)
    {
        float x2 = x0 - float(xNMask | 1);
        float y2 = y0;
        float z2 = z0;
        value += (a2 * a2) * (a2 * a2) * _fnlGradCoord3D(seed,
                                                         i + (~xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x2, y2, z2);
    }
    else
    {
        float a3 = yAFlipMask0 + zAFlipMask0 + a0;
        if (a3 > 0.f)
        {
            float x3 = x0;
            float y3 = y0 - float(yNMask | 1);
            float z3 = z0 - float(zNMask | 1);
            value += (a3 * a3) * (a3 * a3) * _fnlGradCoord3D(seed,
                                                             i + (xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), x3, y3, z3);
        }

        float a4 = xAFlipMask1 + a1;
        if (a4 > 0.f)
        {
            float x4 = float(xNMask | 1) + x1;
            float y4 = y1;
            float z4 = z1;
            value += (a4 * a4) * (a4 * a4) * _fnlGradCoord3D(seed2,
                                                             i + (xNMask & (PRIME_X * 2)), j + PRIME_Y, k + PRIME_Z, x4, y4, z4);
            skip5 = true;
        }
    }

    bool skip9 = false;
    float a6 = yAFlipMask0 + a0;
    if (a6 > 0.f)
    {
        float x6 = x0;
        float y6 = y0 - float(yNMask | 1);
        float z6 = z0;
        value += (a6 * a6) * (a6 * a6) * _fnlGradCoord3D(seed,
                                                         i + (xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x6, y6, z6);
    }
    else
    {
        float a7 = xAFlipMask0 + zAFlipMask0 + a0;
        if (a7 > 0.f)
        {
            float x7 = x0 - float(xNMask | 1);
            float y7 = y0;
            float z7 = z0 - float(zNMask | 1);
            value += (a7 * a7) * (a7 * a7) * _fnlGradCoord3D(seed,
                                                             i + (~xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), x7, y7, z7);
        }

        float a8 = yAFlipMask1 + a1;
        if (a8 > 0.f)
        {
            float x8 = x1;
            float y8 = float(yNMask | 1) + y1;
            float z8 = z1;
            value += (a8 * a8) * (a8 * a8) * _fnlGradCoord3D(seed2,
                                                             i + PRIME_X, j + (yNMask & (PRIME_Y << 1)), k + PRIME_Z, x8, y8, z8);
            skip9 = true;
        }
    }

    bool skipD = false;
    float aA = zAFlipMask0 + a0;
    if (aA > 0.f)
    {
        float xA = x0;
        float yA = y0;
        float zA = z0 - float(zNMask | 1);
        value += (aA * aA) * (aA * aA) * _fnlGradCoord3D(seed,
                                                         i + (xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), xA, yA, zA);
    }
    else
    {
        float aB = xAFlipMask0 + yAFlipMask0 + a0;
        if (aB > 0.f)
        {
            float xB = x0 - float(xNMask | 1);
            float yB = y0 - float(yNMask | 1);
            float zB = z0;
            value += (aB * aB) * (aB * aB) * _fnlGradCoord3D(seed,
                                                             i + (~xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (zNMask & PRIME_Z), xB, yB, zB);
        }

        float aC = zAFlipMask1 + a1;
        if (aC > 0.f)
        {
            float xC = x1;
            float yC = y1;
            float zC = float(zNMask | 1) + z1;
            value += (aC * aC) * (aC * aC) * _fnlGradCoord3D(seed2,
                                                             i + PRIME_X, j + PRIME_Y, k + (zNMask & (PRIME_Z << 1)), xC, yC, zC);
            skipD = true;
        }
    }

    if (!skip5)
    {
        float a5 = yAFlipMask1 + zAFlipMask1 + a1;
        if (a5 > 0.f)
        {
            float x5 = x1;
            float y5 = float(yNMask | 1) + y1;
            float z5 = float(zNMask | 1) + z1;
            value += (a5 * a5) * (a5 * a5) * _fnlGradCoord3D(seed2,
                                                             i + PRIME_X, j + (yNMask & (PRIME_Y << 1)), k + (zNMask & (PRIME_Z << 1)), x5, y5, z5);
        }
    }

    if (!skip9)
    {
        float a9 = xAFlipMask1 + zAFlipMask1 + a1;
        if (a9 > 0.f)
        {
            float x9 = float(xNMask | 1) + x1;
            float y9 = y1;
            float z9 = float(zNMask | 1) + z1;
            value += (a9 * a9) * (a9 * a9) * _fnlGradCoord3D(seed2,
                                                             i + (xNMask & (PRIME_X * 2)), j + PRIME_Y, k + (zNMask & (PRIME_Z << 1)), x9, y9, z9);
        }
    }

    if (!skipD)
    {
        float aD = xAFlipMask1 + yAFlipMask1 + a1;
        if (aD > 0.f)
        {
            float xD = float(xNMask | 1) + x1;
            float yD = float(yNMask | 1) + y1;
            float zD = z1;
            value += (aD * aD) * (aD * aD) * _fnlGradCoord3D(seed2,
                                                             i + (xNMask & (PRIME_X << 1)), j + (yNMask & (PRIME_Y << 1)), k + PRIME_Z, xD, yD, zD);
        }
    }

    return value * 9.046026385208288;
}

// Cellular Noise
float _fnlSingleCellular2D(fnl_state state, int seed, FNLfloat x, FNLfloat y)
{
    int xr = _fnlFastRound(x);
    int yr = _fnlFastRound(y);

    float distance0 = 1e10f;
    float distance1 = 1e10f;
    int closestHash = 0;

    float cellularJitter = 0.43701595f * state.cellular_jitter_mod;

    int xPrimed = (xr - 1) * PRIME_X;
    int yPrimedBase = (yr - 1) * PRIME_Y;

    switch (state.cellular_distance_func)
    {
        case FNL_CELLULAR_DISTANCE_MANHATTAN:
        {
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                int yPrimed = yPrimedBase;

                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    int hash = _fnlHash2D(seed, xPrimed, yPrimed);
                    int idx = hash & (255 << 1);

                    float vecX = float(xi) - x + RAND_VECS_2D[idx] * cellularJitter;
                    float vecY = float(yi) - y + RAND_VECS_2D[idx | 1] * cellularJitter;

                    float newDistance = _fnlFastAbs(vecX) + _fnlFastAbs(vecY);

                    distance1 = _fnlFastMax(_fnlFastMin(distance1, newDistance), distance0);
                    if (newDistance < distance0)
                    {
                        distance0 = newDistance;
                        closestHash = hash;
                    }
                    yPrimed += PRIME_Y;
                }
                xPrimed += PRIME_X;
            }
            break;
        }
        case FNL_CELLULAR_DISTANCE_HYBRID:
        {
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                int yPrimed = yPrimedBase;
                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    int hash = _fnlHash2D(seed, xPrimed, yPrimed);
                    int idx = hash & (255 << 1);

                    float vecX = float(xi) - x + RAND_VECS_2D[idx] * cellularJitter;
                    float vecY = float(yi) - y + RAND_VECS_2D[idx | 1] * cellularJitter;

                    float newDistance = (_fnlFastAbs(vecX) + _fnlFastAbs(vecY)) + (vecX * vecX + vecY * vecY);

                    distance1 = _fnlFastMax(_fnlFastMin(distance1, newDistance), distance0);
                    if (newDistance < distance0)
                    {
                        distance0 = newDistance;
                        closestHash = hash;
                    }
                    yPrimed += PRIME_Y;
                }
                xPrimed += PRIME_X;
            }
            break;
        }
		case FNL_CELLULAR_DISTANCE_EUCLIDEAN:
        case FNL_CELLULAR_DISTANCE_EUCLIDEANSQ:
        default:
        {
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                int yPrimed = yPrimedBase;

                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    int hash = _fnlHash2D(seed, xPrimed, yPrimed);
                    int idx = hash & (255 << 1);

                    float vecX = float(xi) - x + RAND_VECS_2D[idx] * cellularJitter;
                    float vecY = float(yi) - y + RAND_VECS_2D[idx | 1] * cellularJitter;

                    float newDistance = vecX * vecX + vecY * vecY;

                    distance1 = _fnlFastMax(_fnlFastMin(distance1, newDistance), distance0);
                    if (newDistance < distance0)
                    {
                        distance0 = newDistance;
                        closestHash = hash;
                    }
                    yPrimed += PRIME_Y;
                }
                xPrimed += PRIME_X;
            }
            break;
        }
    }

    if (state.cellular_distance_func == FNL_CELLULAR_DISTANCE_EUCLIDEAN && state.cellular_return_type >= FNL_CELLULAR_RETURN_TYPE_DISTANCE)
    {
        distance0 = _fnlFastSqrt(distance0);
        if (state.cellular_return_type >= FNL_CELLULAR_RETURN_TYPE_DISTANCE2)
		{			
            distance1 = _fnlFastSqrt(distance1);
		}
    }

    switch (state.cellular_return_type)
    {
        case FNL_CELLULAR_RETURN_TYPE_CELLVALUE:
            return float(closestHash) * (1.f / 2147483648.f);
        case FNL_CELLULAR_RETURN_TYPE_DISTANCE:
            return distance0 - 1.f;
        case FNL_CELLULAR_RETURN_TYPE_DISTANCE2:
            return distance1 - 1.f;
        case FNL_CELLULAR_RETURN_TYPE_DISTANCE2ADD:
            return (distance1 + distance0) * 0.5f - 1.f;
        case FNL_CELLULAR_RETURN_TYPE_DISTANCE2SUB:
            return distance1 - distance0 - 1.f;
        case FNL_CELLULAR_RETURN_TYPE_DISTANCE2MUL:
            return distance1 * distance0 * 0.5f - 1.f;
        case FNL_CELLULAR_RETURN_TYPE_DISTANCE2DIV:
            return distance0 / distance1 - 1.f;
        default:
            return 0.f;
    }
}

float _fnlSingleCellular3D(fnl_state state, int seed, FNLfloat x, FNLfloat y, FNLfloat z)
{
    int xr = _fnlFastRound(x);
    int yr = _fnlFastRound(y);
    int zr = _fnlFastRound(z);

    float distance0 = 1e10f;
    float distance1 = 1e10f;
    int closestHash = 0;

    float cellularJitter = 0.39614353 * state.cellular_jitter_mod;

    int xPrimed = (xr - 1) * PRIME_X;
    int yPrimedBase = (yr - 1) * PRIME_Y;
    int zPrimedBase = (zr - 1) * PRIME_Z;

    switch (state.cellular_distance_func)
    {
    case FNL_CELLULAR_DISTANCE_MANHATTAN:
    {
        for (int xi = xr - 1; xi <= xr + 1; xi++)
        {
            int yPrimed = yPrimedBase;

            for (int yi = yr - 1; yi <= yr + 1; yi++)
            {
                int zPrimed = zPrimedBase;

                for (int zi = zr - 1; zi <= zr + 1; zi++)
                {
                    int hash = _fnlHash3D(seed, xPrimed, yPrimed, zPrimed);
                    int idx = hash & (255 << 2);

                    float vecX = float(xi) - x + RAND_VECS_3D[idx] * cellularJitter;
                    float vecY = float(yi) - y + RAND_VECS_3D[idx | 1] * cellularJitter;
                    float vecZ = float(zi) - z + RAND_VECS_3D[idx | 2] * cellularJitter;

                    float newDistance = _fnlFastAbs(vecX) + _fnlFastAbs(vecY) + _fnlFastAbs(vecZ);

                    distance1 = _fnlFastMax(_fnlFastMin(distance1, newDistance), distance0);
                    if (newDistance < distance0)
                    {
                        distance0 = newDistance;
                        closestHash = hash;
                    }
                    zPrimed += PRIME_Z;
                }
                yPrimed += PRIME_Y;
            }
            xPrimed += PRIME_X;
        }
        break;
    }
    case FNL_CELLULAR_DISTANCE_HYBRID:
    {
        for (int xi = xr - 1; xi <= xr + 1; xi++)
        {
            int yPrimed = yPrimedBase;

            for (int yi = yr - 1; yi <= yr + 1; yi++)
            {
                int zPrimed = zPrimedBase;

                for (int zi = zr - 1; zi <= zr + 1; zi++)
                {
                    int hash = _fnlHash3D(seed, xPrimed, yPrimed, zPrimed);
                    int idx = hash & (255 << 2);

                    float vecX = float(xi) - x + RAND_VECS_3D[idx] * cellularJitter;
                    float vecY = float(yi) - y + RAND_VECS_3D[idx | 1] * cellularJitter;
                    float vecZ = float(zi) - z + RAND_VECS_3D[idx | 2] * cellularJitter;

                    float newDistance = (_fnlFastAbs(vecX) + _fnlFastAbs(vecY) + _fnlFastAbs(vecZ)) + (vecX * vecX + vecY * vecY + vecZ * vecZ);

                    distance1 = _fnlFastMax(_fnlFastMin(distance1, newDistance), distance0);
                    if (newDistance < distance0)
                    {
                        distance0 = newDistance;
                        closestHash = hash;
                    }
                    zPrimed += PRIME_Z;
                }
                yPrimed += PRIME_Y;
            }
            xPrimed += PRIME_X;
        }
        break;
    }
    case FNL_CELLULAR_DISTANCE_EUCLIDEAN:
    case FNL_CELLULAR_DISTANCE_EUCLIDEANSQ:
    default:
    {
        for (int xi = xr - 1; xi <= xr + 1; xi++)
        {
            int yPrimed = yPrimedBase;

            for (int yi = yr - 1; yi <= yr + 1; yi++)
            {
                int zPrimed = zPrimedBase;

                for (int zi = zr - 1; zi <= zr + 1; zi++)
                {
                    int hash = _fnlHash3D(seed, xPrimed, yPrimed, zPrimed);
                    int idx = hash & (255 << 2);

                    float vecX = float(xi) - x + RAND_VECS_3D[idx] * cellularJitter;
                    float vecY = float(yi) - y + RAND_VECS_3D[idx | 1] * cellularJitter;
                    float vecZ = float(zi) - z + RAND_VECS_3D[idx | 2] * cellularJitter;

                    float newDistance = vecX * vecX + vecY * vecY + vecZ * vecZ;

                    distance1 = _fnlFastMax(_fnlFastMin(distance1, newDistance), distance0);
                    if (newDistance < distance0)
                    {
                        distance0 = newDistance;
                        closestHash = hash;
                    }
                    zPrimed += PRIME_Z;
                }
                yPrimed += PRIME_Y;
            }
            xPrimed += PRIME_X;
        }
        break;
    }
    }

    if (state.cellular_distance_func == FNL_CELLULAR_DISTANCE_EUCLIDEAN && state.cellular_return_type >= FNL_CELLULAR_RETURN_TYPE_DISTANCE)
    {
        distance0 = _fnlFastSqrt(distance0);
        if (state.cellular_return_type >= FNL_CELLULAR_RETURN_TYPE_DISTANCE2)
		{
            distance1 = _fnlFastSqrt(distance1);
		}
    }

    switch (state.cellular_return_type)
    {
    case FNL_CELLULAR_RETURN_TYPE_CELLVALUE:
        return float(closestHash) * (1.f / 2147483648.f);
    case FNL_CELLULAR_RETURN_TYPE_DISTANCE:
        return distance0 - 1.f;
    case FNL_CELLULAR_RETURN_TYPE_DISTANCE2:
        return distance1 - 1.f;
    case FNL_CELLULAR_RETURN_TYPE_DISTANCE2ADD:
        return (distance1 + distance0) * 0.5f - 1.f;
    case FNL_CELLULAR_RETURN_TYPE_DISTANCE2SUB:
        return distance1 - distance0 - 1.f;
    case FNL_CELLULAR_RETURN_TYPE_DISTANCE2MUL:
        return distance1 * distance0 * 0.5f - 1.f;
    case FNL_CELLULAR_RETURN_TYPE_DISTANCE2DIV:
        return distance0 / distance1 - 1.f;
    default:
        return 0.f;
    }
}

// Perlin Noise
float _fnlSinglePerlin2D(int seed, FNLfloat x, FNLfloat y)
{
    int x0 = _fnlFastFloor(x);
    int y0 = _fnlFastFloor(y);

    float xd0 = x - float(x0);
    float yd0 = y - float(y0);
    float xd1 = xd0 - 1.f;
    float yd1 = yd0 - 1.f;

    float xs = _fnlInterpQuintic(xd0);
    float ys = _fnlInterpQuintic(yd0);

    x0 *= PRIME_X;
    y0 *= PRIME_Y;
    int x1 = x0 + PRIME_X;
    int y1 = y0 + PRIME_Y;

    float xf0 = _fnlLerp(_fnlGradCoord2D(seed, x0, y0, xd0, yd0), _fnlGradCoord2D(seed, x1, y0, xd1, yd0), xs);
    float xf1 = _fnlLerp(_fnlGradCoord2D(seed, x0, y1, xd0, yd1), _fnlGradCoord2D(seed, x1, y1, xd1, yd1), xs);

    return _fnlLerp(xf0, xf1, ys) * 1.4247691104677813;
}

float _fnlSinglePerlin3D(int seed, FNLfloat x, FNLfloat y, FNLfloat z)
{
    int x0 = _fnlFastFloor(x);
    int y0 = _fnlFastFloor(y);
    int z0 = _fnlFastFloor(z);

    float xd0 = x - float(x0);
    float yd0 = y - float(y0);
    float zd0 = z - float(z0);
    float xd1 = xd0 - 1.f;
    float yd1 = yd0 - 1.f;
    float zd1 = zd0 - 1.f;

    float xs = _fnlInterpQuintic(xd0);
    float ys = _fnlInterpQuintic(yd0);
    float zs = _fnlInterpQuintic(zd0);

    x0 *= PRIME_X;
    y0 *= PRIME_Y;
    z0 *= PRIME_Z;
    int x1 = x0 + PRIME_X;
    int y1 = y0 + PRIME_Y;
    int z1 = z0 + PRIME_Z;

    float xf00 = _fnlLerp(_fnlGradCoord3D(seed, x0, y0, z0, xd0, yd0, zd0), _fnlGradCoord3D(seed, x1, y0, z0, xd1, yd0, zd0), xs);
    float xf10 = _fnlLerp(_fnlGradCoord3D(seed, x0, y1, z0, xd0, yd1, zd0), _fnlGradCoord3D(seed, x1, y1, z0, xd1, yd1, zd0), xs);
    float xf01 = _fnlLerp(_fnlGradCoord3D(seed, x0, y0, z1, xd0, yd0, zd1), _fnlGradCoord3D(seed, x1, y0, z1, xd1, yd0, zd1), xs);
    float xf11 = _fnlLerp(_fnlGradCoord3D(seed, x0, y1, z1, xd0, yd1, zd1), _fnlGradCoord3D(seed, x1, y1, z1, xd1, yd1, zd1), xs);

    float yf0 = _fnlLerp(xf00, xf10, ys);
    float yf1 = _fnlLerp(xf01, xf11, ys);

    return _fnlLerp(yf0, yf1, zs) * 0.964921414852142333984375;
}


// Value Cubic
float _fnlSingleValueCubic2D(int seed, FNLfloat x, FNLfloat y)
{
    int x1 = _fnlFastFloor(x);
    int y1 = _fnlFastFloor(y);

    float xs = x - float(x1);
    float ys = y - float(y1);

    x1 *= PRIME_X;
    y1 *= PRIME_Y;

    int x0 = x1 - PRIME_X;
    int y0 = y1 - PRIME_Y;
    int x2 = x1 + PRIME_X;
    int y2 = y1 + PRIME_Y;
    int x3 = x1 + PRIME_X * 2;
    int y3 = y1 + PRIME_Y * 2;

    return _fnlCubicLerp(
        _fnlCubicLerp(_fnlValCoord2D(seed, x0, y0), _fnlValCoord2D(seed, x1, y0), _fnlValCoord2D(seed, x2, y0), _fnlValCoord2D(seed, x3, y0),
                      xs),
        _fnlCubicLerp(_fnlValCoord2D(seed, x0, y1), _fnlValCoord2D(seed, x1, y1), _fnlValCoord2D(seed, x2, y1), _fnlValCoord2D(seed, x3, y1),
                      xs),
        _fnlCubicLerp(_fnlValCoord2D(seed, x0, y2), _fnlValCoord2D(seed, x1, y2), _fnlValCoord2D(seed, x2, y2), _fnlValCoord2D(seed, x3, y2),
                      xs),
        _fnlCubicLerp(_fnlValCoord2D(seed, x0, y3), _fnlValCoord2D(seed, x1, y3), _fnlValCoord2D(seed, x2, y3), _fnlValCoord2D(seed, x3, y3),
                      xs),
        ys) * (1.f / (1.5f * 1.5f));
}

float _fnlSingleValueCubic3D(int seed, FNLfloat x, FNLfloat y, FNLfloat z)
{
    int x1 = _fnlFastFloor(x);
    int y1 = _fnlFastFloor(y);
    int z1 = _fnlFastFloor(z);

    float xs = x - float(x1);
    float ys = y - float(y1);
    float zs = z - float(z1);

    x1 *= PRIME_X;
    y1 *= PRIME_Y;
    z1 *= PRIME_Z;

    int x0 = x1 - PRIME_X;
    int y0 = y1 - PRIME_Y;
    int z0 = z1 - PRIME_Z;
    int x2 = x1 + PRIME_X;
    int y2 = y1 + PRIME_Y;
    int z2 = z1 + PRIME_Z;
    int x3 = x1 + PRIME_X * 2;
    int y3 = y1 + PRIME_Y * 2;
    int z3 = z1 + PRIME_Z * 2;

    return _fnlCubicLerp(
        _fnlCubicLerp(
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y0, z0), _fnlValCoord3D(seed, x1, y0, z0), _fnlValCoord3D(seed, x2, y0, z0), _fnlValCoord3D(seed, x3, y0, z0), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y1, z0), _fnlValCoord3D(seed, x1, y1, z0), _fnlValCoord3D(seed, x2, y1, z0), _fnlValCoord3D(seed, x3, y1, z0), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y2, z0), _fnlValCoord3D(seed, x1, y2, z0), _fnlValCoord3D(seed, x2, y2, z0), _fnlValCoord3D(seed, x3, y2, z0), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y3, z0), _fnlValCoord3D(seed, x1, y3, z0), _fnlValCoord3D(seed, x2, y3, z0), _fnlValCoord3D(seed, x3, y3, z0), xs),
            ys),
        _fnlCubicLerp(
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y0, z1), _fnlValCoord3D(seed, x1, y0, z1), _fnlValCoord3D(seed, x2, y0, z1), _fnlValCoord3D(seed, x3, y0, z1), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y1, z1), _fnlValCoord3D(seed, x1, y1, z1), _fnlValCoord3D(seed, x2, y1, z1), _fnlValCoord3D(seed, x3, y1, z1), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y2, z1), _fnlValCoord3D(seed, x1, y2, z1), _fnlValCoord3D(seed, x2, y2, z1), _fnlValCoord3D(seed, x3, y2, z1), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y3, z1), _fnlValCoord3D(seed, x1, y3, z1), _fnlValCoord3D(seed, x2, y3, z1), _fnlValCoord3D(seed, x3, y3, z1), xs),
            ys),
        _fnlCubicLerp(
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y0, z2), _fnlValCoord3D(seed, x1, y0, z2), _fnlValCoord3D(seed, x2, y0, z2), _fnlValCoord3D(seed, x3, y0, z2), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y1, z2), _fnlValCoord3D(seed, x1, y1, z2), _fnlValCoord3D(seed, x2, y1, z2), _fnlValCoord3D(seed, x3, y1, z2), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y2, z2), _fnlValCoord3D(seed, x1, y2, z2), _fnlValCoord3D(seed, x2, y2, z2), _fnlValCoord3D(seed, x3, y2, z2), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y3, z2), _fnlValCoord3D(seed, x1, y3, z2), _fnlValCoord3D(seed, x2, y3, z2), _fnlValCoord3D(seed, x3, y3, z2), xs),
            ys),
        _fnlCubicLerp(
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y0, z3), _fnlValCoord3D(seed, x1, y0, z3), _fnlValCoord3D(seed, x2, y0, z3), _fnlValCoord3D(seed, x3, y0, z3), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y1, z3), _fnlValCoord3D(seed, x1, y1, z3), _fnlValCoord3D(seed, x2, y1, z3), _fnlValCoord3D(seed, x3, y1, z3), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y2, z3), _fnlValCoord3D(seed, x1, y2, z3), _fnlValCoord3D(seed, x2, y2, z3), _fnlValCoord3D(seed, x3, y2, z3), xs),
            _fnlCubicLerp(_fnlValCoord3D(seed, x0, y3, z3), _fnlValCoord3D(seed, x1, y3, z3), _fnlValCoord3D(seed, x2, y3, z3), _fnlValCoord3D(seed, x3, y3, z3), xs),
            ys),
        zs) * (1.f / (1.5f * 1.5f * 1.5f));
}


// Value noise
float _fnlSingleValue2D(int seed, FNLfloat x, FNLfloat y)
{
    int x0 = _fnlFastFloor(x);
    int y0 = _fnlFastFloor(y);

    float xs = _fnlInterpHermite(x - float(x0));
    float ys = _fnlInterpHermite(y - float(y0));

    x0 *= PRIME_X;
    y0 *= PRIME_Y;
    int x1 = x0 + PRIME_X;
    int y1 = y0 + PRIME_Y;

    float xf0 = _fnlLerp(_fnlValCoord2D(seed, x0, y0), _fnlValCoord2D(seed, x1, y0), xs);
    float xf1 = _fnlLerp(_fnlValCoord2D(seed, x0, y1), _fnlValCoord2D(seed, x1, y1), xs);

    return _fnlLerp(xf0, xf1, ys);
}

float _fnlSingleValue3D(int seed, FNLfloat x, FNLfloat y, FNLfloat z)
{
    int x0 = _fnlFastFloor(x);
    int y0 = _fnlFastFloor(y);
    int z0 = _fnlFastFloor(z);

    float xs = _fnlInterpHermite(x - float(x0));
    float ys = _fnlInterpHermite(y - float(y0));
    float zs = _fnlInterpHermite(z - float(z0));

    x0 *= PRIME_X;
    y0 *= PRIME_Y;
    z0 *= PRIME_Z;
    int x1 = x0 + PRIME_X;
    int y1 = y0 + PRIME_Y;
    int z1 = z0 + PRIME_Z;

    float xf00 = _fnlLerp(_fnlValCoord3D(seed, x0, y0, z0), _fnlValCoord3D(seed, x1, y0, z0), xs);
    float xf10 = _fnlLerp(_fnlValCoord3D(seed, x0, y1, z0), _fnlValCoord3D(seed, x1, y1, z0), xs);
    float xf01 = _fnlLerp(_fnlValCoord3D(seed, x0, y0, z1), _fnlValCoord3D(seed, x1, y0, z1), xs);
    float xf11 = _fnlLerp(_fnlValCoord3D(seed, x0, y1, z1), _fnlValCoord3D(seed, x1, y1, z1), xs);

    float yf0 = _fnlLerp(xf00, xf10, ys);
    float yf1 = _fnlLerp(xf01, xf11, ys);

    return _fnlLerp(yf0, yf1, zs);
}

// Generic Noise Gen
float _fnlGenNoiseSingle2D(fnl_state state, int seed, FNLfloat x, FNLfloat y)
{
    switch (state.noise_type)
    {
        case FNL_NOISE_OPENSIMPLEX2:
            return _fnlSingleSimplex2D(seed, x, y);
        case FNL_NOISE_OPENSIMPLEX2S:
            return _fnlSingleOpenSimplex2S2D(seed, x, y);
        case FNL_NOISE_CELLULAR:
            return _fnlSingleCellular2D(state, seed, x, y);
        case FNL_NOISE_PERLIN:
            return _fnlSinglePerlin2D(seed, x, y);
        case FNL_NOISE_VALUE_CUBIC:
            return _fnlSingleValueCubic2D(seed, x, y);
        case FNL_NOISE_VALUE:
            return _fnlSingleValue2D(seed, x, y);
        default:
            return 0.f;
    }
}

float _fnlGenNoiseSingle3D(fnl_state state, int seed, FNLfloat x, FNLfloat y, FNLfloat z)
{
    switch (state.noise_type)
    {
        case FNL_NOISE_OPENSIMPLEX2:
            return _fnlSingleOpenSimplex23D(seed, x, y, z);
        case FNL_NOISE_OPENSIMPLEX2S:
            return _fnlSingleOpenSimplex2S3D(seed, x, y, z);
        case FNL_NOISE_CELLULAR:
            return _fnlSingleCellular3D(state, seed, x, y, z);
        case FNL_NOISE_PERLIN:
            return _fnlSinglePerlin3D(seed, x, y, z);
        case FNL_NOISE_VALUE_CUBIC:
            return _fnlSingleValueCubic3D(seed, x, y, z);
        case FNL_NOISE_VALUE:
            return _fnlSingleValue3D(seed, x, y, z);
        default:
            return 0.f;
    }
}

// Fractal FBm
float _fnlGenFractalFBM2D(fnl_state state, FNLfloat x, FNLfloat y)
{
    int seed = state.seed;
    float sum = 0.f;
    float amp = _fnlCalculateFractalBounding(state);

    for (int i = 0; i < state.octaves; i++)
    {
        float noise = _fnlGenNoiseSingle2D(state, seed++, x, y);
        sum += noise * amp;
        amp *= _fnlLerp(1.f, _fnlFastMin(noise + 1.f, 2.f) * 0.5f, state.weighted_strength);

        x *= state.lacunarity;
        y *= state.lacunarity;
        amp *= state.gain;
    }

    return sum;
}

float _fnlGenFractalFBM3D(fnl_state state, FNLfloat x, FNLfloat y, FNLfloat z)
{
    int seed = state.seed;
    float sum = 0.f;
    float amp = _fnlCalculateFractalBounding(state);

    for (int i = 0; i < state.octaves; i++)
    {
        float noise = _fnlGenNoiseSingle3D(state, seed++, x, y, z);
        sum += noise * amp;
        amp *= _fnlLerp(1.f, (noise + 1.f) * 0.5f, state.weighted_strength);

        x *= state.lacunarity;
        y *= state.lacunarity;
        z *= state.lacunarity;
        amp *= state.gain;
    }

    return sum;
}

// Fractal Ridged
float _fnlGenFractalRidged2D(fnl_state state, FNLfloat x, FNLfloat y)
{
    int seed = state.seed;
    float sum = 0.f;
    float amp = _fnlCalculateFractalBounding(state);

    for (int i = 0; i < state.octaves; i++)
    {
        float noise = _fnlFastAbs(_fnlGenNoiseSingle2D(state, seed++, x, y));
        sum += (noise * -2.f + 1.f) * amp;
        amp *= _fnlLerp(1.f, 1.f - noise, state.weighted_strength);

        x *= state.lacunarity;
        y *= state.lacunarity;
        amp *= state.gain;
    }

    return sum;
}

float _fnlGenFractalRidged3D(fnl_state state, FNLfloat x, FNLfloat y, FNLfloat z)
{
    int seed = state.seed;
    float sum = 0.f;
    float amp = _fnlCalculateFractalBounding(state);

    for (int i = 0; i < state.octaves; i++)
    {
        float noise = _fnlFastAbs(_fnlGenNoiseSingle3D(state, seed++, x, y, z));
        sum += (noise * -2.f + 1.f) * amp;
        amp *= _fnlLerp(1.f, 1.f - noise, state.weighted_strength);

        x *= state.lacunarity;
        y *= state.lacunarity;
        z *= state.lacunarity;
        amp *= state.gain;
    }

    return sum;
}

// Fractal PingPong
float _fnlGenFractalPingPong2D(fnl_state state, FNLfloat x, FNLfloat y)
{
    int seed = state.seed;
    float sum = 0.f;
    float amp = _fnlCalculateFractalBounding(state);

    for (int i = 0; i < state.octaves; i++)
    {
        float noise = _fnlPingPong((_fnlGenNoiseSingle2D(state, seed++, x, y) + 1.f) * state.ping_pong_strength);
        sum += (noise - 0.5f) * 2.f * amp;
        amp *= _fnlLerp(1.f, noise, state.weighted_strength);

        x *= state.lacunarity;
        y *= state.lacunarity;
        amp *= state.gain;
    }

    return sum;
}

float _fnlGenFractalPingPong3D(fnl_state state, FNLfloat x, FNLfloat y, FNLfloat z)
{
    int seed = state.seed;
    float sum = 0.f;
    float amp = _fnlCalculateFractalBounding(state);

    for (int i = 0; i < state.octaves; i++)
    {
        float noise = _fnlPingPong((_fnlGenNoiseSingle3D(state, seed++, x, y, z) + 1.f) * state.ping_pong_strength);
        sum += (noise - 0.5f) * 2.f * amp;
        amp *= _fnlLerp(1.f, noise, state.weighted_strength);

        x *= state.lacunarity;
        y *= state.lacunarity;
        z *= state.lacunarity;
        amp *= state.gain;
    }

    return sum;
}



// Domain Warp Simplex/OpenSimplex2
void _fnlSingleDomainWarpSimplexGradient(int seed, float warpAmp, float frequency, FNLfloat x, FNLfloat y, inout FNLfloat xr, inout FNLfloat yr, bool outGradOnly)
{
    const float SQRT3 = 1.7320508075688772935274463415059;
    const float G2 = (3.f - SQRT3) / 6.f;

    x *= frequency;
    y *= frequency;

    // --- Skew moved to TransformNoiseCoordinate method ---
    // const FNLfloat F2 = 0.5f * (SQRT3 - 1);
    // FNLfloat s = (x + y) * F2;
    // x += s; y += s;


    int i = _fnlFastFloor(x);
    int j = _fnlFastFloor(y);
    float xi = x - float(i);
    float yi = y - float(j);

    float t = (xi + yi) * G2;
    float x0 = xi - t;
    float y0 = yi - t;

    i *= PRIME_X;
    j *= PRIME_Y;

    float vx, vy;
    vx = vy = 0.f;

    float a = 0.5f - x0 * x0 - y0 * y0;
    if (a > 0.f)
    {
        float aaaa = (a * a) * (a * a);
        float xo, yo;
        if (outGradOnly)
		{
            _fnlGradCoordOut2D(seed, i, j, xo, yo);
		}
        else
        {
			_fnlGradCoordDual2D(seed, i, j, x0, y0, xo, yo);
		}
        vx += aaaa * xo;
        vy += aaaa * yo;
    }

    float c = (2.f * (1.f - 2.f * G2) * (1.f / G2 - 2.f)) * t + ((-2.f * (1.f - 2.f * G2) * (1.f - 2.f * G2)) + a);
    if (c > 0.f)
    {
        float x2 = x0 + (2.f * G2 - 1.f);
        float y2 = y0 + (2.f * G2 - 1.f);
        float cccc = (c * c) * (c * c);
        float xo, yo;
        if (outGradOnly)
		{
            _fnlGradCoordOut2D(seed, i + PRIME_X, j + PRIME_Y, xo, yo);
		}
        else
		{
            _fnlGradCoordDual2D(seed, i + PRIME_X, j + PRIME_Y, x2, y2, xo, yo);
		}
        vx += cccc * xo;
        vy += cccc * yo;
    }

    if (y0 > x0)
    {
        float x1 = x0 + G2;
        float y1 = y0 + (G2 - 1.f);
        float b = 0.5f - x1 * x1 - y1 * y1;
        if (b > 0.f)
        {
            float bbbb = (b * b) * (b * b);
            float xo, yo;
            if (outGradOnly)
			{
                _fnlGradCoordOut2D(seed, i, j + PRIME_Y, xo, yo);
			}
            else
			{
                _fnlGradCoordDual2D(seed, i, j + PRIME_Y, x1, y1, xo, yo);
			}
            vx += bbbb * xo;
            vy += bbbb * yo;
        }
    }
    else
    {
        float x1 = x0 + (G2 - 1.f);
        float y1 = y0 + G2;
        float b = 0.5f - x1 * x1 - y1 * y1;
        if (b > 0.f)
        {
            float bbbb = (b * b) * (b * b);
            float xo, yo;
            if (outGradOnly)
			{
                _fnlGradCoordOut2D(seed, i + PRIME_X, j, xo, yo);
			}
            else
            {
				_fnlGradCoordDual2D(seed, i + PRIME_X, j, x1, y1, xo, yo);
			}
            vx += bbbb * xo;
            vy += bbbb * yo;
        }
    }

    xr += vx * warpAmp;
    yr += vy * warpAmp;
}

void _fnlSingleDomainWarpOpenSimplex2Gradient(int seed, float warpAmp, float frequency, FNLfloat x, FNLfloat y, FNLfloat z, inout FNLfloat xr, inout FNLfloat yr, inout FNLfloat zr, bool outGradOnly)
{
    x *= frequency;
    y *= frequency;
    z *= frequency;

    // --- Rotation moved to TransformDomainWarpCoordinate method ---
    // const FNLfloat R3 = (FNLfloat)(2.f / 3.f);
    // FNLfloat r = (x + y + z) * R3; // Rotation, not skew
    // x = r - x; y = r - y; z = r - z;


    int i = _fnlFastRound(x);
    int j = _fnlFastRound(y);
    int k = _fnlFastRound(z);
    float x0 = x - float(i);
    float y0 = y - float(j);
    float z0 = z - float(k);

    int xNSign = int(-x0 - 1.f) | 1;
    int yNSign = int(-y0 - 1.f) | 1;
    int zNSign = int(-z0 - 1.f) | 1;

    float ax0 = float(xNSign) * -x0;
    float ay0 = float(yNSign) * -y0;
    float az0 = float(zNSign) * -z0;

    i *= PRIME_X;
    j *= PRIME_Y;
    k *= PRIME_Z;

    float vx, vy, vz;
    vx = vy = vz = 0.f;

    float a = (0.6f - x0 * x0) - (y0 * y0 + z0 * z0);
    for (int l = 0; l < 2; l++)
    {
        if (a > 0.f)
        {
            float aaaa = (a * a) * (a * a);
            float xo, yo, zo;
            if (outGradOnly)
			{
                _fnlGradCoordOut3D(seed, i, j, k, xo, yo, zo);
			}
            else
			{
                _fnlGradCoordDual3D(seed, i, j, k, x0, y0, z0, xo, yo, zo);
			}
            vx += aaaa * xo;
            vy += aaaa * yo;
            vz += aaaa * zo;
        }

        float b = a + 1.f;
        int i1 = i;
        int j1 = j;
        int k1 = k;
        float x1 = x0;
        float y1 = y0;
        float z1 = z0;
        if (ax0 >= ay0 && ax0 >= az0)
        {
            x1 += float(xNSign);
            b -= float(xNSign) * 2.f * x1;
            i1 -= xNSign * PRIME_X;
        }
        else if (ay0 > ax0 && ay0 >= az0)
        {
            y1 += float(yNSign);
            b -= float(yNSign) * 2.f * y1;
            j1 -= yNSign * PRIME_Y;
        }
        else
        {
            z1 += float(zNSign);
            b -= float(zNSign) * 2.f * z1;
            k1 -= zNSign * PRIME_Z;
        }

        if (b > 0.f)
        {
            float bbbb = (b * b) * (b * b);
            float xo, yo, zo;
            if (outGradOnly)
			{
                _fnlGradCoordOut3D(seed, i1, j1, k1, xo, yo, zo);
			}
            else
			{
                _fnlGradCoordDual3D(seed, i1, j1, k1, x1, y1, z1, xo, yo, zo);
			}
            vx += bbbb * xo;
            vy += bbbb * yo;
            vz += bbbb * zo;
        }

        if (l == 1) break;

        ax0 = 0.5f - ax0;
        ay0 = 0.5f - ay0;
        az0 = 0.5f - az0;

        x0 = float(xNSign) * ax0;
        y0 = float(yNSign) * ay0;
        z0 = float(zNSign) * az0;

        a += (0.75f - ax0) - (ay0 + az0);

        i += (xNSign >> 1) & PRIME_X;
        j += (yNSign >> 1) & PRIME_Y;
        k += (zNSign >> 1) & PRIME_Z;

        xNSign = -xNSign;
        yNSign = -yNSign;
        zNSign = -zNSign;

        seed += 1293373;
    }

    xr += vx * warpAmp;
    yr += vy * warpAmp;
    zr += vz * warpAmp;
}

// Domain Warp Basic Grid
void _fnlSingleDomainWarpBasicGrid2D(int seed, float warpAmp, float frequency, FNLfloat x, FNLfloat y, inout FNLfloat xp, inout FNLfloat yp)
{
    FNLfloat xf = x * frequency;
    FNLfloat yf = y * frequency;

    int x0 = _fnlFastFloor(xf);
    int y0 = _fnlFastFloor(yf);

    float xs = _fnlInterpHermite(xf - float(x0));
    float ys = _fnlInterpHermite(yf - float(y0));

    x0 *= PRIME_X;
    y0 *= PRIME_Y;
    int x1 = x0 + PRIME_X;
    int y1 = y0 + PRIME_Y;

    int idx0 = _fnlHash2D(seed, x0, y0) & (255 << 1);
    int idx1 = _fnlHash2D(seed, x1, y0) & (255 << 1);

    float lx0x = _fnlLerp(RAND_VECS_2D[idx0], RAND_VECS_2D[idx1], xs);
    float ly0x = _fnlLerp(RAND_VECS_2D[idx0 | 1], RAND_VECS_2D[idx1 | 1], xs);

    idx0 = _fnlHash2D(seed, x0, y1) & (255 << 1);
    idx1 = _fnlHash2D(seed, x1, y1) & (255 << 1);

    float lx1x = _fnlLerp(RAND_VECS_2D[idx0], RAND_VECS_2D[idx1], xs);
    float ly1x = _fnlLerp(RAND_VECS_2D[idx0 | 1], RAND_VECS_2D[idx1 | 1], xs);

    xp += _fnlLerp(lx0x, lx1x, ys) * warpAmp;
    yp += _fnlLerp(ly0x, ly1x, ys) * warpAmp;
}

void _fnlSingleDomainWarpBasicGrid3D(int seed, float warpAmp, float frequency, FNLfloat x, FNLfloat y, FNLfloat z, inout FNLfloat xp, inout FNLfloat yp, inout FNLfloat zp)
{
    FNLfloat xf = x * frequency;
    FNLfloat yf = y * frequency;
    FNLfloat zf = z * frequency;

    int x0 = _fnlFastFloor(xf);
    int y0 = _fnlFastFloor(yf);
    int z0 = _fnlFastFloor(zf);

    float xs = _fnlInterpHermite(xf - float(x0));
    float ys = _fnlInterpHermite(yf - float(y0));
    float zs = _fnlInterpHermite(zf - float(z0));

    x0 *= PRIME_X;
    y0 *= PRIME_Y;
    z0 *= PRIME_Z;
    int x1 = x0 + PRIME_X;
    int y1 = y0 + PRIME_Y;
    int z1 = z0 + PRIME_Z;

    int idx0 = _fnlHash3D(seed, x0, y0, z0) & (255 << 2);
    int idx1 = _fnlHash3D(seed, x1, y0, z0) & (255 << 2);

    float lx0x = _fnlLerp(RAND_VECS_3D[idx0], RAND_VECS_3D[idx1], xs);
    float ly0x = _fnlLerp(RAND_VECS_3D[idx0 | 1], RAND_VECS_3D[idx1 | 1], xs);
    float lz0x = _fnlLerp(RAND_VECS_3D[idx0 | 2], RAND_VECS_3D[idx1 | 2], xs);

    idx0 = _fnlHash3D(seed, x0, y1, z0) & (255 << 2);
    idx1 = _fnlHash3D(seed, x1, y1, z0) & (255 << 2);

    float lx1x = _fnlLerp(RAND_VECS_3D[idx0], RAND_VECS_3D[idx1], xs);
    float ly1x = _fnlLerp(RAND_VECS_3D[idx0 | 1], RAND_VECS_3D[idx1 | 1], xs);
    float lz1x = _fnlLerp(RAND_VECS_3D[idx0 | 2], RAND_VECS_3D[idx1 | 2], xs);

    float lx0y = _fnlLerp(lx0x, lx1x, ys);
    float ly0y = _fnlLerp(ly0x, ly1x, ys);
    float lz0y = _fnlLerp(lz0x, lz1x, ys);

    idx0 = _fnlHash3D(seed, x0, y0, z1) & (255 << 2);
    idx1 = _fnlHash3D(seed, x1, y0, z1) & (255 << 2);

    lx0x = _fnlLerp(RAND_VECS_3D[idx0], RAND_VECS_3D[idx1], xs);
    ly0x = _fnlLerp(RAND_VECS_3D[idx0 | 1], RAND_VECS_3D[idx1 | 1], xs);
    lz0x = _fnlLerp(RAND_VECS_3D[idx0 | 2], RAND_VECS_3D[idx1 | 2], xs);

    idx0 = _fnlHash3D(seed, x0, y1, z1) & (255 << 2);
    idx1 = _fnlHash3D(seed, x1, y1, z1) & (255 << 2);

    lx1x = _fnlLerp(RAND_VECS_3D[idx0], RAND_VECS_3D[idx1], xs);
    ly1x = _fnlLerp(RAND_VECS_3D[idx0 | 1], RAND_VECS_3D[idx1 | 1], xs);
    lz1x = _fnlLerp(RAND_VECS_3D[idx0 | 2], RAND_VECS_3D[idx1 | 2], xs);

    xp += _fnlLerp(lx0y, _fnlLerp(lx0x, lx1x, ys), zs) * warpAmp;
    yp += _fnlLerp(ly0y, _fnlLerp(ly0x, ly1x, ys), zs) * warpAmp;
    zp += _fnlLerp(lz0y, _fnlLerp(lz0x, lz1x, ys), zs) * warpAmp;
}

// Domain Warp
void _fnlDoSingleDomainWarp2D(fnl_state state, int seed, float amp, float freq, FNLfloat x, FNLfloat y, inout FNLfloat xp, inout FNLfloat yp)
{
    switch (state.domain_warp_type)
    {
    case FNL_DOMAIN_WARP_OPENSIMPLEX2:
        _fnlSingleDomainWarpSimplexGradient(seed, amp * 38.283687591552734375, freq, x, y, xp, yp, false);
        break;
    case FNL_DOMAIN_WARP_OPENSIMPLEX2_REDUCED:
        _fnlSingleDomainWarpSimplexGradient(seed, amp * 16.f, freq, x, y, xp, yp, true);
        break;
    case FNL_DOMAIN_WARP_BASICGRID:
        _fnlSingleDomainWarpBasicGrid2D(seed, amp, freq, x, y, xp, yp);
        break;
    }
}

void _fnlDoSingleDomainWarp3D(fnl_state state, int seed, float amp, float freq, FNLfloat x, FNLfloat y, FNLfloat z, inout FNLfloat xp, inout FNLfloat yp, inout FNLfloat zp)
{
    switch (state.domain_warp_type)
    {
    case FNL_DOMAIN_WARP_OPENSIMPLEX2:
        _fnlSingleDomainWarpOpenSimplex2Gradient(seed, amp * 32.69428253173828125, freq, x, y, z, xp, yp, zp, false);
        break;
    case FNL_DOMAIN_WARP_OPENSIMPLEX2_REDUCED:
        _fnlSingleDomainWarpOpenSimplex2Gradient(seed, amp * 7.71604938271605, freq, x, y, z, xp, yp, zp, true);
        break;
    case FNL_DOMAIN_WARP_BASICGRID:
        _fnlSingleDomainWarpBasicGrid3D(seed, amp, freq, x, y, z, xp, yp, zp);
        break;
    }
}

// Domain Warp Single Wrapper
void _fnlDomainWarpSingle2D(fnl_state state, inout FNLfloat x, inout FNLfloat y)
{
    int seed = state.seed;
    float amp = state.domain_warp_amp * _fnlCalculateFractalBounding(state);
    float freq = state.frequency;

    FNLfloat xs = x;
    FNLfloat ys = y;
    _fnlTransformDomainWarpCoordinate2D(state, xs, ys);

    _fnlDoSingleDomainWarp2D(state, seed, amp, freq, xs, ys, x, y);
}

void _fnlDomainWarpSingle3D(fnl_state state, inout FNLfloat x, inout FNLfloat y, inout FNLfloat z)
{
    int seed = state.seed;
    float amp = state.domain_warp_amp * _fnlCalculateFractalBounding(state);
    float freq = state.frequency;

    FNLfloat xs = x;
    FNLfloat ys = y;
    FNLfloat zs = z;
    _fnlTransformDomainWarpCoordinate3D(state, xs, ys, zs);

    _fnlDoSingleDomainWarp3D(state, seed, amp, freq, xs, ys, zs, x, y, z);
}

// Domain Warp Fractal Progressive
void _fnlDomainWarpFractalProgressive2D(fnl_state state, inout FNLfloat x, inout FNLfloat y)
{
    int seed = state.seed;
    float amp = state.domain_warp_amp * _fnlCalculateFractalBounding(state);
    float freq = state.frequency;

    for (int i = 0; i < state.octaves; i++)
    {
        FNLfloat xs = x;
        FNLfloat ys = y;
        _fnlTransformDomainWarpCoordinate2D(state, xs, ys);

        _fnlDoSingleDomainWarp2D(state, seed, amp, freq, xs, ys, x, y);

        seed++;
        amp *= state.gain;
        freq *= state.lacunarity;
    }
}

void _fnlDomainWarpFractalProgressive3D(fnl_state state, inout FNLfloat x, inout FNLfloat y, inout FNLfloat z)
{
    int seed = state.seed;
    float amp = state.domain_warp_amp * _fnlCalculateFractalBounding(state);
    float freq = state.frequency;

    for (int i = 0; i < state.octaves; i++)
    {
        FNLfloat xs = x;
        FNLfloat ys = y;
        FNLfloat zs = z;
        _fnlTransformDomainWarpCoordinate3D(state, xs, ys, zs);

        _fnlDoSingleDomainWarp3D(state, seed, amp, freq, xs, ys, zs, x, y, z);

        seed++;
        amp *= state.gain;
        freq *= state.lacunarity;
    }
}

// Domain Warp Fractal Independent
void _fnlDomainWarpFractalIndependent2D(fnl_state state, inout FNLfloat x, inout FNLfloat y)
{
    FNLfloat xs = x;
    FNLfloat ys = y;
    _fnlTransformDomainWarpCoordinate2D(state, xs, ys);

    int seed = state.seed;
    float amp = state.domain_warp_amp * _fnlCalculateFractalBounding(state);
    float freq = state.frequency;

    for (int i = 0; i < state.octaves; i++)
    {
        _fnlDoSingleDomainWarp2D(state, seed, amp, freq, xs, ys, x, y);

        seed++;
        amp *= state.gain;
        freq *= state.lacunarity;
    }
}

void _fnlDomainWarpFractalIndependent3D(fnl_state state, inout FNLfloat x, inout FNLfloat y, inout FNLfloat z)
{
    FNLfloat xs = x;
    FNLfloat ys = y;
    FNLfloat zs = z;
    _fnlTransformDomainWarpCoordinate3D(state, xs, ys, zs);

    int seed = state.seed;
    float amp = state.domain_warp_amp * _fnlCalculateFractalBounding(state);
    float freq = state.frequency;

    for (int i = 0; i < state.octaves; i++)
    {
        _fnlDoSingleDomainWarp3D(state, seed, amp, freq, xs, ys, zs, x, y, z);

        seed++;
        amp *= state.gain;
        freq *= state.lacunarity;
    }
}

// ====================
// Public API
// ====================

// Creates a noise state with default values.
// @param seed Optionally set the state seed.
fnl_state fnlCreateState(int seed)
{
    fnl_state newState;
    newState.seed = seed;
    newState.frequency = 0.01f;
    newState.noise_type = FNL_NOISE_OPENSIMPLEX2;
    newState.rotation_type_3d = FNL_ROTATION_NONE;
    newState.fractal_type = FNL_FRACTAL_NONE;
    newState.octaves = 3;
    newState.lacunarity = 2.f;
    newState.gain = 0.5f;
    newState.weighted_strength = 0.f;
    newState.ping_pong_strength = 2.f;
    newState.cellular_distance_func = FNL_CELLULAR_DISTANCE_EUCLIDEANSQ;
    newState.cellular_return_type = FNL_CELLULAR_RETURN_TYPE_DISTANCE;
    newState.cellular_jitter_mod = 1.f;
    newState.domain_warp_amp = 30.f;
    newState.domain_warp_type = FNL_DOMAIN_WARP_OPENSIMPLEX2;
    return newState;
}

// 2D noise at given position using the state settings
// @returns Noise output bounded between -1 and 1.
float fnlGetNoise2D(fnl_state state, FNLfloat x, FNLfloat y)
{
    _fnlTransformNoiseCoordinate2D(state, x, y);

    switch (state.fractal_type)
    {
        default:
            return _fnlGenNoiseSingle2D(state, state.seed, x, y);
        case FNL_FRACTAL_FBM:
            return _fnlGenFractalFBM2D(state, x, y);
        case FNL_FRACTAL_RIDGED:
            return _fnlGenFractalRidged2D(state, x, y);
        case FNL_FRACTAL_PINGPONG:
            return _fnlGenFractalPingPong2D(state, x, y);
    }
}

// 3D noise at given position using the state settings
// @returns Noise output bounded between -1 and 1.
float fnlGetNoise3D(fnl_state state, FNLfloat x, FNLfloat y, FNLfloat z)
{
    _fnlTransformNoiseCoordinate3D(state, x, y, z);

    // Select a noise type
    switch (state.fractal_type)
    {
        default:
            return _fnlGenNoiseSingle3D(state, state.seed, x, y, z);
        case FNL_FRACTAL_FBM:
            return _fnlGenFractalFBM3D(state, x, y, z);
        case FNL_FRACTAL_RIDGED:
            return _fnlGenFractalRidged3D(state, x, y, z);
        case FNL_FRACTAL_PINGPONG:
            return _fnlGenFractalPingPong3D(state, x, y, z);
    }
}

// 2D warps the input position using current domain warp settings.
// 
// Example usage with fnlGetNoise2D:
// ```
// fnlDomainWarp2D(state, x, y);
// noise = fnlGetNoise2D(state, x, y);
// ```
void fnlDomainWarp2D(fnl_state state, inout FNLfloat x, inout FNLfloat y)
{
    switch (state.fractal_type)
    {
        default:
            _fnlDomainWarpSingle2D(state, x, y);
            break;
        case FNL_FRACTAL_DOMAIN_WARP_PROGRESSIVE:
            _fnlDomainWarpFractalProgressive2D(state, x, y);
            break;
        case FNL_FRACTAL_DOMAIN_WARP_INDEPENDENT:
            _fnlDomainWarpFractalIndependent2D(state, x, y);
            break;
    }
}

// 3D warps the input position using current domain warp settings.
// 
// Example usage with fnlGetNoise3D:
// ```
// fnlDomainWarp3D(state, x, y, z);
// noise = fnlGetNoise3D(state, x, y, z);
// ```
void fnlDomainWarp3D(fnl_state state, inout FNLfloat x, inout FNLfloat y, inout FNLfloat z)
{
	
    switch (state.fractal_type)
    {
        default:
            _fnlDomainWarpSingle3D(state, x, y, z);
            break;
        case FNL_FRACTAL_DOMAIN_WARP_PROGRESSIVE:
            _fnlDomainWarpFractalProgressive3D(state, x, y, z);
            break;
        case FNL_FRACTAL_DOMAIN_WARP_INDEPENDENT:
            _fnlDomainWarpFractalIndependent3D(state, x, y, z);
            break;
    }
}



and here the compute shader


//StarPositions.glsl
#[compute]
#version 450
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Input uniforms
layout(set = 0, binding = 0) uniform Params {
    float u_seed;
    float u_arm_count;
    float u_arm_width;
    float u_star_density;
    float u_star_size;  // Resolution
    float u_star_circle_radius;
    float u_swirl_amount;
};

// Output buffer
layout(set = 0, binding = 1, std430) buffer StarBuffer {
    vec4 star_data[];
};

// Hash function
float hash(vec2 p, float seed) {
    vec3 p3 = fract(vec3(p.xyx) * vec3(5.3983, 5.4427, 6.9371) + seed);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    uvec2 id = gl_GlobalInvocationID.xy;
    vec2 uv = vec2(id) / u_star_size;
    
    // Calculate distance and angle from center
    vec2 centered_uv = uv - 0.5;
    float dist = length(centered_uv);
    float angle = atan(centered_uv.y, centered_uv.x);

    // Apply swirl effect
    float swirl = u_swirl_amount * (1.0 - dist);
    angle += swirl;

    // Calculate arm angle
    float arm_angle = fract((angle / (2.0 * 3.14159265359)) * u_arm_count);
    
    // Create arm mask
    float arm_mask = step(0.5 - u_arm_width / 2.0, arm_angle) - step(0.5 + u_arm_width / 2.0, arm_angle);

    float star_hash = hash(uv, u_seed);
    float star_mask = step(1.0 - u_star_density, star_hash);

    // Apply circular mask
    float circle_mask = step(dist, u_star_circle_radius);

    // Final mask combines arm, star, and circle masks
    float final_mask = arm_mask * star_mask * circle_mask;

    if (final_mask > 0.5) {
        // This is a star within the circle and on an arm
        uint index = gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x + gl_GlobalInvocationID.x;
        // Invert the y-coordinate here before sending
        star_data[index] = vec4(uv.x, 1.0 - uv.y, star_hash, 1.0);
    }
}


Galaxies scene has nodes with these three scripts

# Galaxies.gd in Galaxies scene
@tool
extends Node3D

@export var galaxy_count = 100
@export var field_size = Vector3(1000, 1000, 1000)
@export var base_resolution = 512  # Base resolution for scaling
@export var main_seed = 12345  # Add this line

@export var visible_galaxy_distance: float = 369.0

var galaxy_scene = preload("res://Scenes/GalaxySprite.tscn")
var galaxy_core_scene = preload("res://Scenes/GalaxyCore.tscn")
var rng = RandomNumberGenerator.new()

var debug_rect: TextureRect

# Parameter ranges
var arm_count_range = [2, 3, 4, 5, 6]
var arm_width_range = {
	2: [0.2, 0.4],
	3: [0.3, 0.5],
	4: [0.2, 0.4],
	5: [0.3, 0.5],
	6: [0.3, 0.5]
}
var circle_size_range = [0.4, 0.5]
var star_density_range = [0.01, 0.03]
var galaxy_size_range = [10.0, 10.0]
var resolution_range = [128.0, 512.0]

var galaxy_seed
var galaxy_rng
var galaxy_temp
var cube_cam
var panorama
var galaxy
var skybox_galaxy
var resolution

var galaxies_offset_done = false

func _ready():
	var will_this_help = GlobalState.starting_zone()
	if GlobalState.is_returning_from_galaxy:
		print("Returning from galaxy, setting up return camera")
		setup_return_camera()
		rng.seed = main_seed
		generate_galaxy_field()
		#GlobalState.clear_return_from_star_data()
	else:
		print("Starting new galaxy field generation")
		rng.seed = main_seed
		generate_galaxy_field()

func generate_galaxy_field():
	for i in range(galaxy_count):
		#await get_tree().create_timer(0.001).timeout
		galaxy = galaxy_scene.instantiate()
		# Create and set up the galaxy core
		var galaxy_core = galaxy_core_scene.instantiate()
		# Generate a unique, deterministic seed for each galaxy
		galaxy_seed = generate_galaxy_seed(i)
		add_child(galaxy)
		galaxy.add_child(galaxy_core)
		
		# Use this seed to set up a separate RNG for this galaxy's parameters
		galaxy_rng = RandomNumberGenerator.new()
		galaxy_rng.seed = galaxy_seed
		var position_galaxy = generate_spherical_position(field_size, galaxy_rng)
		#var position_galaxy = Vector3(
		#	galaxy_rng.randf_range(-field_size.x/2, field_size.x/2),
		#	galaxy_rng.randf_range(-field_size.y/2, field_size.y/2),
		#	galaxy_rng.randf_range(-field_size.z/2, field_size.z/2)
		#)
		galaxy.transform.origin = position_galaxy

		var arm_count = arm_count_range[galaxy_rng.randi() % arm_count_range.size()]
		var arm_width = galaxy_rng.randf_range(arm_width_range[arm_count][0], arm_width_range[arm_count][1])
		var circle_size = galaxy_rng.randf_range(circle_size_range[0], circle_size_range[1])
		var star_density = galaxy_rng.randf_range(star_density_range[0], star_density_range[1])
		var galaxy_size = galaxy_rng.randf_range(galaxy_size_range[0], galaxy_size_range[1])
		resolution = resolution_range[galaxy_rng.randi() % resolution_range.size()]
		var fog_density = galaxy_rng.randf_range(0.05, 0.1)
		var fog_arm_width_multiplier = galaxy_rng.randf_range(1.5, 2.0)
		var galaxy_fog_temperature = random_temperature()
		var galaxy_fog_color = random_color(galaxy_fog_temperature)
		var galaxy_fog_swirl = random_swirld(arm_count)
		
		if not galaxy.has_method("set_parameters"):
			print("Error: galaxy instance does not have set_parameters method")
			continue
		galaxy.set_parameters(
			galaxy_seed,
			arm_count,
			arm_width,
			circle_size,
			star_density,
			resolution,
			fog_density,
			fog_arm_width_multiplier,
			galaxy_fog_color,
			galaxy_temp,
			galaxy_fog_temperature,
			galaxy_fog_swirl
		)
		
		galaxy_core.set_parameters(galaxy_fog_color, resolution * 4)
		var scale_factor = galaxy_size
		galaxy.scale = Vector3(scale_factor, scale_factor, scale_factor)
		galaxy.rotation = Vector3(
			galaxy_rng.randf_range(0, 2 * PI),
			galaxy_rng.randf_range(0, 2 * PI),
			galaxy_rng.randf_range(0, 2 * PI)
		)
		galaxy.add_to_group("galaxies")
	print("Galaxy field generation complete!")
	
func generate_spherical_position(field_size: Vector3, rng: RandomNumberGenerator) -> Vector3:
	var radius = field_size.x / 2  # Assuming field_size is cubic
	
	# Generate random spherical coordinates
	var theta = rng.randf_range(0, 2 * PI)  # Azimuthal angle
	var phi = acos(rng.randf_range(-1, 1))  # Polar angle
	var r = radius * pow(rng.randf(), 1.0/3.0)  # Radius
	
	# Convert spherical coordinates to Cartesian
	var x = r * sin(phi) * cos(theta)
	var y = r * sin(phi) * sin(theta)
	var z = r * cos(phi)
	
	return Vector3(x, y, z)
	
func generate_galaxy_seed(index: int) -> int:
	# Generate a base value from the main seed
	rng.seed = main_seed
	var base = rng.randi()
	# Combine the base value with the galaxy index to create a unique seed
	return base + index

func capture_visible_galaxies(target_galaxy):
	var visible_galaxies = []
	var target_position = target_galaxy.global_transform.origin
	for galaxy in get_tree().get_nodes_in_group("galaxies"):
		if galaxy != target_galaxy and is_galaxy_visible(galaxy, target_position):
			visible_galaxies.append({
				"position": galaxy.global_transform.origin - target_position,
				"scale": galaxy.scale,
				"parameters": galaxy.get_shader_parameters()
			})
	return visible_galaxies

func is_galaxy_visible(galaxy, from_position):
	if galaxy == null or from_position == null:
		return false
	var distance = galaxy.global_transform.origin.distance_to(from_position)
	return distance <= visible_galaxy_distance
	
func capture_galaxy_field(target_galaxy: Node3D) -> Dictionary:
	var field_data = {}
	for galaxy in get_tree().get_nodes_in_group("galaxies"):
		if galaxy != target_galaxy:
			field_data[galaxy.get_instance_id()] = {
				"position": galaxy.global_transform.origin - target_galaxy.global_transform.origin,
				"scale": galaxy.scale,
				"color": galaxy.get_node("Sprite3D").modulate,
				"parameters": galaxy.get_shader_parameters()
			}
	return field_data

func store_galaxy_field_data(target_galaxy: Node3D):
	var field_data = capture_galaxy_field(target_galaxy)
	GlobalState.store_galaxy_field(field_data)

func transition_to_galaxy(target_galaxy):
	if target_galaxy == null:
		print("Error: target_galaxy is null")
		return
	# a variant that becomes a function of a variant
	var visible_galaxies = capture_visible_galaxies(target_galaxy)
	GlobalState.store_visible_galaxies(visible_galaxies)
	#Global state function to store galaxy data, something can be like var something = null, and then we make something that is in function in different script in its (word) so that word becomes {} for example
	GlobalState.store_galaxy_data({
		"id": target_galaxy.get_galaxy_id(),
		"seed": target_galaxy.get_galaxy_seed(),
		"shader_params": target_galaxy.get_shader_parameters(),
		"texture": target_galaxy.get_galaxy_texture(),
		"scale": target_galaxy.scale,
		"rotation": target_galaxy.rotation,
		"shader_path": target_galaxy.material_override.shader.resource_path if target_galaxy.material_override and target_galaxy.material_override.shader else null,
		"rotation_quat": target_galaxy.global_transform.basis,  # Capture full rotation
		"galaxy_position": target_galaxy.global_transform.origin
	})
	
	# Store camera information
	var camera = $Camera3D
	print("galaxies pitch stuff transition to a galaxy  camera._total_pitch = ",  camera._total_pitch)
	GlobalState.store_camera_data({
		"position": camera.global_transform.origin - target_galaxy.global_transform.origin,
		"rotation": camera.global_rotation,
		"total_pitch": camera._total_pitch if "_total_pitch" in camera else 0.0
	})
	skybox_galaxy = target_galaxy
	#set up 360 camera, load scene and stuff
	setup_360_camera()
	# generating skybox function
	generate_and_store_skybox(target_galaxy)
	# because of await stuff, i had to move it to where we play around with cubecam
	#get_tree().change_scene_to_file("res://Scenes/GalaxyCloseUp.tscn")

func setup_debug_display():
	debug_rect = TextureRect.new()
	debug_rect.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	debug_rect.expand_mode = TextureRect.EXPAND_IGNORE_SIZE
	debug_rect.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
	add_child(debug_rect)
	
func random_color(galaxy_temperature: float) -> Color:
	var galaxy_type = galaxy_rng.randi() % 5  # 0-4 for different galaxy types
	#print("galaxy temp in function = ", galaxy_temperature)
	
	# Define color ranges for different temperature brackets
	var colors = [
		Color(1.0, 0.0, 0.0),   # Red
		Color(1.0, 0.5, 0.0),   # Orange
		Color(1.0, 1.0, 0.0),   # Yellow
		Color(1.0, 1.0, 1.0),   # White
		Color(0.5, 1.0, 1.0),   # Light Blue
		Color(0.0, 0.0, 1.0),   # Blue
		Color(0.5, 0.0, 1.0)    # Purple
	]

	# Define the temperature range
	var min_temp = 2000.0
	var max_temp = 18000.0

	# Clamp temperature between min_temp and max_temp
	var clamped_temp = clamp(galaxy_temperature, min_temp, max_temp)
	
	# Normalize temperature to 0-1 range
	var normalized_temp = (clamped_temp - min_temp) / (max_temp - min_temp)
	
	# Ensure normalized_temp is exactly 0.0 or 1.0 at the extremes
	if is_equal_approx(normalized_temp, 0.0):
		normalized_temp = 0.0
	elif is_equal_approx(normalized_temp, 1.0):
		normalized_temp = 1.0
	
	# Calculate color index
	var color_index = normalized_temp * (colors.size() - 1)
	
	var index1 = int(floor(color_index))
	var index2 = int(ceil(color_index))
	index2 = min(index2, colors.size() - 1)  # Ensure we don't go out of bounds
	
	var t = fmod(color_index, 1.0)
	
	# Interpolate between the two closest colors
	var final_color = colors[index1].lerp(colors[index2], t)
	
	# Apply gamma correction
	final_color.r = pow(final_color.r, 1.0 / 2.2)
	final_color.g = pow(final_color.g, 1.0 / 2.2)
	final_color.b = pow(final_color.b, 1.0 / 2.2)
	
	#print("final color maybe lol = ", final_color)
	return final_color

func random_temperature():
	var galaxy_temperature = galaxy_rng.randf_range(0.0, 20000.0)
	
	if (galaxy_temperature < 2000.0):
		galaxy_temp = 0 # Red
	elif (galaxy_temperature < 4000.0):
		galaxy_temp = 1 # Orange
	elif (galaxy_temperature < 5000.0):
		galaxy_temp = 2 # Yellow
	elif (galaxy_temperature < 7000.0):
		galaxy_temp = 3 # White
	elif (galaxy_temperature < 8000.0):
		galaxy_temp = 4 # Light Blue
	elif (galaxy_temperature < 10000.0):
		galaxy_temp = 5 # Light Blue
	elif (galaxy_temperature < 14000.0):
		galaxy_temp = 6 # Blue
	elif (galaxy_temperature > 18000.0):
		galaxy_temp = 7 # Purple
	#print(galaxy_temp)
	return galaxy_temperature
	
func random_swirld(arm_count):
	var galaxy_swirld #= galaxy_rng.randf_range(5.0, 13.0)
	#print("arm_count = ", arm_count)
	match arm_count:
		2:  # Two armed galaxies
			galaxy_swirld = galaxy_rng.randf_range(13.0, 22.0)
		3:  # Three armed galaxies
			galaxy_swirld = galaxy_rng.randf_range(9.0, 15.0)
		4:  # Four armed galaxies
			galaxy_swirld = galaxy_rng.randf_range(7.0, 9.0)
		5:  # Five armed galaxies
			galaxy_swirld = galaxy_rng.randf_range(6.0, 8.0)
		6:  # Six armed galaxies
			galaxy_swirld = galaxy_rng.randf_range(5.0, 7.0)
	
	#print("galaxy_swirld = ", galaxy_swirld)
	return galaxy_swirld
func setup_360_camera():
	print("func setup_360_camera():")
	#preloading the scene to add it as node later
	cube_cam = preload("res://addons/camera360/CubeCam.tscn").instantiate()
	#after loading a scene, we add it as node
	add_child(cube_cam)
	cube_cam.cube_size = 1024
	cube_cam.far = 100000  # Adjust based on the scale of your universe

func generate_and_store_skybox(target_galaxy):
	offset_galaxies_first_impact(target_galaxy) #offset_galaxies_first_impact
	cube_cam.global_position = target_galaxy.global_transform.origin
	cube_cam.global_transform.origin = target_galaxy.global_transform.origin
	var target_galaxy_first_position = target_galaxy.global_transform.origin 
	target_galaxy.global_transform.origin = Vector3(2137, 2137, 2137)

	$SubViewportContainer/SubViewport/Panorama.set_from_cubemap(cube_cam)
	
	# Wait for a few frames to ensure the Panorama node is updated
	await get_tree().process_frame
	#await get_tree().process_frame
	await get_tree().create_timer(0.1).timeout
	
	
	
	
	var sub_viewport = $SubViewportContainer/SubViewport
	#print("rotation of cubecam = ", cube_cam.global_rotation)
	#print("SubViewport size: ", sub_viewport.size)
	#print("$SubViewportContainer size: ", $SubViewportContainer.size)
	#print("$SubViewportContainer/SubViewport/Panorama size: ", $SubViewportContainer/SubViewport/Panorama.size)
	var viewport_texture = $SubViewportContainer/SubViewport.get_texture()
	
	var viewport = $SubViewportContainer/SubViewport
	var image = viewport.get_texture().get_image()
	
	# Create a texture from the captured image
	var skybox_texture = ImageTexture.create_from_image(image)
	
	# Ensure the texture is not a placeholder
	if skybox_texture == null:
		print("Error: Panorama texture is null")
		return
	
	GlobalState.store_skybox_texture(skybox_texture)
	print("Skybox texture stored successfully")

	offset_galaxies(target_galaxy_first_position) #offset_galaxies_first_impact


func setup_return_camera():
	if GlobalState.return_camera_data and GlobalState.return_galaxy_data:
		var camera = $Camera3D as FreeLookCamera  # Make sure this matches your camera class name
		
		# Set camera position
		camera.global_transform.origin = GlobalState.return_camera_data.position
		print("Camera return position: ", camera.global_transform.origin)
		
		# Set camera rotation
		camera.global_rotation = GlobalState.return_camera_data.rotation
		print("Camera return rotation: ", camera.global_rotation)
		
		# Set camera pitch
		camera._total_pitch = GlobalState.return_camera_data.total_pitch
		print("Camera return pitch: ", camera._total_pitch)
		
		# Print galaxy data for reference
		print("Returned from galaxy ID: ", GlobalState.return_galaxy_data.id)
		print("Galaxy position: ", GlobalState.return_galaxy_data.galaxy_position)
		
		# You might want to highlight or focus on the galaxy you returned from
		# This depends on how you want to handle the return visually
		highlight_returned_galaxy(GlobalState.return_galaxy_data.galaxy_position)
		
		# Clear the return data after using it
		GlobalState.clear_return_data()
	else:
		print("No return data available, using default position")

func highlight_returned_galaxy(position: Vector3):
	# This is a placeholder function. Implement this based on how you want to
	# visually indicate the galaxy you returned from.
	print("Highlighting galaxy at position: ", position)
	# For example, you might want to create a temporary visual indicator
	# or move the camera to focus on this position

func offset_galaxies_first_impact(target_galaxy_first_position):
	for galaxy in get_tree().get_nodes_in_group("galaxies"):
		var current_position = galaxy.global_transform.origin
		var new_position = current_position * 2
		galaxy.global_transform.origin = new_position
	print("All galaxies have been offset")

func offset_galaxies(target_galaxy_first_position):
	for galaxy in get_tree().get_nodes_in_group("galaxies"):
		var current_position = galaxy.global_transform.origin
		var new_position = current_position * 2
		galaxy.global_transform.origin = new_position
	print("All galaxies have been offset")
	generate_and_store_offset_skybox(target_galaxy_first_position)
	
func offset_galaxies_last_supper(target_galaxy_first_position):
	for galaxy in get_tree().get_nodes_in_group("galaxies"):
		var current_position = galaxy.global_transform.origin
		var new_position = current_position * 2
		galaxy.global_transform.origin = new_position
	print("All galaxies have been offset")
	generate_and_store_celestialbody_skybox(target_galaxy_first_position)

func generate_and_store_offset_skybox(target_galaxy_first_position):

	
	await get_tree().process_frame
	await get_tree().create_timer(0.1).timeout
	
	
	var sub_viewport = $SubViewportContainer/SubViewport
	print("rotation of cubecam = ", cube_cam.global_rotation)
	print("SubViewport size: ", sub_viewport.size)
	print("$SubViewportContainer size: ", $SubViewportContainer.size)
	print("$SubViewportContainer/SubViewport/Panorama size: ", $SubViewportContainer/SubViewport/Panorama.size)
	var viewport_texture = $SubViewportContainer/SubViewport.get_texture()
	
	var viewport = $SubViewportContainer/SubViewport
	var image = viewport.get_texture().get_image()
	
	# Create a texture from the captured image
	var skybox_texture = ImageTexture.create_from_image(image)
	
	# Ensure the texture is not a placeholder
	if skybox_texture == null:
		print("Error: Panorama texture is null")
		return
	
	# Store the skybox texture in GlobalState
	GlobalState.store_offset_skybox_texture(skybox_texture)
	print("Skybox texture stored successfully")
	
	offset_galaxies_last_supper(target_galaxy_first_position)
	#get_tree().change_scene_to_file("res://Scenes/GalaxyCloseUp.tscn")
	
	
#GlobalState.store_celestialbody_skybox_texture(skybox_texture)
func generate_and_store_celestialbody_skybox(target_galaxy_first_position):

	await get_tree().process_frame
	await get_tree().create_timer(0.1).timeout
	var sub_viewport = $SubViewportContainer/SubViewport
	print("rotation of cubecam = ", cube_cam.global_rotation)
	print("SubViewport size: ", sub_viewport.size)
	print("$SubViewportContainer size: ", $SubViewportContainer.size)
	print("$SubViewportContainer/SubViewport/Panorama size: ", $SubViewportContainer/SubViewport/Panorama.size)
	var viewport_texture = $SubViewportContainer/SubViewport.get_texture()
	
	var viewport = $SubViewportContainer/SubViewport
	var image = viewport.get_texture().get_image()
	
	# Create a texture from the captured image
	var skybox_texture = ImageTexture.create_from_image(image)
	
	# Ensure the texture is not a placeholder
	if skybox_texture == null:
		print("Error: Panorama texture is null")
		return
	
	# Store the skybox texture in GlobalState
	GlobalState.store_celestialbody_skybox_texture(skybox_texture)
	print("Skybox texture stored successfully")
	GlobalState.update_elapsed_time()
	get_tree().change_scene_to_file("res://Scenes/GalaxyCloseUp.tscn")



#Camera node in galaxies scene, mostly movement stuff, but here we check what galaxy is closest 
class_name FreeLookCamera extends Camera3D

# Modifier keys' speed multiplier
const SHIFT_MULTIPLIER = 2.5
const ALT_MULTIPLIER = 1.0 / SHIFT_MULTIPLIER

@export_range(0.0, 1.0) var sensitivity = 0.25

# Mouse state
var _mouse_position = Vector2(0.0, 0.0)
var _total_pitch = 0.0

# Movement state
var _direction = Vector3(0.0, 0.0, 0.0)
var _velocity = Vector3(0.0, 0.0, 0.0)
var _acceleration = 300
var _deceleration = -100
var _vel_multiplier = 4

# Keyboard state
var _w = false
var _s = false
var _a = false
var _d = false
var _q = false
var _e = false
var _shift = false
var _alt = false

var closest_galaxy = null
var closest_distance = INF
@export var transition_distance = 1

func _input(event):
	# Receives mouse motion
	if event is InputEventMouseMotion:
		_mouse_position = event.relative
	
	# Receives mouse button input
	if event is InputEventMouseButton:
		match event.button_index:
			MOUSE_BUTTON_RIGHT: # Only allows rotation if right click down
				Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED if event.pressed else Input.MOUSE_MODE_VISIBLE)
			MOUSE_BUTTON_WHEEL_UP: # Increases max velocity
				_vel_multiplier = clamp(_vel_multiplier * 1.1, 0.2, 20)
			MOUSE_BUTTON_WHEEL_DOWN: # Decereases max velocity
				_vel_multiplier = clamp(_vel_multiplier / 1.1, 0.2, 20)

	# Receives key input
	if event is InputEventKey:
		match event.keycode:
			KEY_W:
				_w = event.pressed
			KEY_S:
				_s = event.pressed
			KEY_A:
				_a = event.pressed
			KEY_D:
				_d = event.pressed
			KEY_Q:
				_q = event.pressed
			KEY_E:
				_e = event.pressed

# Updates mouselook and movement every frame
func _process(delta):
	_update_mouselook()
	_update_movement(delta)
	update_closest_galaxy()
	check_for_transition()
	#print("_total_pitch = ", _total_pitch)

# Updates camera movement
func _update_movement(delta):
	# Computes desired direction from key states
	_direction = Vector3((_d as float) - (_a as float), 
						(_e as float) - (_q as float), 
						(_s as float) - (_w as float))
	
	# Computes the change in velocity due to desired direction and "drag"
	# The "drag" is a constant acceleration on the camera to bring it's velocity to 0
	var offset = _direction.normalized() * _acceleration * _vel_multiplier * delta \
		+ _velocity.normalized() * _deceleration * _vel_multiplier * delta
	
	# Compute modifiers' speed multiplier
	var speed_multi = 22
	if _shift: speed_multi *= SHIFT_MULTIPLIER
	if _alt: speed_multi *= ALT_MULTIPLIER
	
	# Checks if we should bother translating the camera
	if _direction == Vector3.ZERO and offset.length_squared() > _velocity.length_squared():
		# Sets the velocity to 0 to prevent jittering due to imperfect deceleration
		_velocity = Vector3.ZERO
	else:
		# Clamps speed to stay within maximum value (_vel_multiplier)
		_velocity.x = clamp(_velocity.x + offset.x, -_vel_multiplier, _vel_multiplier)
		_velocity.y = clamp(_velocity.y + offset.y, -_vel_multiplier, _vel_multiplier)
		_velocity.z = clamp(_velocity.z + offset.z, -_vel_multiplier, _vel_multiplier)
	
		translate(_velocity * delta * speed_multi)

# Updates mouse look 
func _update_mouselook():
	# Only rotates mouse if the mouse is captured
	if Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
		_mouse_position *= sensitivity
		var yaw = _mouse_position.x
		var pitch = _mouse_position.y
		_mouse_position = Vector2(0, 0)
		
		# Prevents looking up/down too far
		pitch = clamp(pitch, -90 - _total_pitch, 90 - _total_pitch)
		_total_pitch += pitch
	
		rotate_y(deg_to_rad(-yaw))
		rotate_object_local(Vector3(1,0,0), deg_to_rad(-pitch))

func update_closest_galaxy():
	var galaxies = get_tree().get_nodes_in_group("galaxies")
	#print("Number of galaxies found: ", galaxies.size())
	
	closest_galaxy = null
	closest_distance = INF
	
	for galaxy in galaxies:
		if galaxy == null:
			print("Found a null galaxy in the group")
			continue
		
		var distance = global_transform.origin.distance_to(galaxy.global_transform.origin)
		#print("galaxy.global_transform.origin = ", galaxy.global_transform.origin)
		if distance < closest_distance:
			closest_galaxy = galaxy
			closest_distance = distance
	
	if closest_galaxy:
		#print("Closest galaxy: %s, Distance: %.2f" % [closest_galaxy.get_galaxy_id(), closest_distance])
		var galaxy_resolution = closest_galaxy.get_resolution()
		transition_distance = galaxy_resolution / 17
		#print(galaxy_resolution)
	else:
		print("No closest galaxy found")

func check_for_transition():
	if closest_galaxy and closest_distance < transition_distance:
		#print("you are number uno lol")
		#print("closest_galaxy.global_transform.origin = ", closest_galaxy.global_transform.origin)
		get_parent().transition_to_galaxy(closest_galaxy)



# PanoramoFromCubeMap.gd a script in that Panorama named node which is probably ColorRect, also in addon folder
extends TextureRect

@export var ForwardTexture:Texture2D : get = get_forward_texture, set = set_forward_texture
@export var LeftTexture:Texture2D : get = get_left_texture, set = set_left_texture
@export var BackTexture:Texture2D : get = get_back_texture, set = set_back_texture
@export var RightTexture:Texture2D : get = get_right_texture, set = set_right_texture
@export var TopTexture:Texture2D : get = get_top_texture, set = set_top_texture
@export var BottomTexture:Texture2D : get = get_bottom_texture, set = set_bottom_texture

var is_ready = false

func set_from_cubemap(cubemap):
	set_forward_texture(cubemap.get_forward_texture())
	set_left_texture(cubemap.get_left_texture())
	set_back_texture(cubemap.get_back_texture())
	set_right_texture(cubemap.get_right_texture())
	set_top_texture(cubemap.get_top_texture())
	set_bottom_texture(cubemap.get_bottom_texture())

func set_forward_texture(new_texture : Texture2D):
	ForwardTexture = new_texture
	if is_ready:
		material.set_shader_parameter('ForwardTexture', ForwardTexture)

func get_forward_texture():
	return ForwardTexture

func set_left_texture(new_texture : Texture2D):
	LeftTexture = new_texture
	if is_ready:
		material.set_shader_parameter('LeftTexture', LeftTexture)

func get_left_texture():
	return LeftTexture

func set_back_texture(new_texture : Texture2D):
	BackTexture = new_texture
	if is_ready:
		material.set_shader_parameter('BackTexture', BackTexture)

func get_back_texture():
	return BackTexture

func set_right_texture(new_texture : Texture2D):
	RightTexture = new_texture
	if is_ready:
		material.set_shader_parameter('RightTexture', RightTexture)

func get_right_texture():
	return RightTexture

func set_top_texture(new_texture : Texture2D):
	TopTexture = new_texture
	if is_ready:
		material.set_shader_parameter('TopTexture', TopTexture)

func get_top_texture():
	return TopTexture

func set_bottom_texture(new_texture : Texture2D):
	BottomTexture = new_texture
	if is_ready:
		material.set_shader_parameter('BottomTexture', BottomTexture)

func get_bottom_texture():
	return BottomTexture

# Called when the node enters the scene tree for the first time.
func _ready():
	# we are ready
	is_ready = true
	
	# assign textures to shader
	set_forward_texture(ForwardTexture)
	set_left_texture(LeftTexture)
	set_back_texture(BackTexture)
	set_right_texture(RightTexture)
	set_top_texture(TopTexture)
	set_bottom_texture(BottomTexture)


Galaxy sprite scene has one node with that script

# GalaxySprite.gd in scene GalaxySprite, here we are generating with help of a shader a Galaxy, with fog and arms
@tool
extends Sprite3D

var shader_material: ShaderMaterial
var pending_parameters: Dictionary = {}
var galaxy_id: int
var shader_parameters: Dictionary = {}
var galaxy_texture: ImageTexture
var galaxy_seed: int
var resolution: float

func _ready():
#	print("GalaxySprite _ready function called")
	
	# Create a placeholder texture
	var image = Image.create(512, 512, false, Image.FORMAT_RGBA8)
	image.fill(Color(1, 1, 1, 1))  # White color
	var texture_galaxy = ImageTexture.create_from_image(image)
	
	# Assign the texture to the Sprite3D
	self.texture = texture_galaxy
	
	# Load the shader directly
	var shader = load("res://Shaders/EnhancedGalaxy.gdshader")
	if shader == null:
		print("Error: Could not load .gdshader file")
		return
	
	# Create a new ShaderMaterial with the loaded shader
	shader_material = ShaderMaterial.new()
	shader_material.shader = shader
	
	# Assign the material to the Sprite3D
	material_override = shader_material
#	print("Created new ShaderMaterial and assigned shader")

	# Apply any pending parameters
	if not pending_parameters.is_empty():
		_apply_parameters(pending_parameters)
	galaxy_id = get_instance_id()
	#print(galaxy_id)
	#add_to_group("galaxies")

func set_parameters(seed_galaxy: int, arm_count: int, arm_width: float, circle_size: float, star_density: float, resolution: float, fog_density: float, fog_arm_width_multiplier: float, galaxy_fog_color: Color, galaxy_temp: int, galaxy_fog_temperature: float, galaxy_fog_swirl: float):
	#print("seed_galaxy",seed_galaxy, "arm_count",arm_count, "arm_width",arm_width, "circle_size",circle_size, "star_density",star_density, "resolution", resolution, "fog_density", fog_density, "fog_arm_width_multiplier", fog_arm_width_multiplier, "galaxy_fog_color", galaxy_fog_color)
	galaxy_seed = seed_galaxy
	self.resolution = resolution
	#print("are we there?")
	shader_parameters = {
		"u_seed": float(seed_galaxy) / 1000000.0,
		"u_arm_count": float(arm_count),
		"u_arm_width": arm_width,
		"u_star_circle_radius": circle_size * 0.95,  # Slightly smaller for stars
		"u_fog_circle_radius": circle_size,
		"u_star_density": star_density,
		"u_star_size": resolution,
		"u_swirl_amount": galaxy_fog_swirl,
		"u_arm_color": Color(0.0, 0.0, 0.0),  # Purple color for arms
		"u_space_color": Color(0.0, 0.0, 0.0),
		"u_star_color": Color(1, 1, 1),
		"u_background_color": Color(0, 0, 0),
		"u_galaxy_color": galaxy_fog_color,  # Lighter purple for fog
		"u_fog_density": float(fog_density),
		"u_noise_scale": 5.0,
		"u_fog_arm_width_multiplier": float(fog_arm_width_multiplier),  # Make fog arms 20% wider than star arms
		"u_galaxy_temp": galaxy_temp,
		"u_galaxy_temperature": galaxy_fog_temperature
	}
	
	#print("this is galaxy temp generated lets see if it is this lol = ", galaxy_temp)
	#print("do we send that shish = ", galaxy_fog_temperature)
	#print(" is this that whole color thingu = ", galaxy_fog_color)
	if shader_material:
		for param in shader_parameters:
			shader_material.set_shader_parameter(param, shader_parameters[param])
	# Create and store the galaxy texture
	var image = Image.create(int(resolution), int(resolution), false, Image.FORMAT_RGBA8)
	galaxy_texture = ImageTexture.create_from_image(image)
	texture = galaxy_texture

func _apply_parameters(params: Dictionary):
	for key in params:
		shader_material.set_shader_parameter(key, params[key])
#	print("Shader parameters applied")

func get_galaxy_id():
	return galaxy_id
	
func get_shader_parameters():
	return shader_parameters
	
func get_galaxy_texture():
	return galaxy_texture
	
func get_galaxy_seed():
	return galaxy_seed

func get_resolution():
	return resolution


//EnhancedGalaxy.gdshader
shader_type spatial;
render_mode blend_mix, cull_disabled, unshaded;

// Original galaxy parameters
uniform float u_swirl_amount : hint_range(0, 10) = 5.0;
uniform float u_arm_count : hint_range(2, 8) = 4.0;
uniform float u_arm_width : hint_range(0, 1) = 0.465;
uniform float u_star_density : hint_range(0, 1) = 0.1;
uniform float u_star_size : hint_range(1, 1024) = 512.0;
uniform vec3 u_star_color : source_color = vec3(1.0, 1.0, 1.0);
uniform float u_circle_radius : hint_range(0, 0.5) = 0.5;
uniform float u_star_circle_radius : hint_range(0, 0.5) = 0.48;
uniform float u_fog_circle_radius : hint_range(0, 0.5) = 0.5;
uniform float u_seed : hint_range(0, 99999999) = 0.003;
uniform float u_galaxy_temperature : hint_range(0.0, 20000) = 4000;

// New parameters for enhanced visuals
uniform vec3 u_galaxy_color : source_color = vec3(0.5, 0.5, 1.0);  // Base color for fog and core
uniform float u_fog_density : hint_range(0, 1) = 0.5;
uniform float u_core_size : hint_range(0, 1) = 0.1;
uniform float u_noise_scale : hint_range(0.1, 10.0) = 2.0;

// Uniform definitions
uniform vec3 u_arm_color : source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 u_space_color : source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 u_background_color : source_color = vec3(0.0, 0.0, 0.0);
uniform float u_fog_arm_width_multiplier : hint_range(1.0, 2.0) = 1.05;

// Additional uniforms for output, probably not needed?
uniform sampler2D u_output_texture;
uniform vec2 u_output_texture_size;
uniform int u_galaxy_temp;


// SimpleNoise functions
float simple_noise_random(vec2 point) {
    return fract(sin(point.x * 100. + point.y * 654.125) * 55647.8745);
}

float value_noise(vec2 uv) {
    vec2 grid_uv = fract(uv);
    vec2 grid_id = floor(uv);
    grid_uv = grid_uv * grid_uv * (3. - 2. * grid_uv);
    float bottom_left = simple_noise_random(grid_id);
    float bottom_right = simple_noise_random(grid_id + vec2(1, 0));
    float bottom = mix(bottom_left, bottom_right, grid_uv.x);
    float top_left = simple_noise_random(grid_id + vec2(0, 1));
    float top_right = simple_noise_random(grid_id + vec2(1, 1));
    float top = mix(top_left, top_right, grid_uv.x);
    return mix(bottom, top, grid_uv.y);
}

float simple_noise(vec2 uv, float scale, int octaves) {
    octaves = clamp(octaves, 1, 6);
    float noise = value_noise(uv * scale);
    float amplitude = 1.;
    for(int i = 1; i < octaves; i++) {
        scale *= 2.;
        amplitude /= 2.;
        noise += value_noise(uv * scale) * amplitude;
    }
    return noise / 2.;
}


// New function for simplex noise (for fog effect)
vec3 mod289_vec3(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289_vec2(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }

vec3 permute(vec3 x) { return mod289_vec3(((x*34.0)+1.0)*x); }

float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                        -0.577350269189626,  // -1.0 + 2.0 * C.x
                        0.024390243902439); // 1.0 / 41.0
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289_vec2(i); // Use the vec2 version here
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
        + i.x + vec3(0.0, i1.x, 1.0 ));

    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

// Hash function (if not already present)
float hash(vec2 p, float seed) {
    vec3 p3 = fract(vec3(p.xyx) * vec3(5.3983, 5.4427, 6.9371) + seed);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

// Galaxy generation function
vec4 generate_galaxy4(vec2 uv, float swirl_amount, float arm_count, float arm_width, float star_density, float star_size, vec3 arm_color, vec3 space_color, vec3 star_color, float circle_radius, vec3 background_color, float your_seed_value) {
    vec2 centered_uv = (floor((uv - 0.5) * star_size) / star_size) + 0.5;
    vec2 offset_uv = centered_uv - 0.5;
    float dist = length(offset_uv);
    float angle = atan(offset_uv.y, offset_uv.x);
    
    // Swirl effect
    float swirl = swirl_amount * (1.0 - dist);
    angle += swirl;
    
    // Galaxy arms
    float arm_angle = fract(angle * arm_count / (2.0 * PI));
    
    // Star arms (sharp edges)
    float star_arm_mask = step(0.5 - arm_width/2.0, arm_angle) - step(0.5 + arm_width/2.0, arm_angle);
    
    // Fog arms (wider with gradient)
    float fog_arm_width = arm_width * u_fog_arm_width_multiplier;
    float fog_arm_mask = smoothstep(0.5 - fog_arm_width/2.0, 0.5 - arm_width/2.0, arm_angle) 
                       - smoothstep(0.5 + arm_width/2.0, 0.5 + fog_arm_width/2.0, arm_angle);
    
    // Stars
    float star_hash = hash(centered_uv, your_seed_value);
    float star_mask = step(1.0 - star_density, star_hash) * star_arm_mask;
    
    // Circular cutouts
    float star_circle_mask = step(dist, u_star_circle_radius);
    float fog_circle_mask = smoothstep(u_fog_circle_radius, u_fog_circle_radius - 0.01, dist);
    
    // Combine colors
    vec3 fog_color = mix(space_color, arm_color, fog_arm_mask * fog_circle_mask);
    vec3 galaxy_color = mix(fog_color, star_color, star_mask * star_circle_mask);
    
    float alpha = max(fog_arm_mask * fog_circle_mask, star_mask * star_circle_mask);
    
    return vec4(galaxy_color, alpha);
}

void fragment() {
    // Generate base galaxy
    vec4 galaxy = generate_galaxy4(UV, u_swirl_amount, u_arm_count, u_arm_width, u_star_density, 
                                   u_star_size, u_arm_color, u_space_color, u_star_color, 
                                   u_circle_radius, u_background_color, u_seed);
    
    // Generate noise for fog
    float noise = simple_noise(UV * u_noise_scale, 10.0, 3);
    
    // Apply noise to fog, but not to stars
    vec3 fog_color = mix(u_arm_color, u_galaxy_color, noise * u_fog_density);
    vec3 final_color = mix(fog_color, galaxy.rgb, step(0.99, max(galaxy.r, max(galaxy.g, galaxy.b))));
    
    // Ensure stars are always visible and white
    final_color = mix(final_color, u_star_color, step(0.99, max(galaxy.r, max(galaxy.g, galaxy.b))));
    
    // Calculate final alpha
    float final_alpha = galaxy.a;
    
    // Make dark areas more transparent, but keep stars fully opaque
    if (length(final_color) < 0.1 && max(galaxy.r, max(galaxy.g, galaxy.b)) < 0.99) {
        final_alpha *= length(final_color) * 10.0;
    }
    
    ALBEDO = final_color;
    ALPHA = final_alpha;
}



The Galaxy Core scene

#GalaxyCore.gd in scene GalaxyCore, here we are generating a core for galaxy, right now it is the same color as galaxy fog, size was done in some way in Galaxies scene if i remember correctly
@tool
extends Sprite3D

var shader_material: ShaderMaterial
var pending_parameters: Dictionary = {}

func _ready():
	#print("GalaxyCore _ready function called")
	
	# Create a placeholder texture
	var image = Image.create(512, 512, false, Image.FORMAT_RGBA8)
	image.fill(Color(1, 1, 1, 1))  # White color
	var texture_core = ImageTexture.create_from_image(image)
	
	# Assign the texture to the Sprite3D
	self.texture = texture_core
	
	# Load the shader directly
	var shader = load("res://Shaders/coregalaxy.gdshader")
	if shader == null:
		print("Error: Could not load GalaxyCore.gdshader file")
		return
	
	# Create a new ShaderMaterial with the loaded shader
	shader_material = ShaderMaterial.new()
	shader_material.shader = shader
	
	# Assign the material to the Sprite3D
	material_override = shader_material
	#print("Created new ShaderMaterial and assigned shader for GalaxyCore")
	
	# Apply any pending parameters
	if not pending_parameters.is_empty():
		apply_parameters(pending_parameters)

func set_parameters(galaxy_fog_color: Color, resolution: float):
	var core_size = 1  # Adjust the 0.2 factor as needed
	var params = {
		"u_galaxy_color": galaxy_fog_color,
		"u_core_size": core_size,
		"u_star_size": resolution
	}
	
	if shader_material:
		apply_parameters(params)
	else:
		pending_parameters = params

func apply_parameters(params: Dictionary):
	for key in params:
		shader_material.set_shader_parameter(key, params[key])
#	print("GalaxyCore shader parameters applied")


//coregalaxy.gdshader
shader_type spatial;
render_mode blend_mix, depth_draw_opaque, cull_back, unshaded;

uniform vec3 u_galaxy_color : source_color = vec3(0.5, 0.5, 1.0);
uniform float u_core_size : hint_range(0.0, 1.0) = 0.5;
uniform float u_star_size : hint_range(1, 2048) = 2048.0;

void vertex() {
    MODELVIEW_MATRIX = VIEW_MATRIX * mat4(INV_VIEW_MATRIX[0], INV_VIEW_MATRIX[1], INV_VIEW_MATRIX[2], MODEL_MATRIX[3]);
}

void fragment() {
    // Convert UV to centered coordinates
    vec2 centered_uv = UV * 2.0 - 1.0;
    
    // Calculate distance from center
    float dist = length(centered_uv);
    
    // Create circular gradient
    float circle = 1.0 - smoothstep(u_core_size * 0.8, u_core_size, dist);
    
    // Apply color and fade out edges
    vec3 core_color = u_galaxy_color * circle;
    
    // Adjust alpha based on distance and star size
    float alpha = circle * smoothstep(1.0, 0.0, dist / (u_star_size / 1024.0));
    
    ALBEDO = core_color;
    ALPHA = alpha;
}

GalaxyCloseUp scene

# GalaxyCloseUp.gd in GalaxyCloseUp scene
extends Node3D

@export var visible_star_distance: float = 50.0
@export var transition_distance: float = 5.0

var closest_star = null
var closest_distance = INF

var star_scene = preload("res://Scenes/Star.tscn")
var rd: RenderingDevice
var shader: RID
var pipeline: RID
var uniform_set: RID
var buffer: RID

var rng = RandomNumberGenerator.new()
var galaxy_seed
var galaxy_rng

var star_seed
var star_rng
var offset_star
var star_data
var star_container
var initial_distance

var cube_cam
var panorama

var sphere_center: Vector3
var sphere_radius: float
var current_look_thingy
var current_look_thingy2
var current_distance_thingy: float
var furthest_distance_thingy: float
var closetst_distance_thingy: float

var shader_material#: ShaderMaterial

var skybox_state = false

func _ready():
	rng.seed = GlobalState.current_galaxy_data.seed
	star_container = Node3D.new()
	star_container.name = "StarContainer"
	add_child(star_container)
	if GlobalState.is_returning_from_star:
		setup_return_camera()
	else:
		setup_camera()
	apply_skybox()
	setup_compute_shader()
	generate_stars()

func _process(delta):
	update_closest_star()
	check_for_transition()
	check_for_return()

	if skybox_state == true:
		var result = calculate_look_distance()
		var look_distance = result[0]
		var horizontal_factor = result[1]
		
		var closest_distance = initial_distance * 0.1
		var furthest_distance = initial_distance * 2.0
		
		var vertical_depth_factor = map_range(look_distance, closest_distance, furthest_distance, 1.1, 0.9)
		var horizontal_depth_factor = map_range(look_distance, closest_distance, furthest_distance, 0.9, 1.1)
		
		var depth_factor = lerp(vertical_depth_factor, horizontal_depth_factor, horizontal_factor)
		depth_factor = clamp(depth_factor, 0.9, 1.1)
		shader_material.set_shader_parameter("depth_factor", depth_factor)
	if skybox_state == false:
		print("the skybox has changed, and we no more need to calculate stuff for depth factor here and now")

func map_range(value, start1, stop1, start2, stop2):
	return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1))

func setup_compute_shader():
	rd = RenderingServer.create_local_rendering_device()
	
	var shader_file = load("res://ComputeShaders/StarPositions.glsl")
	var shader_spirv: RDShaderSPIRV = shader_file.get_spirv()
	shader = rd.shader_create_from_spirv(shader_spirv)
	
	pipeline = rd.compute_pipeline_create(shader)
	
	var params = GlobalState.current_galaxy_data.shader_params
	var uniform_data = PackedFloat32Array([
		params.u_seed,
		params.u_arm_count,
		params.u_arm_width,
		params.u_star_density,
		params.u_star_size,
		params.u_star_circle_radius,
		params.u_swirl_amount,
		params.u_star_size # Adding resolution as the last parameter
	])
	var uniform_bytes = uniform_data.to_byte_array()
	var uniform_buffer = rd.uniform_buffer_create(uniform_bytes.size(), uniform_bytes)
	
	var resolution = int(params.u_star_size)
	buffer = rd.storage_buffer_create(resolution * resolution * 16)  # 16 bytes per vec4
	
	var uniform_1 = RDUniform.new()
	uniform_1.uniform_type = RenderingDevice.UNIFORM_TYPE_UNIFORM_BUFFER
	uniform_1.binding = 0
	uniform_1.add_id(uniform_buffer)
	
	var uniform_2 = RDUniform.new()
	uniform_2.uniform_type = RenderingDevice.UNIFORM_TYPE_STORAGE_BUFFER
	uniform_2.binding = 1
	uniform_2.add_id(buffer)
	
	uniform_set = rd.uniform_set_create([uniform_1, uniform_2], shader, 0)

func generate_stars():
	var params = GlobalState.current_galaxy_data.shader_params
	var resolution = int(params.u_star_size)
	var max_offset = GlobalState.current_galaxy_data.shader_params.u_star_size * 2

	var compute_list = rd.compute_list_begin()
	rd.compute_list_bind_compute_pipeline(compute_list, pipeline)
	rd.compute_list_bind_uniform_set(compute_list, uniform_set, 0)
	rd.compute_list_dispatch(compute_list, resolution / 16, resolution / 16, 1)
	rd.compute_list_end()
	rd.submit()
	rd.sync()
	var output_bytes = rd.buffer_get_data(buffer)
	var output = output_bytes.to_float32_array()
	
	galaxy_seed = GlobalState.current_galaxy_data.seed
	
	for i in range(0, output.size(), 4):
		if output[i + 3] > 0.01:  # Check alpha value
			var pos = Vector3(((output[i] * 0.5 * resolution) - ( resolution / 4)) * 10, ((output[i + 1] * 0.5 * resolution) - ( resolution / 4))  * 10, 0)
			var star_hash = output[i + 2]
			star_seed = generate_star_seed(galaxy_seed, i / 4)
			star_data = GlobalState.generate_star_data(star_seed)
			var y_offset = calculate_spherical_offset(pos, max_offset, star_seed)
			pos.z = y_offset
			create_star_at_position(pos, star_hash)
	var galaxy_rotation = GlobalState.current_galaxy_data.rotation
	$StarContainer.rotation = galaxy_rotation

func create_star_at_position(pos: Vector3, star_hash: float):
	var star = star_scene.instantiate()
	star.position = pos
	star.scale = Vector3.ONE * (star_hash * 0.01 + 0.005)
	var celestial_body_seed = GlobalState.current_star_data.seed
	var celestial_body_temperature = GlobalState.current_star_data.temperature
	var celestial_body_size = GlobalState.current_star_data.size
	$StarContainer.add_child(star)
	star.set_parameters(celestial_body_seed, celestial_body_temperature, celestial_body_size)




# the one that shiftes the timespace
func apply_skybox():
	var skybox_texture = GlobalState.get_skybox_texture()
	if skybox_texture:
		var env = get_environment()
		env.background_mode = Environment.BG_COLOR
		env.background_color = Color(0, 0, 0)
		await get_tree().create_timer(0.01).timeout
		env.background_mode = Environment.BG_SKY
		var sky = Sky.new()
		var sky_material = ShaderMaterial.new()
		sky_material.shader = load("res://Shaders/SkySphere.gdshader")
		sky_material.set_shader_parameter("panorama_texture", skybox_texture)
		shader_material = sky_material
		#var shader_material: ShaderMaterial
		#sky_material.panorama = skybox_texture
		sky.sky_material = sky_material
		env.sky = sky
		skybox_state = true
		#print("Skybox applied successfully")
	else:
		print("No skybox texture found in GlobalState")
		# If no skybox texture, display a debug color
		var env = get_environment()
		env.background_mode = Environment.BG_COLOR
		env.background_color = Color(1, 0, 0)  # Red background for debugging

func get_environment():
	var world = get_viewport().get_world_3d()
	if not world.environment:
		world.environment = Environment.new()
	return world.environment
	
func setup_galaxy():
	if GlobalState.current_galaxy_data:
		var close_up_sprite = $Sprite3D
		# Create a placeholder texture (same as in GalaxySprite)
		var image = Image.create(512, 512, false, Image.FORMAT_RGBA8)
		image.fill(Color(1, 1, 1, 1))  # White color
		var texture = ImageTexture.create_from_image(image)
		# Assign the texture to the Sprite3D
		close_up_sprite.texture = texture
		# Load the shader directly (same as in GalaxySprite)
		var shader = load("res://Shaders/EnhancedGalaxy.gdshader")
		# Create a new ShaderMaterial with the loaded shader
		var shader_material = ShaderMaterial.new()
		shader_material.shader = shader
		var params = GlobalState.current_galaxy_data.shader_params
		var resolution = int(params.u_star_size)
		# Set shader parameters
		for param in GlobalState.current_galaxy_data.shader_params:
			shader_material.set_shader_parameter(param, GlobalState.current_galaxy_data.shader_params[param])
		# Assign the material to the Sprite3D
		close_up_sprite.material_override = shader_material
		# Position the sprite at the center
		close_up_sprite.global_transform.origin = Vector3.ZERO
		# Apply scale
		var stored_scale = GlobalState.current_galaxy_data.scale
		close_up_sprite.scale = Vector3((resolution), (resolution), (resolution))
		close_up_sprite.rotation = GlobalState.current_galaxy_data.rotation
		close_up_sprite.global_transform.origin = Vector3.ZERO
	else:
		print("No galaxy data available")

func setup_camera():
	if GlobalState.camera_data:
		var camera = $Camera3D as FreeLookCamera2  # Ensure this is the correct type
		camera.global_transform.origin = (GlobalState.camera_data.position * 50)
		camera.global_rotation = GlobalState.camera_data.rotation
		camera._total_pitch = GlobalState.camera_data.total_pitch  # Set this
		var coordinator = Vector3(0,0,0)
		initial_distance = camera.global_transform.origin.distance_to(coordinator)
		GlobalState.clear_return_from_star_data()
	else:
		print("No camera data available, using default position")
		
func setup_return_camera():
	if GlobalState.star_to_galaxy_camera_data: # get_return_from_star_data()
		var camera = $Camera3D as FreeLookCamera2  # Ensure this is the correct type
		camera.global_transform.origin = (GlobalState.star_to_galaxy_camera_data.position)
		camera.global_rotation = GlobalState.star_to_galaxy_camera_data.rotation
		camera._total_pitch = GlobalState.star_to_galaxy_camera_data.total_pitch  # Set this
		var coordinator_helper = (GlobalState.camera_data.position * 50)
		var coordinator = Vector3(0,0,0)
		coordinator_helper.distance_to(coordinator)
		var second_distance_for_camera_information = GlobalState.camera_data.position.distance_to(GlobalState.star_to_galaxy_camera_data.previous_star_coordinates)
		initial_distance = coordinator_helper.distance_to(coordinator)
		GlobalState.clear_return_from_star_data()
	else:
		print("No camera data available, using default position")

func generate_star_seed(galaxy_seed: int, star_index: int) -> int:
	return galaxy_seed * 1000000 + star_index
	
func calculate_spherical_offset(pos: Vector3, max_offset: float, star_seed: int) -> float:
	var star_rng = RandomNumberGenerator.new()
	star_rng.seed = star_seed

	var radius = max_offset * 1.1
	var distance_2d = Vector2(pos.x, pos.y).length()

	var max_z_offset
	if distance_2d < radius:
		max_z_offset = sqrt(radius * radius - distance_2d * distance_2d)
	else:
		max_z_offset = 0

	var z_offset = star_rng.randf_range(-max_z_offset, max_z_offset)
	return z_offset / 2.0
	
func update_closest_star():
	var stars = get_tree().get_nodes_in_group("stars")
	closest_star = null
	closest_distance = INF
	for star in stars:
		if star == null:
			print("Found a null star in the group")
			continue
		var distance = $Camera3D.global_transform.origin.distance_to(star.global_transform.origin)
		if distance < closest_distance:
			closest_star = star
			closest_distance = distance
			
	if closest_star:
		var closinger_starminger = 2137
	else:
		print("No closest star found")

func check_for_transition():
	if closest_star and closest_distance < transition_distance:
		transition_to_star(closest_star)

func transition_to_star(target_star):
	print("transition_to_star function")
	var camera = $Camera3D
	if target_star == null:
		print("Error: target_star is null")
		return
	var visible_stars = capture_visible_stars(target_star)
	GlobalState.store_visible_stars(visible_stars)
	var coordinator_2 = Vector3(0,0,0)
	var current_distance_2 = camera.global_transform.origin.distance_to(coordinator_2)
	GlobalState.store_star_data({
		"position": target_star.global_transform.origin,
		"scale": target_star.scale,
		"color": target_star.modulate,
		"seed": target_star.get_star_seed(),
		"temperature": target_star.get_star_temperature(),
		"brightness": target_star.get_star_brightness()
	})
	#print("global store_galaxy_to_star_camera_data camera._total_pitch = ", camera._total_pitch)
	GlobalState.store_galaxy_to_star_camera_data({
		"position": camera.global_transform.origin,
		"rotation": camera.global_rotation,
		"total_pitch": camera._total_pitch
	})
	setup_360_camera()
	store_star_skybox_texture(closest_star)

func capture_visible_stars(target_star):
	var visible_stars = []
	var target_position = target_star.global_transform.origin
	for star in get_tree().get_nodes_in_group("stars"):
		if star != target_star and is_star_visible(star, target_position):
			visible_stars.append({
				"position": star.global_transform.origin - target_position,
				"scale": star.scale,
				"color": star.modulate,
				"seed": star.get_star_seed(),
				"temperature": star.get_star_temperature()
			})
	return visible_stars

func is_star_visible(star, from_position):
	if star == null or from_position == null:
		return false
	var distance = star.global_transform.origin.distance_to(from_position)
	return distance <= visible_star_distance

func check_for_return():
	var camera = $Camera3D as FreeLookCamera2
	var coordinator = Vector3(0,0,0)
	var current_distance = camera.global_transform.origin.distance_to(coordinator)
	var current_coordinates = camera.global_transform.origin
	var furtherst_distance = initial_distance * 1.2
	furthest_distance_thingy = furtherst_distance
	#print("furtherst_distance = ", furtherst_distance)
	current_distance_thingy = current_distance
	#print("current_distance = ", current_distance)
	if current_distance > furtherst_distance:
		
		var stored_galaxy_position = GlobalState.current_galaxy_data.galaxy_position
		transition_to_galaxies()

# the vertical strettch that one day will be better
func calculate_look_distance():
	var player = $Camera3D
	var player_position = player.global_transform.origin
	var look_direction = -player.global_transform.basis.z
	
	# Calculate vertical angle
	var vertical_angle = acos(abs(look_direction.y))
	
	# Calculate horizontal factor (0 when looking straight up/down, 1 when looking horizontally)
	var horizontal_factor = sin(vertical_angle)
	
	sphere_center = Vector3.ZERO
	sphere_radius = initial_distance * 1.2
	
	# Calculate intersection
	var to_center = sphere_center - player_position
	var b = to_center.dot(look_direction)
	var c = to_center.dot(to_center) - sphere_radius * sphere_radius
	var discriminant = b * b - c
	
	if discriminant < 0:
		return INF
	
	var t = b - sqrt(discriminant)
	var intersection_point = player_position + look_direction * t
	var distance = player_position.distance_to(intersection_point)
	
	# Return both the distance and the horizontal factor
	return [distance, horizontal_factor]


func transition_to_galaxies():
	var camera = $Camera3D as FreeLookCamera2
	var stored_galaxy_position = GlobalState.current_galaxy_data.galaxy_position
	var new_camera_position = (camera.global_transform.origin / 50.0) + stored_galaxy_position
	GlobalState.store_return_data(
		{
			"position": new_camera_position,
			"rotation": camera.global_rotation,
			"total_pitch": camera._total_pitch
		},
		GlobalState.current_galaxy_data
	)
	GlobalState.update_elapsed_time()
	get_tree().change_scene_to_file("res://Scenes/Galaxies.tscn")



#Setting up 360 camera, to make a panorama picture for next scene
func setup_360_camera():
	cube_cam = preload("res://addons/camera360/CubeCam.tscn").instantiate()
	add_child(cube_cam)
	cube_cam.cube_size = 1024
	cube_cam.far = 100000  # Adjust based on the scale of your universe
# first texture being created for next scene
func store_star_skybox_texture(target_star):
	#cube_cam = $CubeCam
	skybox_state = false
	change_skybox()
	offset_stars(target_star)
	cube_cam.global_transform.origin = target_star.global_transform.origin
	target_star.global_transform.origin = Vector3(2137, 2137, 2137)
	cube_cam.rotate_y(deg_to_rad(90))
	$SubViewportContainer/SubViewport/Panorama.set_from_cubemap(cube_cam)
	await get_tree().process_frame
	await get_tree().process_frame
	await get_tree().create_timer(0.1).timeout
	var sub_viewport = $SubViewportContainer/SubViewport
	var viewport_texture = $SubViewportContainer/SubViewport.get_texture()
	var viewport = $SubViewportContainer/SubViewport
	var image = sub_viewport.get_texture().get_image()
	var skybox_texture = ImageTexture.create_from_image(image)
	GlobalState.store_star_skybox_texture(skybox_texture)
	#get_tree().change_scene_to_file("res://Scenes/StarCloseUp.tscn")
	store_star_offset_skybox_texture(target_star)
# changing the skybox panorama into second panorama from galaxies scene
func change_skybox():
	var skybox_offset_texture = GlobalState.get_offset_skybox_texture() #skybox_galaxy_texture
	if skybox_offset_texture:
		var env = get_environment()
		env.background_mode = Environment.BG_COLOR
		env.background_color = Color(0, 0, 0)
		await get_tree().create_timer(0.01).timeout
		env.background_mode = Environment.BG_SKY
		var sky = Sky.new()
		var sky_material = PanoramaSkyMaterial.new()
		sky_material.panorama = skybox_offset_texture
		sky.sky_material = sky_material
		env.sky = sky
		#print("Skybox applied successfully")
	else:
		print("No skybox texture found in GlobalState")
		# If no skybox texture, display a debug color
		var env = get_environment()
		env.background_mode = Environment.BG_COLOR
		env.background_color = Color(1, 0, 0)  # Red background for debugging
# offsetting stars function used twice
func offset_stars(target_star_first_position):
	#var stars = get_tree().get_nodes_in_group("stars")
	for star in get_tree().get_nodes_in_group("stars"):
		var current_position = star.global_transform.origin
		var new_position = current_position * 2
		star.global_transform.origin = new_position
	print("All stars have been offset")
# storing second panorma texture
func store_star_offset_skybox_texture(target_star):
	offset_stars(target_star)
	change_skybox_offset()
	$SubViewportContainer/SubViewport/Panorama.set_from_cubemap(cube_cam)
	await get_tree().process_frame
	await get_tree().process_frame
	await get_tree().create_timer(0.1).timeout
	var sub_viewport = $SubViewportContainer/SubViewport
	var viewport_texture = $SubViewportContainer/SubViewport.get_texture()
	var viewport = $SubViewportContainer/SubViewport
	var image = sub_viewport.get_texture().get_image()
	var skybox_texture = ImageTexture.create_from_image(image)
	GlobalState.store_star_skybox_texture(skybox_texture)
	GlobalState.update_elapsed_time()
	get_tree().change_scene_to_file("res://Scenes/StarCloseUp.tscn") 
	

# changing texture to third panorma from first scene
func change_skybox_offset():
	var skybox_offset_texture = GlobalState.get_celestialbody_skybox_texture()
	if skybox_offset_texture:
		var env = get_environment()
		env.background_mode = Environment.BG_COLOR
		env.background_color = Color(0, 0, 0)
		await get_tree().create_timer(0.01).timeout
		env.background_mode = Environment.BG_SKY
		var sky = Sky.new()
		var sky_material = PanoramaSkyMaterial.new()
		shader_material = sky_material
		sky_material.panorama = skybox_offset_texture
		sky.sky_material = sky_material
		env.sky = sky
		#print("Skybox applied successfully")
	else:
		print("No skybox texture found in GlobalState")
		# If no skybox texture, display a debug color
		var env = get_environment()
		env.background_mode = Environment.BG_COLOR
		env.background_color = Color(1, 0, 0)  # Red background for debugging


#Camera node, in Player node, in Main node, in GalaxyCloseUp scene, camera.gd
class_name FreeLookCamera2 extends Camera3D

# Modifier keys' speed multiplier
const SHIFT_MULTIPLIER = 2.5
const ALT_MULTIPLIER = 1.0 / SHIFT_MULTIPLIER

@export_range(0.0, 1.0) var sensitivity = 0.25

# Mouse state
var _mouse_position = Vector2(0.0, 0.0)
var _total_pitch = 0.0

# Movement state
var _direction = Vector3(0.0, 0.0, 0.0)
var _velocity = Vector3(0.0, 0.0, 0.0)
var _acceleration = 300
var _deceleration = -100
var _vel_multiplier = 4

# Keyboard state
var _w = false
var _s = false
var _a = false
var _d = false
var _q = false
var _e = false
var _z = false
var _c = false
var _shift = false
var _alt = false

var initial_basis: Basis

func _ready():
	initial_basis = global_transform.basis

func _input(event):
	# Receives mouse motion
	if event is InputEventMouseMotion:
		_mouse_position = event.relative
	
	# Receives mouse button input
	if event is InputEventMouseButton:
		match event.button_index:
			MOUSE_BUTTON_RIGHT: # Only allows rotation if right click down
				Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED if event.pressed else Input.MOUSE_MODE_VISIBLE)
			MOUSE_BUTTON_WHEEL_UP: # Increases max velocity
				_vel_multiplier = clamp(_vel_multiplier * 1.1, 0.2, 20)
			MOUSE_BUTTON_WHEEL_DOWN: # Decereases max velocity
				_vel_multiplier = clamp(_vel_multiplier / 1.1, 0.2, 20)

	# Receives key input
	if event is InputEventKey:
		match event.keycode:
			KEY_W:
				_w = event.pressed
			KEY_S:
				_s = event.pressed
			KEY_A:
				_a = event.pressed
			KEY_D:
				_d = event.pressed
			KEY_Q:
				_q = event.pressed
			KEY_E:
				_e = event.pressed
			KEY_Z:
				_z = event.pressed
			KEY_C:
				_c = event.pressed

# Updates mouselook and movement every frame
func _process(delta):
	_update_mouselook()
	_update_movement(delta)
	_update_roll(delta)
	# Add these debug prints
	#var camera_quat = Quaternion(global_transform.basis.orthonormalized())
	#print("FreeLookCamera2: camera_quat = ", camera_quat)
	#print("FreeLookCamera2: camera_matrix = ", global_transform.basis)
	#print("_total_pitch = ", _total_pitch)

# Updates camera movement
func _update_movement(delta):
	# Computes desired direction from key states
	_direction = Vector3((_d as float) - (_a as float), 
						(_e as float) - (_q as float), 
						(_s as float) - (_w as float))
	
	# Computes the change in velocity due to desired direction and "drag"
	# The "drag" is a constant acceleration on the camera to bring it's velocity to 0
	var offset = _direction.normalized() * _acceleration * _vel_multiplier * delta \
		+ _velocity.normalized() * _deceleration * _vel_multiplier * delta
	
	# Compute modifiers' speed multiplier
	var speed_multi = 22
	if _shift: speed_multi *= SHIFT_MULTIPLIER
	if _alt: speed_multi *= ALT_MULTIPLIER
	
	# Checks if we should bother translating the camera
	if _direction == Vector3.ZERO and offset.length_squared() > _velocity.length_squared():
		# Sets the velocity to 0 to prevent jittering due to imperfect deceleration
		_velocity = Vector3.ZERO
	else:
		# Clamps speed to stay within maximum value (_vel_multiplier)
		_velocity.x = clamp(_velocity.x + offset.x, -_vel_multiplier, _vel_multiplier)
		_velocity.y = clamp(_velocity.y + offset.y, -_vel_multiplier, _vel_multiplier)
		_velocity.z = clamp(_velocity.z + offset.z, -_vel_multiplier, _vel_multiplier)
	
		translate(_velocity * delta * speed_multi)

# Updates mouse look 
func _update_mouselook():
	# Only rotates mouse if the mouse is captured
	if Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
		_mouse_position *= sensitivity
		var yaw = _mouse_position.x
		var pitch = _mouse_position.y
		_mouse_position = Vector2(0, 0)
		
		# Prevents looking up/down too far
		pitch = clamp(pitch, -90 - _total_pitch, 90 - _total_pitch)
		_total_pitch += pitch
		# Apply rotations relative to the initial orientation
	
		rotate_y(deg_to_rad(-yaw))
		rotate_object_local(Vector3(1,0,0), deg_to_rad(-pitch))

# Updates roll based on Z and C key inputs
func _update_roll(delta):
	var roll_speed = 60.0 * delta  # Adjust roll speed as needed
	if _z:
		rotate_object_local(Vector3(0, 0, 1), deg_to_rad(roll_speed))
	if _c:
		rotate_object_local(Vector3(0, 0, 1), deg_to_rad(-roll_speed))


the Star scene

#Star.gd in Star scene, here we are generating a sprite for stars in GalaxyCloseUp scene, they apeear where just white dots were on a single sprite with some help of compute shader

@tool
extends Sprite3D

var shader_material: ShaderMaterial
var pending_parameters: Dictionary = {}
var star_id: int
var shader_parameters: Dictionary = {}
var star_texture: ImageTexture
var star_seed: int
var star_temperature
var star_brightness

func _ready():
	#print("Star _ready function called")
	add_to_group("stars")
	setup_star()

func setup_star():
	# Create a placeholder texture
	var image = Image.create(512, 512, false, Image.FORMAT_RGBA8)
	image.fill(Color(1, 1, 1, 1))  # White color
	star_texture = ImageTexture.create_from_image(image)

	# Assign the texture to the Sprite3D
	self.texture = star_texture

	# Load the shader directly
	var shader = load("res://Shaders/Star.gdshader")
	if shader == null:
		print("Error: Could not load Star.gdshader file")
		return

	# Create a new ShaderMaterial with the loaded shader
	shader_material = ShaderMaterial.new()
	shader_material.shader = shader

	# Assign the material to the Sprite3D
	material_override = shader_material
	#print("Created new ShaderMaterial and assigned shader")

	# Apply any pending parameters
	if not pending_parameters.is_empty():
		apply_parameters(pending_parameters)

	star_id = get_instance_id()
	#print("Star ID: ", star_id)

func set_parameters(seed_star: int, temperature: float, size: float):
	#print("set parameters for star, we are here now, so work now!")
	#print("seed_star: ", seed_star, ", temperature: ", temperature, ", size: ", size)
	star_seed = seed_star
	
	if shader_material == null:
		#print("Error: shader_material is null. Running setup_star()")
		setup_star()
	
	if shader_material == null:
		print("Error: shader_material is still null after setup_star()")
		return
	
	#print("so we are here again, after the shader thingy and setupstar? so lets se now")
	var star_color = temperature_to_color(temperature)
	#print("temperature = ",temperature, "so we got some star_color, with function from temperature to color = ",star_color)
	#print("we also have size = " , size)
	#print(temperature)
	star_temperature = temperature
	star_brightness = size
	shader_parameters = {
		"color": star_color,
		"brightness": size
	}

	for param in shader_parameters:
		shader_material.set_shader_parameter(param, shader_parameters[param])
	
	# Adjust the scale based on the size parameter
	self.scale = Vector3.ONE * size
	pixel_size = size / 100

func apply_parameters(params: Dictionary):
	for key in params:
		shader_material.set_shader_parameter(key, params[key])
	#print("Shader parameters applied")

func get_star_id():
	return star_id

func get_shader_parameters():
	return shader_parameters

func get_star_texture():
	return star_texture

func get_star_seed():
	return star_seed
	
func get_star_temperature():
	return star_temperature

func get_star_brightness():
	return star_brightness

func temperature_to_color(temperature: float) -> Color:
	#print("galaxy temp in function = ", temperature)
	
	# Define color ranges for different temperature brackets
	var colors = [
		Color(1.0, 0.0, 0.0),   # Red
		Color(1.0, 0.5, 0.0),   # Orange
		Color(1.0, 1.0, 0.0),   # Yellow
		Color(1.0, 1.0, 1.0),   # White
		Color(0.5, 1.0, 1.0),   # Light Blue
		Color(0.0, 0.0, 1.0),   # Blue
		Color(0.5, 0.0, 1.0)    # Purple
	]

	# Define the temperature range
	var min_temp = 2000.0
	var max_temp = 18000.0

	# Clamp temperature between min_temp and max_temp
	var clamped_temp = clamp(temperature, min_temp, max_temp)
	
	# Normalize temperature to 0-1 range
	var normalized_temp = (clamped_temp - min_temp) / (max_temp - min_temp)
	
	# Ensure normalized_temp is exactly 0.0 or 1.0 at the extremes
	if is_equal_approx(normalized_temp, 0.0):
		normalized_temp = 0.0
	elif is_equal_approx(normalized_temp, 1.0):
		normalized_temp = 1.0
	
	# Calculate color index
	var color_index = normalized_temp * (colors.size() - 1)
	
	var index1 = int(floor(color_index))
	var index2 = int(ceil(color_index))
	index2 = min(index2, colors.size() - 1)  # Ensure we don't go out of bounds
	
	var t = fmod(color_index, 1.0)
	
	# Interpolate between the two closest colors
	var final_color = colors[index1].lerp(colors[index2], t)
	
	# Apply gamma correction
	final_color.r = pow(final_color.r, 1.0 / 2.2)
	final_color.g = pow(final_color.g, 1.0 / 2.2)
	final_color.b = pow(final_color.b, 1.0 / 2.2)
	
	#print("final color maybe lol = ", final_color)
	return final_color

func remap(value, old_min, old_max, new_min, new_max):
	return (value - old_min) / (old_max - old_min) * (new_max - new_min) + new_min


// Star.gdshader
shader_type spatial;
render_mode unshaded, blend_add;

uniform vec4 color : source_color = vec4(1.0);
uniform float brightness : hint_range(0, 2) = 2.0;

void fragment() {
    vec2 centered_uv = (UV - 0.5) * 2.0;
    float dist = length(centered_uv);
    float alpha = smoothstep(1.0, 0.0, dist);
    ALBEDO = color.rgb * brightness;
    ALPHA = alpha * color.a;
}

void vertex() {
    MODELVIEW_MATRIX = VIEW_MATRIX * mat4(INV_VIEW_MATRIX[0], INV_VIEW_MATRIX[1], INV_VIEW_MATRIX[2], MODEL_MATRIX[3]);
}

StarCloseUp

#StarCloseUp.gd a Node3D, just a startpoint, it should be a next scene, where in first we generate galaxies, then we go to a single galaxy made from stars, and then we go to a single star that was made in second scene
extends Node3D

var cube_cam
var star_scene = preload("res://Scenes/CelestialBody.tscn")
var Cassiopeia_offset_system
var camera_distance = 100.0
var star_seed
var rng = RandomNumberGenerator.new()
var planet_seed
var planet_scene = preload("res://Scenes/CelestialPlanet.tscn")
var orbit_scene = preload("res://Scenes/Orbit.tscn")
var planets = []
var furthest_planet_distance = 0
var last_planet_distance = 50
var camera_distance_to_star

var return_distance
var camera_fist_distance
var camera_first_position
var camera_return_distance

var closest_planet = null
var closest_distance = INF
var transition_distance = 33.0

# ready function, run once at scene initialization
func _ready():
	star_seed = GlobalState.current_star_data.seed
	rng.seed = star_seed
	setup_star()
	apply_skybox()
	generate_planets()
#	print_planet_info()
	setup_camera()

	

# a function to setup star with previously generated data! that shader is faya tho
func setup_star():
	if GlobalState.current_star_data:
		print("GlobalState.current_star_data = ", GlobalState.current_star_data)
		print("GlobalState.current_star_data.brightness = ", GlobalState.current_star_data.brightness)
		print("so division shall happen here huh? = GlobalState.current_star_data.brightness / 100 = ", GlobalState.current_star_data.brightness / 100)
		var star = star_scene.instantiate()
		star.position = Vector3(0,0,0)
		star.scale = GlobalState.current_star_data.scale
		add_child(star)
		var celestial_body_seed = GlobalState.current_star_data.seed
		var celestial_body_temperature = GlobalState.current_star_data.temperature
		var celestial_body_size = GlobalState.current_star_data.brightness
		star.set_parameters(celestial_body_seed, celestial_body_temperature, celestial_body_size)

# setup camera, its pitch rotations and coordinates
func setup_camera():
	var camera = $Camera3D as FreeLookCamera2
	print("setup camera function star closeup")
	var camera_data = GlobalState.get_galaxy_to_star_camera_data()
	var star_position = GlobalState.current_star_data.position
	if camera_data:
		camera.global_transform.origin = camera_data.position - star_position #* camera_distance
		camera_first_position = camera.global_transform.origin
		var coordinator = Vector3(0,0,0)
		camera_fist_distance = camera.global_transform.origin.distance_to(coordinator)
		Cassiopeia_offset_system = furthest_planet_distance / camera_fist_distance
		
		camera.global_transform.origin = (camera.global_transform.origin * Cassiopeia_offset_system)
		
		camera_distance_to_star = camera.global_transform.origin.distance_to(coordinator)
		
		camera.global_rotation = camera_data.rotation
		print("camera_data.total_pitch = ", camera_data.total_pitch)
		camera._total_pitch = camera_data.total_pitch

# the Panorama image put on sphere inversed, mortals call it skybox, a box that is a sphere?
func apply_skybox():
	var skybox_texture = GlobalState.get_star_skybox_texture()
	if skybox_texture:
		var env = get_environment()
		env.background_mode = Environment.BG_SKY
		var sky = Sky.new()
		var sky_material = PanoramaSkyMaterial.new()
		sky_material.panorama = skybox_texture
		sky.sky_material = sky_material
		env.sky = sky
	else:
		print("No star skybox texture found in GlobalState")
		# Apply a debug color if no skybox is available

# the thingy where we add environment, i kinda dunno why we need it as we already are just adding image as our world? maybe the lights and ambients are there
func get_environment():
	var world = get_viewport().get_world_3d()
	if not world.environment:
		world.environment = Environment.new()
	return world.environment

# we run it each and every frame :)
func _process(delta):
	check_for_return()
	check_for_planet_transition()
	update_closest_planet()

# check if distance from center of scene is further than 1.2 disance from furthest planet
func check_for_return():
	var camera = $Camera3D
	return_distance = furthest_planet_distance * 1.3
	if camera.global_transform.origin.length() > return_distance:
		transition_to_galaxy()

# after we are too far away, we just go back to that fire galaxy made from stars! and them stars were dots previously lol
func transition_to_galaxy():
	var camera = $Camera3D
	GlobalState.store_star_to_galaxy_camera_data({
		"position": camera.global_transform.origin,
		"rotation": camera.global_rotation,
		"total_pitch": camera._total_pitch
	})
	
	var camera_coord_new = (camera.global_transform.origin / (Cassiopeia_offset_system * 0.8))# hmm that line i think
	
	var current_distance_to_star = camera.global_transform.origin.length()
	var some_new_thing = camera_coord_new.distance_to(Vector3(0,0,0))
	GlobalState.store_return_from_star_data({
		"position": camera_coord_new,
		"rotation": camera.global_rotation,
		"total_pitch": camera._total_pitch,
		"previous_star_coordinates": GlobalState.current_star_data.position
	})
	GlobalState.update_elapsed_time()
	get_tree().change_scene_to_file("res://Scenes/GalaxyCloseUp.tscn")

# generate planets! take that tasty seed from my star! then make me them planets
func generate_planets():
	var planet_count = rng.randi_range(1, 8)
	for i in range(planet_count):
		var planet_seed = star_seed * 1000 + i
		var planet_data = generate_planet_data(planet_seed, i)
		create_planet(planet_data, i)

# here we are generating data to create them planets! from here we are also going to few other functions
func generate_planet_data(planet_seed: int, index: int) -> Dictionary:
	rng.seed = planet_seed
	var planet_type = generate_planet_type(index)
	#var radius = rng.randf_range(5.0, 20.0)
	var radius = generate_radius(planet_type)
	var orbit_radius = calculate_orbit_radius(planet_type, radius, index)
	
	var planet = {
		"seed": planet_seed,
		"type": planet_type,
		"radius": radius,
		"mass": calculate_mass(planet_type, radius),
		"orbit_radius": orbit_radius,
		"orbit_speed": calculate_orbit_speed(orbit_radius),
		"moons": rng.randi_range(0, 5),
		"habitable": rng.randf() < 0.1,
		"water": rng.randf() < 0.3,
		"basic_resources": rng.randf() < 0.7,
		"rare_resources": rng.randf() < 0.2,
		"planet_tilt": rng.randf_range(0.0, 360.0),
		"planet_spin_speed": rng.randf_range(0.01, 0.001)
	}
	return planet

func generate_radius(planet_type: int):
	match planet_type:
		0: # Earth-like
			return rng.randf_range(9.0, 22.0)
		1: # Rocky Red
			return rng.randf_range(8.0, 18.0)
		2: # Ice Planet
			return rng.randf_range(12.0, 29.0)
		3: # Lava Planet
			return rng.randf_range(13.0, 22.0)
		4: # Exo Planet
			return rng.randf_range(9.0, 28.0)
		5: # Rocky Grey
			return rng.randf_range(4.0, 15.0)
		6: # Gas Giant
			return rng.randf_range(22.0, 43.0)
# here we shall generate type of planets based on how far away it is from a Star :)
func generate_planet_type(index: int) -> int:
	match index:
		0: # planet_type = 1 or 3
			return [1, 3][rng.randi_range(0, 1)] # Rocky Red, Lava Planet
		1: # planet_type 1 or 5
			return [1, 5][rng.randi_range(0, 1)] # Rocky Red, Rocky Grey
		2: # planet type = 0 or 4
			return [0, 4][rng.randi_range(0, 1)] # Earth-like, Exo Planet
		3: #planet type = 0 or 4
			return [0, 4][rng.randi_range(0, 1)] # Earth-like, Exo Planet
		4: # planet_type = 1 or 5
			return [1, 5][rng.randi_range(0, 1)] # Rocky Red, Rocky Grey
		5: # planet_type = 1 or 5 or 2
			return [1, 5, 2][rng.randi_range(0, 2)] # Rocky Red, Rocky Grey, Ice Planet
		_: # # planet_type = 2 or 5 or 6
			return [2, 5, 6][rng.randi_range(0, 2)]  # Ice Planet, Rocky Grey, or Gas Giant

# here we are calculating orbit radius based on few variable numbers
func calculate_orbit_radius(planet_type: int, radius: float, index: int) -> float:
	var min_distance = last_planet_distance + 20  # Minimum 20 units from the last planet
	var max_distance = min_distance + 50 + (index * 20)  # Increase max distance for outer planets
	
	var new_radius = rng.randf_range(min_distance, max_distance)
	last_planet_distance = new_radius  # Update the last planet distance
	print("new radius = ", new_radius)
	return new_radius

# how fast that baby conna spin around our super star!
func calculate_orbit_speed(orbit_radius: float) -> float:
	# Simplified orbit speed calculation (inverse square law)
	return (1.0 / sqrt(orbit_radius) / 10000)

# here we calculate the mass of planet! gotta change it to something more logical to my monkey brain as i put there whatever lol and the gravity tho!
func calculate_mass(planet_type: int, radius: float) -> float:
	match planet_type: #planet_type
		0: return radius ** 3.7  # Earth-like
		1: return radius ** 3.3  # Rocky Red
		2: return radius ** 3.5  # Ice Giant
		3: return radius ** 3.2  # Lava Giant
		4: return radius ** 4.2  # Exo Planet
		5: return radius ** 3.6  # Rocky Grey
		6: return radius ** 1.2 # Gas Giant
	return 0.0

# adding a scene with nodes and sprite and shader! to make me see the flat image as a 3d hallucination!
func create_planet(planet_data: Dictionary, index: int):
	var orbit_instance = orbit_scene.instantiate()
	add_child(orbit_instance)
	
	var planet_instance = planet_scene.instantiate()
	orbit_instance.add_child(planet_instance)
	
	planet_instance.set_planet_data(planet_data)
	orbit_instance.set_orbit_data(planet_data.orbit_speed, planet_data.orbit_radius)
	# Calculate a random angle for the planet's position in its orbit
	var angle = rng.randf_range(0, 2 * PI)
	
	# Calculate the planet's position using trigonometry, ancient schollars still dont know whatever it is about lol
	var x = cos(angle) * planet_data.orbit_radius
	var z = sin(angle) * planet_data.orbit_radius
	
	# Set the planet's position
	planet_instance.position = Vector3(x, 0, z)
	orbit_instance.Alpha_delta()
	
	# Tilt the orbit slightly (optional)
	var tilt_angle = rng.randf_range(-0.1, 0.1)  # Tilt by up to 0.1 radians (about 5.7 degrees)
	orbit_instance.rotate_x(tilt_angle)
	
	planets.append({
		"instance": planet_instance,
		"orbit": orbit_instance,
		"data": planet_data
	})
	furthest_planet_distance = max(furthest_planet_distance, planet_data.orbit_radius)
	planet_instance.add_to_group("planets")

func update_closest_planet():
	var camera = $Camera3D
	closest_planet = null
	closest_distance = INF
	for planet in get_tree().get_nodes_in_group("planets"):
		var distance = camera.global_transform.origin.distance_to(planet.global_transform.origin)
		if distance < closest_distance:
			closest_planet = planet
			closest_distance = distance

func check_for_planet_transition():
	if closest_planet and closest_distance < transition_distance:  # Define transition_distance
		var planet_data_AR = closest_planet.get_planet_data_records()
		transition_to_planet(planet_data_AR)

func store_planet_system_data():
	GlobalState.store_planet_system(planets)

func transition_to_planet(current_planet_data: Dictionary):
	store_planet_system_data()
	var current_planet_recorda = current_planet_data
	GlobalState.store_planet_data(current_planet_recorda)
	
	# Store camera data
	var camera = $Camera3D
	GlobalState.store_star_to_planet_camera_data({
		"position": camera.global_transform.origin,
		"rotation": camera.global_rotation,
		"total_pitch": camera._total_pitch
	})
	
	# Transition to the CelestialBodyCloseUp scene
	#get_tree().change_scene_to_file("res://Scenes/CelestialBodyCloseUp.tscn")


#Camera node, in Player node, in Main node, in GalaxyCloseUp scene, camera.gd
class_name FreeLookCamera2 extends Camera3D

# Modifier keys' speed multiplier
const SHIFT_MULTIPLIER = 2.5
const ALT_MULTIPLIER = 1.0 / SHIFT_MULTIPLIER

@export_range(0.0, 1.0) var sensitivity = 0.25

# Mouse state
var _mouse_position = Vector2(0.0, 0.0)
var _total_pitch = 0.0

# Movement state
var _direction = Vector3(0.0, 0.0, 0.0)
var _velocity = Vector3(0.0, 0.0, 0.0)
var _acceleration = 300
var _deceleration = -100
var _vel_multiplier = 4

# Keyboard state
var _w = false
var _s = false
var _a = false
var _d = false
var _q = false
var _e = false
var _z = false
var _c = false
var _shift = false
var _alt = false

var initial_basis: Basis

func _ready():
	initial_basis = global_transform.basis

func _input(event):
	# Receives mouse motion
	if event is InputEventMouseMotion:
		_mouse_position = event.relative
	
	# Receives mouse button input
	if event is InputEventMouseButton:
		match event.button_index:
			MOUSE_BUTTON_RIGHT: # Only allows rotation if right click down
				Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED if event.pressed else Input.MOUSE_MODE_VISIBLE)
			MOUSE_BUTTON_WHEEL_UP: # Increases max velocity
				_vel_multiplier = clamp(_vel_multiplier * 1.1, 0.2, 20)
			MOUSE_BUTTON_WHEEL_DOWN: # Decereases max velocity
				_vel_multiplier = clamp(_vel_multiplier / 1.1, 0.2, 20)

	# Receives key input
	if event is InputEventKey:
		match event.keycode:
			KEY_W:
				_w = event.pressed
			KEY_S:
				_s = event.pressed
			KEY_A:
				_a = event.pressed
			KEY_D:
				_d = event.pressed
			KEY_Q:
				_q = event.pressed
			KEY_E:
				_e = event.pressed
			KEY_Z:
				_z = event.pressed
			KEY_C:
				_c = event.pressed

# Updates mouselook and movement every frame
func _process(delta):
	_update_mouselook()
	_update_movement(delta)
	_update_roll(delta)
	# Add these debug prints
	#var camera_quat = Quaternion(global_transform.basis.orthonormalized())
	#print("FreeLookCamera2: camera_quat = ", camera_quat)
	#print("FreeLookCamera2: camera_matrix = ", global_transform.basis)
	#print("_total_pitch = ", _total_pitch)

# Updates camera movement
func _update_movement(delta):
	# Computes desired direction from key states
	_direction = Vector3((_d as float) - (_a as float), 
						(_e as float) - (_q as float), 
						(_s as float) - (_w as float))
	
	# Computes the change in velocity due to desired direction and "drag"
	# The "drag" is a constant acceleration on the camera to bring it's velocity to 0
	var offset = _direction.normalized() * _acceleration * _vel_multiplier * delta \
		+ _velocity.normalized() * _deceleration * _vel_multiplier * delta
	
	# Compute modifiers' speed multiplier
	var speed_multi = 22
	if _shift: speed_multi *= SHIFT_MULTIPLIER
	if _alt: speed_multi *= ALT_MULTIPLIER
	
	# Checks if we should bother translating the camera
	if _direction == Vector3.ZERO and offset.length_squared() > _velocity.length_squared():
		# Sets the velocity to 0 to prevent jittering due to imperfect deceleration
		_velocity = Vector3.ZERO
	else:
		# Clamps speed to stay within maximum value (_vel_multiplier)
		_velocity.x = clamp(_velocity.x + offset.x, -_vel_multiplier, _vel_multiplier)
		_velocity.y = clamp(_velocity.y + offset.y, -_vel_multiplier, _vel_multiplier)
		_velocity.z = clamp(_velocity.z + offset.z, -_vel_multiplier, _vel_multiplier)
	
		translate(_velocity * delta * speed_multi)

# Updates mouse look 
func _update_mouselook():
	# Only rotates mouse if the mouse is captured
	if Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
		_mouse_position *= sensitivity
		var yaw = _mouse_position.x
		var pitch = _mouse_position.y
		_mouse_position = Vector2(0, 0)
		
		# Prevents looking up/down too far
		pitch = clamp(pitch, -90 - _total_pitch, 90 - _total_pitch)
		_total_pitch += pitch
		# Apply rotations relative to the initial orientation
	
		rotate_y(deg_to_rad(-yaw))
		rotate_object_local(Vector3(1,0,0), deg_to_rad(-pitch))

# Updates roll based on Z and C key inputs
func _update_roll(delta):
	var roll_speed = 60.0 * delta  # Adjust roll speed as needed
	if _z:
		rotate_object_local(Vector3(0, 0, 1), deg_to_rad(roll_speed))
	if _c:
		rotate_object_local(Vector3(0, 0, 1), deg_to_rad(-roll_speed))


Scene CelestialBody

# CelestialBody.gd res://Scripts/CelestialBody.gd
@tool
extends Sprite3D

var shader_material: ShaderMaterial
var star_id: int
var star_seed: int
var star_temperature: float
var star_brightness: float
var material
var camera: Camera3D

var position_basis: Basis

func _ready():
	setup_star()
	camera = get_viewport().get_camera_3d()

func _process(delta):
	
	var time = (Time.get_ticks_msec() / 1000.0) * 0.98
	var time2 = (Time.get_ticks_msec() / 10000.0) * 0.96
	var time3 = Time.get_ticks_msec()
	var timer_reset = int(time)
	var timer_reset2 = int(time2)
	var timer_new = time - timer_reset
	var timer_new2 = time2 - timer_reset2
	var information =  0.5 * timer_new
	var oscillation = abs(1 - (timer_new * 2))
	var oscillation2 = abs(1 - (timer_new2 * 2))
	var information2 = 0.5 * oscillation
	var information3 = 0.5 + information2#(0.5 - information2)
	var information4 = 2 + (2.0 * oscillation2)
	shader_material.set_shader_parameter("time", Time.get_ticks_msec() / 1000.0)
	shader_material.set_shader_parameter("offset_one", information2)
	shader_material.set_shader_parameter("offset_two", information3)
	shader_material.set_shader_parameter("offset_three", information4)
	shader_material.set_shader_parameter("time_int", time3)
	
	#camera matrix
	var camera_x = -camera.global_transform.basis.x
	var camera_y = camera.global_transform.basis.y
	var camera_z = -camera.global_transform.basis.z
	var camera_matrix  = Basis(camera_x, camera_y, camera_z).orthonormalized()
	
	var camera_pos = camera.global_transform.origin

	enhanced_look_at(self, camera_pos)
	
	var basis_1_x = (camera_matrix.x + position_basis.x) / 2
	var basis_1_y = (camera_matrix.y + position_basis.y) / 2
	var basis_1_z = (camera_matrix.z + position_basis.z) / 2
	var new_final_matrix = Basis(basis_1_x, basis_1_y, basis_1_z)
	
	shader_material.set_shader_parameter("rotation_matrix", new_final_matrix)

# Enhanced look-at function that adjusts the basis of the node considering all three axes
func enhanced_look_at(node: Node3D, target: Vector3) -> void:
	var origin: Vector3 = node.global_transform.origin
	var forward: Vector3 = (target - origin).normalized()

	# Just return if at the same position
	if origin == target:
		return

	# Calculate right and up vectors based on the camera's basis
	var camera_cam_x = camera.global_transform.basis.x
	var camera_cam_y = camera.global_transform.basis.y
	var right: Vector3 = -camera_cam_x
	var up: Vector3 = -camera_cam_y

	# If the forward vector is too close to the up vector, adjust the up vector to avoid gimbal lock
	if abs(forward.dot(up)) > 0.999:
		up = Vector3.UP if abs(forward.dot(Vector3.UP)) < 0.999 else Vector3.RIGHT

	# Recalculate right and up vectors
	right = up.cross(forward).normalized()
	up = forward.cross(right).normalized()

	# Create a new basis with the calculated vectors
	var new_basis = Basis(right, -up, -forward)
	position_basis = new_basis

func setup_star():

	var image = Image.create(1024, 1024, false, Image.FORMAT_RGBA8)
	image.fill(Color(1, 1, 1, 1))
	var star_texture = ImageTexture.create_from_image(image)
	self.texture = star_texture

	var shader = load("res://Shaders/CelestialBody.gdshader")
	if shader == null:
		print("Error: Could not load CelestialBody.gdshader file")
		return

	shader_material = ShaderMaterial.new()
	shader_material.shader = shader
	material_override = shader_material

	star_id = get_instance_id()

func set_parameters(seed_star: int, temperature: float, brightness: float):

	star_seed = seed_star
	star_temperature = temperature
	star_brightness = brightness

	var star_color = temperature_to_color(temperature)

	shader_material.set_shader_parameter("star_seed", float(seed_star))
	shader_material.set_shader_parameter("temperature_star", temperature)
	shader_material.set_shader_parameter("brightness", brightness)
	shader_material.set_shader_parameter("color", star_color)

	self.scale = Vector3.ONE * brightness
	pixel_size = brightness / 100

func temperature_to_color(temperature: float) -> Color:
	print("galaxy temp in function = ", temperature)
	
	# Define color ranges for different temperature brackets
	var colors = [
		Color(1.0, 0.0, 0.0),   # Red
		Color(1.0, 0.5, 0.0),   # Orange
		Color(1.0, 1.0, 0.0),   # Yellow
		Color(1.0, 1.0, 1.0),   # White
		Color(0.5, 1.0, 1.0),   # Light Blue
		Color(0.0, 0.0, 1.0),   # Blue
		Color(0.5, 0.0, 1.0)    # Purple
	]

	# Define the temperature range
	var min_temp = 2000.0
	var max_temp = 18000.0

	# Clamp temperature between min_temp and max_temp
	var clamped_temp = clamp(temperature, min_temp, max_temp)
	
	# Normalize temperature to 0-1 range
	var normalized_temp = (clamped_temp - min_temp) / (max_temp - min_temp)
	
	# Ensure normalized_temp is exactly 0.0 or 1.0 at the extremes
	if is_equal_approx(normalized_temp, 0.0):
		normalized_temp = 0.0
	elif is_equal_approx(normalized_temp, 1.0):
		normalized_temp = 1.0
	
	# Calculate color index
	var color_index = normalized_temp * (colors.size() - 1)
	
	var index1 = int(floor(color_index))
	var index2 = int(ceil(color_index))
	index2 = min(index2, colors.size() - 1)  # Ensure we don't go out of bounds
	
	var t = fmod(color_index, 1.0)
	
	# Interpolate between the two closest colors
	var final_color = colors[index1].lerp(colors[index2], t)
	
	# Apply gamma correction
	final_color.r = pow(final_color.r, 1.0 / 2.2)
	final_color.g = pow(final_color.g, 1.0 / 2.2)
	final_color.b = pow(final_color.b, 1.0 / 2.2)
	
	#print("final color maybe lol = ", final_color)
	return final_color

func get_star_id():

	return star_id

func get_star_seed():

	return star_seed

func get_star_temperature():

	return star_temperature

func get_star_brightness():

	return star_brightness


// CelestialBody.gdshader

shader_type spatial;
render_mode unshaded;

uniform float star_seed : hint_range(1, 10000);
uniform vec4 color1 : source_color = vec4(1.0, 1.0, 1.0, 1.0);  // White
uniform vec4 color2 : source_color = vec4(0.0, 0.0, 0.0, 1.0);  // Black
uniform vec3 color3 : source_color = vec3(1.0, 1.0, 1.0);
uniform vec3 color4 : source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 color5 : source_color = vec3(1.0, 0.5, 0.0);
uniform float noise_scale = 99.0;
uniform float rotation_speed = 0.1;
uniform vec3 player_position;
uniform float time; // Added time variable
uniform vec4 blob_color : source_color = vec4(1.0, 0.5, 0.0, 1.0); // Orange for blobs
uniform float blob_size = 0.5;
varying vec3 vertex_position;
varying vec3 view_direction;
uniform mat3 rotation_matrix;
uniform float offset_one;
uniform float offset_two;
uniform float offset_three;
uniform vec4 flares_color : source_color = vec4(1.0, 1.0, 1.0, 1.0); 
uniform vec4 void_color : source_color = vec4(0.0, 0.0, 0.0, 0.0); 

uniform float flare_intensity = 1.0;
uniform float flare_scale = 1.0;

uniform float time_speed : hint_range(0.0, 1.0) = 0.05;
//uniform float time;
uniform float storm_width : hint_range(0.0, 0.5) = 0.3;
uniform float storm_dither_width : hint_range(0.0, 0.5) = 0.07;
//uniform float flare_scale = 1.0;
uniform float flare_seed: hint_range(1, 10);
uniform float circle_amount : hint_range(2.0, 30.0) = 5.0;
uniform float circle_scale : hint_range(0.0, 1.0) = 1.0;

uniform float flare_size = 50.0;
uniform int OCTAVES : hint_range(0, 20, 1) = 4;

uniform float blob_detail_scale = 2.0;
uniform float blob_detail_intensity = 0.3;
uniform float blob_detail_speed = 0.1;
uniform float time_int;

//uniform vec4 flares_color : source_color = vec4(1.0, 0.7, 0.3, 1.0); // Bright orange-yellow

uniform float temperature_star = 2100;
#include "res://ShaderInc/FastNoiseLite.gdshaderinc"

vec3 temperature_to_base_color(float temperature) {
    vec4 colors[7] = vec4[7](
        vec4(1.0, 0.0, 0.0, 1.0), // Red
        vec4(1.0, 0.5, 0.0, 1.0), // Orange
        vec4(1.0, 1.0, 0.0, 1.0), // Yellow
        vec4(1.0, 1.0, 1.0, 1.0), // White
        vec4(0.5, 1.0, 1.0, 1.0), // Light Blue
        vec4(0.0, 0.0, 1.0, 1.0), // Blue
        vec4(0.5, 0.0, 1.0, 1.0)  // Purple
    );
	
    // Clamp temperature between 2000K and 18000K
    float clamped_temp = clamp(temperature_star, 2000.0, 18000.0);
   
    // Normalize temperature to 0-1 range
    float normalized_temp = (clamped_temp - 2000.0) / 16000.0;

    float colorIndex = normalized_temp * float(colors.length() - 1);
    int index1 = int(floor(colorIndex));
    int index2 = int(ceil(colorIndex));
    index2 = min(index2, colors.length() - 1); // Ensure we don't go out of bounds
    
    float t = fract(colorIndex);
    
    vec4 finalColor = mix(colors[index1], colors[index2], t);
    
    // Apply gamma correction
    finalColor.rgb = pow(finalColor.rgb, vec3(1.0 / 2.2));
    return finalColor.rgb;
}

float animate_blobs2(float blob_noise) {
    float edge0 = offset_one - 0.3;
    float edge1 = offset_one + 0.1;
    float smooth_factor = smoothstep(edge1, edge0, blob_noise);
    return (blob_noise < offset_one) ? smooth_factor * 3.6 : 0.0;
}

float animate_blobs(float blob_noise) {
    float edge0 = offset_two - 1.0;
    float edge1 = offset_two + 0.5;
    float smooth_factor = smoothstep(edge0, edge1, blob_noise);
    return (blob_noise > offset_two) ? smooth_factor * 3.9 : 0.0;
}



float getDistanceFromCenter(vec3 point) {
	return length(point);
}


float mapFlareNoise(float noise, float distance) {
    if (distance < 0.7) {
        return 0.0; // No flare in core
    } else if (distance < 0.85) {
        // Map noise for inner flare
        return smoothstep(0.7, 0.85, distance) * noise;
    } else {
        // Map noise for outer flare
        return smoothstep(0.85, 1.0, distance) * noise;
    }
}


vec4 get_cloud_color(float noise, float detail, vec3 color_1, vec3 color_2) {
    float cloud_threshold = 0.2;
    float cloud_edge = 0.8;
    
    float combined_noise = noise + ((detail * 0.5 - 0.25) + offset_one );
    
    if (combined_noise < cloud_threshold) return vec4(0.0);
    
    float opacity = smoothstep(cloud_threshold, cloud_edge, combined_noise);
    vec3 cloud_color = mix(color_1, color_2, opacity);
    return vec4(cloud_color, opacity * 0.7);
}

void vertex() {
    MODELVIEW_MATRIX = VIEW_MATRIX * mat4(INV_VIEW_MATRIX[0], INV_VIEW_MATRIX[1], INV_VIEW_MATRIX[2], MODEL_MATRIX[3]);
}

void fragment() {
    // Create a 3D position from the 2D UV
    vec2 uv = UV * 2.0 - 1.0;
    float d = length(uv);
	
	    // Adjust scales for each layer
    float core_scale = 0.93; // Adjust this to change core size
    float blob_scale = 0.98; // Slightly larger than core
    //float flare_scale = 1.0; // Full size for flares
	
	    // Calculate separate distances for each layer
    float core_d = d / core_scale;
    float blob_d = d / blob_scale;
    float flare_d = d;
    vec3 p = vec3(uv, sqrt(max(0.0, 1.0 - d * d)));
    
    // Apply rotation
    p = rotation_matrix * p;
    
    // Setup FastNoiseLite
    fnl_state noise_state = fnlCreateState(int(star_seed));
    noise_state.noise_type = FNL_NOISE_OPENSIMPLEX2;
    noise_state.frequency = 0.01;
    noise_state.fractal_type = FNL_FRACTAL_FBM;
	noise_state.lacunarity = 4.f;
	noise_state.gain = .3f;
    noise_state.octaves = 4;
    
	fnl_state base_noise_state = fnlCreateState(int(star_seed));
	base_noise_state.noise_type = FNL_NOISE_OPENSIMPLEX2;
	base_noise_state.frequency = 0.01;
	base_noise_state.fractal_type = FNL_FRACTAL_FBM;
	base_noise_state.lacunarity = 4.f;
	base_noise_state.gain = .3f;
    base_noise_state.octaves = 4;

	fnl_state blob_noise_state = fnlCreateState(int(star_seed + 3.69));
	blob_noise_state.noise_type = FNL_NOISE_OPENSIMPLEX2;
	blob_noise_state.frequency = 0.02;
	blob_noise_state.fractal_type = FNL_NOISE_VALUE; //FNL_NOISE_VALUE;
	blob_noise_state.lacunarity = 3.f;
	blob_noise_state.gain = .3f;
    blob_noise_state.octaves = 3;
	
	fnl_state flares_noise_state = fnlCreateState(int(star_seed + 5.67));
	flares_noise_state.noise_type = FNL_NOISE_OPENSIMPLEX2;
	flares_noise_state.frequency = 0.03;
	flares_noise_state.fractal_type = FNL_NOISE_CELLULAR;
	flares_noise_state.lacunarity = 3.f;
	flares_noise_state.gain = .3f;
    flares_noise_state.octaves = 2;
	
    // Generate noise for base star appearance
    float n = fnlGetNoise3D(noise_state, p.x * noise_scale, p.y * noise_scale, p.z * noise_scale + (time * 2.2));
    //vec4 star_color = temperature_to_base_color(temperature_star);
    vec3 main_color = temperature_to_base_color(temperature_star);
    vec3 second_color = main_color * 0.3; // Slightly darker
    vec3 blobs_color = main_color * 1.3; // Slightly brighter

	vec3 flaren_colo = main_color * 1.36;
	vec4 flar_color = vec4(flaren_colo.x, flaren_colo.y, flaren_colo.z, 1.0);
	vec4 flarenern_coloroo = vec4((flares_color.x + flaren_colo.x ) * 0.5, (flares_color.y + flaren_colo.y ) * 0.5, (flares_color.z + flaren_colo.z ) * 0.5, flares_color.w);
	

    // Mix colors based on noise for base star
    vec4 base_color = vec4(mix(second_color, main_color, n * 0.5 + 0.5), 1.0);
    
    // Generate noise for blobs
    float blob_noise = fnlGetNoise3D(blob_noise_state, p.x * noise_scale * 1.5, p.y * noise_scale * 1.5, p.z * noise_scale * 1.5 + (time * 9.3));

	float blob_noise2 = fnlGetNoise3D(blob_noise_state, p.x * noise_scale * 1.5, p.y * noise_scale * 1.5, p.z * noise_scale * 1.5 + (time * 3.6));
    
    
	float distance = getDistanceFromCenter(p);
	vec3 point = p ;//* noise_scale * offset_three;
	float flares_noise = fnlGetNoise3D(flares_noise_state, point.x * noise_scale, point.y  * noise_scale, point.z  * noise_scale + (time * 3.3));
	float flares_noise2 = fnlGetNoise3D(flares_noise_state, point.x * noise_scale, point.y  * noise_scale, point.z  * noise_scale + (time * 6.3));
	
	float flareEffect = mapFlareNoise(flares_noise, distance);

	vec4 final_color = vec4(0.0, 0.0, 0.0, 0.0); // Fully transparent
	vec4 flare_layer = vec4(0.0);
	vec4 blob_layer = vec4(0.0);
	vec4 core_layer = vec4(0.0);
	vec4 flares_layer = vec4(0.0);


	// Core layer
	if (core_d <= 1.0) {
	    core_layer = base_color;
	    core_layer.a = smoothstep(1.0, 0.99, core_d);
	}
	final_color = mix(final_color, core_layer, core_layer.a);
	// Blob layer
	if (blob_d <= 1.0) {

		vec3 color_1 = main_color.rgb;
		vec3 color_2 = blobs_color.rgb;
		vec4 blobin_color = get_cloud_color(blob_noise, blob_noise2, color_1, color_2);

		//float blobs_opacity = smoothstep(blob_noise, blob_noise2, -0.2);
		blob_layer = mix(final_color, blobin_color * 3.2, blob_noise * blobin_color.a);
		blob_layer.a = smoothstep(1.0, 0.9, blob_d);
	}
	final_color = mix(final_color, blob_layer, blob_layer.a);
// Flare layer
	if (flare_d <= 1.0) {
		//flares_noise  flareEffect
		vec3 color_3 = main_color.rgb;
		vec3 color_4 = flaren_colo.rgb;
		vec4 flarin_color = get_cloud_color(flares_noise, flares_noise, color_3, color_4);
    //flares_layer = vec4(flar_color.rgb, flareEffect);
	//blob_layer = mix(final_color, blobin_color, blob_noise * blobin_color.a);
		flares_layer = mix(final_color, flarin_color, flares_noise * flarin_color.a);
		flare_layer = mix(final_color, flares_layer , flares_layer.a);
	//flare_layer = mix(final_color, flares_layer, flares_layer);
		flare_layer.a = smoothstep(1.0, 0.9, flare_d);
	}

	final_color = mix(final_color, flare_layer, flare_layer.a);

	// Apply final mask
	float mask = smoothstep(1.0, 0.99, d);
	ALBEDO = final_color.rgb;
	ALPHA = final_color.a * mask;
}


CelestialPlanet

#OrbitStabilizer a CelestialPlanet.gd

extends Node3D

var planet_sprite: Sprite3D

var star_position_basis: Basis# = Basis.IDENTITY
var planet_data_system

func _ready():
	planet_sprite = get_node("CelestialPlanetSprite")
	if not planet_sprite:
		print("Error: CelestialPlanetSprite not found!")

func _process(delta):
	global_transform.basis = star_position_basis
	
func set_planet_data(data: Dictionary):
	planet_data_system = data
	#print("we tried")
	#print("planet data, send to scene CelestialPlanet data = ", data)
	planet_sprite.set_parameters(data.seed, data.type, data.radius, data.orbit_radius, data.planet_tilt, data.planet_spin_speed, planet_data_system)
	#set_parameters()
	
func get_planet_data_records():
	return planet_data_system


# CelestialPlanetSprite.gd

extends Sprite3D

var shader_material: ShaderMaterial
var planet_id: int
var planet_seed: int
#var star_temperature: float
#var star_brightness: float
var material
var camera: Camera3D
var rotation_speed: float = 1.0  # Adjust as needed
var position_basis: Basis
var star_basis: Basis
var tilt_angle: float = 0.0
var star_vector: Vector3
var planet_data
var planet_type
var radius
var orbit_radius
var mass
var orbit_speed
var moons
var habitable
var water
var basic_resources
var rare_resources
var spin_speed
var planet_data_records

func _ready():
	setup_planet()
	camera = get_viewport().get_camera_3d()
	#rotation_degrees.x = tilt_angle


func _process(delta):
	
	var time = (Time.get_ticks_msec() / 1000.0) * 0.98
	var time2 = (Time.get_ticks_msec() / 10000.0) * 0.96
	var time3 = Time.get_ticks_msec()
	var timer_reset = int(time)
	var timer_reset2 = int(time2)
	var timer_new = time - timer_reset
	var timer_new2 = time2 - timer_reset2
	var information =  0.5 * timer_new
	var oscillation = abs(1 - (timer_new * 2))
	var oscillation2 = abs(1 - (timer_new2 * 2))
	var information2 = 0.5 * oscillation
	var information3 = 0.5 + information2
	var information4 = 2 + (2.0 * oscillation2)
	shader_material.set_shader_parameter("time", Time.get_ticks_msec() / 1000.0)
	shader_material.set_shader_parameter("offset_one", information2)
	shader_material.set_shader_parameter("offset_two", information3)
	shader_material.set_shader_parameter("offset_three", information4)
	shader_material.set_shader_parameter("time_int", time3)
	
	var camera_x = -camera.global_transform.basis.x
	var camera_y = camera.global_transform.basis.y
	var camera_z = -camera.global_transform.basis.z
	var camera_matrix  = Basis(camera_x, camera_y, camera_z).orthonormalized()
	
	var camera_pos = camera.global_transform.origin

	enhanced_look_at(self, camera_pos)
	
	var basis_1_x = (camera_matrix.x + position_basis.x) / 2
	var basis_1_y = (camera_matrix.y + position_basis.y) / 2
	var basis_1_z = (camera_matrix.z + position_basis.z) / 2
	var new_final_matrix = Basis(basis_1_x, basis_1_y, basis_1_z)

	var planet_rotation = global_transform.basis
	var planet_rotation_x = planet_rotation.x
	var planet_rotation_y = planet_rotation.y
	var planet_rotation_z = planet_rotation.z
	var rotation_planet = Basis(-planet_rotation_x, -planet_rotation_y, planet_rotation_z)
	
	var combined_basis = rotation_planet * position_basis

	#var spin_speed: float = 2.0
	self.rotate_y(spin_speed * delta) #
	
	shader_material.set_shader_parameter("rotation_matrix", combined_basis) # one for our camera combined_basis
	shader_material.set_shader_parameter("position_matrix", position_basis) # one for light direction position_basis
	#var position_basis2 = Basis(-position_basis.x, -position_basis.y, -position_basis.z)
	#shader_material.set_shader_parameter("position_matrix2", position_basis2) # one for light direction position_basis
	#var light_direction = calculate_light_direction()
	#var light_direction_x = light_direction.x
	#var light_direction_y = light_direction.y
	#var light_direction_z = light_direction.z
	#print(star_vector)
	enhanced_look_at_star(self, star_vector) # star_basis

	
	#var light_direction_matrix = Basis(light_direction, light_direction.cross(Vector3.UP).normalized(), light_direction.cross(Vector3.RIGHT).normalized())
	var star_basis_x = star_basis.x
	var star_basis_y = star_basis.y
	var star_basis_z = star_basis.z
	var rotation_star = Basis(-star_basis_x, -star_basis_y, -star_basis_z)
	
	#camera_matrix = camera orientation, so sprite looks good
	#position_basis = what enhanced look at spits out
	#rotation_planet = planet own rotation
	#star_basis = what lok at does when we put target as 0,0,0
	#new_final_matrix = camera + position /2
	#var combined_basis = rotation_planet * new_final_matrix
	#var planet_rot = rotation_planet * position_basis
	#var basis_2_x = (star_basis.x + rotation_planet.x) / 2
	#var basis_2_y = (star_basis.y + rotation_planet.y) / 2
	#var basis_2_z = (star_basis.z + rotation_planet.z) / 2
	#var new_final_matrix2 = Basis(basis_2_x, basis_2_y, basis_2_z)

	#var new_ld = star_basis * planet_rot
	#var newest_ld = new_final_matrix * new_ld
	shader_material.set_shader_parameter("direction_matrix", star_basis)
	#shader_material.set_shader_parameter("direction_matrix2", rotation_star)
	#shader_material.set_shader_parameter("planet_position", global_transform.origin)
	
#func calculate_light_direction():
#	var star_position = Vector3.ZERO
#	var planet_position = global_transform.origin
#	var light_direction = (star_position - planet_position).normalized()
#	
	# Try switching the components around
#	return Vector3(light_direction.z, light_direction.y, -light_direction.x)
	
# Enhanced look-at function that adjusts the basis of the node considering all three axes
func enhanced_look_at(node: Node3D, target: Vector3) -> void:
	var origin: Vector3 = node.global_transform.origin
	var forward: Vector3 = (target - origin).normalized()

	# Just return if at the same position
	if origin == target:
		return

	# Calculate right and up vectors based on the camera's basis
	var camera_cam_x = camera.global_transform.basis.x
	var camera_cam_y = camera.global_transform.basis.y
	var right: Vector3 = -camera_cam_x
	var up: Vector3 = -camera_cam_y

	# If the forward vector is too close to the up vector, adjust the up vector to avoid gimbal lock
	if abs(forward.dot(up)) > 0.999:
		up = Vector3.UP if abs(forward.dot(Vector3.UP)) < 0.999 else Vector3.RIGHT

	# Recalculate right and up vectors
	right = up.cross(forward).normalized()
	up = forward.cross(right).normalized()

	# Create a new basis with the calculated vectors
	var new_basis = Basis(right, -up, -forward)
	position_basis = new_basis

func enhanced_look_at_star(node: Node3D, target: Vector3) -> void:
	var origin: Vector3 = node.global_transform.origin
	var forward: Vector3 = (target - origin).normalized()

	# Just return if at the same position
	if origin == target:
		return

	# Calculate right and up vectors based on the camera's basis
	var camera_cam_x = camera.global_transform.basis.x
	var camera_cam_y = camera.global_transform.basis.y
	var right: Vector3 = -camera_cam_x
	var up: Vector3 = -camera_cam_y

	# If the forward vector is too close to the up vector, adjust the up vector to avoid gimbal lock
	if abs(forward.dot(up)) > 0.999:
		up = Vector3.UP if abs(forward.dot(Vector3.UP)) < 0.999 else Vector3.RIGHT

	# Recalculate right and up vectors
	right = up.cross(forward).normalized()
	up = forward.cross(right).normalized()

	# Create a new basis with the calculated vectors
	var new_basis = Basis(right, -up, -forward)
	star_basis = new_basis

func setup_planet():

	var image = Image.create(1024, 1024, false, Image.FORMAT_RGBA8)
	image.fill(Color(1, 1, 1, 1))
	var star_texture = ImageTexture.create_from_image(image)
	self.texture = star_texture

	var shader = load("res://Shaders/CelestialPlanet.gdshader")
	if shader == null:
		print("Error: Could not load CelestialBody.gdshader file")
		return

	shader_material = ShaderMaterial.new()
	shader_material.shader = shader
	material_override = shader_material

	planet_id = get_instance_id()

func set_parameters(seed_planet: int, planet_type: int, radius: float, orbit_radius: float, planet_tilt: float, planet_rotation: float, planet_data_system: Dictionary):
	#print("celestal planet sprite data, seed_planet = ", seed_planet," planet_type = ", planet_type," radius = ", radius, " orbit_radius = ",orbit_radius)
	#noise_scale, shininess, planet_type
	planet_data_records = planet_data_system
	planet_seed = seed_planet
	tilt_angle = planet_tilt
	rotation_degrees.x = tilt_angle
	spin_speed = planet_rotation
	var delta_Alpha = GlobalState.elapsed_time_seconds
	print("delta_Alpha = ", delta_Alpha)
	self.rotate_y(spin_speed * delta_Alpha)
	shader_material.set_shader_parameter("planet_seed", float(planet_seed))
	shader_material.set_shader_parameter("noise_scale", radius * 8)
	#shader_material.set_shader_parameter("shininess", how far it is from sun either divided or multipled by something, we need to check)
	shader_material.set_shader_parameter("planet_type", planet_type)

	#self.scale = Vector3.ONE * (radius / )
	pixel_size = radius / 1000

func temperature_to_color(temperature: float) -> Color:

	if temperature < 3500:
		return Color(1.0, 0.5, 0.0, 1.0)  # Red
	elif temperature < 5000:
		return Color(1.0, 0.8, 0.0, 1.0)  # Orange
	elif temperature < 6000:
		return Color(1.0, 1.0, 1.0, 1.0)  # White
	elif temperature < 10000:
		return Color(0.8, 0.8, 1.0, 1.0)  # Light Blue
	else:
		return Color(0.6, 0.6, 1.0, 1.0)  # Blue

func get_planet_id():

	return planet_id

func get_planet_seed():

	return planet_seed

func get_planet_type():

	return planet_type

func get_planet_data():

	return planet_data
	
func get_planet_data_records():
	return planet_data_records




// CelestialPlanet.gdshader

shader_type spatial;
render_mode unshaded;

uniform float planet_seed : hint_range(1, 10000);
uniform vec4 color1 : source_color = vec4(1.0, 1.0, 1.0, 1.0);  // White
uniform vec4 color2 : source_color = vec4(0.0, 0.0, 0.0, 1.0);  // Black
uniform float noise_scale = 96.0;

uniform float time; // Added time variable
uniform mat3 rotation_matrix; // our position
uniform float offset_one;
uniform float offset_two;
uniform float offset_three;

// rotation position matrixes
uniform mat3 direction_matrix; // light point
uniform mat3 position_matrix; // our position
uniform vec3 planet_position;

//star light and darkness stuff
uniform vec3 light_color = vec3(1.0, 1.0, 1.0); // Slightly yellow sunlight
uniform float ambient_strength = 0.005;
uniform float diffuse_strength = 0.9;
uniform float specular_strength = 1.0;
uniform float shininess = 4.0;

// Define your colors
uniform vec4 water_deep_blue : source_color = vec4(0.0, 0.0, 0.5, 1.0); // first color for planets
uniform vec4 water_aqua_blue : source_color = vec4(0.0, 0.5, 1.0, 1.0); // second color for planets
uniform vec4 sandy_yellow : source_color = vec4(1.0, 0.9, 0.2, 1.0); // third color for planets
uniform vec4 lowlands_green : source_color = vec4(0.0, 0.8, 0.0, 1.0); // fourth color for planets
uniform vec4 highlands_deep_green : source_color = vec4(0.0, 0.5, 0.0, 1.0); // fifth color for planets
uniform vec4 mountain_gray : source_color = vec4(0.5, 0.5, 0.5, 1.0); // sixth color for planets
uniform vec4 mountain_white : source_color = vec4(1.0, 1.0, 1.0, 1.0); // seventh color for planets

uniform vec4 atmosphere_color : source_color = vec4(0.52, 0.9, 0.9, 1.0);  // Light blue 135, 206, 235 0.52, 0.9, 0.9 
uniform float atmosphere_intensity : hint_range(0.0, 1.0) = 0.3;
uniform float atmosphere_falloff : hint_range(1.0, 5.0) = 1.0;
uniform float atmosphere_size : hint_range(0.0, 0.2) = 0.1;  // How far the atmosphere extends beyond the planet's edge
uniform float cloud_extend : hint_range(0.0, 0.1) = 0.02; // How much clouds extend beyond planet edge
uniform int planet_type : hint_range(0 , 5) = 0; // 0 - earth like planet, 1 - Rocky Planet , 2 - Ice Planet, 3 - Fire Planet, 4 - Exo Planet, kinda like earth planets, but its purple and green, purple lands and green water, 5 - Gas Giants

uniform float stripe_scale = 0.1;
uniform float sphere_scale = 2.0;

#include "res://ShaderInc/FastNoiseLite.gdshaderinc"


vec4 get_cloud_color(float noise, float detail, vec3 color_one, vec3 color_two) {
    float cloud_threshold = 0.1;
    float cloud_edge = 0.9;
    
    float combined_noise = noise + detail;//(detail * 0.5 - 0.25);
    
    if (combined_noise < cloud_threshold) return vec4(0.0);
    
    float opacity = smoothstep(cloud_threshold, cloud_edge, combined_noise);
    vec3 cloud_color = mix(color_one, color_two, opacity);
    return vec4(cloud_color, opacity * 0.9);
}

vec4 get_first_planet_color(int type_of_planet){
    vec4 first_planet_color;
    if (type_of_planet == 0) first_planet_color = vec4(0.0, 0.0, 0.5, 1.0); // Earth-like (water_deep_blue)
    else if (type_of_planet == 1) first_planet_color = vec4(0.5, 0.0, 0.0, 1.0); // Rocky Red (Dark Red)
    else if (type_of_planet == 2) first_planet_color = vec4(0.565, 0.761, 0.886, 1.0); // Ice (Deep Ice Blue)
    else if (type_of_planet == 3) first_planet_color = vec4(0.545, 0.0, 0.0, 1.0); // Fire (Deep Lava Red)
    else if (type_of_planet == 4) first_planet_color = vec4(0.08, 0.39, 0.26, 1.0); // Exo (Dark Green)
    else if (type_of_planet == 5) first_planet_color = vec4(0.2, 0.2, 0.2, 1.0); // Rocky Grey (Dark Gray)
	else if (type_of_planet == 6) first_planet_color = vec4(0.6, 0.3, 0.0, 1.0); // Gas Giant (Deep Orange)
    return first_planet_color;
}

vec4 get_second_planet_color(int type_of_planet){
    vec4 second_planet_color;
    if (type_of_planet == 0) second_planet_color = vec4(0.0, 0.5, 1.0, 1.0); // Earth-like (water_aqua_blue)
    else if (type_of_planet == 1) second_planet_color = vec4(1.0, 0.0, 0.0, 1.0); // Rocky Red (Red)
    else if (type_of_planet == 2) second_planet_color = vec4(0.878, 0.969, 1.0, 1.0); // Ice (Pale Blue)
    else if (type_of_planet == 3) second_planet_color = vec4(1.0, 0.27, 0.0, 1.0); // Fire (Lava Orange)
    else if (type_of_planet == 4) second_planet_color = vec4(0.47, 0.88, 0.64, 1.0); // Exo (Light Green)
    else if (type_of_planet == 5) second_planet_color = vec4(0.5, 0.5, 0.5, 1.0); // Rocky Grey (Gray)
	else if (type_of_planet == 6) second_planet_color = vec4(0.8, 0.6, 0.2, 1.0); // Gas Giant (Light Orange)
    return second_planet_color;
}


vec4 get_third_planet_color(int type_of_planet){
	vec4 third_planet_color;
    if (type_of_planet == 0) third_planet_color = vec4(1.0, 0.9, 0.2, 1.0); // Earth-like (sandy_yellow)
    else if (type_of_planet == 1) third_planet_color = vec4(1.0, 0.5, 0.0, 1.0); // Rocky Red (Orange)
    else if (type_of_planet == 2) third_planet_color = vec4(0.780, 0.824, 0.851, 1.0); // Ice (Glacier Grey)
    else if (type_of_planet == 3) third_planet_color = vec4(1.0, 0.0, 0.0, 1.0); // Fire (Red)
    else if (type_of_planet == 4) third_planet_color = vec4(0.72, 0.49, 0.83, 1.0); // Exo (Light Purple)
    else if (type_of_planet == 5) third_planet_color = vec4(0.8, 0.8, 0.8, 1.0); // Rocky Grey (Light Gray)
	else if (type_of_planet == 6) third_planet_color = vec4(0.9, 0.8, 0.5, 1.0); // Gas Giant (Pale Yellow)
	return third_planet_color;
}

vec4 get_fourth_planet_color(int type_of_planet){
	vec4 fourth_planet_color;
    if (type_of_planet == 0) fourth_planet_color = vec4(0.0, 0.8, 0.0, 1.0); // Earth-like (lowlands_green)
    else if (type_of_planet == 1) fourth_planet_color = vec4(1.0, 1.0, 0.0, 1.0); // Rocky Red (Yellow)
    else if (type_of_planet == 2) fourth_planet_color = vec4(0.761, 0.906, 1.0, 1.0); // Ice (Frosty Blue)
    else if (type_of_planet == 3) fourth_planet_color = vec4(1.0, 0.549, 0.0, 1.0); // Fire (Bright Flame)
    else if (type_of_planet == 4) fourth_planet_color = vec4(0.56, 0.25, 0.79, 1.0); // Exo (Medium Purple)
    else if (type_of_planet == 5) fourth_planet_color = vec4(1.0, 1.0, 1.0, 1.0); // Rocky Grey (White)
	else if (type_of_planet == 6) fourth_planet_color = vec4(1.0, 0.9, 0.7, 1.0); // Gas Giant (Cream)
	return fourth_planet_color;
}

vec4 get_fifth_planet_color(int type_of_planet){
	vec4 fifth_planet_color;
    if (type_of_planet == 0) fifth_planet_color = vec4(0.0, 0.5, 0.0, 1.0); // Earth-like (highlands_deep_green)
    else if (type_of_planet == 1) fifth_planet_color = vec4(0.8, 0.6, 0.4, 1.0); // Rocky Red (Light Brown)
    else if (type_of_planet == 2) fifth_planet_color = vec4(0.847, 0.886, 0.914, 1.0); // Ice (Light Grey)
    else if (type_of_planet == 3) fifth_planet_color = vec4(0.2, 0.2, 0.2, 1.0); // Fire (Dark Grey)
    else if (type_of_planet == 4) fifth_planet_color = vec4(0.36, 0.04, 0.48, 1.0); // Exo (Dark Purple)
    else if (type_of_planet == 5) fifth_planet_color = vec4(0.4, 0.4, 0.6, 1.0); // Rocky Grey (Blueish Gray)
	return fifth_planet_color;
}

vec4 get_sixth_planet_color(int type_of_planet){
	vec4 sixth_planet_color;
    if (type_of_planet == 0) sixth_planet_color = vec4(0.5, 0.5, 0.5, 1.0); // Earth-like (mountain_gray)
    else if (type_of_planet == 1) sixth_planet_color = vec4(0.6, 0.3, 0.1, 1.0); // Rocky Red (Dark Brown)
    else if (type_of_planet == 2) sixth_planet_color = vec4(1.0, 1.0, 1.0, 1.0); // Ice (Snow White)
    else if (type_of_planet == 3) sixth_planet_color = vec4(0.0, 0.0, 0.0, 1.0); // Fire (Black)
    else if (type_of_planet == 4) sixth_planet_color = vec4(0.5, 0.34, 0.6, 1.0); // Exo (Greyish Purple)
    else if (type_of_planet == 5) sixth_planet_color = vec4(0.5, 0.4, 0.3, 1.0); // Rocky Grey (Brownish Gray)
	return sixth_planet_color;
}

vec4 get_seventh_planet_color(int type_of_planet){
	vec4 seventh_planet_color;
    if (type_of_planet == 0) seventh_planet_color = vec4(1.0, 1.0, 1.0, 1.0); // Earth-like (mountain_white)
    else if (type_of_planet == 1) seventh_planet_color = vec4(0.3, 0.1, 0.1, 1.0); // Rocky Red (Very Dark Red)
    else if (type_of_planet == 2) seventh_planet_color = vec4(0.694, 0.878, 1.0, 1.0); // Ice (Icy Blue)
    else if (type_of_planet == 3) seventh_planet_color = vec4(0.0, 0.0, 0.0, 1.0); // Fire (Black)
    else if (type_of_planet == 4) seventh_planet_color = vec4(0.64, 0.84, 0.79, 1.0); // Exo (Atmospheric Purple)
    else if (type_of_planet == 5) seventh_planet_color = vec4(0.0, 0.0, 0.0, 1.0); // Rocky Grey (Black)
	return seventh_planet_color;
}


vec4 get_surface_color(float noise, vec4 first_planet_color, vec4 second_planet_color, vec4 third_planet_color, vec4 fourth_planet_color, vec4 fifth_planet_color, vec4 sixth_planet_color, vec4 seventh_planet_color){
    // Define the colors for the height map
    vec4 colors[7] = vec4[7](
        first_planet_color,      // Deep water
        second_planet_color,     // Shallow water
        third_planet_color,      // Beach
        fourth_planet_color,     // Lowlands
        fifth_planet_color,      // Highlands
        sixth_planet_color,      // Mountains
        seventh_planet_color     // Snowy peaks
    );

    // Normalize the height to the range 0-1
    float normalized_height = clamp((noise + 0.5) / 2.0, 0.0, 1.0); // unknown identifier in expresion height
    
    float colorIndex = normalized_height * float(colors.length() - 1);
    int index1 = int(floor(colorIndex));
    int index2 = int(ceil(colorIndex));
    index2 = min(index2, colors.length() - 1); // Ensure we don't go out of bounds
    
    float t = fract(colorIndex);
    
    return mix(colors[index1], colors[index2], t);
}

void vertex() {
    MODELVIEW_MATRIX = VIEW_MATRIX * mat4(INV_VIEW_MATRIX[0], INV_VIEW_MATRIX[1], INV_VIEW_MATRIX[2], MODEL_MATRIX[3]);
}

void fragment() {
	// Create a 3D position from the 2D UV
	vec2 uv = UV * 2.0 - 1.0;
	float d = length(uv);
	
	// Adjust scales for each layer
	float core_scale = 0.9; // Adjust this to change core size
	float blob_scale = 0.95; // Slightly larger than core

	
	// Calculate separate distances for each layer
	float core_d = d / core_scale;
    float blob_d = d / blob_scale;
    float flare_d = d;
    vec3 p = vec3(uv, sqrt(max(0.0, 1.0 - d * d)));
    
    // Apply rotation
    p = rotation_matrix * p;
    
    // Setup FastNoiseLite for planets lands and maybe waters lol
    fnl_state noise_state = fnlCreateState(int(planet_seed));
    noise_state.noise_type = FNL_NOISE_OPENSIMPLEX2;
    noise_state.frequency = 0.01;
    noise_state.fractal_type = FNL_FRACTAL_FBM;
	noise_state.lacunarity = 4.f;
	noise_state.gain = .3f;
    noise_state.octaves = 4;
    // not used yet?
	fnl_state base_noise_state = fnlCreateState(int(planet_seed));
	base_noise_state.noise_type = FNL_NOISE_OPENSIMPLEX2;
	base_noise_state.frequency = 0.01;
	base_noise_state.fractal_type = FNL_FRACTAL_FBM;
	base_noise_state.lacunarity = 4.f;
	base_noise_state.gain = .3f;
    base_noise_state.octaves = 4;
	// we use it for them clouds!
	fnl_state blob_noise_state = fnlCreateState(int(planet_seed + 3.69));
	blob_noise_state.noise_type = FNL_NOISE_OPENSIMPLEX2;
	blob_noise_state.frequency = 0.02;
	blob_noise_state.fractal_type = FNL_FRACTAL_FBM;
	blob_noise_state.lacunarity = 3.f;
	blob_noise_state.gain = .3f;
    blob_noise_state.octaves = 3;
	// another not used noise :(
	fnl_state flares_noise_state = fnlCreateState(int(planet_seed + 5.67));
	flares_noise_state.noise_type = FNL_NOISE_OPENSIMPLEX2;
	flares_noise_state.frequency = 0.005 + (offset_three * 0.0005);
	flares_noise_state.fractal_type = FNL_NOISE_CELLULAR;
	flares_noise_state.lacunarity = 3.f;
	flares_noise_state.gain = .3f;
    flares_noise_state.octaves = 2;
	
	fnl_state new_type_circl = fnlCreateState(int(planet_seed + 3.69));
	new_type_circl.noise_type = FNL_NOISE_OPENSIMPLEX2;
	new_type_circl.frequency = 0.5;
	new_type_circl.fractal_type = FNL_NOISE_VALUE; //FNL_NOISE_VALUE;
	new_type_circl.lacunarity = 3.f;
	new_type_circl.gain = .3f;
    new_type_circl.octaves = 3;
	
	
    // Setup noise for stripes
    fnl_state stripe_noise_state = fnlCreateState(int(planet_seed));
    stripe_noise_state.noise_type = FNL_NOISE_OPENSIMPLEX2;
    stripe_noise_state.frequency = 0.5;
    stripe_noise_state.fractal_type = FNL_FRACTAL_FBM;
    stripe_noise_state.octaves = 4;
    stripe_noise_state.lacunarity = 2.0;
    stripe_noise_state.gain = 0.5;

    // Setup noise for spherical features
    fnl_state sphere_noise_state = fnlCreateState(int(planet_seed + 1000.0));
    sphere_noise_state.noise_type = FNL_NOISE_CELLULAR;
    sphere_noise_state.cellular_distance_func = FNL_CELLULAR_DISTANCE_EUCLIDEANSQ;
    sphere_noise_state.noise_type = FNL_NOISE_CELLULAR;
    sphere_noise_state.frequency = 1.3;
	sphere_noise_state.cellular_return_type = FNL_CELLULAR_RETURN_TYPE_DISTANCE;
    sphere_noise_state.cellular_jitter_mod = 1.0;
    sphere_noise_state.fractal_type = FNL_FRACTAL_PINGPONG;
    sphere_noise_state.octaves = 5;
    sphere_noise_state.lacunarity = 1.8;
    sphere_noise_state.gain = 0.0;
    sphere_noise_state.weighted_strength = 1.0;
    sphere_noise_state.ping_pong_strength = 3.0;
	
	
	
	vec4 final_color = vec4(0.0, 0.0, 0.0, 0.0);
	
	if (planet_type <= 5) {
	
    // Generate noise for base star appearance
    float n = fnlGetNoise3D(noise_state, p.x * noise_scale, p.y * noise_scale, p.z * noise_scale);
    
	vec4 first_color = get_first_planet_color(planet_type);
	vec4 second_color = get_second_planet_color(planet_type);
	vec4 third_color = get_third_planet_color(planet_type);
	vec4 fourth_color = get_fourth_planet_color(planet_type);
	vec4 fifth_color = get_fifth_planet_color(planet_type);
	vec4 sixth_color = get_sixth_planet_color(planet_type);
	vec4 seventh_color = get_seventh_planet_color(planet_type);
	vec4 base_color = get_surface_color(n, first_color, second_color, third_color, fourth_color, fifth_color, sixth_color, seventh_color);
 
	vec4 atmospheric_color = first_color;
	 // Fully transparent
	vec4 flare_layer = vec4(0.0);
	vec4 blob_layer = vec4(0.0);
	vec4 core_layer = vec4(0.0);
	vec4 atmosphere_layer = vec4(0.0);
	vec4 atmosphere_layer2 = vec4(0.0);

	float cloud_noise = fnlGetNoise3D(blob_noise_state, p.x * noise_scale * 1.5, p.y * noise_scale * 1.5, p.z * noise_scale * 1.5 + (time * 3.1));
	float cloud_detail = fnlGetNoise3D(blob_noise_state, p.x * noise_scale * 1.5, p.y * noise_scale * 1.5, p.z * noise_scale * 1.5 + (time * 3.1));
	//atmosphere_color = first_color
if (d <= 1.0); {
	//atmosphere_effect
    float atmosphere_factor = 1.0 - smoothstep(0.0, atmosphere_falloff, d);
    vec4 atmosphere_effect = atmospheric_color * atmospheric_color * atmosphere_intensity;
	flare_layer = mix(atmospheric_color, atmospheric_color, atmospheric_color * atmosphere_effect.a);
	flare_layer.a = smoothstep(1.0, 0.91, flare_d);
	
}
	// Core layer
	if (core_d <= 1.0) {
		core_layer = mix(final_color, base_color, base_color.a);
	    core_layer.a = smoothstep(1.0, 0.99, core_d);
	}

	// Combine layers
	final_color = mix(final_color, flare_layer , flare_layer.a);
	final_color = mix(final_color, core_layer, core_layer.a);

    // Cloud layer
    if (blob_d <= 1.0) {
		vec3 color_one = seventh_color.rgb;
		vec3 color_two = sixth_color.rgb;
        vec4 cloud_color = get_cloud_color(cloud_noise, cloud_detail, color_one, color_two);

        // Ensure areas outside clouds are fully transparent
        float cloud_opacity = smoothstep(cloud_noise, cloud_noise, -0.2);
        blob_layer = mix(final_color, cloud_color, cloud_noise * cloud_color.a);
        blob_layer.a = smoothstep(1.0, 0.9, blob_d);
    }

	final_color = mix(final_color, blob_layer, blob_layer.a); 

if (flare_d <= 1.0) {
	//atmosphere_effect
    float atmosphere_factor = 1.0 - smoothstep(0.0, atmosphere_falloff, d);
    vec4 atmosphere_effect = atmospheric_color * atmosphere_factor * atmosphere_intensity;
	atmosphere_layer = mix(atmospheric_color, atmospheric_color, atmospheric_color * atmosphere_effect.a);
	atmosphere_layer.a = smoothstep(-1.0, 0.91, flare_d) * 0.369;
	atmosphere_layer2 = mix(final_color, atmosphere_layer, atmosphere_layer.a);
    atmosphere_layer2.a = smoothstep(1.0, 0.9, blob_d);
	
}

	final_color = mix(final_color, atmosphere_layer2, atmosphere_layer2.a);

} 








 // them damn gas giants mary! the ones that were supposed to burn too!
if (planet_type > 5) {
    // Basic structure noise
    float base_noise = fnlGetNoise3D(new_type_circl, 
                                     p.x * sphere_scale, 
                                     p.y * sphere_scale * 0.5, // Slightly squeezed in y to create some banding
                                     p.z * sphere_scale);
    
    // Variation noise
    float variation_noise = fnlGetNoise3D(stripe_noise_state, 
                                          p.x * stripe_scale  , 
                                          p.y * stripe_scale * 19.9 , 
                                          p.z * stripe_scale  + time * 0.1 ); // Add some movement
    
    // Combine noises
    float combined_noise = variation_noise;//base_noise * 0.8 + variation_noise * 0.2;
    
    // Use the existing color gradient system, but with colors suited for gas giants
    vec4 color_1 = get_first_planet_color(6);
    vec4 color_2 = get_second_planet_color(6);
    vec4 color_3 = get_third_planet_color(6);
    vec4 color_4 = get_fourth_planet_color(6);
    
    final_color = get_surface_color(combined_noise, color_1, color_2, color_3, color_4, color_4, color_3, color_2);
    
    // Add atmosphere effect
    float atmosphere_factor = 1.0 - smoothstep(0.0, atmosphere_falloff, d);
    vec4 atmosphere_effect = get_fifth_planet_color(6) * atmosphere_factor * atmosphere_intensity;
    //final_color = mix(final_color, atmosphere_effect, atmosphere_effect.a);
}




	vec2 uv1 = UV * 2.0 - 1.0;
    float d1 = length(uv1);
    vec3 p1 = vec3(uv1, sqrt(max(0.0, 1.0 - d1 * d1)));
    
    // Apply rotation
    p1 = position_matrix * p1;

    // Lighting calculation
    vec3 normal = normalize(cross(dFdx(p1), dFdy(p1)));
    vec3 light_dir = normalize(direction_matrix * vec3(0.0, 0.0, -1.0));
    
    // Ambient
    vec3 ambient = ambient_strength * light_color;
    
    // Diffuse
    float diff = smoothstep(1.0, 1.0, dot(normal, light_dir)); // float diff = smoothstep(-0.3, 0.7, dot(normal, light_dir));
	//float diff = smoothstep(-0.3, 0.7, dot(normal, light_dir));
    vec3 diffuse = diff * diffuse_strength * light_color;
    
    // Specular
    vec3 view_dir = normalize(-p1);
    vec3 reflect_dir = reflect(-light_dir, normal);
    float spec = pow(max(dot(view_dir, reflect_dir), 0.0), shininess);
    vec3 specular = specular_strength * spec * light_color;
    
    // Combine lighting with the final color
    vec3 lighting = ambient + diffuse + specular;
    final_color.rgb *= lighting;
	
	// Apply final mask
	float mask = smoothstep(1.0, 0.99, d);
	ALBEDO = final_color.rgb;
	ALPHA = final_color.a * mask;
}

Orbit scene

#Orbit.gd in Orbit.tscn, #res://Scenes/Orbit.tscn
extends Node3D

var orbit_speed #float = 1.0
var orbit_radius #float = 10.0

func set_orbit_data(speed: float, radius: float):
	#print("speed = ", speed, " radius = ", radius)
	orbit_speed = speed
	orbit_radius = radius

func _process(delta):
	rotate_y(orbit_speed * delta)
	
func Alpha_delta():
	var delta_Alpha = GlobalState.elapsed_time_seconds
	rotate_y(orbit_speed * delta_Alpha)


we also have the shared file between scene, where we just put words in some spaces to use between the spaces



#GlobalSTate.gd a script that is setup in autoload so it is always in background and we can store and save things with help of it and send between scenes some informations
@tool
extends Node

var current_galaxy_data = null
var visible_galaxies = []
var camera_data = null
var current_star_data = null
var return_galaxy_data = null
var visible_stars = []
var galaxy_field_data: Dictionary
var all_star_data = {}
var return_star_coordinates = null

var current_planet_system = []
var current_planet_data = null

var skybox_texture: Texture2D
var skybox_galaxy_texture: Texture2D
var skybox_galaxy_celestialbody_texture: Texture2D

var star_skybox_texture: Texture2D
var star_skybox_celestialbody_texture: Texture2D
var sphere_of_creation_texture: Texture2D

var is_returning_from_galaxy = false
var is_returning_from_star = false
var is_returning_from_celestialbody = false
var is_returning_from_sphere_of_creation = false

var return_camera_data = null
var galaxy_to_star_camera_data = null
var star_to_galaxy_camera_data = null
var star_to_planet_camera_data = null
var celestialbody_to_star_camera_data = null
var sphere_of_creation_return_data = null

var elapsed_time_seconds: float = 0.0
var last_update_time: int = 0

func update_elapsed_time():
	var current_time = Time.get_ticks_msec()
	if last_update_time != 0:
		var delta_time = (current_time - last_update_time) / 1000.0
		elapsed_time_seconds += delta_time
	last_update_time = current_time

func store_galaxy_field(field_data: Dictionary):
	galaxy_field_data = field_data

func get_galaxy_field() -> Dictionary:
	return galaxy_field_data

func store_galaxy_data(galaxy_data: Dictionary):
	current_galaxy_data = {
		"id": galaxy_data.id,
		"seed": galaxy_data.seed,
		"shader_path": galaxy_data.shader_path if "shader_path" in galaxy_data else null,
		"shader_params": galaxy_data.shader_params,
		"texture": galaxy_data.texture if "texture" in galaxy_data else null,
		"scale": galaxy_data.scale if "scale" in galaxy_data else Vector3.ONE,
		"rotation": galaxy_data.rotation if "rotation" in galaxy_data else Vector3.ZERO,
		"rotation_quat": galaxy_data.rotation_quat,
		"galaxy_position": galaxy_data.galaxy_position
	}

func store_visible_galaxies(galaxies):
	visible_galaxies = galaxies
	print("GlobalState: Stored ", visible_galaxies.size(), " visible galaxies")

func store_camera_data(data):
	camera_data = data
	print("Stored camera data: ", camera_data)

func store_visible_stars(stars):
	visible_stars = stars
	print("GlobalState: Stored ", visible_stars.size(), " visible stars")
	
func generate_star_data(star_seed: int) -> Dictionary:
	var star_rng = RandomNumberGenerator.new()
	star_rng.seed = star_seed + 1

	var galaxy_color = current_galaxy_data.shader_params.u_galaxy_color
	
	# Calculate a temperature bias based on the galaxy color
	var temp_bias# = (galaxy_color.r * 15000 + galaxy_color.g * 10000 + galaxy_color.b * 25000) / (galaxy_color.r + galaxy_color.g + galaxy_color.b)
	var galaxy_temp_type = current_galaxy_data.shader_params.u_galaxy_temp
	var galaxy_temperature = current_galaxy_data.shader_params.u_galaxy_temperature
	#print("galaxy temperature = " , galaxy_temperature)
	# Generate star temperature with a bias towards the galaxy color
	var base_temp = galaxy_temperature
	temp_bias = star_rng.randf_range(1000, 20000)
	#print("temp_bias = ", temp_bias, " base_temp = ", base_temp)
	var temperature = (base_temp + temp_bias) / 2
	#print("temperature = ", temperature)
	temperature = clamp(temperature, 1000, 20000)
	
	var star_size = star_rng.randf_range(0.5, 2.0)
	var star_color = temperature_to_color(temperature)

	var star_data = {
		"seed": star_seed,
		"size": star_size,
		"color": star_color,
		"temperature": temperature
	}
	#print("global state star data = ", star_data)
	#print("star_data = ", star_data,  "star_seed = " , star_seed)
	all_star_data[star_seed] = star_data
	current_star_data = star_data

	return star_data

func temperature_to_color(temperature: float) -> Color:
	# This is a simplified version. You can make it more accurate.
	if temperature < 3500:
		return Color(1.0, 0.5, 0.0)  # Red
	elif temperature < 5000:
		return Color(1.0, 0.8, 0.0)  # Orange
	elif temperature < 6000:
		return Color(1.0, 1.0, 1.0)  # White
	elif temperature < 10000:
		return Color(0.8, 0.8, 1.0)  # Light Blue
	else:
		return Color(0.6, 0.6, 1.0)  # Blue

func store_star_data(star_data: Dictionary):
	#print("you are in store star data in global state and here is star_data = ", star_data)
	current_star_data = {
		"seed": star_data.get("seed"),
		"brightness": star_data.get("brightness"), #"brightness": target_star.get_star_brightness()
		"color": star_data.get("color"),
		"temperature": star_data.get("temperature"),
		"position": star_data.get("position"),
		"scale": star_data.get("scale")
	}
	#print("Stored star data: ", current_star_data, "star_data = ", star_data)

func get_visible_galaxies() -> Array:
	return visible_galaxies

func store_planet_data(planet_data: Dictionary):
	print(" ")
	print("Global State planet_data = ", planet_data)
	current_planet_data = {
		"seed": planet_data.seed,
		"type": planet_data.type,
		"radius": planet_data.radius,
		"mass": planet_data.mass,
		"orbit_radius": planet_data.orbit_radius,
		"orbit_speed": planet_data.orbit_speed,
		"moons": planet_data.moons,
		"habitable": planet_data.habitable,
		"water": planet_data.water,
		"basic_resource": planet_data.basic_resources,
		"rare_resources": planet_data.rare_resources,
		"planet_tilt": planet_data.planet_tilt,
		"planet_spin_speed": planet_data.planet_spin_speed
	}
	print(" and we are done here")
func get_current_planet_data() -> Array:
	return current_planet_data

func store_skybox_texture(texture: Texture2D):
	skybox_texture = texture
	#print("Skybox texture stored in GlobalState")
	if skybox_texture:
		print("Texture size: ", skybox_texture.get_size())
	else:
		print("Stored texture is null")

func get_skybox_texture() -> Texture2D:
	if skybox_texture:
		print("Returning skybox texture from GlobalState. Size: ", skybox_texture.get_size())
	else:
		print("No skybox texture found in GlobalState")
	return skybox_texture

func store_offset_skybox_texture(texture: Texture2D):
	skybox_galaxy_texture = texture
	#print("Skybox texture stored in GlobalState")
	if skybox_galaxy_texture:
		print("Texture size: ", skybox_galaxy_texture.get_size())
	else:
		print("Stored texture is null")

func get_offset_skybox_texture() -> Texture2D:
	if skybox_galaxy_texture:
		print("Returning skybox texture from GlobalState. Size: ", skybox_galaxy_texture.get_size())
	else:
		print("No skybox texture found in GlobalState")
	return skybox_galaxy_texture

#skybox_galaxy_celestialbody_texture

func store_celestialbody_skybox_texture(texture: Texture2D):
	skybox_galaxy_celestialbody_texture = texture
	#print("Skybox texture stored in GlobalState")
	if skybox_galaxy_celestialbody_texture:
		print("Texture size: ", skybox_galaxy_celestialbody_texture.get_size())
	else:
		print("Stored texture is null")

func get_celestialbody_skybox_texture() -> Texture2D:
	if skybox_galaxy_celestialbody_texture:
		print("Returning skybox texture from GlobalState. Size: ", skybox_galaxy_celestialbody_texture.get_size())
	else:
		print("No skybox texture found in GlobalState")
	return skybox_galaxy_celestialbody_texture


#store_star_skybox_texture
func store_star_skybox_texture(texture: Texture2D):
	star_skybox_texture = texture

func get_star_skybox_texture() -> Texture2D:
	return star_skybox_texture


func store_star_offest_skybox_texture(texture: Texture2D):
	star_skybox_celestialbody_texture = texture

func get_star_offest_skybox_texture() -> Texture2D:
	return star_skybox_celestialbody_texture


func store_return_data(camera_data: Dictionary, galaxy_data: Dictionary):
	is_returning_from_galaxy = true
	return_camera_data = camera_data
	return_galaxy_data = galaxy_data

func clear_return_data():
	is_returning_from_galaxy = false
	return_camera_data = null

func get_star_data() -> Dictionary:
	return current_star_data

func clear_star_data():
	current_star_data = null

func store_galaxy_to_star_camera_data(data):
	galaxy_to_star_camera_data = data
	#print("Stored galaxy to star camera data: ", galaxy_to_star_camera_data)

func get_galaxy_to_star_camera_data():
	return galaxy_to_star_camera_data

func store_star_to_galaxy_camera_data(data):
	star_to_galaxy_camera_data = data
	#print("Stored star to galaxy camera data: ", star_to_galaxy_camera_data)

func get_star_to_galaxy_camera_data():
	return star_to_galaxy_camera_data

func store_return_from_star_data(camera_data: Dictionary):
	is_returning_from_star = true
	star_to_galaxy_camera_data = camera_data
	#print("global state camera_data = ", camera_data)
	#print("global state star_to_galaxy_camera_data.position = ", star_to_galaxy_camera_data.position)
	#print("global state camera data ,previous_star_coordinates", camera_data.previous_star_coordinates)
	return_star_coordinates = camera_data.previous_star_coordinates
	var someting_test = camera_data.previous_star_coordinates + star_to_galaxy_camera_data.position
	star_to_galaxy_camera_data.position = someting_test
	#print("so maybe what we need? someting_test = ", someting_test)
	#print("star_to_galaxy_camera_data.position = ", star_to_galaxy_camera_data.position)
	#print("Stored return from star data")

func get_return_from_star_data():
	return star_to_galaxy_camera_data


func store_star_to_planet_camera_data(data):
	star_to_planet_camera_data = data
	#star_to_planet_camera_data
	
func get_star_to_planet_camera_data():
	return star_to_planet_camera_data

func clear_return_from_star_data():
	is_returning_from_star = false
	star_to_galaxy_camera_data = null

func starting_zone():
	var helping_hand
	#print("global_state thingy maybe?")
	return is_returning_from_galaxy


# storing planets
func store_planet_system(planet_data):
	print("store_planet_system in Global state = ", planet_data)
	print("thats done")
	print(" ")
	current_planet_system = planet_data
	
func get_planet_system():
	return current_planet_system





