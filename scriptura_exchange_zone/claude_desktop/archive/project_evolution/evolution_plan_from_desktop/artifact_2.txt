#!/bin/bash
# Game Evolution System Setup
# Creates multi-language, multi-engine game development environment

echo "ðŸŽ® Game Evolution System Setup"
echo "=============================="

# Create the game evolution workspace
GAME_ROOT="/mnt/c/Users/Percision 15/claude_evolution/game_evolution"
mkdir -p "$GAME_ROOT"/{games,templates,shared_assets,docs}

cd "$GAME_ROOT"

# Copy the evolution system
cat > game_evolution_system.py << 'EOF'
# The Python system code goes here - truncated for brevity
# (Include the full GameEvolutionSystem class from the artifact above)
EOF

# Create quick command scripts
cat > create_game.sh << 'EOF'
#!/bin/bash
# Quick game creation script

if [ $# -lt 5 ]; then
    echo "Usage: $0 <id> <n> <engine> <language> <complexity> [features...]"
    echo ""
    echo "Engines: godot, unity, pygame, javascript, custom"
    echo "Languages: python, csharp, cpp, rust, javascript, gdscript"
    echo "Complexity: simple, intermediate, advanced, expert"
    echo ""
    echo "Example: $0 my_3d_world \"3D World Explorer\" pygame python simple 3d_world procedural_generation"
    exit 1
fi

python3 game_evolution_system.py create "$@"
EOF

cat > evolve_game.sh << 'EOF'
#!/bin/bash
# Game evolution script

if [ $# -lt 4 ]; then
    echo "Usage: $0 <source_game_id> <new_engine> <new_language> <new_complexity>"
    echo ""
    echo "Example: $0 my_3d_world godot gdscript intermediate"
    exit 1
fi

python3 game_evolution_system.py evolve "$@"
EOF

cat > game_status.sh << 'EOF'
#!/bin/bash
# Show game evolution system status

python3 game_evolution_system.py status
echo ""
echo "ðŸš€ Quick Commands:"
echo "  ./create_game.sh <id> <n> <engine> <lang> <complexity> [features]"
echo "  ./evolve_game.sh <source> <engine> <lang> <complexity>"
echo "  ./nav_game.sh <game_id>  # Navigate to game project"
echo ""
echo "ðŸ’¡ Available engines: godot, unity, pygame, javascript"
echo "ðŸ’¡ Available languages: python, csharp, rust, javascript, gdscript"
echo "ðŸ’¡ Complexity levels: simple â†’ intermediate â†’ advanced â†’ expert"
EOF

cat > nav_game.sh << 'EOF'
#!/bin/bash
# Navigate to game project

if [ $# -lt 1 ]; then
    echo "Usage: $0 <game_id>"
    echo ""
    echo "Available games:"
    python3 game_evolution_system.py list
    exit 1
fi

GAME_ID=$1
GAME_DIR="games/$GAME_ID"

if [ ! -d "$GAME_DIR" ]; then
    echo "âŒ Game '$GAME_ID' not found"
    echo "Available games:"
    python3 game_evolution_system.py list
    exit 1
fi

echo "ðŸ“ Navigating to game: $GAME_ID"
cd "$GAME_DIR"

# Show game context
if [ -f "GAME_EVOLUTION.md" ]; then
    echo "ðŸ“– Game Evolution Context:"
    head -20 GAME_EVOLUTION.md
    echo ""
fi

echo "ðŸŽ® Game Development Environment Ready!"
echo "ðŸ“ Current directory: $(pwd)"
echo ""
echo "ðŸ§  Claude AI commands for game development:"
echo "  ultrathink 'game architecture for complex 3D world'"
echo "  think harder 'procedural generation algorithm'"
echo "  think hard 'performance optimization strategies'"
echo ""

# Start a new shell in the game directory
exec bash
EOF

# Make scripts executable
chmod +x *.sh

# Create example templates
mkdir -p templates/features

cat > templates/features/procedural_generation.md << 'EOF'
# Procedural Generation Feature Template

## Core Concept
Generate content algorithmically using noise functions and mathematical patterns.

## Implementation Approaches

### Simple Level
- Basic random number generation
- Simple tile/grid based generation
- 2D height maps

### Intermediate Level  
- Perlin/Simplex noise
- Layered generation (terrain + features)
- Basic biome systems

### Advanced Level
- Multiple octave noise
- Complex terrain generation
- Dynamic loading/streaming
- Procedural textures

### Expert Level
- Custom noise algorithms
- Real-time generation
- GPU-accelerated generation
- Complex ecosystem simulation

## Visualization Focus
- Real-time noise preview
- Interactive parameter adjustment
- 3D terrain visualization
- Texture generation preview

## Code Examples by Engine/Language
[Specific examples would be generated based on chosen engine]
EOF

cat > templates/features/3d_visualization.md << 'EOF'
# 3D Visualization Feature Template

## Core Concept
Create immersive 3D environments with proper lighting, texturing, and camera systems.

## Implementation Approaches

### Simple Level
- Basic 3D shapes
- Orthographic projection
- Fixed camera
- Flat shading

### Intermediate Level
- Perspective projection
- Free camera movement
- Basic lighting (directional)
- Texture mapping

### Advanced Level
- Multiple light types
- Shadow mapping
- Normal mapping
- Post-processing effects

### Expert Level
- PBR (Physically Based Rendering)
- Global illumination
- Advanced shaders
- Ray tracing/path tracing

## Visualization Techniques
- Wireframe mode toggle
- Real-time lighting adjustment
- Material property editors
- Performance visualization

## Engine-Specific Implementation
[Generated based on chosen engine - Godot, Unity, etc.]
EOF

# Create shared assets structure
mkdir -p shared_assets/{textures,models,audio,scripts}
mkdir -p shared_assets/textures/{terrain,characters,ui,particles}
mkdir -p shared_assets/models/{low_poly,high_poly,characters,environments}
mkdir -p shared_assets/audio/{music,sfx,ambient}
mkdir -p shared_assets/scripts/{noise,lighting,camera,utils}

# Create example noise generation script
cat > shared_assets/scripts/noise/perlin_3d.py << 'EOF'
"""
3D Perlin Noise Generator
Suitable for terrain, clouds, textures
"""

import numpy as np
from noise import pnoise3
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

class Perlin3D:
    def __init__(self, width=64, height=64, depth=64):
        self.width = width
        self.height = height  
        self.depth = depth
        
    def generate(self, scale=0.1, octaves=6, persistence=0.5, lacunarity=2.0, seed=0):
        """Generate 3D Perlin noise array"""
        noise_array = np.zeros((self.depth, self.height, self.width))
        
        for z in range(self.depth):
            for y in range(self.height):
                for x in range(self.width):
                    noise_value = pnoise3(
                        x * scale,
                        y * scale, 
                        z * scale,
                        octaves=octaves,
                        persistence=persistence,
                        lacunarity=lacunarity,
                        base=seed
                    )
                    noise_array[z, y, x] = noise_value
                    
        return noise_array
    
    def visualize_slice(self, noise_array, z_slice=None):
        """Visualize a 2D slice of the 3D noise"""
        if z_slice is None:
            z_slice = self.depth // 2
            
        plt.figure(figsize=(10, 8))
        plt.imshow(noise_array[z_slice], cmap='terrain', origin='lower')
        plt.colorbar(label='Noise Value')
        plt.title(f'3D Perlin Noise - Z Slice {z_slice}')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.show()
    
    def export_for_engine(self, noise_array, format='numpy'):
        """Export noise data for game engines"""
        if format == 'numpy':
            np.save('terrain_noise.npy', noise_array)
        elif format == 'raw':
            # Convert to 0-255 range for raw export
            normalized = ((noise_array + 1) * 127.5).astype(np.uint8)
            normalized.tofile('terrain_noise.raw')
        
        print(f"Exported noise data in {format} format")

if __name__ == "__main__":
    # Example usage
    generator = Perlin3D(128, 128, 64)
    noise = generator.generate(scale=0.05, octaves=4)
    generator.visualize_slice(noise)
    generator.export_for_engine(noise)
EOF

# Create quick access symlinks
cd "/mnt/c/Users/Percision 15"
ln -sf "claude_evolution/game_evolution/create_game.sh" ./create_game
ln -sf "claude_evolution/game_evolution/evolve_game.sh" ./evolve_game
ln -sf "claude_evolution/game_evolution/game_status.sh" ./game_status
ln -sf "claude_evolution/game_evolution/nav_game.sh" ./nav_game

# Make everything executable
chmod +x ./create_game ./evolve_game ./game_status ./nav_game

echo ""
echo "ðŸŽ‰ GAME EVOLUTION SYSTEM READY!"
echo "==============================="
echo ""
echo "ðŸŽ® Your Multi-Language Game Evolution Environment:"
echo ""
echo "ðŸš€ Quick Commands:"
echo "  ./create_game <id> <n> <engine> <language> <complexity> [features]"
echo "  ./evolve_game <source> <new_engine> <new_language> <new_complexity>"
echo "  ./game_status                    # View all games"
echo "  ./nav_game <game_id>            # Enter game project"
echo ""
echo "ðŸ’¡ Example Workflow:"
echo "  # Create simple Python/Pygame game"
echo "  ./create_game world_01 'Simple World' pygame python simple 3d_world"
echo ""  
echo "  # Evolve it to Godot when ready"
echo "  ./evolve_game world_01 godot gdscript intermediate"
echo ""
echo "  # Then to Unity for advanced features"  
echo "  ./evolve_game world_01_godot_intermediate unity csharp advanced"
echo ""
echo "ðŸŒŸ Special Features:"
echo "â€¢ Cross-engine evolution (Pygame â†’ Godot â†’ Unity)"
echo "â€¢ Language translation (Python â†’ GDScript â†’ C#)"
echo "â€¢ Complexity progression (Simple â†’ Expert)"
echo "â€¢ Shared asset library"
echo "â€¢ Procedural generation focus"
echo "â€¢ 3D visualization emphasis"
echo "â€¢ Claude AI integration for complex problems"
echo ""
echo "ðŸŽ¯ Perfect for:"
echo "â€¢ Learning different game engines"
echo "â€¢ Prototyping in simple engines, finishing in complex ones"
echo "â€¢ Language learning through game development"
echo "â€¢ Procedural generation experimentation"
echo "â€¢ 3D visualization projects"
echo ""
echo "Start with: ./create_game my_world 'My First Evolution' pygame python simple procedural_generation 3d_world"