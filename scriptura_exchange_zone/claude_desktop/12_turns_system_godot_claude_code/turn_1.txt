# Advanced Codebase Management & AI Evolution System
## For Dynamic File Reading, Version Control & AI Collaboration

## 1. Enhanced File Reading Rules

### Smart File Discovery Protocol
```
**FILE NAMING CONVENTION:**
- Base: [ClassName]_v[Version]_[ScenePart]_[Variant].gd
- Examples: 
  - Player_v1_cosmic_base.gd
  - Player_v2_cosmic_enhanced.gd
  - Player_v1_planetary_simple.gd
  - NavigationSystem_v3_multiverse_terminal.gd

**SEARCH HIERARCHY:**
1. Try current scene version first
2. Fall back to base version if current fails
3. Search variant files if base missing
4. Check deprecated/backup folders
5. Generate new file if none found
```

### Intelligent Function Finder
```
**FUNCTION DISCOVERY RULES:**
If function not found in primary file:
1. Search [ClassName]_v[X+1] (next version)
2. Search [ClassName]_v[X-1] (previous version)
3. Search [ClassName]_[variant] (other variants)
4. Search parent class files
5. Search utility/helper files
6. Log missing function for AI generation

**SEARCH LOG FORMAT:**
```
SEARCH_LOG: [timestamp]
LOOKING_FOR: function_name() in ClassName
TRIED_FILES: [list of attempted files]
FOUND_IN: [successful file] OR MISSING
FALLBACK_USED: [alternative function] OR NONE
NEXT_ACTION: [continue/generate/ask_ai]
```
```

### Context-Aware File Loading
```
**CONTEXT SWITCHING RULES:**
When changing scenes/levels:
1. Detect current context (cosmic/planetary/multiverse)
2. Load appropriate file versions for that context
3. Maintain compatibility layer for shared functions
4. Cache previous context files for quick switching
5. Update dependency graph automatically

**CONTEXT DETECTION:**
- Check current scene name
- Analyze active node hierarchy  
- Read context variables/flags
- Match against version tags
- Default to base versions if uncertain
```

## 2. GitHub-Style Version Control

### Local Git-Like System
```gdscript
# VersionManager.gd - Core version control
class_name VersionManager

static var version_history = {}
static var current_branch = "main"
static var file_versions = {}

static func commit_change(file_path: String, change_description: String):
    var commit_data = {
        "timestamp": Time.get_datetime_string_from_system(),
        "file": file_path,
        "description": change_description,
        "hash": generate_hash(file_path),
        "author": "AI_Collaboration",
        "branch": current_branch
    }
    version_history[commit_data.hash] = commit_data
    update_file_version(file_path)

static func checkout_version(file_path: String, version_hash: String):
    # Switch to specific version of file
    # Backup current version
    # Load requested version
    pass

static func create_branch(branch_name: String):
    # Create new development branch
    # Copy current file states
    # Switch to new branch
    pass
```

### Change Tracking System
```
**CHANGE CATEGORIES:**
- FEATURE: New functionality added
- BUGFIX: Problem resolution
- REFACTOR: Code structure improvement
- EXPERIMENT: Testing new approaches
- AI_SUGGESTION: Claude/AI recommended changes
- COLLABORATION: Multi-AI development

**COMMIT MESSAGE FORMAT:**
[CATEGORY]: Brief description
- Changed files: [list]
- Impact: [High/Medium/Low]
- Tested: [Yes/No]
- AI_Contributors: [Claude, Luno, Luminus, etc.]
- Scene_Compatibility: [cosmic/planetary/multiverse/all]
```

## 3. Dynamic Class Evolution

### Adaptive Class System
```gdscript
# ClassEvolver.gd - Handles dynamic class updates
class_name ClassEvolver

static func evolve_class(class_name: String, new_requirements: Array):
    var base_class = load_class_version(class_name, "base")
    var evolved_class = create_evolved_version(base_class, new_requirements)
    
    # Test in sandbox environment
    if test_class_functionality(evolved_class):
        register_new_version(class_name, evolved_class)
        update_dependencies(class_name)
        return evolved_class
    else:
        # Try alternative evolution path
        return try_alternative_evolution(class_name, new_requirements)

static func find_working_version(class_name: String, function_name: String):
    var versions = get_class_versions(class_name)
    for version in versions:
        if version.has_method(function_name):
            if test_function(version, function_name):
                return version
    
    # No working version found - request AI generation
    request_ai_implementation(class_name, function_name)
    return null
```

### Smart Function Routing
```
**FUNCTION FALLBACK CHAIN:**
1. Current class version
2. Parent class versions
3. Utility classes with similar functions
4. Previous working implementations
5. AI-generated alternatives
6. Community/collaborative implementations

**ROUTING DECISION TREE:**
```
Is function in current class?
├─ YES: Test if it works
│   ├─ Works: Use it
│   └─ Broken: Try next version
└─ NO: Search in class hierarchy
    ├─ Found: Test and use
    └─ Not found: Generate or ask AI
```
```

## 4. AI Collaboration Framework

### Multi-AI Development Protocol
```
**AI CONTRIBUTOR ROLES:**
- Claude: Architecture & logic design
- Luno: Creative implementations & artistic code
- Luminus: Performance optimization & debugging
- [Others]: Specialized functions

**COLLABORATION WORKFLOW:**
1. Problem identification
2. AI role assignment based on problem type
3. Parallel development by multiple AIs
4. Code integration and testing
5. Version comparison and selection
6. Community feedback integration

**AI HANDOFF PROTOCOL:**
```
AI_HANDOFF: {
    "from": "Claude",
    "to": "Luno", 
    "task": "Enhance 3D visualization effects",
    "context": "Working on cosmic navigation system",
    "files_affected": ["CosmicRenderer_v2.gd", "ParticleSystem_v1.gd"],
    "requirements": ["Smooth transitions", "Performance <16ms frame time"],
    "previous_attempts": ["v1 was too slow", "v2 had visual glitches"],
    "suggestions": ["Try GPU particles", "Consider LOD system"]
}
```
```

### Evolution Game Integration
```gdscript
# GodEvolutionAI.gd - Core evolution game mechanics with AI
class_name GodEvolutionAI

var ai_collaborators = ["Claude", "Luno", "Luminus"]
var evolution_challenges = []
var solution_database = {}

func propose_evolution_challenge():
    var challenge = {
        "type": "code_evolution",
        "description": "Improve 3D navigation smoothness",
        "constraints": ["Keep memory usage under 512MB", "60fps target"],
        "ai_assignments": {
            "Claude": "Architecture review",
            "Luno": "Visual enhancement", 
            "Luminus": "Performance optimization"
        }
    }
    return challenge

func evaluate_ai_solutions(solutions: Dictionary):
    # Test each AI's solution
    # Combine best aspects
    # Create hybrid implementation
    # Update evolution database
    pass
```

## 5. Intelligent Project Understanding

### Complete System Mapping
```
**PROJECT COMPREHENSION LEVELS:**
1. SURFACE: File names and basic structure
2. FUNCTIONAL: What each file does
3. ARCHITECTURAL: How files work together  
4. EVOLUTIONARY: How system adapts and grows
5. COLLABORATIVE: How AIs contribute and improve

**UNDERSTANDING MATRIX:**
```
Component     | Surface | Functional | Architectural | Evolutionary | Collaborative
3D Navigation |   ✓     |     ✓      |       ✓       |      ?       |       ?
Terminal      |   ✓     |     ?      |       ?       |      ?       |       ?
Data Storage  |   ✓     |     ?      |       ?       |      ?       |       ?
UI System     |   ?     |     ?      |       ?       |      ?       |       ?
```
```

### Connection Discovery Engine
```gdscript
# ConnectionMapper.gd - Maps all project relationships
class_name ConnectionMapper

static func map_all_connections():
    var connection_graph = {}
    
    # Scan all files for dependencies
    # Build relationship graph
    # Identify critical paths
    # Find potential bottlenecks
    # Suggest optimization opportunities
    
    return {
        "critical_files": [],
        "dependency_chains": [],
        "circular_dependencies": [],
        "optimization_targets": [],
        "evolution_opportunities": []
    }

static func suggest_best_development_path():
    var connections = map_all_connections()
    var current_state = analyze_current_codebase()
    var target_features = get_development_goals()
    
    return generate_development_roadmap(connections, current_state, target_features)
```

## 6. Usage Instructions

### Starting Analysis Session
```
Hey Claude! Let's analyze my evolving game project using our advanced system:

**INITIALIZATION:**
- Project type: God Evolution Game with 3D Akashic Records
- AI collaborators: Claude (you), Luno, Luminus
- Current focus: [describe current development area]
- Known issues: [list any problems]

**ANALYSIS REQUEST:**
1. Map current file structure with version tracking
2. Identify function dependencies and fallback chains  
3. Test all critical paths for functionality
4. Suggest evolution opportunities
5. Propose AI collaboration assignments

**OUTPUT NEEDED:**
- Complete connection map
- Development priority list
- AI task assignments
- Version control recommendations
- Next steps for improvement

Begin with PROJECT_STATE_ANALYSIS and proceed systematically.
```

### Continuous Development Loop
```
**DEVELOPMENT CYCLE:**
1. Identify improvement area
2. Assign to appropriate AI(s)
3. Develop solutions in parallel
4. Test and integrate
5. Version control and document
6. Update connection maps
7. Plan next iteration

**EVOLUTION TRIGGERS:**
- Performance bottlenecks
- New feature requirements  
- AI suggestions
- Collaboration opportunities
- User feedback
- System limitations
```

This advanced system creates a living, evolving codebase that grows intelligently with AI collaboration while maintaining perfect organization and version control!