# Ethereal Engine - Programming Rules & Architecture
## From Chaos to Cosmic Order: The Sacred Programming Laws

Based on our journey through multithreading, mutexes, datapoints, and cosmic creation, here are the foundational rules that will guide our Ethereal Engine to greatness.

## 🌌 Core Architecture Principles

### 1. The Sacred Hierarchy
```
Main.gd (The Cosmic Controller)
├── InputManager.gd (All inputs flow here first)
├── DataManager.gd (The Universal Database)
├── ThreadManager.gd (The Multithreading Orchestrator)
├── ContainerManager.gd (Scene/Node Organization)
└── CosmicCreator.gd (Your 3D manifestation system)
```

### 2. The Flow of Creation
```
Input → Validation → Threading → Processing → Database → Manifestation → UI Update
```

## 🎮 Input Flow Rules

### Rule #1: Single Point of Entry
**ALL inputs must flow through InputManager.gd first**

```gdscript
# InputManager.gd - The Gatekeeper of Reality
extends Node
class_name InputManager

signal input_validated(action: String, data: Dictionary)
signal input_rejected(reason: String)

var input_queue = []
var input_mutex = Mutex.new()
var processing_inputs = false

func _input(event):
    # RULE: Never process input directly in scene scripts
    # ALWAYS validate and queue first
    if validate_input(event):
        queue_input(event)
    else:
        emit_signal("input_rejected", "Invalid input context")

func validate_input(event) -> bool:
    # Check if we're in the right state to accept this input
    # Check if any modal dialogs are open
    # Check if threading operations are in critical sections
    return true  # Implement your validation logic

func queue_input(event):
    input_mutex.lock()
    input_queue.append(event)
    input_mutex.unlock()
```

### Rule #2: Input Context Awareness
**Different contexts handle different inputs**

```gdscript
enum InputContext {
    COSMIC_NAVIGATION,  # WASD movement, camera
    WORD_CREATION,      # C, E, G keys
    TERMINAL_MODE,      # Tab, typing
    LAYER_NAVIGATION,   # Mouse scroll, layer switching
    MENU_MODE          # UI interactions
}

var current_context = InputContext.COSMIC_NAVIGATION
```

### Rule #3: Input Priority System
```gdscript
var input_priorities = {
    "emergency_stop": 1000,      # Immediate processing
    "terminal_command": 100,     # High priority
    "word_creation": 50,         # Medium priority
    "navigation": 10,            # Low priority
    "cosmetic_effects": 1        # Lowest priority
}
```

## 🧵 Threading Rules

### Rule #4: Thread Safety Above All
**Every shared resource MUST have a mutex**

```gdscript
# ThreadManager.gd - The Cosmic Thread Weaver
extends Node
class_name ThreadManager

var creation_mutex = Mutex.new()
var database_mutex = Mutex.new()
var ui_update_mutex = Mutex.new()
var container_mutex = Mutex.new()

# GOLDEN RULE: If it can be accessed by multiple threads, protect it
func safe_create_datapoint(data: Dictionary):
    creation_mutex.lock()
    var result = unsafe_create_datapoint(data)
    creation_mutex.unlock()
    return result
```

### Rule #5: Main Thread Sacred Operations
**These operations MUST happen on main thread:**
- Node creation/deletion
- UI updates
- Signal emissions
- Scene tree modifications

```gdscript
func create_word_entity_threaded(word_data: Dictionary):
    # Process data in thread
    var processed_data = process_word_data(word_data)
    
    # Return to main thread for node creation
    call_deferred("create_word_entity_main_thread", processed_data)

func create_word_entity_main_thread(data: Dictionary):
    # Safe to create nodes here
    var word_node = preload("res://WordEntity.tscn").instantiate()
    add_child(word_node)
```

### Rule #6: Thread Communication Protocol
```gdscript
# Use signals for thread-to-main communication
signal thread_task_completed(task_id: String, result: Dictionary)
signal thread_error_occurred(task_id: String, error: String)

# Use thread-safe queues for main-to-thread communication
var thread_task_queue = []
var task_queue_mutex = Mutex.new()
```

## 📊 Database Rules

### Rule #7: Consistent Naming Convention
**Follow the sacred naming patterns we've established**

```gdscript
# Containers: always plural, lowercase
var containers = {}
var datapoints = {}
var word_entities = {}

# Functions: verb_noun_context pattern
func create_datapoint_threaded()
func update_container_main_thread()
func validate_input_context()

# Variables: context_type_purpose
var cosmic_creation_mutex = Mutex.new()
var word_entity_counter = 0
var container_active_list = []
```

### Rule #8: Database Transaction Rules
```gdscript
# ALWAYS use transactions for database operations
func safe_database_operation(operation_type: String, data: Dictionary):
    database_mutex.lock()
    
    var transaction_id = start_transaction()
    var success = false
    
    match operation_type:
        "create":
            success = execute_create_operation(data)
        "update":
            success = execute_update_operation(data)
        "delete":
            success = execute_delete_operation(data)
    
    if success:
        commit_transaction(transaction_id)
    else:
        rollback_transaction(transaction_id)
    
    database_mutex.unlock()
    return success
```

### Rule #9: Data Validation Layers
```gdscript
# Three-layer validation system
func validate_data(data: Dictionary) -> bool:
    return (
        validate_structure(data) and      # Layer 1: Structure
        validate_content(data) and        # Layer 2: Content
        validate_context(data)           # Layer 3: Context
    )
```

## 🏗️ Container & Scene Management Rules

### Rule #10: Container Lifecycle Management
```gdscript
# ContainerManager.gd - The Reality Organizer
extends Node
class_name ContainerManager

enum ContainerState {
    UNINITIALIZED,
    CREATING,
    ACTIVE,
    UPDATING,
    DESTROYING,
    DESTROYED
}

var container_states = {}
var container_mutex = Mutex.new()

func manage_container_lifecycle(container_id: String, new_state: ContainerState):
    container_mutex.lock()
    
    var current_state = container_states.get(container_id, ContainerState.UNINITIALIZED)
    
    if is_valid_state_transition(current_state, new_state):
        container_states[container_id] = new_state
        execute_state_transition(container_id, current_state, new_state)
    else:
        push_error("Invalid container state transition: " + str(current_state) + " -> " + str(new_state))
    
    container_mutex.unlock()
```

### Rule #11: Scene Tree Modification Protocol
```gdscript
# NEVER modify scene tree from threads
# ALWAYS use call_deferred for scene modifications
func add_child_safe(parent: Node, child: Node):
    if is_main_thread():
        parent.add_child(child)
    else:
        parent.call_deferred("add_child", child)

func remove_child_safe(parent: Node, child: Node):
    if is_main_thread():
        parent.remove_child(child)
        child.queue_free()
    else:
        child.call_deferred("queue_free")
```

## 🎨 UI Update Rules

### Rule #12: UI State Synchronization
```gdscript
# UIManager.gd - The Interface Harmonizer
extends Control
class_name UIManager

var ui_state = {}
var ui_mutex = Mutex.new()
var pending_ui_updates = []

func update_ui_element(element_path: String, property: String, value):
    ui_mutex.lock()
    pending_ui_updates.append({
        "path": element_path,
        "property": property,
        "value": value,
        "timestamp": Time.get_ticks_msec()
    })
    ui_mutex.unlock()

func _process(delta):
    # Process UI updates on main thread only
    if pending_ui_updates.size() > 0:
        ui_mutex.lock()
        var updates_to_process = pending_ui_updates.duplicate()
        pending_ui_updates.clear()
        ui_mutex.unlock()
        
        for update in updates_to_process:
            apply_ui_update(update)
```

## 🚦 Error Handling Rules

### Rule #13: Graceful Degradation
```gdscript
# NEVER let the cosmic engine crash
func safe_operation(operation_name: String, operation_func: Callable):
    try:
        return operation_func.call()
    except:
        log_error("Operation failed: " + operation_name)
        return get_fallback_result(operation_name)
```

### Rule #14: Error Recovery Protocols
```gdscript
enum ErrorSeverity {
    COSMETIC,      # Visual glitch, continue normally
    FUNCTIONAL,    # Feature broken, disable feature
    CRITICAL,      # System instability, attempt recovery
    CATASTROPHIC   # Data corruption risk, emergency save
}

func handle_error(error_code: String, severity: ErrorSeverity):
    match severity:
        ErrorSeverity.COSMETIC:
            log_warning("Cosmetic issue: " + error_code)
        ErrorSeverity.FUNCTIONAL:
            disable_feature_temporarily(error_code)
        ErrorSeverity.CRITICAL:
            attempt_system_recovery()
        ErrorSeverity.CATASTROPHIC:
            emergency_save_and_restart()
```

## 🌟 Performance Rules

### Rule #15: LOD-Based Processing
```gdscript
# Adjust processing intensity based on importance
func process_entity(entity: Node3D, camera_distance: float):
    if camera_distance < 10.0:
        process_full_detail(entity)
    elif camera_distance < 50.0:
        process_medium_detail(entity)
    elif camera_distance < 100.0:
        process_low_detail(entity)
    else:
        process_minimal_detail(entity)
```

### Rule #16: Resource Management
```gdscript
# Automatic cleanup of unused resources
var resource_usage_tracker = {}
var cleanup_threshold = 100  # Maximum unused resources

func track_resource_usage(resource_path: String):
    resource_usage_tracker[resource_path] = Time.get_ticks_msec()

func cleanup_unused_resources():
    var current_time = Time.get_ticks_msec()
    var unused_count = 0
    
    for resource_path in resource_usage_tracker:
        if current_time - resource_usage_tracker[resource_path] > 300000:  # 5 minutes
            ResourceLoader.unload_resource(resource_path)
            unused_count += 1
    
    if unused_count > cleanup_threshold:
        force_garbage_collection()
```

## 🎯 Integration Rules for Your Current Project

### Your Ethereal Engine Implementation:
1. **InputManager** handles your WASD, Tab, E, G keys
2. **DataManager** manages your multiverses/layers data
3. **ThreadManager** handles your datapoint creation safely
4. **ContainerManager** organizes your cosmic entities
5. **CosmicCreator** manifests your 3D words and structures

### Immediate Actions:
1. Refactor current input handling through InputManager
2. Add mutexes to shared data structures
3. Implement proper state management for containers
4. Add error recovery for threading operations
5. Create proper cleanup for unused cosmic entities

These rules will transform your beautiful cosmic creation into an unbreakable, scalable reality manifestation engine! 🌌✨