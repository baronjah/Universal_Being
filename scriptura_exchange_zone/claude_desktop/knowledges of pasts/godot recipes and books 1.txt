https://kidscancode.org/godot_recipes/4.x/


On this site you’ll find a gentle introduction to the Godot game engine, as well as a wide variety of gamedev tips and techniques. Feel free to browse the categories in the sidebar and see what catches your interest.

If you’re new to Godot, start here: What is Godot?.

How to use this site
Beginners
If you’re new to game development, start with the “Godot 101: Basics” section. There you’ll find an introduction to the Godot application, and a step-by-step guide to creating your first project. There is a lot of material to absorb here. Don’t feel discouraged if you feel you don’t get it at first. Repetition is the key to learning complex topics; the more you work with Godot’s features, the more familiar and easy they will start to feel.

 Info
It’s assumed that you have at least some general programming experience. If you’re completely new to programming, click here for tips on how to get started.

Experienced Developers
If you’re an experienced developer and/or you’re familiar with other modern game engine(s), feel free to explore the menu on the left. You’ll find a number of useful guides and tutorials to show you how to do things the “Godot Way”. Code samples and example projects are available for all articles.




Your introduction to the Godot game engine. If you’ve never used a game engine before, or if you’re just new to Godot, this is the place to start.

In this section:
Getting Started
Introduction to GDScript
Intro to 3D
See also:
Game Tutorials/Your First 2D Game


Have you downloaded Godot yet? You can get it here:

https://godotengine.org

 Updating to Godot 4.0
We’re working on a new version of Godot 101 for Godot 4.0. In the meantime, we recommend new learners stick with Godot 3.x, which has a lot more resources and learning materials available.

In this section:
What is Godot?
The Godot Editor: Finding your way around
Nodes: Godot's building blocks



Game Engines
Game development is complex and involves a wide variety of knowledge and skills. In order to build a modern game, you need a lot of underlying technology before you can make the actual game itself. Imagine if you had to build your own computer and write your own operating system before you could even start programming. Game development would be a lot like that if you truly had to start from scratch and build everything you needed.

In addition, there are a number of common needs every game has. For example, no matter what your game is, it’s going to need to draw things on the screen. If the code to do that has already been written, it makes more sense to reuse it that to create it all over again for every game. This is where game engines come in.

A game engine is a collection of tools and technologies designed to assist in developing games. This allows you to focus more on building your game, and less on reinventing the wheel. Here are some of the features a good game engine will provide:

Rendering (2D/3D)
“Rendering” is the process of displaying your game on the player’s screen. A good rendering pipeline needs to work with modern GPU features, high resolution displays, and effects like lighting and perspective, while maintaining a high frame rate.

Physics
Building an accurate and usable physics engine is an enormous task. Most games require some sort of collision detection and response, and many need simulated physics (ie. friction, inertia, etc.), but few developers want to take on the task of writing one.

Platform Support
In today’s market, you want to be able to release your game on multiple platforms, such as mobile, web, PC, and/or console. A game engine lets you build your game once and export it to one or more platforms.

Development Environment
All of these tools are brought together in a single application, combining everything into one environment so you don’t have to learn a new workflow for every new project.

There are dozens of popular game engines to choose from today, such as Unity, Unreal, and GameMaker Studio, to name a few. It is important to remember that the majority of popular engines are commercial products. They may or may not be free to download, but the will require some kind of licensing or royalty agreement if you plan to release your game (and especially if your game makes money). You need to carefully read and understand what you’re agreeing to and what you are and are not allowed to do with the engine.

Why use Godot?
altClick here to download Godot

In contrast to the above, Godot is completely free and open source, released under the very permissive MIT license. This means there are no fees, hidden costs, or royalties you need to pay. This is in addition to being a fully featured modern game engine.

As a developer, the benefits are great. Because it’s unencumbered by commercial licensing, you have complete control over exactly how and where your game is distributed. In addition, Godot’s open source nature also means there is a much greater level of transparency than you’ll find with commercial engines. For example, if you find a particular feature doesn’t quite meet your needs, you’re free to modify the engine itself - no permission required.



Project Manager
The Project Manager is the first thing you’ll see when opening Godot.

alt
In this window you can see a list of your Godot projects. You can choose an existing project and click “Run” to play the game or click “Edit” to work on it in the Godot editor. Since you probably don’t have any projects yet, let’s start by clicking the “New Project” button.

alt
Here you can give the project a name and create a folder to store it in.

 Note
Every Godot project is contained in its own folder. This has many benefits, including making it easy to move, share, and backup projects. It also means that all the project’s files (images, sounds, etc.) must be in the project folder.

When you’re naming your project, try to choose a name that describes the project. “New Game Project #23” is not going to help you remember what that project was. You should also think about compatibility: some operating systems are case-sensitive, and some are not. This can lead to problems if you move or share your project from one computer to another. For this reason, many programmers develop a standardized naming scheme. For example: “No spaces, use ‘_’ between words.”

Let’s name this new project “getting_started”. Type this name, click Create Folder, and then click Create & Edit.

You’re now looking at the Godot editor window. This is where you’ll spend most of your time when working in Godot. The editor is divided into sections.

alt
Viewport: This is where you’ll see the parts of your game as you’re working on them.
Workspaces: At the center-top, you can switch between working in the 2D, 3D, or Script workspaces. You start in 3D.
Playtest Buttons: These buttons let you launch and control your game when testing.
Docks/Tabs: On both sides are a number of docks where you can view game items and set their properties.
Bottom Panel: Here, you’ll see context-specific information for various tools. The most important one to note first is the Output panel, where you’ll see any error or informational messages when your game is running.
Project Settings
Now we’ve talked about the main parts of the Godot window and how they work, let’s spend a little time talking about our Project settings. Usually one of the first tasks when starting a new project is make sure it’s all set up correctly.

So let’s click on Project in the menu and select Project Settings.

alt
This is the Project settings window. On the left is a list of categories. For most projects, the default settings will be fine, and you shouldn’t worry about changing them unless you have a very specific need. For now, we’re just going to look at two of the sections. First, Application/Config.

In here, you can set your game’s title, choose which scene is the “main scene” (more about that in a bit), and change the icon.

Second, let’s look at the Display section. This is where you set up your game’s display. width & height let you set the size of the game window. If, for example, you were making a mobile game, you’d want to set this to the resolution and proportions of your target device. There are also settings for scaling, stretching, fullscreen mode, and more. For now, we’ll leave the default size - later on we’ll talk about how to adjust these to get our game running on different devices.

alt
There are also some tabs across the top. We’ve been looking at the General tab. I’ll also point out briefly, the Input Map. This is where you can define different input actions for keyboard control, gamepad, mouse, and so on. In your game, you’ll just worry about the action, not what individual key or button was pressed. This is a very powerful and flexible way of handling player input.

We also have localization options, if you plan to support multiple languages. Autoloading, which we’ll get to later, and plugins. The Godot community has created a variety of useful plugins that you can download and add to supply more features, different tools, and so on.

We’ll come back to the project settings window later. Let’s close it for now and we’re ready to move on to the next step: working with nodes.


NODES: GODOT'S BUILDING BLOCKS
Nodes are the basic building blocks for creating games in Godot. A node is an object that can represent some kind of specialized game function. A given type of node might display graphics, play an animation, or represent a 3D model of an object. The node also contains a collection of properties, allowing you to customize its behavior. Which nodes you add to your project will depend on what functionality you need. It’s a modular system designed to give you flexibility in building your game objects.

Working with Nodes
Nodes are objects, in the programming sense. They encapsulate data and behavior, and they can inherit properties from other nodes. Rather than use one of the default suggestions, let’s click the “Add/Create a New Node” button in the scene dock.

alt
Here you’ll see the whole hierarchy of node types available in the engine. For example, the nodes with the bluish icons all fall under the “Node2D” category, meaning they will all have the properties of a Node2D. More about that in a moment.

alt
The list is long, and it would be frustrating to have to drill down every time to find the node you need. Instead, you can use the search function to find it using a small number of characters. We’re looking for the Sprite2D node, so I’ll just type “sp” and we’ll jump right to it. Click “Create” to add the node.

alt
Now we have this Sprite2D node in our Scene dock. Make sure it’s selected, and then look at the Inspector dock on the right side. Over here, you’ll see all the properties of whatever node you have selected. Notice that the properties are organized by where they come from. The Sprite2D node inherits from Node2D, which inherits from CanvasItem, which inherits from the plain old Node.

alt
Over in the viewport, the sprite doesn’t look like much. A sprite’s purpose is to display an image, or texture. As you can see in the Inspector, the Texture property is currently empty. Fortunately, every new Godot project comes with an image we can use: the Godot icon. Drag the icon from the Filesystem dock and drop it in the texture property.

In the Inspector, click to expand the “Transform” section, and type (50, 50) in the Position property.

alt
You can also click and drag the sprite around in the viewport, and you’ll see the Position values changing as you move.

One important property of nodes is that they can be arranged in a parent-child hierarchy. Make sure you have the Sprite2D selected and press the add button again. Add another Sprite2D and also drag the icon into its texture.

This new sprite is a child of the first. This means that it’s “attached” to its parent. If the parent sprite moves, so will the child. Click on the child sprite and set its Position to (50, 50). Now click and drag the parent sprite to move it around the screen.

Notice that the Position of the parent is changing as you move it around. Now check the child: it’s still (50, 50). That’s because its “Transform” properties are relative to its parent.

alt
Scenes
Grouping nodes together like this is a powerful tool, enabling you to construct complex objects out of node “building blocks”. For example, a “Player” node in your game might have many child nodes attached to it: a Sprite2D for display, an AnimationPlayer to animate it, a Camera2D to follow it around, and so on.

alt
A group of nodes arranged in a “tree” structure like this is called a Scene. In the next part, we’ll look at how you can use scenes to organize your game’s objects into independent parts that all work together. You’ll see this in practice was you work through the examples in later lessons.


 GDScript
GDScript is Godot’s built-in scripting language. Its syntax is based on Python, so if you’re familiar with that language, you’ll feel right at home. In this chapter, we’ll introduce the language and get you up to speed with how it works.

 Updating to Godot 4.0
We’re working on a new version of Godot 101 for Godot 4.0. In the meantime, we recommend new learners stick with Godot 3.x, which has a lot more resources and learning materials available.

In this section:
Getting started


Overview
Writing scripts and attaching them to nodes and other objects is how you build behavior and game mechanics into your game. For example, a Sprite2D node automatically displays an image, but to move it across the screen, you’ll add a script that tells it how fast, in what direction, and so on.

You can think of it as the coding version of using the Inspector - GDScript knows all about Godot nodes and how to access them, plus it allows you to change them dynamically.

GDScript is Godot’s built-in language for scripting and interacting with nodes. The GDScript documentation on the Godot website is a great place to get an overview of the language, and I highly recommend taking the time to read through it.

Is GDScript Python?

You’ll often read comments to the effect that “GDScript is based on Python”. That’s somewhat misleading; GDScript uses a syntax that’s modeled on Python’s, but it’s a distinct language that’s optimized for and integrated into the Godot engine. That said, if you already know some Python, you’ll find GDScript looks very familiar.

 Warning
Many tutorials (and Godot in general) assume that you have at least some programming experience already. If you’ve never coded before, you’ll likely find learning Godot to be a challenge. Learning a game engine is a large task on its own; learning to code at the same time means you’re taking on a lot. If you find yourself struggling with the code in this section, you may find that working through an introductory programming lesson (Python is a good option) will help you grasp the basics.

Structure of a script
The first line of any GDScript file must be extends <Class>, where <Class> is some existing built-in or user-defined class. For example, if you’re attaching a script to a CharacterBody2D node, then your script would start with extends CharacterBody2D. This states that your script is taking all the functionality of the built-in CharacterBody2D object and extending it with additional functionality created by you.

In the rest of the script, you can define any number of variables (aka “class properties”) and functions (aka “class methods”).

Creating a script
Let’s make our first script. Remember, any node can have a script attached to it.

Open the editor and add a Sprite2D node to empty scene. Right-click on the new node, and choose “Attach Script”. You can also click the button next to the search box.

alt
Next you need to decide where you want the script saved and what to call it. If you’ve named the node, the script will automatically be named to match it (so unless you’ve changed anything this script will likely be called “sprite2d.gd”).

Now the script editor window opens up, and this is your new, empty sprite script. Godot has automatically included some lines of code, as well as some comments describing what they do.

extends Sprite2D

# Called when the node enters the scene tree for the first time.
func _ready():
    pass # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta):
    pass
Since the script was added to a Sprite2D, the first line is automatically set to extends Sprite2D. Because this script extends the Sprite2D class, it will be able to access and manipulate all the properties and methods that a Sprite2D node provides.

 Properties and methods
Properties and methods are two terms which specifically mean variables and functions that are defined in an object. Programmers tend to use the terms interchangeably.

After that is where you’re going to define all the variables you will use in the script, the “member variables”. You define variables with the ‘var’ keyword - as you can see by the comment examples.

Go ahead and delete the comments and let’s talk about this next piece.

Now we see a function called _ready(). In GDScript you define a function with the keyword “func”. The _ready() function is a special one that Godot looks for and runs whenever a node is added to the tree, for example when we hit “Play”.

Let’s say that when the game starts, we want to make sure the sprite goes to a particular location. In the Inspector, we want to set the Position property. Notice that it’s in the section called “Node2D” - that means this is a property that any Node2D type node will have, not just Sprite2Ds.

How do we set the property in code? One way to find the name of the property is by hovering over it in the Inspector.

alt
Godot has a great built-in help/reference tool. Click on “Classes” at the top of the Script window and search for Node2D and you’ll see a help page showing you all the properties and methods the class has available. Looking down a bit you can see position in the “Member Variables” section - that’s the one we want. It also tells us the property is of the type “Vector2”.

alt
Let’s go back to the script and use that property:

func _ready():
    position = Vector2(100, 150)
Notice how the editor is making suggestions as you type. Godot uses vectors for lots of things, and we’ll talk more about them later. For now, let’s type Vector2, and the hint tells us to put two floats for x and y.

Now we have a script that says “When this sprite starts, set its position to (100, 150)”. We can try this out by pressing the “Play Scene” button.

alt
 Learning tip
When first learning to code, beginners often ask “How do you memorize all these commands?” Just like any other skill, it’s not a matter of memorization, it’s about practice. As you use things more, the things you do frequently will “stick” and become automatic. Until then, it’s a great idea to keep the reference docs handy. Use the search function whenever you see something you don’t recognize. If you have multiple monitors, keep a copy of the web docs open on the side for quick reference.

Wrapping up
Congratulations on making your first script in GDScript! Before moving on, make sure you understand everything we did in this step. In the next part, we’ll add some more code to move the sprite around the screen.	





A gentle introduction to the 3D side of Godot development.

In this section:
The 3D Editor
Importing 3D Objects
Creating a 3D Character


In this tutorial, we’ll look at how to start working in 3D in Godot. You’ll learn how to navigate in the 3D editor, how to create and manipulate 3D objects, and how to work with some of Godot’s essential 3D nodes, such as cameras and lighting.

Are you ready?
A word of warning: 3D development can be quite a bit more complex than working in 2D. While many of the same principles apply - such as working with nodes, writing scripts, and handling logic/data - 3D brings with it a number of other considerations. For this reason, it’s a good idea to stick to 2D for your first few projects, moving to 3D once you have a good understanding of the game development process. This tutorial will assume you have completed at least an introductory Godot 2D project, such as the one in the [official Godot tutorial] (https://docs.godotengine.org/en/stable/getting_started/step_by_step/your_first_game.html).

Getting Started in 3D
One of Godot’s strengths is its ability to handle both 2D and 3D games. While much of what you’ve learned working on 2D projects (nodes, scenes, signals, etc.) applies equally well in 3D, there is also a whole new layer of complexity and capabilities. First, you’ll find that there are some additional features available in the 3D editor window, so we’ll start there:

Orienting in 3D Space
When you first open a new project in Godot, you will see the 3D project view:

alt
The first thing you should notice is the three colored lines in the center. These are the x (red), y (green), and z (blue) axes. The point where they meet is the origin, which has the coordinates (0, 0, 0). You’ll find that this color scheme will also apply elsewhere in the Inspector.

 Note
Different 3D applications follow different conventions for orientation. Godot uses Y-Up orientation, so that when looking at the axes, if x is pointing to the left/right, then y is up/down, and z is forward/back. Some other popular 3D software uses Z-UP. It’s good to keep this in mind when moving between applications.

Navigation in 3D is performed using the mouse and keyboard. Here are the basic controls for the view camera:

Mousewheel up/down: zoom in/out
Middle button + drag: orbit camera around current target
Shift + middle button + drag: pan camera
Right-click + drag: rotate camera in place
In addition, if you’re familiar with popular 3D games, you might prefer Freelook mode, which you can toggle on/off using Shift+F. In this mode, you can use the WASD keys to fly around the scene while aiming with the mouse.

You can also alter the camera’s view by clicking on the [Perspective] label in the upper-left corner. Here, you can snap the camera to a particular orientation.

alt
Adding 3D Objects
Now let’s add our first 3D node. Just as all 2D nodes inherit from Node2D, which provides properties such as position and rotation, 3D nodes inherit from Node3D, which provides 3D versions of the same properties. Add one to your scene and you’ll see the following object appear at the origin:

alt
This object is not the node. It is something called a 3D gizmo. Gizmos are tools that allow you to move and rotate objects in space. The three rings control rotation, while the three arrows move (translate) the object along the three axes. Note that the rings and arrows are color-coded to match the axis colors.

Take a few minutes to experiment and get familiar with the gizmo. Use Undo if you find yourself getting lost.

 Tip
Sometimes you may feel the gizmos are getting in your way. You can click on the mode icons to restrict yourself to only one type of transformation: move, rotate, or scale:alt
Global vs. Local Space
By default, the gizmo controls operate in global space. When you rotate the object, the gizmo’s arrows still point along the axes. However, if you click the Use Local Space button, the gizmo will switch to moving the body in local space.

alt
Now when you rotate the object, the gizmo arrows point along the object’s axes and not the world’s. Switching back and forth between Local and World space can make it much easier to place an object exactly where you want it.

Transforms
Look at the Inspector for the Node3D node. In the Transform section, you’ll see properties for Position, Rotation, and Scale. Drag the object around with the gizmo and observe how these values change. Just like in 2D, these properties are relative to the node’s parent.

Together, these properties make up the node’s transform. When changing the node’s spatial properties in code, you’ll access the transform property, which is a Godot Transform3D object. It has two properties: origin and basis. The origin represents the body’s position, while the basis contains three vectors that define the body’s local coordinate axes - think of the three axis arrows in the gizmo when you’re in Local Space mode.

You’ll see how to use these properties later in this section.

Meshes
Just like a Node2D, a Node3D has no size or appearance of its own. In 2D, you would use a Sprite2D to add a texture to the node. In 3D, you need to add a mesh. A mesh is a mathematical description of a shape. It consists of a collection of points, called vertices. These vertices are connected by lines, called edges, and multiple edges (at least three) together make a face.

alt
For example, a cube is made up of 8 vertices, 12 edges, and 6 faces.

Adding Meshes
Typically, meshes are created by using 3D modeling software, such as Blender. You can also find many collections of 3D models available for download, if you’re unable to create your own. However, often you just need a basic shape such as a cube or sphere. In this case, Godot provides a way to create simple meshes called primitives.

Add a MeshInstance3D node as a child of the Node3D and in the Inspector, click its Mesh property:

alt
Here you can see the list of available primitives. They represent a handy collection of common useful shapes. Select “New BoxMesh” and you’ll see a plain cube appear on the screen.

Cameras
Try running the scene with your cube object. Did you see anything? In 3D, you won’t see anything in the game viewport without adding a Camera3D. Add one to the root node and use the camera’s gizmo to position it pointing towards the cube:

alt
The pinkish-purple pyramid shape on the camera is called the fustrum and represents the camera’s view. Notice the small triangular arrow which represents the camera’s “up” orientation. As you’re moving the camera around, try pressing the Preview button in the upper-left to see what the camera sees. Play the scene to verify everything is working as expected.

Wrapping Up
In this tutorial you learned how to use Godot’s 3D editor, how to add 3D nodes such as Node3D, MeshInstance3D, and Camera3D, and how to use gizmos to place your objects. You also learned a bunch of new terminology. Hopefully you’re not overwhelmed.

In the next part, we’ll look at how to build a 3D scene by importing 3D assets and how to use more of Godot’s 3D nodes.


IMPORTING 3D OBJECTS
In the last part, we started a 3D project and looked at how to navigate and create 3D objects. In this part, you’ll learn how to import existing 3D objects that you’ve made or downloaded and how to use more of Godot’s 3D nodes.

Importing 3D Objects
If you’re familiar with 3D modeling software such as Blender, you can make your own models to use in your game. If not, there are many sources where you can download objects or even collections of objects for particular game types. One of our favorite makers of free game art is Kenney.nl.

For our tutorials, we’re going to use Kenney’s Platformer Kit, which you can download here: https://kenney.nl/assets/platformer-kit

This kit has a wide selection of objects that we can use to practice our Godot 3D skills. Here’s a sample showing what the kit looks like:

alt
Once you’ve downloaded the kit, you’ll find that the objects inside are provided in a variety of different formats. Godot is able to use several of these, but since GLTF is available in this pack, it’s preferred over the others. Drop the GLTF format folder into your Godot project’s folder and rename it to “platformer_kit”.

 3D file formats
Whether you create your own models or download the, you’ll need them to be saved in a format that Godot can use. Godot supports the following 3D file formats:

glTF - supported in both text (.gltf) and binary (.glb) versions
DAE (Collada) - an older format that is still supported
OBJ (Wavefront) - an older format that is supported, but the format is limited compared to modern options
FBX - a commercial format that has limited support
glTF is the recommended format - it has the most features and is very well supported in Godot.

When you switch back to your Godot window, you’ll see progress bar while Godot scans the folder and imports all of the objects. Let’s click on one of them to see what’s going on. In the FileSystem tab, double-click on crate.glb:

alt
Here you can see the object will be imported as a scene, with its root type set to Node3D and named “Scene Root”. Let’s change these: set the root type to RigidBody3D and the root name to “Crate”, then click the “Reimport” button.

Now right-click on “crate.glb” and choose New Inherited Scene. Here we have a classic game object: the crate. The root node of the scene is a RigidBody3D named “Crate” just as we wanted.

Finally, we need to add a collision shape to the body. While we could do this by adding a CollionShape3D, as you would typically do in 2D, but there’s a quicker way.

Select the crate2 mesh and you’ll see a Mesh menu appear at the top of the viewport. Click it and select Create Single Convex Collision Sibling. Godot will automatically add a CollionShape3D with a collision shape that matches the mesh.

Now we’re finished setting up the object. Save your Crate scene and let’s see how we can use it.

Building a 3D Scene
Create a new scene with a Node3D root. The first child we’ll add is one to give us a “ground” to stack some crates on. Add a StaticBody3D called “Ground”, and to that add a MeshInstance3D. In the Mesh property, select “New BoxMesh” and then click it to open its properties. Set Size to (10, 0.1, 10) so that we have a nice large surface. However, it would look better if it weren’t plain white.

Also in the mesh properties is a Material property. Materials are how you define the appearance of an object. Select “New StandardMaterial3D” and then click it to open a large list of properties. To set the color of the mesh, we need the Albedo/Color property. Choose a color, such as brown or dark green.

If we add a crate, it will fall right through the mesh, so we also need to give it a collision shape. Add a CollisionShape3D to the Ground and choose “New BoxShape3D”. Set the collision box to the same size as the mesh.

Now instance a few crates in the scene and arrange them in a rough stack. Add a Camera and place it where it has a good view of the crates. Run the scene and watch your crates go tumbling!

alt
Why is the scene so dark? Because there’s no light! By default, Godot doesn’t add any lighting or environment to your scenes, like it does in the editor viewport. This is great when you want to set up your own specific lighting, but for a quick example scene like this, there’s a shortcut.

Lighting
There are multiple light nodes available in 3D, which you can use to create a variety of lighting effects. But we’re going to start with DirectionalLight3D. However, instead of adding one manually, we’re going to have Godot use the same one it’s using in the editor window. At the top ove the viewport, there are two icons that control the preview lighting and preview environment. If you click the three dots next to them, you can see their settings.

alt
Click the Add Sun to Scene button, and Godot will add a DirectionalLight3D to your scene. Click Add Environment to Scene and it will do the same with the preview sky by adding a WorldEnvironment node.

Run the scene again, and you’ll be able to see your crates falling.

Rotating Camera
Let’s make the camera a little more dynamic by having it slowly orbit around the scene. Select the root node and add a Node3D, which will be located at (0, 0, 0) and name it “CameraHub”. In the scene tree, drag the camera to make it a child of this new node. Now, if the CameraHub rotates around the y axis, it will drag the camera along with it.

Add a script to the root node and add the following:

extends Node3D

func _process(delta):
    $CameraHub.rotate_y(0.6 * delta)
Run the scene to see what happens.

Wrapping Up
In this tutorial you learned how to import 3D objects from outside sources, and how to combine them into a simple scene. We also investigated lights and moving cameras.

In the next part, we’ll look at how to build a more complex scene and include a player-controlled character.


CREATING A 3D CHARACTER
In the last part, we covered how to import 3D objects and how to arrange them in a scene. In this installment, we’ll add more objects to the scene, including a user-controlled character.

Building the Scene
We’re going to continue using the Kenney Platformer Kit we downloaded in Part 2. Select all the block*.glb files and in the Import tab set their Root Type to StaticBody3D. Uncheck the Root Name property and click Reimport. Select blockLarge.glb and make a new inherited scene. Use the Create Single Convex Collision Sibling option on the mesh using the menu as you did in the last tutorial. Now you can save the scene - I recommend making a separate folder for this, as soon you’re going to have a bunch of scenes representing the differently shaped platform parts.

Open the scene from the previous step with the “Ground” plane and the crates. Delete the crates and add an instance of the large block. We want to be able to place these blocks so that they line up. To do this, select “Configure Snap” from the “Transform” menu at the top of the Viewport and set Translate Snap to 0.5. Then click on the “Snap Mode” button (or press the Y key). Now duplicate the block a few times and drag them to arrange.

If you like, go ahead and add scenes for some of the other platform blocks and arrange them into a pleasing level. Be creative!

alt
Adding a Character
Now we’re going to make a character so we can walk around on the platforms. Open a new scene and start with a CharacterBody3D named “Character”. This PhysicsBody node behaves very much like its 2D equivalent (you’ve already done the 2D tutorials, right?). It has a move_and_slide() method that we’ll use to perform the movement and collision detection.

Add a capsule-shaped MeshInstance3D and a matching CollionShape3D. Remember, you can add a StandardMaterial3D to the mesh and set its Albedo/Color property to change the color.

The capsule is nice, but it’s going to be hard to tell what direction it’s facing. Let’s add another mesh, this time with a CylinderMesh3D shape. Set its Top Radius to 0.2, its Bottom Radius to 0.001 and its Height to 0.5, then its x rotation to -90 degrees. Now you have a nice cone shape. Arrange it so it’s pointing out from the body along the negative z axis. (You can tell which way is negative because the gizmo arrows point in the positive direction).

alt
In this picture, we’ve also added two sphere meshes for eyes to give a little more character. Feel free to add whatever details you like.

Let’s also add a Camera3D to the scene, so it will follow the player around. Position the camera behind and above the character, angling it down a bit. Click the “Preview” button to check the camera’s view.

Before we add a script, open the “Project Settings” and add the following inputs on the “Input Map” tab:

Input Action	Key
move_forward	W
move_back	S
strafe_right	D
strafe_left	A
jump	Space
Now let’s add a script to the body.

extends CharacterBody3D

var gravity = ProjectSettings.get_setting("physics/3d/default_gravity")
var speed = 4.0  # movement speed
var jump_speed = 6.0  # determines jump height
var mouse_sensitivity = 0.002  # turning speed


func get_input():
    var input = Input.get_vector("strafe_left", "strafe_right", "move_forward", "move_back")
    velocity.x = input.x * speed
    velocity.z = input.y * speed

func _physics_process(delta):
    velocity.y += -gravity * delta
    get_input()
    move_and_slide()
The code in _physics_process() is pretty straightforward: add gravity to accelerate in the positive Y direction (downward), call get_input() to check for input, and then use move_and_slide() to move in the direction of the velocity vector.

In get_input() we check to see which key is pressed and then move in that direction. Run the program and test:

alt
This is all good, but we need to be able to rotate using the mouse. Add the following code to the character’s script:

func _unhandled_input(event):
    if event is InputEventMouseMotion:
        rotate_y(-event.relative.x * mouse_sensitivity)
This will convert any mouse motion in the x direction into a rotation around the y axis.

Run the scene and confirm that moving the mouse rotates the character:

alt
However, there’s a problem. No matter which way we’re facing, pressing W moves us along the Z axis of the world. Our movement is using global coordinates, but we need to move in the object’s forward direction.

The Power of Transforms
This is where transforms come in. A transform is a mathematical matrix that contains the object’s translation, rotation, and scale information all in one. In Godot it’s stored in the Transform data type. The position information is called the transform.origin and the orientation information is in the transform.basis.

Remember how the 3D gizmo can be set to “Local Space Mode”? When in this mode, the gizmo’s X/Y/Z axes point along the object’s axes. This is the same as the basis of the transform. The basis contains three Vector3 objects called x, y, and z that represent these directions. We can use this to ensure that pressing the W key will always move us in the object’s forward direction.

Change the get_input() function like so:

func get_input():
    var input = Input.get_vector("strafe_left", "strafe_right", "move_forward", "move_back")
    var movement_dir = transform.basis * Vector3(input.x, 0, input.y)
    velocity.x = movement_dir.x * speed
    velocity.z = movement_dir.z * speed
By multiplying the input vector by the transform.basis, we apply that transformation to the vector. Since the basis represents the object’s rotation, we’ve now converted forward and back to point along the object’s Z axis, and the strafe keys along its X.

alt
Jumping
Let’s add one more movement to the player: jumping.

Add these lines to the end of _unhandled_input():

if event.is_action_pressed("jump") and is_on_floor():
    velocity.y = jump_speed
Improving the camera
You may have noticed that the if the character stands near an obstacle, the camera can “clip” inside the object, which doesn’t look nice. While coding a good 3D camera can be a complex topic on its own, we can use a built-in Godot node to get a pretty good solution.

Delete the Camera3D from the character scene and add a SpringArm3D. This node can act as a moving arm that holds the camera while detecting collisions. It will move the camera closer if there’s an obstacle.

In its properties, set Spring Length to 5, and set its Position to (0, 1, 0), which is at the character’s head. Note the yellow line indicating the Spring Length. The camera will move along this line - at its end whenever possible, but moving closer if an obstacle is there.

Add back a Camera3D as a child of the SpringArm3D, and try running the game again. You can experiment with rotating the spring arm (around its x axis to point down slightly, for example) until you find something you like.

What about first person?
If you’re curious how you would do this in first person, see the Basic FPS Character recipe. You’ll notice several similarities with the 3rd person script we wrote above.

Wrapping Up
In this tutorial you learned how to build a more complex scene, and how to write movement code for a user-controlled character. You also learned about transforms, which are a very important concept in 3D - you’re going to be using a lot in the future.


FRESH RECIPES
Here you can find the most recently added recipes:

Multitarget Camera
Character to Rigid Body Interaction
CharacterBody3D: Align with Surface
CharacterBody3D: Movement
Arcade-style Car
Pathfinding on a 2D Grid
Migrating from 3.x
Shooting with Raycasts
Basic FPS Character
RigidBody2D: Drag and Drop
2D Car Steering
3D Healthbars
Grid-based Movement
Arcade-style 3D Spaceship
Interpolated Camera
Platform Character



UNDERSTANDING TREE ORDER
Problem
You need to understand in what order Godot handles nodes in the scene tree.

Solution
“Tree order” is mentioned often in the Godot docs and in tutorials. However, it is not always obvious to a beginner what is meant by this. Generally speaking, the order in which nodes are handled in the tree is in top-down fashion, starting at the root and going down each branch in turn.

Scene tree order is something that can cause a great deal of confusion for Godot beginners. In this example, we’ll illustrate in what order things happen.

Here’s our sample node setup:

alt
On each node, we have the following script attached:

extends Node

func _init():
    # Note: a Node doesn't have a "name" yet here.
    print("TestRoot init")

func _enter_tree():
    print(name + " enter tree")

func _ready():
    print(name + " ready")

# This ensures we only print *once* in process().
var test = true
func _process(delta):
    if test:
        print(name + " process")
    test = false
Before we talk about the results, let’s review what each of these callback functions represents:

_init() is called when the object is first created. It now exists in the computer’s memory.

_enter_tree() is called when the node first enters the tree. This can be when instancing or when add_child() is used, for example.

_ready() is called when the node and its children have all been added to the tree and are ready.

_process() is called every frame (typically 60 times per second) on every node in the tree.

If we ran this on a single node all by itself, the order would be as you might expect:

TestRoot init
TestRoot enter tree
TestRoot ready
TestRoot process
Once we add children to the mix, it becomes a bit more complex, and probably needs some clarification:

TestRoot init
TestChild1 init
TestChild3 init
TestChild2 init

TestRoot enter tree
TestChild1 enter tree
TestChild3 enter tree
TestChild2 enter tree

TestChild3 ready
TestChild1 ready
TestChild2 ready
TestRoot ready

TestRoot process
TestChild1 process
TestChild3 process
TestChild2 process
As you can see, all of these nodes printed their messages in tree order, from top to bottom, following branches first - with the exception of the _ready() code.

Here’s a quote from the Node reference:

Called when the node is “ready”, i.e. when both the node and its children have entered the scene tree. If the node has children, their _ready callbacks get triggered first, and the parent node will receive the ready notification afterwards.

This leads to an important rule-of-thumb to remember when setting up your node structure:

 Tip
Parent nodes should manage their children, not vice-versa.

This means any code in the parent must be able to fully access any data in its children. For that reason, _ready() must be processed in reverse tree order.

Remember this when trying to access other nodes in _ready(). If you need to go up the tree to a parent (or grandparent), you should probably run that code in the parent rather than the child.

Related recipes
Understanding node paths


NODE COMMUNICATION (THE RIGHT WAY)
 Info
Many thanks to @TheDuriel on the Godot Discord for the original diagram that inspired this article. Save this and keep it handy.

Problem
Your project has started getting complex. You have multiple scenes, instances, and a lot of nodes. You’ve probably found yourself writing code like the following:

get_node("../../SomeNode/SomeOtherNode")
get_parent().get_parent().get_node("SomeNode")
get_tree().get_root().get_node("SomeNode/SomeOtherNode")
If you do this, you’ll soon find that node references like this break easily. As soon as you change one thing about your scene tree, none of those references may be valid anymore.

Communication between nodes and scenes doesn’t have to be complicated. There is a better way.

Solution
As a general rule, nodes should manage their children, not the other way around. If you’re using get_parent() or get_node(".."), then you’re probably headed for trouble. Node paths like this are brittle, meaning they can break easily. The three main problems with this arrangement:

You can’t test a scene independently. If you run the scene by itself or in a test scene that doesn’t have the exact same node setup, get_node() will cause a crash.

You can’t change things easily. If you decide to rearrange or redesign your tree, paths will no longer be valid.

Ready order is children-first, parent-last. This means that trying to access a parent’s property in a node’s _ready() can fail because the parent isn’t ready yet.

 Tip
See Understanding tree order for an explanation of how nodes enter the tree and become ready.

Generally speaking, a node or scene should be able to be instanced anywhere in your game, and it should make no assumptions about what its parent is going to be.

We’ll go into detailed examples later in this tutorial, but for now, here’s the “golden rule” of node communication:

Call down, signal up.

If a node is calling a child (i.e. going “down” the tree), then get_node() is appropriate.

If a node needs to communicate “up” the tree, it should probably use a signal.

If you keep this rule in mind when designing your scene setup, you’ll be well on your way to a maintainable, well-organized project. And you’ll avoid using the cumbersome node paths that lead to problems.

Now, let’s look at each of these strategies along with some examples.

1. Using get_node()
get_node() traverses the scene tree using a given path to find the named node.

 Tip
See Understanding node paths for a more detailed explanation of node paths.

get_node() example
Let’s consider the following common configuration:

alt
The script in the Player node needs to notify the AnimatedSprite2D which animation to play, based on the player’s movement. In this situation, get_node() works well:

extends CharacterBody2D

func _process(delta):
    if speed > 0:
        get_node("AnimatedSprite2D").play("run")
    else:
        get_node("AnimatedSprite2D").play("idle")
 Tip
In GDScript you can use $ as a shorthand for get_node(), writing $AnimatedSprite2D instead.

A better way
The downsides of this approach are that you have to specify the node path, and if that changes later, you’ll have to edit the code as well. Instead, you can use the @export feature to directly select a node.

extends CharacterBody2D

@export var animation : AnimatedSprite2D

func _process(delta):
    if speed > 0:
        animation.play("run")
    else:
        animation.play("idle")
With this method, you can assign the value of the variable directly in the Inspector by choosing the node.

2. Using signals
Signals should be used to call functions on nodes that are higher in the tree or at the same level (i.e. “siblings”).

You can connect a signal in the editor (most often for nodes that exist before the game starts) or in code (for nodes that you’re instancing at runtime). The syntax for connecting a signal is:

signal_name.connect(target_node.target_function)

Looking at this, you may be thinking “Wait, if I’m connecting to a sibling, won’t I need a node paths like ../Sibling?”. While you could do this, it breaks our rule above. The answer to this puzzle is to make sure that connections are made by the common parent.

Following the rule of calling down the tree, a node that’s a common parent to the signaling and receiving nodes will by definition know where they are and be ready after both of them.

Signal example
A very common use case for signals is updating your UI. Whenever the player’s health variable changes, you want to update a Label or ProgressBar display. However, your UI nodes are completely separated from your player (as they should be). The player knows nothing about where those nodes are and how to find them.

Here’s our example setup:

alt
Note that the UI is an instanced scene, we’re just showing the contained nodes. This is where you often see things like get_node("../UI/VBoxContainer/HBoxContainer/Label).text = str(health), which is what we want to avoid.

Instead the player emits a health_changed signal whenever it adds/loses health. We need to send that signal to the UI’s update_health() function, which handles setting the Label value. In the Player script we use this code whenever the player’s health is changed:

health_changed.emit(health)
In the UI script we have:

onready var label = $VBoxContainer/HBoxContainer/Label

func update_health(value):
    label.text = str(value)
Now we just need to connect the signal to the function. The perfect place to do that is in World, which is the common parent, and knows where both nodes are:

func _ready():
    $Player.health_changed.connect($UI.update_health)
3. Using groups
Groups are another way to decouple, especially when you have a lot of similar objects that need to do the same thing. A node can be added to any number of groups and membership can be changed dynamically at any time with add_to_group() and remove_from_group().

A common misconception about groups is that they are some kind of object or array that “contains” node references. Groups are a tagging system. A node is “in” a group if it has that tag assigned from it. The SceneTree keeps track of the tags and has functions like get_nodes_in_group() to help you find all nodes with a particular tag.

Group example
Let’s consider a Galaga-style space shooter where you have a lots of enemies flying around. These enemies may have different types and behaviors. You’d like to add a “smart bomb” upgrade that, when activated, destroys all enemies on the screen. Using groups, you can implement this with a minimal amount of code.

First, add all enemies to an “enemies” group. You can do this in the editor using the “Node” tab:

alt
You can also add nodes to the group in your script:

func _ready():
    add_to_group("enemies")
Let’s assume every enemy has an explode() function that handles what happens when it dies (playing an animation, spawning dropped items, etc). Now that every enemy is in the group, we can implement our smart bomb function like this:

func activate_smart_bomb():
    get_tree().call_group("enemies", "explode")
4. Using owner
owner is a Node property that’s set automatically when you save a scene. Every node in that scene will have its owner set to the scene’s root node. This makes for a convenient way to connect child signals up to the main node.

owner example
In a complex UI, you often find yourself with a very deep, nested hierarchy of containers and controls. Nodes that the user interacts with, such as Button, emit signals, and you may want to connect those signals to the script on the UI’s root node.

Here’s an example setup:

alt
The script on the root CenterContainer has the following function, which we want to call whenever any button is pressed:

extends CenterContainer

func _on_button_pressed(button_name):
    print(button_name, " was pressed")
The buttons here are instances of a Button scene, representing an object which may contain dynamic code that sets the button’s text or other properties. Or perhaps you have buttons that are dynamically added/removed from the container depending on the game state. Regardless, all we need to connect the button’s signal is the following:

extends Button

func _ready():
    pressed.connect(owner._on_button_pressed.bind(name))
No matter where you place the buttons in the tree - if you add more containers, for example - the CenterContainer remains the owner.

Related recipes
Understanding tree order
Understanding node paths


UNDERSTANDING NODE PATHS
Problem
It’s probably the most common problem seen in the Godot help channels: an invalid node reference. Most often, it appears as the following error message:

Invalid get index ‘position’ (on base: ’null instance’).

Solution
It’s that last part, the “null instance”, that’s the source of this problem, and the main source of confusion for Godot beginners.

The way to avoid this problem is to understand the concept of node paths.

Understanding node paths
The scene tree is made of nodes, which are connected together in parent-child relationships. A node path is the path it takes to get from one node to another by moving through this tree.

As an example, let’s take a simple “Player” scene:

alt
The script for this scene is on the Player node. If the script needs to call play() on the AnimatedSprite node, it needs a reference to that node:

get_node("AnimatedSprite").play()
The argument of the get_node() function is a string representing the path to the desired node. In this case, it’s a child of the node the script is on. If the path you give it is invalid, you’ll get the dreaded null instance error (as well as “Node not found”).

Getting a node reference with get_node() is such a common situation that GDScript has a shortcut for it:

$AnimatedSprite.play()
 Info
get_node() returns a reference to the desired node.

Let’s look at a more complex scene tree:

alt
If the script on Main needs to access ScoreLabel it can do so with this path:

get_node("HUD/ScoreLabel").text = "0"
# or using the shortcut:
$HUD/ScoreLabel.text = "0"
 Tip
When using $ notation, the Godot editor will autocomplete paths for you. You can also right-click on a node in the Scene tab and choose “Copy Node Path”.

What if the node you want to access is higher in the tree? You can use get_parent() or ".." to reference the parent node. In the above example tree, to get the Player node from the ScoreLabel:

get_node("../../Player")
Let’s break that down. The path "../../Player" means “get the node that’s up one level (HUD), then one more level (Main), then its child Player”.

 Tip
Does this seem familiar? Node paths work exactly like directory paths in your operating system. The / character indicates the parent-child relationship, and .. means “up one level”.

Relative vs absolute paths
The above examples all use relative paths - meaning they start at the current node and follow the path to the destination. Node paths can also be absolute, starting from the root node of the scene.

For example, the absolute path to the player node is:

get_node("/root/Main/Player")
/root, which can also be accessed with get_tree().root is not the root node of your scene. It’s the Viewport node that is always present by default in the SceneTree.

A warning
While the above examples work just fine, there are some things you should be aware of that may cause problems later. Imagine the following situation: the Player node has a health property, which you want to display in a HealthBar node somewhere in your UI. You might write something like this in the player’s script:

func take_damage(amount):
    health -= amount
    get_node("../Main/UI/HealthBar").text = str(health)
While this may work fine at first, it is brittle, meaning it can break easily. There are two main problems with this kind of arrangement:

You can’t test the player scene independently. If you run the player scene by itself or in a test scene that doesn’t have a UI, the get_node() line will cause a crash.
You can’t change your UI. If you decide to rearrange or redesign your UI, the path will no longer be valid and you have to change it.
For this reason, you should try to avoid using node paths that go up the scene tree. In the above situation, if the player instead emitted a signal when the health changed, the UI could listen for that signal to update itself. You could then rearrange and separate nodes without fear of breaking your game.

Wrapping up
Once you understand how to use node paths, you’ll see how easy it is to reference any node you need. And put a stop to seeing those null instance error messages.



UNDERSTANDING 'DELTA'
Problem
The delta or “delta time” parameter is a frequently-misunderstood concept in game development. In this tutorial, we’ll explain how it’s used, the importance of frame-rate independent movement, and practical examples of its use in Godot.

Solution
To illustrate the problem, let’s consider a Sprite node moving across the screen. If our screen is 600 pixels wide and we want the sprite to take 5 seconds to cross the screen, we can use the following calculation to find the necessary speed:

600 pixels / 5 seconds = 120 pixels/second
We’ll move the sprite every frame using the _process() function. If the game is running at 60 frames per second, we can find the per-frame movement like so:

120 pixels/second * 1/60 second/frame = 2 pixels/frame
 Tip
Notice the units are consistent in all the calculations above. Always pay attention to the units in your calculations - it’ll save you from making mistakes.

Here’s the necessary code:

extends Node2D

# Desired movement in pixels/frame
var movement = Vector2(2, 0)

func _process(delta):
    $Sprite.position += movement
Run this code and you’ll see the sprite takes 5 seconds to cross the screen.

alt
Maybe. The trouble begins if there is something else occupying the computer’s time. This is called lag and can come from a variety of sources - the cause could be your code or even other applications running on your computer. If this happens, then the length of a frame might increase. As an extreme example, imagine that the frame rate is halved - each frame took 1/30 instead of 1/60 of a second. Moving at 2 px/frame, it’s now going to take twice as long for the sprite to reach the edge.

alt
Even small frame rate fluctuations will result in inconsistent movement speed. If this were a bullet or other fast-moving object, we wouldn’t want it slowing down like this. We need the movement to be frame rate independent.

Fixing the frame rate problem
When using the _process() function, it automatically includes a parameter called delta that’s passed in from the engine (so does _physics_process(), which is used for physics-related code). This is a floating point value representing the length of time since the previous frame. Typically, this will be approximately 1/60 or 0.0167 seconds.

With this information, we can stop thinking about how much to move each frame, and only consider our desired speed in pixels/second (120 from the above calculation).

Multiplying the engine’s delta value by this number will give us how many pixels to move each frame. The number will automatically adjust if the frame time fluctuates.

# 60 frames/second
120 pixels/second * 1/60 second/frame = 2 pixels/frame

# 30 frames/second
120 pixels/second * 1/30 second/frame = 4 pixels/frame
Note that if the frame rate decreases by half (meaning the frame time doubles), then our per-frame movement must also double to keep the desired speed.

Let’s change the code to use this calculation:

extends Node2D

# Desired movement in pixels/second.
var movement = Vector2(120, 0)

func _process(delta):
    $Sprite.position += movement * delta
Now when running at 30 frames per second, the travel time is consistent:

alt
If the frame rate gets very low, the movement is no longer smooth, but the time remains the same.

alt
Using delta with motion equations
What if your movement is more complex? The concept remains the same. Keep your units in seconds, not frames, and multiply by delta each frame.

 Tip
Working in pixels and seconds is much easier to conceptualize too, since it relates to how we measure these quantities in the real world. “Gravity is 100 pixels/second/second, so after the ball falls for 2 seconds, it’s traveling at 200 pixels/second.” If you’re working with frames, then you have to think about acceleration in units of pixels/frame/frame. Go ahead and try - it’s not very natural.

For example, if you are applying a gravity, that’s an acceleration - each frame it will increase the velocity by some amount. As in the above example, the velocity then changes the node’s position.

Try adjusting delta and target_fps in the following code to see the effect:

extends Node2D

# Acceleration in pixels/sec/sec.
var gravity = Vector2(0, 120)
# Acceleration in pixels/frame/frame.
var gravity_frame = Vector2(0, .033)

# Velocity in pixels/sec or pixels/frame.
var velocity = Vector2.ZERO

var use_delta = false
var target_fps = 60

func _ready():
    Engine.target_fps = target_fps

func _process(delta):
    if use_delta:
        velocity += gravity * delta
        $Sprite.position += velocity * delta
    else:
        velocity += gravity_frame
        $Sprite.position += velocity
Note that we’re multiplying by our timestep each frame to update both velocity and position. Any quantity that is updated every frame should be multiplied by delta to ensure it changes independent or frame rate.

Using kinematic functions
In the above examples, we’ve used a Sprite to keep things simple, updating the position every frame. If you’re using a kinematic body (in 2D or 3D), you’ll instead be using one of its movement methods. Specifically in the case of move_and_slide(), there tends to be some confusion, because it uses the velocity vector, not the position. This means you won’t multiply your velocity by delta to find distance - the function does that for you. But you will still need to apply it on any other calculations, such as the acceleration. For example:

# Sprite movement code:
velocity += gravity * delta
position += velocity * delta

# Kinematic body movement code:
velocity += gravity * delta
move_and_slide()
If you don’t use delta when applying acceleration to your velocity, then your acceleration will be subject to fluctuations in frame rate. This can have a_much more subtle effect on movement - it will be inconsistent, but much more difficult to diagnose.

 Tip
When using move_and_slide() you still need to apply delta to any other quantities such as gravity, friction, etc.

Related Recipes


SAVING/LOADING DATA
Problem
You need to save and load local data between game sessions.

Solution
Godot’s file I/O (input/output) system is based around the FileAccess object. You open a file by calling open().

var file = FileAccess.open("user://myfile.name", File.READ)
 Warning
User data should only be stored in the user:// path. While res:// can be used when running from the editor, when your project is exported, the res:// path becomes read-only.

The second argument after the file path is the “Mode Flag”, which can be one of the following:

FileAccess.READ - Open for reading.
FileAccess.WRITE - Open for writing. Creates the file if it doesn’t exist and truncates if it does.
FileAccess.READ_WRITE - Open for reading and writing. Doesn’t truncate the file.
FileAccess.WRITE_READ - Open for reading/writing. Creates the file if it doesn’t exist and truncates if it does.
Storing data
You can save data using its specific data type (store_float(), store_string(), etc.), or using the generic store_var(), which will use Godot’s built-in serialization to encode your data, including complex data like objects (more on this later).

Let’s start with a small example: saving the player’s high score. We can write a function that we can call whenever the score needs to be saved:

var save_path = "user://score.save"

func save_score():
    var file = FileAccess.open(save_path, FileAccess.WRITE)
    file.store_var(highscore)
We’re saving our score, but we need to be able to load it when the game starts:

func load_score():
    if FileAccess.file_exists(save_path):
        print("file found")
        var file = FileAccess.open(save_path, FileAccess.READ)
        highscore = file.get_var()
    else:
        print("file not found")
        highscore = 0
Don’t forget to check for the file’s existence before attempting to read from it - it may not be there! If that’s the case, you can use a default value.

You can store_var() and get_var() as many times as you need for any number of values.

Saving Resources
The above technique works great when all you need to save are a few values. For more complex situations, you can save your data in a Resource, just like Godot does. Godot saves all its data Resources as .tres files (Animations, TileSets, Shaders, etc.) and you can too!

To save and load Resources, use the ResourceSaver and ResourceLoader Godot classes.

For this example, let’s say you have all the data about your character’s stats stored in a Resource like this:

extends Resource
class_name PlayerData

var level = 1
var experience = 100

var strength = 5
var intelligence = 3
var charisma = 2
You can then save and load like so:

func load_character_data():
    if ResourceLoader.exists(save_path):
        return load(save_path)
    return null

func save_character_data(data):
    ResourceSaver.save(data, save_path)
Resources can contain subresources, so you could have your player’s inventory Resource included as well, and so on.

What about JSON?
I see it very often (and some readers may be asking it already): “What if I want to use JSON to save my data?” This is my response:

Don’t use JSON for your save files!

While Godot has JSON support, saving game data is not what JSON is for. JSON is a data interchange format - its purpose is to allow systems using different data formats and/or languages to exchange data between each other.

This means JSON has limitations that are negatives for you when it comes to saving your game data. JSON doesn’t support many data types (no int vs. float, for example) so you have to do a lot of converting and validating to try and save/load your data. It’s cumbersome and time consuming.

Don’t waste your time. Using Godot’s built-in serialization, you can store native Godot objects - Nodes, Resources, even Scenes - without any effort, which means less code and fewer errors.

There’s a reason that Godot itself doesn’t use JSON for saving scenes and resources.

Wrapping up
This article just scratches the surface of what you can do with FileAccess. For the full list of available FileAccess methods, see the FileAccess documentation.


MIGRATING FROM 3.X
This is an evolving list of the main changes and “gotchas” to look out for if you’re transitioning to 4.0.

New Names
One of the biggest changes in Godot 4 is a whole bunch of renaming - of nodes, functions, and property names. Most of it is done to make things consistent or clear. Here are a few of the biggest ones to watch out for:

2D/3D nodes - In Godot 3.x, 2D nodes had the “2D” suffix, but 3D nodes had none. This has been made consistent - they all now have “2D” or “3D” suffixes. For example: RigidBody2D vs. RigidBody3D.

Also in the category of 3D, the Spatial node is renamed to Node3D to match.

One of the most popular nodes, KinematicBody, has been renamed to CharacterBody2D/CharacterBody3D. See below for further changes with this node’s API.

PackedScene’s instance() function has been renamed to instantiate().

The position and global_position properties replace translation and global_translation in 3D, making them consistent with 2D.

Signals and Callables
Working with signals is much more streamlined in 4.0. Signal is a native type now, so you’ll be using fewer strings, meaning you get autocomplete and error checking. This applies to functions as well, which can now be directly referenced rather than using strings.

Here’s an example of defining, connecting, and emitting a signal.

extends Node

signal my_signal

func _ready():
    my_signal.connect(signal_handler)

func _input(event):
    if event.is_action_pressed("ui_select"):
        my_signal.emit()

func signal_handler():
    print("signal received")
Tweens
If you started using SceneTreeTween in Godot 3.5, then you’ll be familiar with Godot 4.0’s Tween usage.

Tween is no longer a node. Instead, you create one-off tween animation objects whenever you need them. Once you get used to it, it’s a lot more powerful and easier to use than the old method.

AnimatedSprite[2D|3D]
The biggest change that catches people who are familiar with the 3.x version of this node is that the playing property is gone. It’s now much more consistent with AnimationPlayer’s usage - to automatically play an animation, you can toggle autoplay in the SpriteFrames panel. In code, use play() and stop() to control playback.

CharacterBody[2D|3D]
The biggest change in this node is in using move_and_slide(). It no longer takes any parameters - they are all now built-in properties. This includes a native velocity property, so you no longer need to declare your own.

For detailed examples of using these nodes, see Platform Character and/or Basic FPS Character.

TileMap
The TileMap node is completely overhauled for 4.0. Just about everything, from how you create TileSets to how you draw and interact with tiles is 100% new.

Our “Using TileMaps” guide is coming soon.

RNG
There are a few changes to GDScript’s built-in random number generator functions:

You no longer need to call randomize() - this is automatic. If you do want repeatable “randomness”, use seed() to set it to a preselected value.

rand_range() is now replaced with either randf_range() (for floats) or randi_range() (for ints).

Raycasting
When casting rays in code, there’s a new API. PhysicsDirectSpaceState[2D|3D].intersect_ray() now takes a special object as a parameter. This object specifies the ray properties. For example, to cast a ray in 3D:

var space = get_world_3d().direct_space_state
var ray = PhysicsRayQueryParameters3D.create(position, destination)
var collision = space.intersect_ray(ray)
if collision:
    print("ray collided")


 KNOW YOUR NODES
In the “Know Your Nodes” series, we go in-depth with a single one of Godot’s nodes. Learn what makes it tick and see some examples of how it’s used.

In this section:
RayCast2D


RAYCAST2D
RayCast2D
Raycasting is a common technique in game development. “Casting a ray” means extending a line from a point until it collides with something or reaches its limit.

Node properties
Add a RayCast2D node and take a look at the Inspector:

alt
Here are the main properties you’ll need to understand:

Enabled
Turn this off to disabled the raycast work.

Exclude Parent
This property causes the ray to ignore collisions with the parent object. Enabled by default.

Target Position
This is the destination point of the ray. Note: This is in local coordinates.

Also, take note of the Collide With section. By default the ray will only detect bodies, so you’ll need to go here if you want to detect areas as well or instead.

Useful functions
You can see the full list of the node’s functions in the API Documentation. Here are the some of the most useful ones:

is_colliding()
Boolean function, lets you know if the ray is colliding with something.

get_collision_point()
If the ray is colliding, this will return the position of the collision (in global coordinates).

get_collider()
If the ray is colliding, this function will return a reference to the colliding object.

get_collision_normal()
Another useful piece of information, this is the normal of the collided object at the point of collision.

Example uses
There are many uses for raycasts: visibility (can A see B, or is there an obstacle between?), proximity (am I close to a wall/ground/obstacle?), etc. Here are a couple of practical examples in use:

1. Shooting
Fast-moving projectiles often have the problem of “tunneling” through obstacles - they are moving too fast for the collision to be detected in a single frame. As an alternative, you can use a Raycast2D to represent the path (or a laser, etc.).

Here’s a player sprite with a raycast attached to the end of the gun. The target_position is set to (250, 0).

alt
When the player shoots, you check to see if the ray is colliding with something:

func _input(event):
    if event.is_action_pressed("shoot"):
        if $RayCast2D.is_colliding():
            print($RayCast2D.get_collider().name)
2. Edge detection
Consider a platformer enemy that walks on platforms, but you don’t want it to fall off the edges. Add two downward-pointing raycasts to the mob like so:

alt
In the mob’s script, check for when the ray stops colliding. That means you’ve found the edge and should turn around:

func _physics_process(delta):
    velocity.y += gravity * delta
    if not $RayRight.is_colliding():
        dir = -1
    if not $RayLeft.is_colliding():
        dir = 1
    velocity.x = dir * speed
    $AnimatedSprite.flip_h = velocity.x > 0
    velocity = move_and_slide(velocity, Vector2.UP)
Here’s what it looks like in action:




Tips, tricks, and tutorials on the 2D side of game development.

In this section:
Entering/Exiting the screen
Platform character
Screen wrap
Top-down movement
Grid-based movement
Shooting projectiles
Car steering
8-Directional Movement/Animation
Using Y-Sort
Coyote Time
Moving Platforms
Pathfinding on a 2D Grid
Multitarget Camera
Line2D Collision


ENTERING/EXITING THE SCREEN
Problem
You want to detect when an object enters or exits the screen.

Solution
The engine provides a node for this: VisibleOnScreenNotifier2D. Attach this node to your object, and you’ll be able to use its screen_entered and screen_exited signals. *

Example 1
Consider a projectile that travels in a straight line after it’s fired. If we continue firing, eventually we’ll have a large number of objects for the engine to track, event though they’re offscreen, which can cause lag.

Here’s the movement code for the projectile:

extends Area2D

var velocity = Vector2(500, 0)

func _process(delta):
    position += velocity * delta
To have the projectile automatically deleted when it moves offscreen, add a VisibleOnScreenNotifier2D and connect its screen_exited signal.

func _on_VisibleOnScreenNotifier2D_screen_exited():
    queue_free()
Example 2
We have an enemy that performs some actions, such as moving along a path or playing an animation. On a large map with many enemies, only a few of them will be onscreen at the same time. We can disable the enemy’s actions while it’s offscreen using VisibleOnScreenNotifier2D.

Partial code:

var active = false

func _process(delta):
    if active:
        play_animation()
        move()

func _on_VisibleOnScreenNotifier2D_screen_entered():
    active = true

func _on_VisibleOnScreenNotifier2D_screen_exited():
    active = false


PLATFORM CHARACTER
Problem
You need to make a 2D platform-style character.

Solution
New developers are often surprised at how complex a platform character can be to program. Godot provides some built-in tools to assist, but there are as many solutions as there are games. In this tutorial, we won’t be going in-depth with features like double-jumps, crouching, wall-jumps, or animation. Here we’ll discuss the fundamentals of platformer movement. See the rest of the recipes for other solutions.

 Tip
While it’s possible to use RigidBody2D to make a platform character, we’ll be focusing on CharacterBody2D. Kinematic bodies are well-suited for platformers, where you are less interested in realistic physics than in responsive, arcade feel.

Start with a CharacterBody2D node, and add a Sprite2D and CollisionShape2D to it.

Attach the following script to the root node of the character. Note that we’re using input actions we’ve defined in the InputMap: "walk_right", "walk_left", and "jump". See InputActions.

extends CharacterBody2D

@export var speed = 1200
@export var jump_speed = -1800
@export var gravity = 4000


func _physics_process(delta):
    # Add gravity every frame
    velocity.y += gravity * delta

    # Input affects x axis only
    velocity.x = Input.get_axis("walk_left", "walk_right") * speed

    move_and_slide()

    # Only allow jumping when on the ground
    if Input.is_action_just_pressed("jump") and is_on_floor():
        velocity.y = jump_speed
The values used for speed, gravity, and jump_speed depend greatly on the size of your player sprite. The player’s texture in this example is 108x208 pixels. If your sprite is smaller, you’ll want to use smaller values. We also want high values so that everything feels fast and responsive. A low gravity results in a floaty-feeling game while a high value means you’re quickly back on the ground and ready to jump again.

Note that we’re checking is_on_floor() after using move_and_slide(). The move_and_slide() function sets the value of this method, so it’s important not to check it before, or you’ll be getting the value from the previous frame.

Friction and acceleration
The above code is a great start, and you can use it as the foundation for a wide variety of platform controllers. One problem it has, though, is the instantaneous movement. For a more natural feel, it’s better if the character has to accelerate up to its max speed and that it coasts to a stop when there is no input.

One way to add this behavior is to use linear interpolation (“lerp”). When moving, we will lerp between the current speed and the max speed and while stopping we’ll lerp between the current speed and 0. Adjusting the lerp amount will give us a variety of movement styles.

 Tip
For an overview of linear interpolation, see Gamedev Math: Interpolation.

extends CharacterBody2D

@export var speed = 1200
@export var jump_speed = -1800
@export var gravity = 4000
@export_range(0.0, 1.0) var friction = 0.1
@export_range(0.0 , 1.0) var acceleration = 0.25


func _physics_process(delta):
    velocity.y += gravity * delta
    var dir = Input.get_axis("walk_left", "walk_right")
    if dir != 0:
        velocity.x = lerp(velocity.x, dir * speed, acceleration)
    else:
        velocity.x = lerp(velocity.x, 0.0, friction)

    move_and_slide()
    if Input.is_action_just_pressed("jump") and is_on_floor():
        velocity.y = jump_speed
Try changing the values for friction and acceleration to see how they affect the game’s feel. An ice level, for example, could use very low values, making it harder to maneuver.

alt
Conclusion
This code gives you a starting point for building your own platformer controller. For more advanced platforming features such as wall jumps, see the other recipes in this section.

 Download This Project
Download the project code here: https://github.com/godotrecipes/2d_platform_basic



SCREEN WRAP
Problem
You want to allow the player to “wrap around” the screen, teleporting from one side of the screen to the other. This is a common feature, especially in old-school 2D games (think Pac-man).

Solution
Get your screen (viewport) size

@onready var screen_size = get_viewport_rect().size
get_viewport_rect() is available to any CanvasItem derived node.

Compare your player’s position

if position.x > screen_size.x:
    position.x = 0
if position.x < 0:
    position.x = screen_size.x
if position.y > screen_size.y:
    position.y = 0
if position.y < 0:
    position.y = screen_size.y
Note that this is using the node’s position, which is usually the center of your sprite and/or body.

Simplifying with wrapf()

The above code can be simplified using GDScript’s wrapf() function, which “loops” a value between the given limits.

position.x = wrapf(position.x, 0, screen_size.x)
position.y = wrapf(position.y, 0, screen_size.y)



TOP-DOWN MOVEMENT
Problem
You’re making a 2D top-down game, and you want to control a character’s movement.

Solution
For this solution, we’ll assume you have the following input actions defined:

Action Name	Key(s)
"up"	W,↑
"down"	S,↓
"right"	D,→
"left"	A,←
"click"	Mouse button 1
We will also assume you’re using a CharacterBody2D node.

We can solve this problem in many ways, depending on what type of behavior you’re looking for.

Option 1: 8-way movement
In this scenario, the player uses the four directional keys to move (including diagonals).

extends CharacterBody2D

var speed = 400  # speed in pixels/sec

func _physics_process(delta):
    var direction = Input.get_vector("left", "right", "up", "down")
    velocity = direction * speed

    move_and_slide()
Option 2: Rotate and move
In this scenario, the left/right actions rotate the character and up/down move the character forward and back in whatever direction it’s facing. This is sometimes referred to as “Asteroids-style” movement.

extends CharacterBody2D

var speed = 400  # move speed in pixels/sec
var rotation_speed = 1.5  # turning speed in radians/sec

func _physics_process(delta):
    var move_input = Input.get_axis("down", "up")
    var rotation_direction = Input.get_axis("left", "right")
    velocity = transform.x * move_input * speed
    rotation += rotation_direction * rotation_speed * delta
    move_and_slide()
 Note
Godot considers an angle of 0 degrees to be pointing along the x axis. This means that a node’s forward direction (transform.x) is to the right. You should ensure that your character’s sprite is also drawn pointing to the right.

Option 3: Aim with mouse
Similar to option 2, but this time the character rotation is controlled with the mouse (ie the character always points towards the mouse). Forward/back movement is done with the keys as before.

extends CharacterBody2D

var speed = 400  # move speed in pixels/sec

func _physics_process(delta):
    look_at(get_global_mouse_position())
    var move_input = Input.get_axis("down", "up")
    velocity = transform.x * move_input * speed
    move_and_slide()
Option 4: Click and move
In this option, the character moves to the clicked location.

extends CharacterBody2D

var speed = 400  # move speed in pixels/sec
var target = null

func _input(event):
    if event.is_action_pressed("click"):
        target = get_global_mouse_position()

func _physics_process(delta):
    if target:
        # look_at(target)
        velocity = position.direction_to(target) * speed
        if position.distance_to(target) < 10:
            velocity = Vector2.ZERO
    move_and_slide()
Note that we stop moving if we get close to the target position. If you don’t do this, the character will “jiggle” back and forth as it moves a little bit past the target, moves back, goes a little past it, and so on. Optionally, you can use look_at() to face in the direction of movement.

 Download This Project
Download the project code here: https://github.com/godotrecipes/topdown_movement



GRID-BASED MOVEMENT
Problem
You need a 2D character that moves in a grid pattern.

Solution
Grid- or tile-based movement means the character’s position is restricted. They can only stand on a particular tile - never between two tiles.

Character setup
Here are the nodes we’ll use for the player:

Area2D (“Player”): Using an Area2D means we can detect overlap (for picking up objects or colliding with enemies).
Sprite2D: You can use a sprite sheet here (we’ll set up the animation below).
CollisionShape2D: Don’t make the hitbox too big. Since the player will be standing on the center of a tile, overlaps will be from the center.
RayCast2D: For checking if movement is possible in the given direction.
AnimationPlayer: For playing the character’s walk animation(s).
Add some input actions to the Input Map. We’ll use “up”, “down”, “left”, and “right” for this example.

Basic movement
We’ll start by setting up the tile-by-tile movement, without any animations or interpolation.

extends Area2D

var tile_size = 64
var inputs = {"right": Vector2.RIGHT,
            "left": Vector2.LEFT,
            "up": Vector2.UP,
            "down": Vector2.DOWN}
tile_size should be set to match the size of your tiles. In a larger project, this can be set by your main scene when instancing the player. We’re using 64x64 tiles in the example below.

The inputs dictionary maps the input action names to direction vectors. Make sure you have the names spelled the same here and in the Input Map (capitalization counts!).

func _ready():
    position = position.snapped(Vector2.ONE * tile_size)
    position += Vector2.ONE * tile_size/2
snapped() allows us to “round” the position to the nearest tile increment, and adding a half-tile amount makes sure the player is centered on the tile.

func _unhandled_input(event):
    for dir in inputs.keys():
        if event.is_action_pressed(dir):
            move(dir)

func move(dir):
    position += inputs[dir] * tile_size
Here’s the actual movement code. When an input event occurs, we check the four directions to see which one matched, then pass it to move() to change the position.

alt
Collision
Now we can add some obstacles. You can add StaticBody2Ds to manually add some obstacles (enable snapping to make sure they’re aligned with the grid) or use a TileMap (with collisions defined), as in the example below.

We’ll use the RayCast2D to determine whether a move to the next tile is allowed.

onready var ray = $RayCast2D

func move(dir):
    ray.target_position = inputs[dir] * tile_size
    ray.force_raycast_update()
    if !ray.is_colliding():
        position += inputs[dir] * tile_size
When changing a raycast’s target_position property, the physics engine won’t recalculate its collisions until the next physics frame. force_raycast_update() lets you update the ray’s state immediately. If it’s not colliding, then we allow the move.

alt
 Note
Another common method is to use 4 separate raycasts, one for each direction.

Animating movement
Lastly we can interpolate the position between tiles, giving a smooth feel to the movement. We’ll use the Tween node to animate the position property.


var animation_speed = 3
var moving = false
Add a reference to the Tween node and a variable to set our movement speed.

func _unhandled_input(event):
    if moving:
        return
    for dir in inputs.keys():
        if event.is_action_pressed(dir):
            move(dir)
We’ll ignore any input while the tween is running and remove the direct position change so that the tween can handle it.

func move(dir):
    ray.target_position = inputs[dir] * tile_size
    ray.force_raycast_update()
    if !ray.is_colliding():
        #position += inputs[dir] * tile_size
        var tween = create_tween()
        tween.tween_property(self, "position",
            position + inputs[dir] *    tile_size, 1.0/animation_speed).set_trans(Tween.TRANS_SINE)
        moving = true
        await tween.finished
        moving = false
alt
Experiment with different tween transitions for different movement effects.

 Download This Project
Download the project code here: https://github.com/godotrecipes/2d_grid_movement/



SHOOTING PROJECTILES
Problem
You want to shoot projectiles from your player/mob/etc..

Solution
Setting up the bullet
First, we’ll set up a “bullet” object that we can instance. Here are the nodes we’ll use:

 Area2D: Bullet
     Sprite2D
     CollisionShape2D
For the Sprite2D’s texture, you can use any image you like. Here’s an example one:

alt
Set up the nodes and configure the sprite and collision shape. If your texture is oriented pointing up, like the one above, make sure to rotate the Sprite node by 90° so that it’s pointing to the right, ensuring it matches the parent’s “forward” direction.

Add a script and connect the Area2D’s body_entered signal.

extends Area2D

var speed = 750

func _physics_process(delta):
    position += transform.x * speed * delta

func _on_Bullet_body_entered(body):
    if body.is_in_group("mobs"):
        body.queue_free()
    queue_free()
For this example, we’ll remove the bullet if it hits anything at all. We’ll also delete anything tagged in the “mobs” group that it hits.

Shooting
We need to set up a spawn location for the bullets. Add a Marker2D and place it where you want the bullets to spawn. Here’s an example, placed at the barrel of the gun. I’ve named it “Muzzle”.

alt
Notice that as the player rotates, the Muzzle’s transform remains oriented the same way relative to the gun. This will be very convenient when spawning the bullets, as they can use the transform to get the proper position and direction. We just set the new bullet’s transform equal to the muzzle’s.

 Tip
This will work for any character type, not just the “rotate-and-move” style shown here. Just attach the Marker2D where you want the bullets to spawn.

In the character’s script we add a variable to hold the bullet scene for instancing:

@export var Bullet : PackedScene
And check for our defined input action:

    if Input.is_action_just_pressed("shoot"):
        shoot()
Now in our shoot() function we can instance a bullet and add it to the tree. A common mistake is to add the bullet as a child of the player:

func shoot():
    var b = Bullet.instantiate()
    add_child(b)
    b.transform = $Muzzle.transform
The problem here is that since the bullets are children of the player, they are affected when the player moves or rotates.

alt
To fix this, we should make sure the bullets are added to the world instead. In this case, we’ll use owner, which refers to the root node of the scene the player is in. Note that we also need to use the muzzle’s global transform, or else the bullet would not be where we expected.

func shoot():
    var b = Bullet.instantiate()
    owner.add_child(b)
    b.transform = $Muzzle.global_transform
alt
Related recipes
Gamedev Math: transforms
 Download This Project
Download the project code here: https://github.com/godotrecipes/2d_shooting


CAR STEERING
Problem
You need to create a 2D top-down car controller.

Solution
When approaching this problem, beginners often wind up creating something that handles nothing like a real car. Some common mistakes you’ll find in amateur car games:

A car doesn’t rotate around its center. Put another way, a car’s rear wheels don’t slide side-to-side. (Unless it’s drifting, but we’ll talk about that later.)
A car can only turn when it’s moving - it can’t spin in place.
A car isn’t a train; it’s not on rails. Turning at high speeds should involve some sliding (drifting).
There are many approaches to 2D car physics, mainly depending on how “realistic” you want to be. For this solution, we’re going for an “arcade” level of realism, meaning we’ll prioritize action over realism.

 Note
The method below is based on the algorithm found here: http://engineeringdotnet.blogspot.com/2010/04/simple-2d-car-physics-in-games.html

The recipe below is broken into 5 parts, each adding a different feature to the car’s movement. Feel free to mix-and-match for your needs.

Scene setup
Here’s the car scene setup:

 CharacterBody2D
     Sprite2D
     CollisionShape2D
     Camera2D
Add whatever sprite texture you like. For this demo, we’ll use art from Kenney’s Racing Pack. CapsuleShape2D is a good choice for the collision, so that the car won’t have sharp corners to get caught on obstacles.

We’ll also use four input actions: “steer_right”, “steer_left”, “accelerate”, and “brake” - set them to whatever key inputs you prefer.

Part 1: Movement
The first step is to code the movement based on the algorithm described above.

Start with a few variables:

extends CharacterBody2D

var wheel_base = 70  # Distance from front to rear wheel
var steering_angle = 15  # Amount that front wheel turns, in degrees

var steer_direction
Set wheelbase to a value that works with your sprite.

steer_direction will be the amount that the wheels are turned.

 Note
Since we’re using keyboard controls, turning is all-or-nothing. If you’re using an analog joystick, you can instead vary this value based on the distance the stick moves.

func _physics_process(delta):
    get_input()
    calculate_steering(delta)
    move_and_slide()
Each frame, we need to check for input and calculate steering. Then we pass the resulting velocity to move_and_slide(). We’ll define those two function next:

func get_input():
    var turn = Input.get_axis("steer_left", "steer_right")
    steer_direction = turn * deg_to_rad(steering_angle)
    velocity = Vector2.ZERO
    if Input.is_action_pressed("accelerate"):
        velocity = transform.x * 500
Here we check for user input and set the velocity. Note: the speed of 500 is temporary so that we can test movement. We’ll address it in the next part.

Here is where we implement the algorithm from the link:

func calculate_steering(delta):
    # 1. Find the wheel positions
    var rear_wheel = position - transform.x * wheel_base / 2.0
    var front_wheel = position + transform.x * wheel_base / 2.0
    # 2. Move the wheels forward
    rear_wheel += velocity * delta
    front_wheel += velocity.rotated(steer_direction) * delta
    # 3. Find the new direction vector
    var new_heading = rear_wheel.direction_to(front_wheel)
    # 4. Set the velocity and rotation to the new direction
    velocity = new_heading * velocity.length()
    rotation = new_heading.angle()
Run the project and the car should move and turn. It’s still very unnatural though - the car starts and stops instantly. To fix that, we’ll add acceleration into the calculation.

Part 2: Acceleration
We’ll need another setting variable and one to track the car’s overall acceleration:

var engine_power = 900  # Forward acceleration force.

var acceleration = Vector2.ZERO
Change the input code to apply acceleration instead of directly changing the car’s velocity.

func get_input():
    var turn = Input.get_axis("steer_left", "steer_right")
    steer_direction = turn * deg_to_rad(steering_angle)
    if Input.is_action_pressed("accelerate"):
        acceleration = transform.x * engine_power
Once we’ve got our acceleration, we can apply it to the velocity like so:

func _physics_process(delta):
    acceleration = Vector2.ZERO
    get_input()
    calculate_steering(delta)
    velocity += acceleration * delta
    move_and_slide()
Now when you run, the car should gradually increase its speed. Careful: we don’t have any way to slow down yet!

Part 3: Friction/drag
A car experiences two different deceleration forces: friction and drag.

Friction is the force applied by the ground. It’s very high if driving on sand, but very low if driving on ice. Friction is proportional to velocity - the faster you’re going the stronger the force.

Drag is the force resulting from wind resistance. It’s based on the car’s cross-section - a large truck or van experiences more drag than a sleek race car. Drag is proportional to the velocity squared.

This means that friction is more significant when moving slowly, but drag becomes dominant at high speeds. We’ll add both of these forces to our calculation. As a bonus, the values of these quantities will also give our car a maximum speed - the point where the force from the engine can’t overcome the drag force any longer.

Here are our starting values for these quantities:

var friction = -55
var drag = -0.06
As you can see in this graph, these values mean that at a speed of 600 the drag force overcomes the friction force.

alt
You can play with the values here to see how they change: https://www.desmos.com/calculator/e4ayu3xkip

In _physics_process() we’ll call a function to calculate the current friction and apply it to the acceleration force.

func _physics_process(delta):
    acceleration = Vector2.ZERO
    get_input()
    apply_friction(delta)
    calculate_steering(delta)
    velocity += acceleration * delta
    velocity = move_and_slide(velocity)

func apply_friction(delta):
    if acceleration == Vector2.ZERO and velocity.length() < 50:
        velocity = Vector2.ZERO
    var friction_force = velocity * friction * delta
    var drag_force = velocity * velocity.length() * drag * delta
    acceleration += drag_force + friction_force
First, we’ll set a minimum speed. This will ensure that the car doesn’t keep creeping forward at very low speeds as friction never quite brings the velocity to zero.

Then we calculate the two forces and add them to the total acceleration. Since they’re both negative, they’ll affect the car in the opposite direction.


Part 4: Reverse/Brake
We’ll need two more settings variables:

var braking = -450
var max_speed_reverse = 250
Add the input to get_input():

    if Input.is_action_pressed("brake"):
        acceleration = transform.x * braking
This is fine for coming to a stop, but we also want to be able to put the car in reverse. Currently, that won’t work, because the acceleration is always being applied in the “heading” direction, which is forward. When we’re reversing, we need to accelerate backward.

func calculate_steering(delta):
    var rear_wheel = position - transform.x * wheel_base / 2.0
    var front_wheel = position + transform.x * wheel_base / 2.0
    rear_wheel += velocity * delta
    front_wheel += velocity.rotated(steer_angle) * delta
    var new_heading = (front_wheel - rear_wheel).normalized()
    var d = new_heading.dot(velocity.normalized())
    if d > 0:
        velocity = new_heading * velocity.length()
    if d < 0:
        velocity = -new_heading * min(velocity.length(), max_speed_reverse)
    rotation = new_heading.angle()
We can find whether we’re accelerating forward or backward using the dot product. If the two vectors are aligned, the result will be greater than 0. If the movement is in the opposite direction the car’s facing, then the dot product will be less than 0 and we must be moving backward.


Part 5: Drift/slide
We could stop here and you’d have a satisfactory driving experience. However, the car still feels like it’s “on rails”. Even at top speed, the turns are perfect, as if the tires have perfect “grip”.

At high speeds (or even low ones, if desired), the turning force should cause the tires to slip and result in a fishtailing/sliding motion.

var slip_speed = 400  # Speed where traction is reduced
var traction_fast = 2.5 # High-speed traction
var traction_slow = 10  # Low-speed traction
We’ll apply these values when calculating the steering. Currently, the velocity is instantly set to the new heading. Instead, we’ll use interpolation - lerp() - to cause it to only “turn” partway towards the new direction. The “traction” values will determine how “sticky” the tires are.

func calculate_steering(delta):
    var rear_wheel = position - transform.x * wheel_base / 2.0
    var front_wheel = position + transform.x * wheel_base / 2.0
    rear_wheel += velocity * delta
    front_wheel += velocity.rotated(steer_angle) * delta
    var new_heading = (front_wheel - rear_wheel).normalized()
    # choose which traction value to use - at lower speeds, slip should be low
    var traction = traction_slow
    if velocity.length() > slip_speed:
        traction = traction_fast
    var d = new_heading.dot(velocity.normalized())
    if d > 0:
        velocity = lerp(velocity, new_heading * velocity.length(), traction * delta)
    if d < 0:
        velocity = -new_heading * min(velocity.length(), max_speed_reverse)
    rotation = new_heading.angle()
Here, we select which traction value to use and apply lerp() to the velocity.


Adjustments
At this point, we have a large number of settings that control the car’s behavior. Adjusting them can drastically change how the car drives. To make experimenting with different values easier, download the project for this recipe below. When you run the game, you’ll see a set of sliders you can use to change the car’s behavior as you drive (press <Tab> to show/hide the slider panel).

alt
Related recipes
Gamedev Math: Interpolation
 Download This Project
Download the project code here: https://github.com/godotrecipes/2d_car_steering	


8-DIRECTIONAL MOVEMENT/ANIMATION
Problem
You need a 2D character that has 8-directional movement, including animation.

Solution
For our example, we’ll use the Isometric Mini-Crusader, which contains 8-directional animations for idle, run, attack, and several other states.

alt
The animations are organized in folders, with a separate image for each frame. We’ll use an AnimatedSprite2D and we’ll name each animation based on its direction. For example, idle0 pointing to the right and going clockwise to idle7.

When our character moves, it will pick an animation based on the direction of movement:

alt
We’ll use the mouse to move - the character will always face the mouse and run in that direction when we click the mouse button.

To choose which animation to play, we need to get the mouse direction and map it to this same range of 0-7. get_local_mouse_position() gives us the position of the mouse relative to the character. We can then use snappedf() to snap the angle of the mouse vector to the closest multiple of 45° (PI/4 radians) giving the following result:

alt
Divide each value by 45° (PI/4 radians), and we have:

alt
Finally, we need to map the resulting range to 0-7 using the wrapi() function, and we’ll have our correct values. Adding that value to the end of the animation name (“idle”, “run”, etc) gives us the correct animation:

func _physics_process(delta):
    current_animation = "idle"

    var mouse = get_local_mouse_position()
    angle = snappedf(mouse.angle(), PI/4) / (PI/4)
    angle = wrapi(int(angle), 0, 8)

    if Input.is_action_pressed("left_mouse") and mouse.length() > 10:
        current_animation = "run"
        velocity = mouse.normalized() * speed
        move_and_slide()
    $AnimatedSprite2D.animation = current_animation + str(a)
Testing the movement, we see this:

alt
Keyboard input
If you’re using keyboard controls instead of mouse, you can get the angle of movement based on which keys are being held. The rest of the process works in the same way.

func _process(delta):
    current_animation = "idle"
    var input_dir = Input.get_vector("left", "right", "up", "down")
    if input_dir.length() != 0:
        angle = input_dir.angle() / (PI/4)
        angle = wrapi(int(a), 0, 8)
        current_animation = "run"
    velocity = input_dir * speed
    move_and_slide()
    $AnimatedSprite2D.play(current_animation + str(angle))
 Download This Project
Download the project code here: https://github.com/godotrecipes/8_direction_animation


USING Y-SORT
Problem
Many 2D games use a “3/4 view” perspective, giving the impression that the camera is looking at the world at an angle. To make this work, objects that are “farther” away need to be rendered behind “nearer” objects. In practice, that means we want to “y-sort” - making the drawing order tied to the object’s y coordinate. The higher on the screen, the farther away and therefore lower the render order.

Here’s an example of the problem:

alt
These objects are being drawn in the default render order: tree order. They are arranged like this in the scene tree:

alt
Solution
Godot has a built-in option to change the render order: on any CanvasItem node (Node2D or Control), we can enable the Y Sort Enabled property. When this is enabled, all child nodes are then y-sorted.

In the above example, we can enable the property on the TileMap node. However, there’s still a problem:

alt
The draw order is based on each object’s y coordinate. By default, that is the object’s center:

alt
Since we want to give the impression that the objects are on the “ground”, we can solve this by offsetting each object’s sprite so that the object’s position is aligned with the bottom of the sprite:

alt
Now things look a lot better:

alt
 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/using_ysort


COYOTE TIME
Problem
Your platformer jumping feels “off”. Players don’t have good control and sometimes they “miss” jumping off the edge of platforms.

Solution
The answer to this problem is to use a technique called “coyote time”. This gives the player a greater feeling of control and a little “wiggle room” around the process of jumping from the edges of platforms.

“Coyote time” works like this:

If the player walks off the edge of a platform, for a few frames afterward, we still allow them to jump as if they were still on the ground.

 Origins
The name “coyote time” comes from the famous cartoon coyote, who wouldn’t fall until he looked down:

alt
We’re going to add this to an already existing platform character. See the Platform character recipe for how to set one up.

To handle the timing, we’ll add a Timer node called CoyoteTimer and set it to One Shot.

There are a few new variables we’ll need to keep track of coyote time:

var coyote_frames = 6  # How many in-air frames to allow jumping
var coyote = false  # Track whether we're in coyote time or not
var last_floor = false  # Last frame's on-floor state
Since we’re using frames to set the duration, we can translate that to time when setting the Timer’s length in _ready():

$CoyoteTimer.wait_time = coyote_frames / 60.0
Each frame we’ll store the current value of is_on_floor() to be used in the following frame, so put this in _physics_process() after the move_and_slide():

    last_floor = is_on_floor()
When we detect the jump input, we need to check if the character is on the floor or in coyote time:

    if Input.is_action_just_pressed("jump") and (is_on_floor() or coyote):
        velocity.y = jump_speed
        jumping = true
Coyote time begins if the player walks off the edge of a platform. That means that they are no longer on the floor, but were on the floor in the previous frame. We can check that like this, and start the timer if we did just transition from on- to off-floor:

    if !is_on_floor() and last_floor and !jumping:
        coyote = true
        $CoyoteTimer.start()
The CoyoteTimer tells us when the coyote state ends:

func _on_coyote_timer_timeout():
    coyote = false
 Implementing in 3D
You can apply the same process to 3d characters.

 Download This Project
The character in the Moving Platforms project has coyote time implemented.

Download the project code here: https://github.com/godotrecipes/2d_moving_platforms

Related recipes
Platform character


MOVING PLATFORMS
Problem
You need moving platforms in your 2D platformer.

Solution
There are several ways to approach this problem. In this recipe, we’ll use AnimatableBody2Ds for our platform and move it with a Tween. This allows for a variety of movement styles while minimizing the amount of code we need to write.

 Info
You can also implement this moving platform technique using an AnimationPlayer rather than a tween. Much of the setup will be the same, but rather than tween code, you’ll animate the body’s position property.

Setting up
We’ll start with a basic platformer setup using the Platform character recipe. The basic movement from that recipe will work fine with the platforms. If you’ve modified it or used your own, everything should still work the same.

Creating the platform
The platform scene contains the following nodes:

Node2D (“MovingPlatform”): The Node2D parent is there to act as the “anchor” or start point for the platform. We’ll animate the platform’s position relative to this parent node.
AnimatableBody2D: This represents the platform itself. This is the node that will move.
Sprite2D: You can use a sprite sheet here, individual images, or even a TileMap.
CollisionShape2D: Don’t make the hitbox too big, or the player will appear to be “hovering” off the edge of the platform.
Set up the Sprite2D’s Texture and the collision shape appropriately. In the AnimatableBody2D, set the Sync to Physics property “On”. Since we’re moving the body in code, this ensures that it’s moved during the physics step, keeping it in sync with the player and other physics bodies.

Now add a script to the root Node2D:

extends Node2D

@export var offset = Vector2(0, -320)
@export var duration = 5.0

func _ready():
    start_tween()

func start_tween():
    var tween = get_tree().create_tween().set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
    tween.set_loops().set_parallel(false)
    tween.tween_property($AnimatableBody2d, "position", offset, duration / 2)
    tween.tween_property($AnimatableBody2d, "position", Vector2.ZERO, duration / 2)
We’ve used a few of Tween’s options here to make everything work smoothly:

set_process_mode(): ensures that all movement takes place during the physics processing step.
set_loops(): this makes the tween repeat.
set_parallel(false): by default, all tween_property() changes would happen at that same time. This makes the two happen one after another: moving to one end of the offset, then back to the start.
Using the two exported properties, you can adjust the platform’s movement. Set the offset to determine where the tween moves relative to its starting point, and the duration to determine how long it takes to complete the cycle.

Add some platforms in your level/world and try them out:


 Download This Project
Download the project code here: https://github.com/godotrecipes/2d_moving_platforms

Related recipes
Platform character


PATHFINDING ON A 2D GRID
Problem
You have a grid-based environment and you’d like to set up pathfinding to allow navigation.

Solution
Godot provides a number of methods for pathfinding. For this recipe, we’ll consider the A* algorithm.

 About A*
A* is a widely-used algorithm for finding the shortest path between two points. It can be used in any graph-based data structure, not just a grid.

AStarGrid2D is a specialized version of Godot’s more generic AStar2D class. Because it’s specialized for using with a grid, it’s quicker and easier to set up because you don’t have to manually add all the individual grid cells and their connections.

Setting up the Grid
The most important configuration decision is the size of the cells and the size of the grid itself. We’ll use (64, 64) for this example, and we’ll use the window size to determine how many cells fit on the screen, but everything will work the same regardless of cell size.

Add this code to a Node2D.

extends Node2D

@export var cell_size = Vector2i(64, 64)

var astar_grid = AStarGrid2D.new()
var grid_size

func _ready():
    initialize_grid()

func initialize_grid():
    grid_size = Vector2i(get_viewport_rect().size) / cell_size
    astar_grid.size = grid_size
    astar_grid.cell_size = cell_size
    astar_grid.offset = cell_size / 2
    astar_grid.update()
In this code, we divide the size of the screen by the cell_size to calculate how big the whole grid will be. This lets us set the size property of the AStarGrid2D.

The offset property will come into play when we ask for a path between two points. Using cell_size / 2 means the path will be calculated from the center of each cell rather than the corners.

Finally, we need to call update() after setting or changing any of the AStarGrid2D’s properties.

Drawing the Grid
For the purposes of this demo, we’ll draw the grid on the screen in code. In a game application, you’ll probably have a TileMap or some other visual representation of your world.

Here’s some code to draw the grid:

func _draw():
    draw_grid()

func draw_grid():
    for x in grid_size.x + 1:
        draw_line(Vector2(x * cell_size.x, 0),
            Vector2(x * cell_size.x, grid_size.y * cell_size.y),
            Color.DARK_GRAY, 2.0)
    for y in grid_size.y + 1:
        draw_line(Vector2(0, y * cell_size.y),
            Vector2(grid_size.x * cell_size.x, y * cell_size.y),
            Color.DARK_GRAY, 2.0)
This gives us a nice visual of the grid:

alt
Drawing the Path
In order to find a path, we need a start and end point. Add these variables at the top of the script:

var start = Vector2i.ZERO
var end = Vector2i(5, 5)
And a couple of lines in _draw() to show them:

    draw_rect(Rect2(start * cell_size, cell_size), Color.GREEN_YELLOW)
    draw_rect(Rect2(end * cell_size, cell_size), Color.ORANGE_RED)
We can find the path between the two points using the get_point_path() method, but we also need to visualize it. We can use a Line2D, so add one to the scene.

Here’s how we can get the path, and add the resulting points to the Line2D:

func update_path():
    $Line2D.points = PackedVector2Array(astar_grid.get_point_path(start, end))
Here’s the result:

alt
Note that we have a diagonal line between the two points. This is because, by default, the path will use diagonals. This can be modified by changing the diagonal_mode:

DIAGONAL_MODE_ALWAYS - The default value, uses diagonals.
DIAGONAL_MODE_NEVER - All movement is orthogonal.
DIAGONAL_MODE_AT_LEAST_ONE_WALKABLE - This allows diagonals, but prevents the path going “between” diagonally placed obstacles.
DIAGONAL_MODE_ONLY_IF_NO_OBSTACLES - This allows diagonals only in “open” areas, not near obstacles.
Modifying this property can give you very different results, so make sure to experiment based on your setup. Let’s add this in the initialize_grid() function:

astar_grid.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_NEVER
Now we only have orthogonal moves:

alt
Adding Obstacles
We can also add obstacles to the grid. By marking a cell as “solid”, the path will not include that cell. A cell can be toggled solid/not solid by using the set_point_solid() function.

Let’s add some code to draw our walls (when they exist), by finding any solid cells and coloring them in:

func fill_walls():
    for x in grid_size.x:
        for y in grid_size.y:
            if astar_grid.is_point_solid(Vector2i(x, y)):
                draw_rect(Rect2(x * cell_size.x, y * cell_size.y, cell_size.x, cell_size.y), Color.DARK_GRAY)
Call this function in _draw().

Then, we can use the mouse to click on cells and toggle their state:

func _input(event):
    if event is InputEventMouseButton:
        # Add/remove wall
        if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
            var pos = Vector2i(event.position) / cell_size
            if astar_grid.is_in_boundsv(pos):
                astar_grid.set_point_solid(pos, not astar_grid.is_point_solid(pos))
            update_path()
            queue_redraw()
Note that we’re checking is_in_boundsv() first - this will prevent errors from being thrown if we click outside the grid boundaries.

Now we can see the effect of obstacles on the path:

alt
Choosing a Heuristic
A big factor that affects the resulting path is what heuristic you choose to use. The term “heuristic” refers to a “best guess”, and in the context of pathfinding just means: what direction should we try first when moving toward the goal?

For example, the Euclidean distance uses the Pythagorean theorem to estimate the path to try:

alt
While Manhattan distance only considers distance in N/S or E/W directions:

alt
And the Octile heuristic results in a path like this:

alt
You can choose the heuristic using this property:

astar_grid.default_estimate_heuristic = AStarGrid2D.HEURISTIC_OCTILE
Which of these works best (results in the most pleasing paths) depends on the nature of your environment. Is it mostly wide-open spaces with few obstacles scattered around? Or is it a maze of twisty passages? Make sure to experiment with your specific project.

Download the example project below to experiment with this setup yourself. In addition to placing walls, you can use the right/middle mouse buttons to move the end/start locations.

 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/grid_pathfinding


MULTITARGET CAMERA
Problem
You need a dynamic camera that moves and zooms to keep multiple objects on screen at the same time.

An example might be in a 2 player game, keeping both players on-screen as they move farther and closer together, like so:

alt
Solution
In a single-player game, you’re probably used to attaching the camera to the player, so that it automatically follows them. We can’t really do this here because we have 2 (or more) players or other game objects that we want to keep on the screen at all times.

We need our camera to do 3 things:

Add/remove any number of targets.
Keep the camera’s position centered at the midpoint of the targets.
Adjust the camera’s zoom to keep all targets on screen.
Create a new scene with a Camera2D and attach a script. We’ll add this camera to our game once we’re done.

Let’s break down how the script works.

 Note
You can see the full script at the end of the article.

Here’s how the script starts:

extends Camera2D

@export var move_speed = 30 # camera position lerp speed
@export var zoom_speed = 3.0  # camera zoom lerp speed
@export var min_zoom = 5.0  # camera won't zoom closer than this
@export var max_zoom = 0.5  # camera won't zoom farther than this
@export var margin = Vector2(400, 200)  # include some buffer area around targets

var targets = []  # Array of targets to be tracked.

@onready var screen_size = get_viewport_rect().size
These settings will let you adjust the camera’s behavior. We’ll lerp() all camera changes, so setting the move/zoom speeds to lower values will introduce some delay in the camera “catching up” to sudden changes.

Maximum and minimum zoom values will also depend on the size of objects in your game and how close or far you want to get. Adjust to suit.

The margin property is going to add some extra space around the targets so they’re not right on the edge of the viewable area.

Lastly, we have our array of targets and we get the viewport size so that we can properly calculate the scale.

func add_target(t):
    if not t in targets:
        targets.append(t)

func remove_target(t):
    if t in targets:
        targets.erase(t)
For adding and removing targets, we have two helper functions. You can use these during gameplay to change what targets are being tracked (“Player 3 has entered the game!”). Note that we don’t want to have the same target tracked twice, so we reject it if it’s already there.

Most of the functionality happens in _process(). First, moving the camera:

func _process(delta):
    if !targets:
        return
    # Keep the camera centered between the targets
    var p = Vector2.ZERO
    for target in targets:
        p += target.position
    p /= targets.size()
    position = lerp(position, p, move_speed * delta)
Here, we loop through the targets’ positions and find the common center. Using lerp() we make sure it moves there smoothly.

Next, we’ll handle the zoom:

# Find the zoom that will contain all targets
var r = Rect2(position, Vector2.ONE)
for target in targets:
    r = r.expand(target.position)
r = r.grow_individual(margin.x, margin.y, margin.x, margin.y)
var z
if r.size.x > r.size.y * screen_size.aspect():
    z = 1 / clamp(r.size.x / screen_size.x, min_zoom, max_zoom)
else:
    z = 1 / clamp(r.size.y / screen_size.y, min_zoom, max_zoom)
zoom = lerp(zoom, Vector2.ONE * z, zoom_speed)
The key functionality here comes from Rect2. We want to find a rectangle that encloses all the targets, which we can get with the expand() method. We then grow the rect by the margin.

Here you can see the rectangle being drawn (press “Tab” in the demo project to enable this drawing):

alt
Then, depending whether the rectangle is wider or taller (relative to the screen’s aspect ratio), we find the scale and clamp it in the max/min range we’ve defined.

Full script
extends Camera2D

@export var move_speed = 30 # camera position lerp speed
@export var zoom_speed = 3.0  # camera zoom lerp speed
@export var min_zoom = 5.0  # camera won't zoom closer than this
@export var max_zoom = 0.5  # camera won't zoom farther than this
@export var margin = Vector2(400, 200)  # include some buffer area around targets

var targets = []

@onready var screen_size = get_viewport_rect().size

func _process(delta):
    if !targets:
        return

    # Keep the camera centered among all targets
    var p = Vector2.ZERO
    for target in targets:
        p += target.position
    p /= targets.size()
    position = lerp(position, p, move_speed * delta)

    # Find the zoom that will contain all targets
    var r = Rect2(position, Vector2.ONE)
    for target in targets:
        r = r.expand(target.position)
    r = r.grow_individual(margin.x, margin.y, margin.x, margin.y)
    var z
    if r.size.x > r.size.y * screen_size.aspect():
        z = 1 / clamp(r.size.x / screen_size.x, max_zoom, min_zoom)
    else:
        z = 1 / clamp(r.size.y / screen_size.y, max_zoom, min_zoom)
    zoom = lerp(zoom, Vector2.ONE * z, zoom_speed * delta)

    # For debug
    get_parent().draw_cam_rect(r)

func add_target(t):
    if not t in targets:
        targets.append(t)

func remove_target(t):
    if t in targets:
        targets.remove(t)
 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/multitarget_camera


LINE2D COLLISION
Problem
You want to have collisions with a Line2D.

Solution
Node setup
Add the following nodes to your scene, and draw your line as desired:

 Line2D
     StaticBody2D
Don’t add a collision shape to the body yet!

 Note
You can use an Area2D instead if you want to detect overlap with the line rather than collision.

Next, we need to add collision shapes to the body. We have two options:

Option 1: Using SegmentShape2D
SegmentShape2D is a line-segment collision shape. The idea here is to create a segment collision for each pair of points in the line.

extends Line2D

func _ready():
    for i in points.size() - 1:
        var new_shape = CollisionShape2D.new()
        $StaticBody2D.add_child(new_shape)
        var segment = SegmentShape2D.new()
        segment.a = points[i]
        segment.b = points[i + 1]
        new_shape.shape = segment
Option 2: Using RectangleShape2D
SegmentShape2D does not have any width component, so if you need your line collision to have a thickness, you can use a rectangle collision instead.

extends Line2D

func _ready():
    for i in points.size() - 1:
        var new_shape = CollisionShape2D.new()
        $StaticBody2D.add_child(new_shape)
        var rect = RectangleShape2D.new()
        new_shape.position = (points[i] + points[i + 1]) / 2
        new_shape.rotation = points[i].direction_to(points[i + 1]).angle()
        var length = points[i].distance_to(points[i + 1])
        rect.extents = Vector2(length / 2, width / 2)
        new_shape.shape = rect
 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/line2d_collision

Tips, tricks, and tutorials on the 3D side of game development.

In this section:
Working with 3D Assets
Basic FPS Character
Camera Gimbal
Interpolated Camera
Shooting with Raycasts
CharacterBody3D: Movement
3D Unit Healthbars
Rolling Cube
Arcade-style Spaceship
Arcade-style Airplane
Arcade-style Car
Click to move
Smooth rotation
CharacterBody3D: Align with Surface


 WORKING WITH 3D ASSETS
Detailed recipes for importing and working with 3D assets including models, animations, and materials.

For these examples, we’ll be using the following 3d assets from Kay Lousberg:

Adventurers Character Pack
Dungeon Asset Pack
In this section:
Importing Assets
Character Animation
Character Controller

IMPORTING ASSETS
Problem
You’ve downloaded (or created) a set of 3D assets, including rigged and animated characters, and you want to import it into Godot.

Solution
For this example, we’ll assume you’ve downloaded the art packs linked in the section description and unzipped them.

Before copying the files into your Godot project, notice that there are multiple versions of the assets in different file formats: OBJ, FBX, and GLTF. There are also some extra files such as examples and separate textures in case you want to modify them. We don’t need all of that, and GLTF is the preferred import format for Godot. So make sure you’re only dragging the gltf folder or .gltf files (or .glb, which is the binary version of the same) into your project folder.

Here, I’ve taken the gltf folder from the “Dungeon” pack and the characters folder from the “Adventurers” pack and dragged them into my project.

 Note
There are a lot of files in the Dungeon pack - Godot may take a little time to read them all!

Importing a Character
Select the knight.glb file in the FileSystem tab, then click the Import tab at the top left.

alt
Here you’ll find some basic import settings, but we can go into more detail. Click Advanced button and you’ll see a new window appear:

alt
One the left you’ll see all the data that is contained in the GLTF scene, including textures and animations. Note all the weapon options attached to the character and the extensive list of animations.

There’s a preview of the character in the middle, and a set of options on the right side where you can adjust how the selected item is configured.

Since we will code our player as a CharacterBody3D, we can go ahead and specify that node type here. Click on the Scene Root and on the right set the Root Type to CharacterBody3D.

Animations
Scroll down to the list of animations. You’ll see that there are many, but while some we’ll only want to play once, such as attacks, others like “Idle” and “Running”, we’d like to be looping. For any animation like this, select the animation name and set the Loop Mode to “Linear”. Do this for all of the “Walking”, “Running”, and “Idle” variations. When you’re done, click the Reimport button at the bottom.

alt
 Setting Loop Automatically
If you are making your own characters, you can skip this step by ensuring that your animations’ names end with "-loop". For details on this and other import hints, see Import Hints in the Godot documentation.

Right click knight.glb in the FileSystem and choose New Inherited Scene.

In this scene you’ll see all the models and the AnimationPlayer where you can test out the animations.

Importing World Items
Importing objects for the environment will be a similar process. As an example, let’s use one of the dungeon walls. There are a lot of files in the dungeon pack, so type “wall” in the file filter to help find it:

alt
We’ll want our dungeon walls to be solid, and it would be painful to manually create a StaticBody3D and collision shape for each one. Fortunately, when importing, Godot can do this for us.

In the import window, select the mesh object. On the right side, check the Physics box, and set the Shape Type to “Simple Convex” (feel free to check out the other options too).

alt
Click Reimport. Now when using this in the game, Godot will automatically create a StaticBody3D with a collision shape to match.

 Automating Collision Shapes
As above, there is an import hint for collision shapes as well. In your Blender project, appending -col (or some other variations) will let the importer know to do this step automatically. See the import hints link for details.

Automating Imports
While adding import hints is the preferred method when making your own assets, it’s not something you can do when downloading an asset pack like the one we’re using.

It is possible to write an import script that can run on every imported node of a particular type. For example, we could automate the creation of the static collision we did above.

As an example, the following script will loop through all the nodes of the imported object and create a static collision on each mesh it finds.

@tool
extends EditorScenePostImport

func _post_import(scene):
    iterate(scene)
    return scene

func iterate(node):
    if node != null:
        if node is MeshInstance3D:
            node.create_trimesh_collision()
        for child in node.get_children():
            iterate(child)
In the Import tab, you can set this as the Import Script, and when you click Reimport, the collisions will be created.

Wrapping up
That concludes the overview of importing 3D assets into Godot.

See the section description for examples of working with the 3D assets you’ve imported.

Companion Video


CHARACTER ANIMATION
Problem
You’ve got a rigged, animated 3D character (either made by you or downloaded from a third party) and you want to set up its animations in Godot.

Solution
In this recipe, we’ll assume you’ve already imported your character model and animations. If you haven’t yet, see Importing Assets for details. As a reminder, we’re using the art packs linked in the section description.

Prepping the character
We’ve chosen CharacterBody3D for our character, so your scene should look like this (I’ve collapsed the Rig node since the mesh list is so long):

alt
The first thing you probably noticed is that the character’s hands are full! The artist has helpfully provided all the weapons & shields attached and oriented at the correct points. You can go down the list and hide the ones you don’t want to see.

alt
About the AnimationTree
With all of the animations we have available, it’s going to quickly get very complicated to handle all of them in code. Think about how many if statement’s we’d need to decide which animation to play at which time, depending on what the player is doing. While this is not bad if you only have a few animations, it quickly gets out of hand and becomes impractical.

Also, consider when the character is standing still: it should be playing the “Idle” animation. When the player presses “forward”, the character should move and switch to playing the “Walking” animation. This sudden transition is going to look jarring, so we’d prefer if the two animations can be “blended” into a smoother transition.

The solution to these complex animation issues is to use the AnimationTree node. This node is designed to control an AnimationPlayer and has functionality to control how animations transition and blend together.

Add an AnimationTree to the scene. In the Inspector, set Tree Root to a new AnimationNodeStateMachine, in Anim Player select the character’s AnimationPlayer node, and check the box next to Active.

alt
 Note
You may notice that when the AnimationTree is active, you can’t choose animations in the AnimationPlayer. If you need to make any changes or test the animations, uncheck the tree’s Active property while doing so.

The Idle/Walk/Run Cycle
There are a lot of animations provided with these models. For this example, we’re going to focus on the idle-walk-run cycle, jumping, and attacking. If you want to include other animations, they’ll be handled in a similar way.

In the AnimationPlayer, find the “Idle”, “Running_A”, “Walking_Backwards”, and “Running_Strafe_Left”/“Running_Strafe_Right” animations. Make sure they’re all set to loop - you can test them by pressing the “Play” button: (▶). If any of them are not, reimport the character after setting them (see Importing Assets).

Select the AnimationTree node and you’ll see the panel open at the bottom of the window:

alt
As an example, right-click in the empty space and choose Add Animation → Idle, then add the “1H_Melee_Attack_Chop” animation as well.

Select the Connect Nodes button and draw a connection from Start to Idle. You should immediately see the “Idle” animation playing.

Now, we want to be able to transition from idle to attack and then back to idle when the attack animation finishes. Draw two more connection arrows to and from the attack. It won’t quite work, however, you’ll just be rapidly flickering between the two animations, because both are set to immediately transition.

To change the transition conditions, change to Select mode using the icon and then click on one of the connections. In the Inspector, you’ll see the connection properties. For the connection from idle to attack, we want Advance/Mode to be “Enabled” (not “Auto”). This means it happens only when told to. Notice that the icon on the connection line changes color.

For the connection from attack to idle, set Switch Mode to “At End” and Advance Mode to “Auto”.

Now, when you press the ▶ button on the attack node, it will play and then transition back to idle as soon as it completes.

This gives you an idea how to set up different animations and transition between them. However, we want to do a little more here, so delete the two animations using the trash can icon, and let’s set up a blendspace.

Blendspaces
Right-click in the empty space to create a new BlendSpace2D. Click on its name to rename it to IWR (for idle-walk-run). Add a transition from Start so that the blendspace will start playing automatically.

Click the pencil icon to edit the blend space.

alt
This 2D space represents the character’s horizontal movement vector. When standing still that’s (0, 0), so click the Create Points button and click in the center of the grid to Add Animation → Idle.

At the center-top, add the “Running_A” animation, and center-bottom, “Walking_Backwards”. At the two horizontal ends, add the strafe animations.

alt
Now click the crosshair button to set the blend position and click to drag it around the grid. You should see the animations transition smoothly between the extremes.


When you’re done experimenting with the blendspace, click “Root” in the Path at the top of the panel to return to the root of the tree.

Setting up the state machine
The IWR looping animations can be thought of as the “heart” of the animation tree. The character will spend most of its time playing these animations. Any other animations will branch off from it (like we did earlier with the attack).

In the image below, I’ve done that with several other animations. Note the transition properties are set as we did in the example above.

alt
You can also click to change the names the animations, as some of them are quite long.

The one animation that’s different is jumping. The jump animation is split into three parts: “start"and “land”, which are played when the character starts jumping, and when the jump ends. The “idle” portion of the jump is a looping animation that plays as long as the character is in the air - if they fall a long way, for example.

Add the three jumping animations and link them like this:

alt
We need to be able to go straight from IWR to Jump_Idle in the event of falling off a ledge, but if pressing “jump”, we’ll go through Jump_Start first.

In addition, we’ve left the transition from IWR to Jump_Start as “Auto”. Instead of changing it to “Enabled”, we’ve added a Condition of jumping to the transition:

alt
Similarly, the transition between Jump_Idle and Jump_Land has a condition of grounded.

We’ll be able to set these conditions in code to trigger the transition.

Finally, if you’re looking closely, you may notice that the transition from Jump_Land to IWR does not look smooth, because the last frame and first frame of the two animations don’t quite match up. We can solve this by selecting the transition between them and setting a small Xfade Time of 0.1, which will smooth it out nicely.

Wrapping up
We’ve now set up our 3D character’s animations and they’re ready to use. By setting up the AnimationTree, it will now be much easier to select and transition between animations in the character’s movement code.

See the section description for more examples of working in 3D and for example Godot projects you can download.

Companion Video

https://youtu.be/YrNQCB34PAc

CHARACTER CONTROLLER
Problem
You’ve imported a rigged, animated 3D character in Godot and set up its animations using AnimationTree. Now you need to implement movement: you need a character controller.

Solution
In this recipe, we’ll assume you’ve already imported your character model and animations, and that you’re set up AnimationTree to handle transitioning and blending the animations. If you haven’t yet, see Importing Assets and Character Animation for details. As a reminder, we’re using the art packs linked in the section description.

Adding collision
We’ve chosen CharacterBody3D as the root node of the imported scene, and it’s complaining about a missing collision shape, so let’s fix that first. Add a CollisionShape3D child and choose CapsuleShape3D as its Shape property.

Size and position the capsule to enclose the character’s body. For reference, here are the values I used:

alt
Note that the imported rig is positioned so that its feet are on the “ground”, ie at the body’s position. This will be helpful later, as the player’s position will represent its position on the ground, rather than floating in mid-air if it were at the center of its body.

If you’re familiar with Godot’s 3D orientation, you’ll also notice that the character is facing the +Z direction, which is backwards. Select the Skeleton3D node and set its Y Rotation to 180 to correct this.

Input actions
In the Input Map, we’re using the following inputs: forward, back, left, right, and jump. Assign them to whatever keys/buttons you prefer.

Camera
There are many ways to handle a 3D camera that follows the player. For this example, we’ll use a SpringArm3D as the camera “mount”.

The SpringArm3D node works by casting a ray and then moving its children to the collision point. Using this for a camera means nothing can get between the camera and the player, and we can implement zoom by varying this length.

Add one as a child of the root node, and then add a Camera3D as a child of that.

In the spring arm’s properties, set Spring Length to 5, the Margin to 0.1, and the Position to (0, 2.5, 0).

We don’t want the spring arm to collide with the player’s capsule shape, so in the root CharacterBody3D set the collision layer to 2. Since the spring arm is checking collision layer 1, that will prevent the camera hitting the player’s head.

 Collision Layers
Eventually, we’ll want to organize our collision layers for various game objects: player, environment, enemies, etc.

Movement
Now we are ready to add a script to the player. We’ll start with the variables we’ll need:

extends CharacterBody3D
class_name Knight

@export var speed = 5.0
@export var acceleration = 4.0
@export var jump_speed = 8.0

var gravity = ProjectSettings.get_setting("physics/3d/default_gravity")
var jumping = false
And then, some references to the nodes we’ll need to access:

@onready var spring_arm = $SpringArm3D
@onready var model = $Rig
@onready var anim_tree = $AnimationTree
@onready var anim_state = $AnimationTree.get("parameters/playback")
We’ll use the anim_tree reference to set the blend position for the Idle/Walk/Run blendspace and the trigger conditions for jumping. Select the AnimationTree and you can see these properties in the Inspector:

alt
anim_state is a reference to the animation state machine, which we can use to call transitions between animations. See the Character Animation recipe for how we set these up.

Movement is a matter of getting the player’s input and calling move_and_slide():

func _physics_process(delta):
    velocity.y += -gravity * delta
    get_move_input(delta)

    move_and_slide()
The player’s input should be applied to the horizontal motion only (X and Z axes), since gravity is acting on the Y axis. For that reason, we’ll temporarily zero out the velocity.y, set the input, and then restore the value when we’re done.

Note that we’re rotating the input vector using the camera’s rotation - our character is going to move forward in whatever direction the camera is facing.

func get_move_input(delta):
    var vy = velocity.y
    velocity.y = 0
    var input = Input.get_vector("left", "right", "forward", "back")
    var dir = Vector3(input.x, 0, input.y).rotated(Vector3.UP, spring_arm.rotation.y)
    velocity = lerp(velocity, dir * speed, acceleration * delta)
    velocity.y = vy
Before we do anything else, this is a good point to test things out. You can make a quick test scene with a big StaticBody3D for the ground, or start making a scene using the dungeon pack assets.

You should be able to move forward/back/left/right (without any animations yet).

Camera Control
Now let’s get the camera working. We want to control the camera with mouse movement. We’ll add a variable that lets us adjust the sensitivity.

@export var mouse_sensitivity = 0.0015
Then, we want to detect mouse motion and rotate the spring arm accordingly. Rotating the arm around the X axis tilts it up and down (using the mouse’s y motion), and rotating it around Y changes its facing direction (using the mouse’s x motion). We also clamp the camera’s tilt so that it doesn’t go too far up/down.

func _unhandled_input(event):
    if event is InputEventMouseMotion:
        spring_arm.rotation.x -= event.relative.y * mouse_sensitivity
        spring_arm.rotation_degrees.x = clamp(spring_arm.rotation_degrees.x, -90.0, 30.0)
        spring_arm.rotation.y -= event.relative.x * mouse_sensitivity
Try it out and you should see when pressing “forward”, the character moves in the direction the camera faces.

Now we need to rotate the character so they face in the direction of movement.

We’ll add a variable for the rotation speed, so that we don’t snap instantly to the new heading.

@export var rotation_speed = 12.0
And then add this in _physics_process(), after move_and_slide():

    if velocity.length() > 1.0:
        model.rotation.y = lerp_angle(model.rotation.y, spring_arm.rotation.y, rotation_speed * delta)
Using lerp_angle() ensures we’ll always rotate the shortest direction to the new angle (rather than going the long way around from a 359° rotation to a 1° rotation, for example).

IWR Animations
Now that we have movement and rotation, we need to choose animations. The idea is to take the character’s horizontal velocity (the x/z movement) and use it to set the blend position in the IWR blendspace we created.

In get_move_input(), we’re setting the player’s velocity. Just after that, we can set the blend position:

    velocity = lerp(velocity, dir * speed, acceleration * delta)
    var vl = velocity * model.transform.basis
    anim_tree.set("parameters/IWR/blend_position", Vector2(vl.x, -vl.z) / speed)
Since velocity is in global space, but the character model is rotating, we need to transform velocity into model space using the model’s basis. Once we have that, we need to map that 3D vector to the 2D vector of the blend space, dividing by speed so that we’ll get values between -1 and 1. Also, -z is forward, but +y represents the blendspace forward animation, so we negate the value to make them match.

Note that you can get that parameter path by looking at the Inspector for the AnimationTree - you can even drag it into the script window to fill it in.

Attacks
We can handle attacks by first adding an input action called "attack", which I’ve assigned to the left mouse button.

Since we have 3 separate attacks in the AnimationTree, we’ll make a list of them:

var attacks = [
    "1h_slice_diagonal",
    "1h_slice_horizontal",
    "1h_attack_chop"
]
Then, in _unhandled_input(), pick a random animation from the list when the action is pressed:

    if event.is_action_pressed("attack"):
        anim_state.travel(attacks.pick_random())
Jumping
Jumping is a little bit more involved, because it involves three separate animations. As a reminder, this is how we set up the state machine:

alt
First, we want to transition to the “Jump_Start” animation by setting jumping = true. This triggers the transition in the state machine.

    if is_on_floor() and Input.is_action_just_pressed("jump"):
        velocity.y = jump_speed
        jumping = true
        anim_tree.set("parameters/conditions/grounded", false)
    anim_tree.set("parameters/conditions/jumping", jumping)
Next, we need to know when we touch the ground, so we can transition out of the “Jump_Idle” animation. To do this, we need to keep track of our grounded status by comparing it with the previous frame. Add a new variable at the top:

var last_floor = true
And then this if statement after the first one above:

    # We just hit the floor after being in the air
    if is_on_floor() and not last_floor:
        jumping = false
        anim_tree.set("parameters/conditions/grounded", true)
    last_floor = is_on_floor()
Finally, there’s the direct transition to “Jump_Idle” that happens if we step off a ledge:

    # We're in the air, but we didn't jump
    if not is_on_floor() and not jumping:
        anim_state.travel("Jump_Idle")
        anim_tree.set("parameters/conditions/grounded", false)
Wrapping up
We’ve now got a functional, controllable character with a chase camera and multiple animations. What’s next?

See the section description for more examples of working in 3D and for example Godot projects you can download.

Companion Video


BASIC FPS CHARACTER
Problem
You need to make a first-person shooter (FPS) character.

Solution
Start with a CharacterBody3D node, and add a CollisionShape3D to it. The CapsuleShape3D collision shape is the most common choice. Depending on your world setup, you may want to add additional shapes here, but for the purposes of this example, we’ll stick to the basics.

We’ll leave all the sizing at the default values, meaning the capsule will be 2 meters high. Move it up by 1.0 m to align its bottom with the ground.

Next, add a Camera3D as a child of the body and move it up about 1.6 m.

 Where’s the body?
For this example, we’ll leave the character “bodyless” - meaning we’re not adding a mesh to display for the player’s body. Depending on your setup, you may or may not need to see the player’s body.

Attach a script to the body and start by defining some properties:

extends CharacterBody3D

var gravity = ProjectSettings.get_setting("physics/3d/default_gravity")
var speed = 5
var jump_speed = 5
var mouse_sensitivity = 0.002
The _physics_process() function is the place to handle movement. Note that Input.get_vector() returns a 2-dimensional vector based on the combination of the forward/back/left/right keys. We want to use this vector to set the x and z components of the body’s velocity (because y is handled by gravity). Multiplying this vector by the body’s basis ensures we account for rotation - forward should always be the body’s forward vector.

func _physics_process(delta):
    velocity.y += -gravity * delta
    var input = Input.get_vector("left", "right", "forward", "back")
    var movement_dir = transform.basis * Vector3(input.x, 0, input.y)
    velocity.x = movement_dir.x * speed
    velocity.z = movement_dir.z * speed

    move_and_slide()
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        velocity.y = jump_speed
Don’t forget to add the input actions to your Input Map using the keys/inputs you prefer (W/A/S/D is typical, or you can use joystick axes if you prefer a controller).

Add the player to a “World” scene where you’ve created some StaticBody3D nodes for the floor and some walls.

When you try to move, you’ll notice you can move forward/back and left/right, but you can’t rotate. That’s what we’ll handle next.

Mouse control in 3D
First, we need the player to rotate left/right when we move the mouse the same way. Mouse input is represented in 2D, relative to the screen, so we need the x movement of the mouse to rotate the player’s body around its y (vertical) axis. The mouse_sensitivity property we defined above lets us adjust how many pixels of mouse movement translate to a degree of rotation.

func _input(event):
    if event is InputEventMouseMotion:
        rotate_y(-event.relative.x * mouse_sensitivity)
Try the code again, and you’ll see that you can now rotate with the mouse. However, you may find your mouse running outside the game window. This is the perfect time to add some code to capture your mouse. See Input: Capturing the Mouse for details.

Our updated code then becomes

func _input(event):
    if event is InputEventMouseMotion and Input.mouse_mode == Input.MOUSE_MODE_CAPTURED:
        rotate_y(-event.relative.x * mouse_sensitivity)
Finally, to look up/down, we’ll use the y motion of the mouse to tilt the camera. We don’t want it to turn completely upside-down, though, so we’ll clamp() the rotation to a reasonable value of 70 degrees.

func _input(event):
    if event is InputEventMouseMotion and Input.mouse_mode == Input.MOUSE_MODE_CAPTURED:
        rotate_y(-event.relative.x * mouse_sensitivity)
        $Camera3D.rotate_x(-event.relative.y * mouse_sensitivity)
        $Camera3D.rotation.x = clampf($Camera3D.rotation.x, -deg_to_rad(70), deg_to_rad(70))
Holding a weapon
alt
An FPS character typically has a 3D mesh of a weapon positioned in front. Setting this up can be easy with a couple of Godot editor tricks.

Add your weapon mesh as a child of the Camera3D. Then, in the editor view menu, choose “2 Viewports” and set one of them to preview the camera. Then, you can move around the weapon and easily see how it will look from the player’s perspective.

To add a little personality, try using an AnimationPlayer to animate the weapon’s position from side-to-side as the player moves.

Related recipes
Input: Capturing the Mouse
 Download This Project
Download the project code here: https://github.com/godotrecipes/basic_fps


CAMERA GIMBAL
Problem
You need a camera controller, using mouse or keyboard, that remains level while rotating and following a target.

Solution
Try this: take a Camera3D node and rotate it a small amount around X (the red ring on the gizmo), then a small amount around Z (the blue ring). Now reverse the X rotation and click the “Preview” button. Observe how the camera is now tilted.

The solution to this problem is to place the camera on a gimbal - a device designed to keep an object level during movement. We can create a gimbal using two Node3D nodes, which will control the camera’s left/right and up/down rotation respectively.

The node setup should look like this:

 Node3D: CameraGimbal
     Node3D: InnerGimbal
         Camera3D
Set the Transform/Position of the Camera3D to (0, 0, 4).

Here’s how the gimbal works: the outer node can only be rotated in Y, while the inner one rotates only in X. You can test this out by rotating them manually, but make sure you change to “Local Space Mode” first (that’s the cube icon next to the lock in the menu bar - the keyboard shortcut to toggle is “T”). Remember to only move the green ring of the outer node and only the red ring of the inner one. Don’t touch the camera node at all.


Reset all the rotations to 0 once you’ve finished experimenting.

Keyboard control
We’ll start with the keyboard controls, then add an option to use the mouse as well. Here are the required actions and their assigned inputs:

Action Name	Input
"cam_up"	W
"cam_down"	S
"cam_right"	D
"cam_left"	A
"cam_zoom_in"	Mouse Wheel Up
"cam_zoom_out"	Mouse Wheel Down
Here’s the initial script. Note that we’re making sure to rotate each Node3D in its local space around the specific axis, as described above.

extends Node3D

var rotation_speed = PI/2

func get_input_keyboard(delta):
    # Rotate outer gimbal around y axis
    var y_rotation = Input.get_axis("cam_left", "cam_right")
    rotate_object_local(Vector3.UP, y_rotation * rotation_speed * delta)
    # Rotate inner gimbal around local x axis
    var x_rotation = Input.get_axis("cam_up", "cam_down")
    x_rotation = -x_rotation if invert_y else x_rotation
    inner.rotate_object_local(Vector3.RIGHT, x_rotation * rotation_speed * delta)

func _process(delta):
    get_input_keyboard(delta)
Make a test scene with a MeshInstance3D and instance the CameraGimbal in it to test out the movement.

You’ll notice that holding the up/down control will cause the camera to rotate all the way around, eventually becoming upside-down. To prevent this, we can clamp the rotation.

func _process(delta):
    get_input_keyboard(delta)
    $InnerGimbal.rotation.x = clamp($InnerGimbal.rotation.x, -1.4, -0.01)
The -1.4 value lets it go almost to 90 degrees up, while setting a very small value for the minimum keeps the camera from clipping into the ground. Feel free to experiment with other values.

Mouse control
We’ll add a flag called mouse_control to enable easy toggling of mouse/keyboard controls.

# mouse properties
var invert_y = false
var invert_x = false
var mouse_control = false
var mouse_sensitivity = 0.005

func _unhandled_input(event):
    if mouse_control and event is InputEventMouseMotion:
        if event.relative.x != 0:
            var dir = 1 if invert_x else -1
            rotate_object_local(Vector3.UP, dir * event.relative.x * mouse_sensitivity)
        if event.relative.y != 0:
            var dir = 1 if invert_y else -1
            $InnerGimbal.rotate_object_local(Vector3.RIGHT, dir * event.relative.y * mouse_sensitivity)

func _process(delta):
    if !mouse_control:
        get_input_keyboard(delta)
This code works by converting horizontal mouse motion to Y rotation of the outer gimbal and vertical to X rotation for the inner gimbal. We’ve also added invert_x and invert_y flags so that you can flip the motion in either axis - many players prefer one over the other, so it’s best to allow for both options.

Also, in _process() we disable keyboard input when using mouse control.

You may notice a problem with the up/down movement if you move the mouse too quickly. A large value for event.relative.y results in “skipping” to the opposite side of the clamped value. We can solve this by clamping the vertical mouse movement to a reasonable value. Change the above code for y to this:

if event.relative.y != 0:
    var dir = 1 if invert_y else -1
    var y_rotation = clamp(event.relative.y, -30, 30)
    $InnerGimbal.rotate_object_local(Vector3.RIGHT, dir * y_rotation * mouse_sensitivity)
 Note
In your project, you’ll probably also want to capture the mouse during gameplay. See the linked recipe at the end of this document for details.

Camera zoom
Camera zoom works by varying the scale of the gimbal system.

# zoom settings
var max_zoom = 3.0
var min_zoom = 0.5
var zoom_speed = 0.09

var zoom = 1.5

func _unhandled_input(event):
    if event.is_action_pressed("cam_zoom_in"):
        zoom -= zoom_speed
    if event.is_action_pressed("cam_zoom_out"):
        zoom += zoom_speed
    zoom = clamp(zoom, min_zoom, max_zoom)

func _process(delta):
    scale = lerp(scale, Vector3.ONE * zoom, zoom_speed)
Using lerp() to change the zoom level results in smoother zooming.

alt
Following a target
Once you have the camera gimbal set up, it can follow a target by adding the following:

@export var target : Node3D

func _process(delta):
    if target:
        global_position = target.global_position
Instance the camera in your scene and use the Inspector to choose the node you want to follow.

Final script
For completeness, here’s the full script, including @export variables for all the camera settings, so that you can configure it in your project.

extends Node3D

@export var target : Node3D

@export_range(0.0, 2.0) var rotation_speed = PI/2

# mouse properties
@export var mouse_control = false
@export_range(0.001, 0.1) var mouse_sensitivity = 0.005
@export var invert_y = false
@export var invert_x = false

# zoom settings
@export var max_zoom = 3.0
@export var min_zoom = 0.4
@export_range(0.05, 1.0) var zoom_speed = 0.09

var zoom = 1.5

@onready var inner = $InnerGimbal

func _unhandled_input(event):
    if Input.mouse_mode != Input.MOUSE_MODE_CAPTURED:
        return
    if event.is_action_pressed("cam_zoom_in"):
        zoom -= zoom_speed
    if event.is_action_pressed("cam_zoom_out"):
        zoom += zoom_speed
    zoom = clamp(zoom, min_zoom, max_zoom)
    if mouse_control and event is InputEventMouseMotion:
        if event.relative.x != 0:
            var dir = 1 if invert_x else -1
            rotate_object_local(Vector3.UP, dir * event.relative.x * mouse_sensitivity)
        if event.relative.y != 0:
            var dir = 1 if invert_y else -1
            var y_rotation = clamp(event.relative.y, -30, 30)
            inner.rotate_object_local(Vector3.RIGHT, dir * y_rotation * mouse_sensitivity)

func get_input_keyboard(delta):
    # Rotate outer gimbal around y axis
    var y_rotation = Input.get_axis("cam_left", "cam_right")
    rotate_object_local(Vector3.UP, y_rotation * rotation_speed * delta)
    # Rotate inner gimbal around local x axis
    var x_rotation = Input.get_axis("cam_up", "cam_down")
    x_rotation = -x_rotation if invert_y else x_rotation
    inner.rotate_object_local(Vector3.RIGHT, x_rotation * rotation_speed * delta)

func _process(delta):
    if !mouse_control:
        get_input_keyboard(delta)
    inner.rotation.x = clamp(inner.rotation.x, -1.4, -0.01)
    scale = lerp(scale, Vector3.ONE * zoom, zoom_speed)
    if target:
        global_position = target.global_position


INTERPOLATED CAMERA
Problem
You need a 3D camera that smoothly follows a target (interpolates).

Solution
 Info
Godot’s built-in InterpolatedCamera node is deprecated and will be removed in the release of Godot 4.0.

Attach the script below to a Camera3D node in your scene. The three export properties let you choose:

lerp_speed - the camera’s movement speed. Lower values result in a “lazier” camera.
target - choose the camera’s target node.
offset - position of the camera relative to the target.
See below for some examples of the camera in action.

extends Camera3D

@export var lerp_speed = 3.0
@export var target: Node3D
@export var offset = Vector3.ZERO

func _physics_process(delta):
    if !target:
        return

    var target_xform = target.global_transform.translated_local(offset)
    global_transform = global_transform.interpolate_with(target_xform, lerp_speed * delta)

    look_at(target.global_transform.origin, target.transform.basis.y)
In the _physics_process() function we interpolate the camera’s position with the target’s (plus offset).

Examples
lerp_speed: 3.0
offset: (0, 7, 5)



SHOOTING WITH RAYCASTS
Problem
You need to implement shooting in an FPS, but moving individual projectiles is impractical.

Solution
Game physics engines often break down when trying to handle very fast-moving objects. The solution is to cast a ray from the shooter’s location and detect the first thing that would be hit.

There are two ways to approach raycasting in Godot: the RayCast3D node, or directly casting a ray in space using the physics engine. While they can both accomplish the same thing, each has its uses. The node method tends to be best for situations where you continuously want to check for collisions - a downward-facing ray to check if you’re on the floor, for example.

We’ll use the second method, querying the physics state, because we want to know, at the moment we press the “shoot” key, whether we’ve hit anything.

 Note
This recipe assumes you already have a working FPS character controller and a world to move around in. If you don’t, see the Basic FPS Character recipe first.

To display what we’ve hit, add a CanvasLayer with a Label node to the FPSPlayer scene.

We’ll add an input check in the _input() function, which we’re already using to handle mouse input.

    if event.is_action_pressed("shoot"):
        shoot()
Then we’ll define the shoot() method. Whenever it’s called, we want to build a PhysicsRayQueryParameters3D object, which defines the start (position of the camera) and end (position of the camera projected forward by 100 meters) points of the ray. We’ll pass this to the physics engine using the direct_space_state of the world. If we get a returned value (a dictionary containing data about the collision), we’ll update the label so we can see what kind of object we hit.

func shoot():
    var space = get_world_3d().direct_space_state
    var query = PhysicsRayQueryParameters3D.create($Camera3D.global_position,
            $Camera3D.global_position - $Camera3D.global_transform.basis.z * 100)
    var collision = space.intersect_ray(query)
    if collision:
        $CanvasLayer/Label.text = collision.collider.name
    else:
        $CanvasLayer/Label.text = ""
Related recipes
Basic FPS Character
 Download This Project
Download the project code here: https://github.com/godotrecipes/3d_shoot_raycasts


CHARACTERBODY3D: MOVEMENT
Problem
You need a player-controlled 3D character body.

Solution
For this recipe, we’ll be using this adorable tank model:

alt
You can grab this model on Itch.io: https://gtibo.itch.io/mini-tank or use any other model you’d like. We won’t be doing anything that’s tank-specific here.

In the case of this asset, the download includes an OBJ file, and we’ll find it more convenient if we import it as a scene:

alt
We can add the model to the scene, but we’ll need a couple of additional nodes:

alt
For the collision shape, we’re just going to use a BoxShape aligned and sized with the tank’s treads. CamPos is a Position3D we’ll use to place our following camera. It’s placed behind and above the tank, angled down.

We’ve also rotated the individual MeshInstance nodes 180 degrees around the Y axis. This is because they were modeled facing towards +Z, but -Z is the forward direction in Godot, and we don’t want our tank to look like it’s backwards.

Before we add a script, open the “Project Settings” and add the following inputs on the “Input Map” tab:

Input Action	Key
forward	W
back	S
right	D
left	A
Now let’s add a script, starting with the required variables:

extends CharacterBody3D

@export var speed = 4.0
@export var turn_speed = 0.8
speed is the tank’s movement speed (forward and back), while rot_speed defines how fast it can turn.

 Tip
Declaring properties with @export makes it easy to adjust them in the Inspector.

Using the move_and_slide() method makes our movement code quite simple:

func _physics_process(delta):
    velocity.y -= gravity * delta
    get_input(delta)
    move_and_slide()
With this code, we add the downward acceleration of gravity to the current velocity, get the user’s input (more about that below), and call move_and_slide().

Next we need to define get_input(), where we’ll process and apply the input actions:

func get_input(delta):
    var vy = velocity.y
    velocity = Vector3.ZERO
    var move = Input.get_axis("back", "forward")
    var turn = Input.get_axis("right", "left")
    velocity += -transform.basis.z * move * speed
    rotate_y(turn_speed * turn * delta)
    velocity.y = vy
Let’s examine this more closely. Player input should affect horizontal movement: forward/back along the ground, and rotation around the tank’s center. Movement in the Y direction should only be affected by gravity, which means we don’t want to set it to 0 every frame. This is why we’re using the vy variable to temporarily hold that value while we assign a new velocity vector for the horizontal movement, then add it back in at the end.

For the forward and back movement, we’re using transform.basis.z so that we’ll move in our body’s local forward direction.

Here’s the tank in action. We’ve made a test scene with a StaticBody3D plane for the ground and an Camera3D using the Interpolated Camera recipe.


Wrapping up
This is the basis of movement for any kind of kinematic character. From here you can add jumping, shooting, AI behavior, etc. See the related recipes for examples that build on this recipe.

 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/characterbody3d_examples

Related recipes
Intro to 3D
Input Actions


3D UNIT HEALTHBARS
Problem
You want a floating “healthbar” for your 3D game objects (mobs, characters, etc.).

Solution
For this solution, we’re going to re-use a 2D healthbar based on a TextureProgressBar node. It’s already set up with textures and code for updating the value and color. If you already have something similar, feel free to use it here. In the example, we’ll name this scene “Healthbar2D”.

alt
If you need some assets, here are the three images used in the bar:

alt
alt
alt
 Note
Re-using existing objects can save you a lot of time. Don’t re-invent the wheel everytime you need a healthbar, camera, or other common object.

Project setup
For our example “mob”, we’ll start with a CharacterBody3D node. It’s programmed to spawn and travel in a straight line. It also has the following code to handle damage:

func _on_input_event(_camera, event, _position, _normal, _shape_idx):
    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
        health -= 1
        if health <= 0:
            queue_free()
alt
Clicking on a unit deals one damage. Do ten damage, and the unit is destroyed. Now we need a visual representation of that using our 2D bar.

2D in 3D
We can display a 2D image in 3D using a Sprite3D. Add one to a new scene and name it “Healthbar3D”. First, we’ll get it configured and sized, so set the Texture property to the green bar image.

The Sprite3D acts like any other 3D object - as we pan the camera around, our perspective on it changes. However, we want the healthbar to always “face” toward the camera so that we can see it.

In the Inspector, under Flags, set Billboard to “Enabled”.

Now try moving the camera to confirm that the texture is always facing you.

alt
Add an instance of this scene to the Mob scene and position the bar above the mob’s body.

alt
Viewport texture
We don’t want the Sprite3D to show a static texture - we want it to display the 2D TextureProgressBar. We can do that using a SubViewport node, which can export a texture.

Add a SubViewport as a child of the Sprite3D. In the Inspector set Transparent BG to On.

We also need to set the size of the viewport to match the size of the healthbar texture, which is (200, 26).

Instance the HealthBar2D as a child of the Viewport. Your scene should look like this:

alt
If the SubViewport were not a child of the Sprite3D, we could set it as the sprite’s texture directly in the Inspector. Since it’s a child, it won’t be ready at the right time, so we’ll need to set it in a script attached to the Sprite3D:

extends Sprite3D

func _ready():
    texture = $SubViewport.get_texture()
Connecting it all together
In the mob’s _on_input_event() method, add the following after reducing the health:

$HealthBar3D.update(health, max_health)
Add the following to HealthBar3D.gd:

func update_health(_value, _max_value):
    $SubViewport/HealthBar2D.update_health(_value, _max_value)
This calls the update method that already exists on the 2D bar, setting the progress bar’s value and selecting the bar color:

func update_health(_value, _max_value):
    value = _value
    if value < _max_value:
        show()
    texture_progress = bar_green
    if value < 0.75 * _max_value:
        texture_progress = bar_yellow
    if value < 0.45 * _max_value:
        texture_progress = bar_red
Click on the mobs to see the health bars change.

alt
Wrapping up
You can use this technique to display any other Node2D or Control nodes, such as Label, VideoStreamPlayer, etc. You can even use the SubViewport to “project” an entire 2D game in 3D space.

 Download This Project
Download the project code here: https://github.com/godotrecipes/3d_object_healthbars


ROLLING CUBE
Problem
You want to make a rolling cube in 3D.


Solution
Rolling a cube is trickier than it seems. You can’t just rotate the cube around its center:

alt
Instead, the cube needs to be rotated around its bottom edge.

alt
Here’s the tricky part: which bottom edge? It depends on which direction the cube is rolling.

In preparing this recipe, I experimented with a few different solutions to this problem:

Pure math - calculating and applying rotation transforms
AnimationPlayer - using animations to key the rotations and offsets
Helper nodes - using Spatial(s) as rotation helpers
They all worked fine, but I found the last option the most flexible and easiest to adapt, so that’s what we’ll do here.

Node setup
Cube:  CharacterBody3D
    Pivot:  Node3D
        Mesh:  MeshInstance3D
    Collision:  CollisionShape3D
 Tip
You can do this with RigidBody3D, CharacterBody3D, or Area3D as your collision node. There will be minor differences in how you handle movement. Which node you choose should depend on what other behavior you want in your game. For this recipe, we’re only concerned with the movement.

By default, everything is centered at (0, 0, 0) so the first thing we’re going to do is offset everything so that the bottom center of the cube is the CharacterBody3D’s position.

The default size of a BoxMesh3D is (1, 1, 1), so do this, move the mesh and collision nodes both up to (0, 0.5, 0), leaving the rest where they are. Now when you select the root node, its position will be the bottom of the cube:

alt
Now when you want to roll the cube, you’ll need to move the Pivot 0.5 in the direction you want to move. Since the mesh is attached, you need to move it the opposite amount. For example, to roll to the right (+X), you’ll end up with this:

alt
Now the pivot node is at the correct edge and rotating it will also rotate the mesh.

Movement script
The movement is broken in to 3 steps:

Step 1
Here we apply the two offsets shown above: shift the Pivot in the direction of movement, and shift the Mesh in the opposite direction.

Step 2
In this step we animate the rotation. We find the axis of rotation using the cross product of the direction and the down vector. Then we use a Tween to animate rotating the pivot’s transform.

Step 3
Finally, once the animation has finished, we need to reset everything so that it’s ready to happen again. In the end, we want to have the cube moved 1 unit in the chosen direction (for a cube of size 1) and have the pivot and mesh back at their original positions.

extends CharacterBody3D

@onready var pivot = $Pivot
@onready var mesh = $Pivot/MeshInstance3D

var cube_size = 1.0
var speed = 4.0
var rolling = false

func _physics_process(delta):
    var forward = Vector3.FORWARD
    if Input.is_action_pressed("ui_up"):
        roll(forward)
    if Input.is_action_pressed("ui_down"):
        roll(-forward)
    if Input.is_action_pressed("ui_right"):
        roll(forward.cross(Vector3.UP))
    if Input.is_action_pressed("ui_left"):
        roll(-forward.cross(Vector3.UP))

func roll(dir):
    # Do nothing if we're currently rolling.
    if rolling:
        return
    rolling = true

    # Step 1: Offset the pivot.
    pivot.translate(dir * cube_size / 2)
    mesh.global_translate(-dir * cube_size / 2)

    # Step 2: Animate the rotation.
    var axis = dir.cross(Vector3.DOWN)
    var tween = create_tween()
    tween.tween_property(pivot, "transform",
            pivot.transform.rotated_local(axis, PI/2), 1 / speed)
    await tween.finished

    # Step 3: Finalize the movement and reset the offset.
    transform.origin += dir * cube_size
    var b = mesh.global_transform.basis
    pivot.transform = Transform3D.IDENTITY
    mesh.position = Vector3(0, cube_size / 2, 0)
    mesh.global_transform.basis = b
    rolling = false
If your cube’s texture isn’t symmetrical, you may notice that it’s resetting after every roll. To preserve the rotation of the mesh, add the following:

In Step 1:

Change mesh.translate(-dir) to mesh.global_translate(-dir).

In Step 3:

Add two lines to keep the mesh rotation after reset:

    # Step 3: Finalize the movement and reset the offset.
	transform.origin += dir * cube_size
	var b = mesh.global_transform.basis  # Save the mesh rotation.
	pivot.transform = Transform3D.IDENTITY
	mesh.position = Vector3(0, cube_size / 2, 0)
	mesh.global_transform.basis = b  # Restore the mesh rotation.
Checking for collisions
If you plan to have obstacles in your game, you can check for collisions before moving (similar to any other grid-based movement scheme). Add a raycast check before Step 1 of the move:

# Cast a ray before moving to check for obstacles
var space = get_world_3d().direct_space_state
var ray = PhysicsRayQueryParameters3D.create(mesh.global_position,
        mesh.global_position + dir * cube_size, collision_mask, [self])
var collision = space.intersect_ray(ray)
if collision:
    return
 Note
You could also use a RayCast3D node. Just remember to call force_raycast_update() before checking.

Playing with transitions
You can add a lot of “personality” to the cube’s rolling behavior by changing which TransitionType you use. The default is Tween.TRANS_LINEAR, which results in a constant speed throughout the movement.

By setting a different transition type, you can get a very different feel. For example:

var tween = create_tween().set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_IN)
 Download This Project
Download the project code here: https://github.com/godotrecipes/rolling_cube

Related recipes
Transforms


ARCADE-STYLE SPACESHIP
Problem
You want to make a 3D spaceship that flies in an arcade/cinematic way. You’re not looking for realistic physics, but more of a dog-fighting, “Star Wars”-style of spaceflight.

Solution
To accomplish this, we’ll use a  CharacterBody3D for the ship. The three axis inputs (pitch, roll, and yaw) will rotate the body’s basis around the corresponding axis. The direction of motion will always point forward.

 Note
You can do this with  RigidBody3D and get the same results. See the example project linked below, which includes a rigid body version as well.

Assets
Spaceship models are from this asset pack:

Ultimate Spaceships Pack by Quaternius

I’ve chosen the “Executioner” ship model:

alt
Feel free to choose your favorite design.

Setup
Select the gltf file of the ship you want, and click the Import tab. Change the Root Type to  CharacterBody3D and click “Reimport”. Then double-click the gltf and you’ll have a new inherited scene with a CharacterBody3D root and a  MeshInstance child. Add a  CollisionShape3D to the body.

In Project Settings -> Input Map, set up the following inputs:

roll_right/ roll_left
pitch_up / pitch_down
yaw_right / yaw_left
throttle_up / throttle_down
You can assign keys or controller inputs. Analog stick inputs will work best.

Movement
To start the script, let’s handle the forward movement. Pressing the throttle buttons smoothly increases/decreases the speed.

extends CharacterBody

@export var max_speed = 50.0
@export var acceleration = 0.6

var forward_speed = 0

func get_input(delta):
    if Input.is_action_pressed("throttle_up"):
        forward_speed = lerp(forward_speed, max_speed, acceleration * delta)
    if Input.is_action_pressed("throttle_down"):
        forward_speed = lerp(forward_speed, 0, acceleration * delta)

func _physics_process(delta):
    get_input(delta)
    velocity = -transform.basis.z * forward_speed
    move_and_collide(velocity * delta)
Make a test scene with a  Camera3D to try it out. You can use a stationary camera or a chase camera. Check that the ship accelerates and slows before moving on to the next step.

alt
Rotation
Now we can handle rotation in the three axes. Add the following variables at the top of the script:

@export var pitch_speed = 1.5
@export var roll_speed = 1.9
@export var yaw_speed = 1.25

var pitch_input = 0.0
var roll_input = 0.0
var yaw_input = 0.0
The three axis speeds will affect the “handling” of the ship. Experiment to find values the work for you and your desired flight style.

Next, add these lines to get_input() to capture the three axis inputs:

pitch_input = Input.get_axis("pitch_down", "pitch_up")
roll_input = Input.get_axis("roll_right", "roll_left")
yaw_input = Input.get_axis("yaw_right", "yaw_left")
Finally, we need to rotate the ship’s Basis according to the inputs. Note how each input affects one axis of rotation:

transform.basis = transform.basis.rotated(transform.basis.z,
    roll_input * roll_speed * delta)
transform.basis = transform.basis.rotated(transform.basis.x,
    pitch_input * pitch_speed * delta)
transform.basis = transform.basis.rotated(transform.basis.y,
    yaw_input * yaw_speed * delta)
transform.basis = transform.basis.orthonormalized()
alt
Improvements
Currently the rotations are a little to “sharp”. The ship starts and stops rotating instantly, which feels a bit too unnatural. We can solve this with lerp(), and by adding one more configuration variable to set how “floaty” we’d like the controls to be:

@export var input_response = 8.0
Change the three axis inputs in get_input() to the following:

pitch_input = lerp(pitch_input, Input.get_axis("pitch_down", "pitch_up"),
        input_response * delta)
roll_input = lerp(roll_input, Input.get_axis("roll_right", "roll_left"),
        input_response * delta)
yaw_input = lerp(yaw_input, Input.get_axis("yaw_right", "yaw_left"),
        input_response * delta)
Now when stopping or changing direction, there’s a little bit of inertia.

alt
Linking roll/yaw
One problem with this control scheme is that it’s awkward. Having to use a separate stick for the yaw input makes it difficult to control, especially when also shooting and using other controls. Many games solve this by linking the roll input to also apply a small amount of yaw. To do this, change the yaw_speed to around 1/4 to 1/2 of the roll_speed.

In the get_input() function, change the line getting yaw_input to the following:

yaw_input = roll_input
This is another fun place to experiment by changing the roll and yaw speeds. For example, what if yaw was primary and roll smaller? What if other axes were linked? If your game has different ships, you can give them different values for variety in flight styles/performance.

Wrapping up
That’s it, now you can fly! This controller is a great start for whatever space-based game you might have in mind. Add some other ships, and a few effects, and you’re ready go:


Full script
Here’s the complete script:

extends CharacterBody3D

@export var max_speed = 50.0
@export var acceleration = 0.6
@export var pitch_speed = 1.5
@export var roll_speed = 1.9
@export var yaw_speed = 1.25  # Set lower for linked roll/yaw
@export var input_response = 8.0

var forward_speed = 0.0
var pitch_input = 0.0
var roll_input = 0.0
var yaw_input = 0.0

func get_input(delta):
    if Input.is_action_pressed("throttle_up"):
        forward_speed = lerp(forward_speed, max_speed, acceleration * delta)
    if Input.is_action_pressed("throttle_down"):
        forward_speed = lerp(forward_speed, 0.0, acceleration * delta)

    pitch_input = lerp(pitch_input, Input.get_axis("pitch_down", "pitch_up"),
            input_response * delta)
    roll_input = lerp(roll_input, Input.get_axis("roll_right", "roll_left"),
            input_response * delta)
    # yaw_input = lerp(yaw_input, Input.get_axis("yaw_right", "yaw_left"),
            input_response * delta)
    yaw_input = roll_input

func _physics_process(delta):
    get_input(delta)
    transform.basis = transform.basis.rotated(transform.basis.z,
            roll_input * roll_speed * delta)
    transform.basis = transform.basis.rotated(transform.basis.x,
            pitch_input * pitch_speed * delta)
    transform.basis = transform.basis.rotated(transform.basis.y,
            yaw_input * yaw_speed * delta)
    transform.basis = transform.basis.orthonormalized()
    velocity = -transform.basis.z * forward_speed
    move_and_collide(velocity * delta)
Related recipes
Interpolated Camera
 Download This Project
Download the project code here: https://github.com/godotrecipes/3d_spaceship


ARCADE-STYLE AIRPLANE
Problem
You want to make an airplane controller in 3D, but don’t need a fully accurate flight-simulator.

Solution
In this recipe, we’re going to make a simplified airplane controller. By “simplified” we mean stripping things down to the basics. We’re looking for the “feel” of flying a plane - one that you can just jump in and start flying effortlessly, with a minimal control scheme.

 Note
This recipe is not an accurate flight simulator. We are not simulating aerodynamics, so this doesn’t fly like a real airplane. We’re going for simplicity and “fun” here, not accuracy.

Node setup
We’re going to use a CharacterBody3D for this. Since we won’t be simulating actual flight physics (lift, drag, etc.), we don’t need RigidBody3D in this case.

Here’s our model setup:

alt
We’re using a cylinder for the collision shape, sized to match the plane’s fuselage. This will allow for detecting the ground, which is all we’re concerned with for this demo.

To start the script, let’s look at our plane’s properties:

extends CharacterBody3D

# Can't fly below this speed
var min_flight_speed = 12
# Maximum airspeed
var max_flight_speed = 40
# Turn rate
var turn_speed = 0.75
# Climb/dive rate
var pitch_speed = 0.5
# Wings "autolevel" speed
var level_speed = 3.0
# Throttle change speed
var throttle_delta = 50
# Acceleration/deceleration
var acceleration = 6.0

# Current speed
var forward_speed = 0
# Throttle input speed
var target_speed = 0
# Lets us change behavior when grounded
var grounded = false

var turn_input = 0
var pitch_input = 0
Controls
We’ll need the following input actions for our controls. We’re using a game controller in this demo, but you can add keyboard inputs as well if you like.

alt
This function captures the inputs and sets the input values. Note that increasing/decreasing throttle changes the target_speed, not the actual speed. This will allow us to acclerate/decelerate from the current speed to the target speed.

func get_input(delta):
    # Throttle input
    if Input.is_action_pressed("throttle_up"):
        target_speed = min(forward_speed + throttle_delta * delta, max_flight_speed)
    if Input.is_action_pressed("throttle_down"):
        var limit = 0 if grounded else min_flight_speed
        target_speed = max(forward_speed - throttle_delta * delta, limit)

    # Turn (roll/yaw) input
    turn_input = Input.get_axis("roll_right", "roll_left")

    # Pitch (climb/dive) input
    pitch_input =  Input.get_axis("pitch_down", "pitch_up")
Movement
Movement happens in _physics_process(), first lerping the speed towards the target speed and then using move_and_slide():

func _physics_process(delta):
    get_input(delta)
    # Accelerate/decelerate
    forward_speed = lerpf(forward_speed, target_speed, acceleration * delta)

    # Movement is always forward
    velocity = -transform.basis.z * forward_speed

    move_and_slide()
To test, add the plane to a test scene (don’t forget a  Camera). Press the "throttle_up" input and you should see the plane accelerate forward.

 Tip
We’re using the Interpolated Camera recipe in this demo.

alt
Next, let’s handle changing the pitch of the plane. Add this right after calling get_input() in _physics_process():

transform.basis = transform.basis.rotated(transform.basis.x, pitch_input * pitch_speed * delta)
Run the scene again and try pitching up and down:

alt
After that, add the following for the turn input:

transform.basis = transform.basis.rotated(Vector3.UP, turn_input * turn_speed * delta)
alt
Notice that while the plane turns, it doesn’t really look natural. Airplanes bank when they turn, so let’s animate that by changing the rotation of the mesh:

mesh.rotation.z = lerpf(mesh.rotation.z, -turn_input, level_speed * delta)
alt
Where mesh is a reference to the MeshInstance3D in the plane scene (in the example, this is $cartoon_plane).

The amount of roll is related to the turn_input so a shallow turn banks less. Going straight will “auto” level the plane.

That’s it! You now have the basic flying controls working correctly, and it should feel comfortable and natural to fly around. Try adjusting the various properties to see how they affect the movement.

Landing/taking off
While the above is fine for flying, it doesn’t handle the ground very well. Here, we’ll simulate landing using a simplistic approach (by “simplistic”, we mean doing so in a very basic way - you’ll probably want to expand on it depending on what your game may need).

First, we’ll want to distinguish between being on the ground and being in the air. On the ground, we can slow down to 0; in the air, we must maintain the minimum airspeed. Also, when on the ground, we won’t bank when turning (we don’t want our wings digging into the ground!).

func _physics_process(delta):
    get_input(delta)
    transform.basis = transform.basis.rotated(transform.basis.x, pitch_input * pitch_speed * delta)
    transform.basis = transform.basis.rotated(Vector3.UP, turn_input * turn_speed * delta)

    # Bank when turning
    if grounded:
        mesh.rotation.z = 0
    else:
        mesh.rotation.z = lerpf(mesh.rotation.z, -turn_input, level_speed * delta)

    # Accelerate/decelerate
    forward_speed = lerpf(forward_speed, target_speed, acceleration * delta)

    # Movement is always forward
    velocity = -transform.basis.z * forward_speed

    # Landing
    if is_on_floor():
        if not grounded:
            rotation.x = 0
        grounded = true
    else:
        grounded = false
    move_and_slide()
Meanwhile, in the get_input() function, we’ll also take into account grounded when throttling down and when pitching down, and only allow takeoff if above min_flight_speed:

func get_input(delta):
    # Throttle input
    if Input.is_action_pressed("throttle_up"):
        target_speed = min(forward_speed + throttle_delta * delta, max_flight_speed)
    if Input.is_action_pressed("throttle_down"):
        var limit = 0 if grounded else min_flight_speed
        target_speed = max(forward_speed - throttle_delta * delta, limit)

    # Turn (roll/yaw) input
    turn_input = Input.get_axis("roll_right", "roll_left")
    if forward_speed <= 0.5:
        turn_input = 0

    # Pitch (climb/dive) input
    pitch_input = 0
    if not grounded:
        pitch_input -= Input.get_action_strength("pitch_down")
    if forward_speed >= min_flight_speed:
        pitch_input += Input.get_action_strength("pitch_up")
alt
Full script
Here’s the full script:

 Click to expand…
Wrapping up
You can adapt this technique to a variety of arcade-style flying games. For example, for mouse control, you could use the relative property of InputEventMouseMotion to set the pitch and turn input.

 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/3d_airplane_demo



ARCADE-STYLE CAR
Problem
You want to make an arcade-style car game, so you’re looking for simplicity over realistic physics. In this recipe, you’ll learn how to make a fun, driveable car using a rolling sphere.


Solution
There are a lot of ways to make a driving game. Different games need different levels of realism. If you’re trying to make a light, arcade-style car, you don’t need all of the features that Godot’s VehicleBody3D node provides, such as supension, independently modeled wheels, etc.

Instead, we’re going to use a single RigidBody3D sphere to handle the driving physics. The sphere will be invisible, and the car mesh will be placed at the sphere’s location, making it look like it’s the car that’s driving.

As you can see in the preview clip above, the result looks remarkably good (and feels great to play!). Read on, and you’ll see that the amount of code required is also surprisingly small.

Inputs
For control, we’re going to add four inputs to the Input Map:

accelerate
brake
steer_left
steer_right
You can use keyboard input, game controller, or both. However, we recommend going with the analog stick for better steering.

Node setup
The car is made with two main nodes: a RigidBody3D sphere for the physics, and a MeshInstance3D to display the car body. Here’s the scene layout:

 RigidBody3D (Car)
      CollisionShape3D (Sphere)
      CarMesh (Imported model)
Here’s how these nodes will interact: pressing “accelerate” will apply a force on the RigidBody3D in the direction the CarMesh is facing, while the turning inputs will rotate the CarMesh. As the ball rolls, it will carry the car mesh along with it (we’ll ignore the ball’s rotation).

CarMesh
Here’s the car model we’ll use:

alt
 Note
You can find this and other car models in Kenney’s “Car Kit”, available here: https://kenney.nl/assets/car-kit. Download the whole kit; you can use any of them that you choose. Note that this kit includes the models in multiple formats - you won’t need all of them for your project. GLTF is the recommended format for use with Godot.

If you use the GLTF models, you shouldn’t have adjust anything in the import settings.

Here’s what the node tree looks like when importing the “suv” model:

alt
Note that the wheels & body are separate meshes. This will make it easy to add some visual appeal - like turning the wheels when steering.

Ball
Add a sphere shape to the CollisionShape3D. We’re using a radius of 1 here, but you’ll want to experiment with the size of the ball to get different driving behaviors.

Here’s how to adjust the settings on the body:

Angular Damp: 10 - this property will have a huge effect on the driving feel. A higher value will bring the car to a stop much faster.
Gravity Scale: 5 - Default gravity in Godot (9.8) feels a bit floaty, especially when going for an action feel. This will really matter if you plan to have jumps, hills, etc. in your world. You can set this globally in the Project Settings instead, if you prefer.
Physics Material/Bounce: 0.1 - Playing around with this value can be a lot of fun. Be careful going above 0.5, though!
For the demo, we’ve also added a spherical mesh to the collision shape for debugging purposes. You don’t need this, but it helps when troubleshooting to have a visual of the ball rolling.

RayCast
Finally, add a RayCast3D node as a child of the CarMesh. Set its Target Position to (0, -1, 0).

alt
We’re going to use this for ground detection. When the car’s in the air, steering and acceleration won’t work. We can also use it to align the car mesh to a slope (if your game’s track isn’t flat).

Now we’re ready to start coding.

Script
We’ll begin the script with some node references we’ll need:

extends RigidBody3D

@onready var car_mesh = $CarMesh
@onready var body_mesh = $CarMesh/suv2
@onready var ground_ray = $CarMesh/RayCast3D
@onready var right_wheel = $CarMesh/suv2/wheel_frontRight
@onready var left_wheel = $CarMesh/suv2/wheel_frontLeft
Next, some variables configuring the car’s behavior. See the comments describing each one’s purpose.

# Where to place the car mesh relative to the sphere
var sphere_offset = Vector3.DOWN
# Engine power
var acceleration = 35.0
# Turn amount, in degrees
var steering = 18.0
# How quickly the car turns
var turn_speed = 4.0
# Below this speed, the car doesn't turn
var turn_stop_limit = 0.75

# Variables for input values
var speed_input = 0
var turn_input = 0
You can @export these if you’d like to adjust them from the Inspector.

In _physics_process() we add a force to the body based on the direction the car is pointing, as well as keeping the car mesh positioned at the ball’s position:

func _physics_process(delta):
    car_mesh.position = position + sphere_offset
    if ground_ray.is_colliding():
        apply_central_force(-car_mesh.global_transform.basis.z * speed_input)
The next step is to get the inputs, but we’ll also check if the ray is colliding with the ground first:

func _process(delta):
    if not ground_ray.is_colliding():
        return
    speed_input = Input.get_axis("brake", "accelerate") * acceleration
    turn_input = Input.get_axis("steer_right", "steer_left") * deg_to_rad(steering)
    right_wheel.rotation.y = turn_input
    left_wheel.rotation.y = turn_input
 Tip
At this point, you can try it out. You should be able to accelerate forward and back (but not steer yet).

Next, still in the _process() function, we’ll rotate the car mesh based on the rotation input. We’ll use slerp() (spherical linear interpolation) to do this smoothly:

# rotate car mesh
if linear_velocity.length() > turn_stop_limit:
    var new_basis = car_mesh.global_transform.basis.rotated(car_mesh.global_transform.basis.y, turn_input)
    car_mesh.global_transform.basis = car_mesh.global_transform.basis.slerp(new_basis, turn_speed * delta)
    car_mesh.global_transform = car_mesh.global_transform.orthonormalized()
 Warning
Because of floating point imprecision, repeatedly rotating a transform will eventually cause it to become distorted. The scale can drift or the axes can become no-perpendicular. In any script where you’re regularly rotating a transform, it’s a good idea to use orthonormalized() to correct any error before it accumulates.

You should try playing again at this point. You’ll be able to control the car and drive around, and everything works pretty much as expected. However, there are a few more things to add that will improve the “feel” of the driving.

Final touches
1. Align with slopes
FIX THIS

If you’ve tried driving on a slope, you’ve seen that the car mesh doesn’t tilt at all, it always remains level. That looks unnatural, so let’s use the process described in KinematicBody: Align with Surface to fix that.

Add this code after rotating the mesh in _process():

if ground_ray.is_colliding():
    var n = ground_ray.get_collision_normal()
    var xform = align_with_y(car_mesh.global_transform, n)
    car_mesh.global_transform = car_mesh.global_transform.interpolate_with(xform, 10.0 * delta)
And the align function (notice how we’re using orthonormalized() again?):

func align_with_y(xform, new_y):
    xform.basis.y = new_y
    xform.basis.x = -xform.basis.z.cross(new_y)
    xform.basis = xform.basis.orthonormalized()
    return xform.orthonormalized()
2. Turn the wheels
It looks nice if the front wheels turn when you steer. Add some references to the front wheel meshes at the top of the script:

@onready var right_wheel = $CarMesh/suv2/wheel_frontRight
@onready var left_wheel = $CarMesh/suv2/wheel_frontLeft
And right after getting input, add the following:

    # rotate wheels for effect
    right_wheel.rotation.y = rotate_input
    left_wheel.rotation.y = rotate_input
alt
3. Tilt the body
This one adds lots of visual appeal. We’re going to tilt the car’s body based on the speed of the turn. Add a variable at the top of the script:

var body_tilt = 35
The smaller this number, the more extreme the tilt effect will be. Between 35 and 40 works well for the SUV model.

Now add the following right after rotating the car mesh (in the if statement):

# tilt body for effect
var t = -rotate_input * ball.linear_velocity.length() / body_tilt
body_mesh.rotation.z = lerp(body_mesh.rotation.z, t, 10 * delta)
Observe the difference:

alt
Credits
The demo project seen here uses the following open-source/creative commons assets:

Cars: Kenney Car Kit by Kenney
Track: Modular Racekart Track by Keith at Fertile Soil Productions
 Download This Project
Download the project code here: https://github.com/godotrecipes/3d_car_sphere

Related recipes
Input Actions


CLICK TO MOVE
Problem
You want to move a 3D object to a clicked position.

Solution
We’ll start with a flat plane for our world. Our actor will move on this plane.

alt
The actor for this demo is a triangular prism mesh:

alt
Here is the code for the movement. If given a target, the object will turn and move toward it.

extends CharacterBody3D

@export var speed = 5
@export var gravity = -5

var target = Vector3.ZERO

func _physics_process(delta):
    velocity.y += gravity * delta
    if target:
        look_at(target, Vector3.UP)
        rotation.x = 0
        velocity = -transform.basis.z * speed
        if transform.origin.distance_to(target) < .5:
            target = Vector3.ZERO
            velocity = Vector3.ZERO
    move_and_slide()
We’ve also added a MeshInstance3D called “Marker” to the scene. This will be moved to indicate the clicked position.

alt
Mouse -> 3D
Now we need a way to map mouse position into our 3D world. If you imagine the screen as a window into the 3D world, the mouse is trapped on the glass. To select something in 3D, we must project a ray from our eye (the camera), through the mouse’s position and into the world.

While this can be done manually using the Camera3D’s project_ray methods, we can take advantage of the fact that CollisionObject3D nodes do this automatically. All we need to do is connect our StaticBody3D ground’s input_event signal:

func _on_StaticBody_input_event(camera, event, click_position, click_normal, shape_idx):
    if event is InputEventMouseButton and event.pressed:
        $Marker.transform.origin = click_position
        $Player.target = click_position
We set the position of the marker and the Player’s target to the clicked position:

alt
Wrapping up
You can use this technique to detect clicks on any objects in your 3D world.


SMOOTH ROTATION
Problem
You want to smoothly rotate a 3D object to point in a new direction.

Solution
When you first encounter this problem, you may find yourself thinking in terms of Euler angles - the three values representing the angles to the x/y/z axes. While Godot will allow you to see the object’s Euler angles in the rotation property, it is not recommended to use them to work in 3D. There are a number of reasons why this the case, such as a problem called “gimbal lock”, where you lose one degree of freedom when one of your rotations reaches 90 degrees.

 Info
If you’re interested in the background behind Euler angles and the problems they introduce, like gimbal lock, here’s a video that explains it well.

We can avoid using 3D Euler angles in Godot by using the object’s transform property. This property represents the body’s position and orientation in space. It uses a mathematical construct called a matrix to do this, but you don’t really need to understand the underlying math in order to make use of it.

look_at()
Let’s say you have a 3D object such as a missile or arrow and you want it to point at its target. You can do this using the Node3D method look_at():

func _process(delta):
    var target_position = $Target.transform.origin
    $Arrow.look_at(target_position, Vector3.UP)
This code would make our node ($Arrow) always point at the target’s position, no matter how it moves.

alt
Note that look_at() requires 2 parameters: the target position, and an “up vector”. Imagine an airplane pointing its nose towards a target - there are an infinite number of ways it could be oriented, because the plane could roll about its axis. This second parameter is how you define what you want the final orientation to be.

Smooth rotation
The above code works, but it snaps the rotation instantly to the target. This might be fine if you have a very slow-moving target, but looks unnatural. It would look better if we move smoothly, or “interpolated”, the rotation smoothly between the starting orientation and the ending.

Godot has us covered here too. Rather than look_at(), we can use the Transform object’s looking_at() method, which doesn’t rotate the node, but returns the transform that would be looking at the target. Combine this with the interpolate_with() method, which returns an intermediate transform between a current one and a target one, and we can smoothly transition between the current orientation and our desired one.

var speed = 5

func _process(delta):
    var target_position = $Target.transform.origin
    var new_transform = $Arrow.transform.looking_at(target_position, Vector3.UP)
    $Arrow.transform  = $Arrow.transform.interpolate_with(new_transform, speed * delta)
alt
Note that since interpolate_with() operates on the transform, it can be used to interpolate both rotation and position of an object.

Wrapping up
That’s it! Use this handy method to rotate your 3D objects, and stop thinking about angles!

Related recipes


CHARACTERBODY3D: ALIGN WITH SURFACE
Problem
You need your character body to align with the surface or terrain.

Solution
This recipe builds on the basic CharacterBody3D controller described in the CharacterBody3D: Movement recipe, so read that one first.

First, we’ve added some terrain to the scene. You can download the terrain from here: https://fertile-soil-productions.itch.io/modular-terrain-pack. This is low-poly terrain, but you can use or make any terrain you like for this technique.

As you can see, the movement still works with the terrain, but the tank seems to “float” above the slopes because it doesn’t change its orientation.


Instead, we need to rotate the tank so that its treads are aligned with the ground, even as the slope changes. To do that, we need to know which way is up.

Surface normals
A surface normal is a unit vector (“normal vector” and “unit vector” mean the same thing) perpendicular to a surface. It shows which way the surface is facing. In the case of a mesh, every surface has a normal pointing outward.

alt
alt
In Godot, when a body collides, you can get the normal of the collision. This will be the colliding body’s normal at the point of contact.

Once we have the surface normal, we need to align the tank’s Y axis with it. Note that we can’t use Transform3D.looking_at(), because that will align the -Z (forward) axis with the normal.

To do this, we’ll use the following function:

func align_with_y(xform, new_y):
    xform.basis.y = new_y
    xform.basis.x = -xform.basis.z.cross(new_y)
    xform.basis = xform.basis.orthonormalized()
    return xform
Given a transform and a new Y direction vector, this function returns the transform rotated so that its basis.y is aligned with the given normal.

 Note
If you’re unfamiliar with the cross product or other vector math, there’s a great vector math intro in the Godot Docs.

We can update the tank’s movement code to call this function when it collides with a surface:

func _physics_process(delta):
    velocity += gravity * delta
    get_input(delta)
    move_and_slide()
    for i in get_slide_count():
        var c = get_slide_collision(i)
        global_transform = align_with_y(global_transform, c.get_normal())
This doesn’t work quite as expected:


The problem is that the tank’s collision shape could be colliding with more than one of the terrain’s faces. Also, move_and_slide() can result in more than one collision in a single frame. This leads to the jittering. We need to choose one face and stick with it.

Add a RayCast3D child to the tank and set its Target Position to (0, -1, 0).

Since this raycast is pointing down from the exact center of the tank, we’ll align with the individual surface that it collides with - the one directly beneath the tank.

func _physics_process(delta):
    velocity += gravity * delta
    get_input(delta)
    move_and_slide(v)
    var n = $RayCast3D.get_collision_normal()
    global_transform = align_with_y(global_transform, n)
This is much better, but because we are instantly snapping to the new alignment every time the tank crosses an edge, it still looks a little jarring:


We can solve this last problem by interpolating to the new transform rather than snapping immediately to it.

func _physics_process(delta):
    velocity += gravity * delta
    get_input(delta)
    velocity = move_and_slide_with_snap(velocity, Vector3.DOWN*2, Vector3.UP, true)
    var n = $RayCast.get_collision_normal()
    var xform = align_with_y(global_transform, n)
    global_transform = global_transform.interpolate_with(xform, 12 * delta)
The result is much smoother and more pleasing:


You can get even better results with two raycasts - one at the front and one at the back. Get the average normal from them:

var n = ($FrontRay.get_collision_normal() + $RearRay.get_collision_normal()) / 2.0
Feel free to experiment with the interpolation amount. We found 12 to work well in this situation, but you might find a higher or lower value works better for your setup.

 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/characterbody3d_examples

Related recipes
CharacterBody3D: Movement
Math: Interpolation
Math: Transforms


 ANIMATION
Using Godot’s animation system.

In this section:
Spritesheet animation
Using the AnimationTree StateMachine


SPRITESHEET ANIMATION
Problem
You want to use a spritesheet containing 2D animations.

Solution
Spritesheets are a common way for 2D animations to be distributed. In a spritesheet, all of the animation frames are packed into a single image.

For this demo, we’ll be using the excellent “Adventurer” sprite by Elthen. You can get this and lots of other great art athttps://elthen.itch.io/.

alt
 Warning
Make sure the images in your spritesheet are laid out in a constant-sized grid. This will enable Godot to automatically slice them. If they’re packed irregularly, you will not be able to use the following technique.

Node setup
This animation technique uses a Sprite2D node to display the texture, and then we animate the changing frames with AnimationPlayer. This can work with any 2D node, but for this demo, we’ll use a CharacterBody2D.

Add the following nodes to your scene:

CharacterBody2D: Player
   Sprite2D
   CollisionShape2D
   AnimationPlayer
Drag the spritesheet texture into the Texture property of the Sprite2D. You’ll see the entire spritesheet displayed in the viewport. To slice it up into individual frames, expand the “Animation” section in the Inspector and set the Hframes to 13 and Vframes to 8. Hframes and Vframes are the number of horizontal and vertical frames in your spritesheet.

alt
Try changing the Frame property to see the image change. This is the property we’ll be animating.

Adding animations
Select the AnimationPlayer and click the “Animation” button followed by “New" . Name the new animation “idle”. Set the animation length to 2 and click the “Loop” button so that our animation will repeat (see below).

With the scrubber at time 0, select the Sprite2D node. Set its Animation/Frame to 0, then click the key icon next to the value.

alt
If you try playing the animation, you’ll see it doesn’t appear to do anything. That’s because the last frame (12) looks the same as the first (0), but we’re not seeing any of the frames in-between (1-11). To fix this, change the “Update Mode” of the track from its default value of “Discrete” to “Continuous”. You can find this button at the end of the track on the right side.

alt
Note that this will only work for spritesheets where the frames are already in order. If they are not, you’ll have to keyframe each Frame seperately along the timeline.

alt
Feel free to add the other animations yourself. For example, the “jump” animation is on frames 65 through 70.

Related recipes
Platform character

USING THE ANIMATIONTREE STATEMACHINE
Problem
A common situation: you have a large number of animations, and it’s becoming difficult to manage transitions between them. Your code has become full of if statements, and every time you change something, it all breaks.

Solution
Use an AnimationTree to create an animation state machine. This will allow us to organize our animations and most importantly, control the transitions between them.

Getting started
For this demo, we’ll be using the excellent “Adventurer” sprite by Elthen. You can get this and lots of other great art at https://elthen.itch.io/.

alt
We’ll also assume you’ve already set up the character’s animations using AnimationPlayer. Using the above spritesheet, we have the following animations: “idle”, “run”, “attack1”, “attack2”, “hurt”, and “die”.

AnimationTree
Add an AnimationTree node to the scene. In its Tree Root property, choose “New AnimationNodeStateMachine”.

alt
An AnimationTree is a node that controls animations created in AnimationPlayer. To let it access the existing animations, click “Assign” in the Anim Player property and select your animation node.

Now we can begin to set up our state machine in the AnimationTree panel:

alt
Note the warning. Set the Active property to “On” in the Inspector.

Right-click and choose “Add Animation”. Choose “idle”, and you’ll see a small box representing that animation. Press its “Play” button and you should see the animation play. Do the same to add boxes for the other animations.

Now we can add connections. Click the “Connect nodes” button and drag between nodes to connect them. As an example, let’s use the two attack animations:

alt
When you select an animation, the tree will follow the connected path from the current node to the destination. However, in the configuration above, if you play “attack2” you won’t see “attack1” along the way. That’s because the default “switch mode” for a connection is “Immediate”. Click the “Move/select” button and then click on the connection between “attack1” and “attack2”. In the Inspector, change Switch Mode to “At End”. Do the same with “attack2” to “idle”. The connection icon changes from  to .

Now, with “idle” playing, if you click “attack2”, you’ll see the two attacks play in sequence.

But now the animation stops on “attack2”. On its connection, set the Advance/Mode property to “Auto”. This will make the tree go back to “idle” after playing both animations. Note that the connection icon turns green to show this.

alt
Now the animations are played in sequence whenever they’re triggered.

Calling states in code
Here is the full tree for all of the animations:

alt
Now let’s set up the character to use these animations in a script.

extends CharacterBody2D

var state_machine
var run_speed = 80.0
var attacks = ["attack1", "attack2"]

@onready var state_machine = $AnimationTree["parameters/playback"]
state_machine holds a reference to the state machine, which is an AnimationNodeStateMachinePlayback. To call a specific animation, you use travel(), which will follow the connections to the given animation.

func hurt():
    state_machine.travel("hurt")

func die():
    state_machine.travel("die")
    set_physics_process(false)
Here we have examples of functions we would call if the player is hurt or killed. For the other animations (running, attacking, etc.), we’ll need to combine them with our input and movement code. velocity determines whether we should be showing “run” or “idle”.

func get_input():
    var current = state_machine.get_current_node()
    velocity = Input.get_vector("move_left", "move_right", "move_up", "move_down") * run_speed
    if Input.is_action_just_pressed("attack"):
        state_machine.travel(attacks.pick_random())
        return
    # flip the character sprite left/right
    if velocity.x != 0:
        $Sprite2D.scale.x = sign(velocity.x)
    # choose animation
    if velocity.length() > 0:
        state_machine.travel("run")
    else:
        state_machine.travel("idle")
    move_and_slide()
Note that we’re using return after traveling to the attack animations. This is so that we won’t instead travel to the “run” or “idle” animations further down in the function.

alt
You can use the AnimationTreeStateMachine to handle

 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/ai_behavior_demos

Related recipes
Spritesheet animation
Top-down character


 INPUT
Handling input - from keyboard and mouse to game controllers and touchscreens.

In this section:
Input Actions
Mouse Input
Adding Input Actions in code
Capturing the Mouse
Mouse: Drag-select multiple units


INPUT ACTIONS
Problem
You want to understand Godot’s “input action” system.

Solution
Let’s say you’re making a top-down character and you write code using InputActionKey that uses the arrow keys for movement. You’ll quickly find that many players prefer to use “WASD” style controls. You can go back into your code and add the additional key checks, but this would result in duplicated/redundant code.

Input actions can help to make your code more configurable. Rather than hard-coding specific keys, you’ll be able to modify and customize them without changing the code.

Creating inputs
You define input actions in the “Project Settings” under the “Input Map” tab. Here, you can create new actions and/or assign inputs to them.

You’ll see when you click on the tab there are already some default actions configured. They are all named “ui_*” to indicate that they are the default interface actions. “Tab” for next UI element, for example.

Generally speaking, you should create your own actions for your game, rather than use the existing ones.

For this example, let’s say you want to allow the player to control the game with the keyboard or the mouse. They need to be able to shoot by pressing either the left mouse button or the spacebar.

Create the new action “shoot” by typing the name in the “Action” field at the top and clicking “Add” (or pressing enter). Scroll to the bottom and you’ll see the new action has been added to the list.

Now you can assign inputs to this action by clicking the “+” sign to the right. Inputs can be keys, mouse buttons, or joy/gamepad inputs. Choose “Key” and you can press the key on the keyboard you want to assign - let’s press the spacebar - and click “OK”.

Click “+” to add another input, and this time choose “Mouse Button”. The default of “Device 0” and “Left Button” is fine, but you can select others if you like.

Using input actions
You can check for the action either by polling the Input singleton every frame:

func _process(delta):
    if Input.is_action_pressed("shoot"):
        # This will execute every frame as long as the input is held.
This is best for continuous actions - i.e. those you want to check constantly, such as movement.

If instead you want to detect the action at the moment it occurs, you can use the _input() or _unhandled_input() callbacks:

func _unhandled_input(event):
    if event.is_action_pressed("shoot"):
       # This will run once on the frame when the action is first pressed
There are several functions you can use for checking input state:

is_action_pressed(): This function returns true if the action is currently in the pressed state.

is_action_released(): This function returns true if the action is not In the pressed state.

is_action_just_pressed() / is_action_just_released(): These methods work like the above, but only return true on the single frame after the event occurs. This is useful for non-recurring actions like shooting or jumping where the user needs to let go and then press the key again to repeat the action.

Related Recipes
Inputs: Introduction



MOUSE INPUT
Problem
You want to detect mouse input.

Solution
InputEventMouse is the base class for mouse events. It contains position and global_position properties. Inheriting from it are two classes: InputEventMouseButton and InputEventMouseMotion.

 Note
You can assign mouse button events in the InputMap, so you can use them with is_action_pressed().

InputEventMouseButton
@GlobalScope.ButtonList contains a list of BUTTON_* constants for each possible button, which will be reported in the event’s button_index property. Note that the scrollwheel also counts as a button - two buttons, to be precise, with both BUTTON_WHEEL_UP and BUTTON_WHEEL_DOWN being separate events.

 Tip
Unlike regular buttons, mouse wheel clicks only produce pressed events. There is no concept of a mouse wheel click being “released”.

func _unhandled_input(event):
    if event is InputEventMouseButton:
        if event.button_index == BUTTON_LEFT:
            if event.pressed:
                print("Left button was clicked at ", event.position)
            else:
                print("Left button was released")
        if event.button_index == BUTTON_WHEEL_DOWN:
            print("Wheel down")
InputEventMouseMotion
These events occur whenever the mouse moves. You can find the distance moved (in screen coordinates) with the relative property.

Here’s an example using mouse movement to rotate a 3D character:

# Converts mouse movement (pixels) to rotation (radians).
var mouse_sensitivity = 0.002

func _unhandled_input(event):
    if event is InputEventMouseMotion:
        rotate_y(-event.relative.x * mouse_sensitivity)



ADDING INPUT ACTIONS IN CODE
Problem
You need to add actions to the InputMap at runtime.

Solution
Typically, you’ll add actions to the InputMap via Project Settings, as shown in Recipe: Input Actions. However, you may find yourself needing to add one or more actions directly in a script. The InputMap singleton has methods to help you do this.

Here’s an example that would add a new action called “attack” using the space key:

func _ready():
    InputMap.add_action("attack")
    var ev = InputEventKey.new()
    ev.keycode = KEY_SPACE
    InputMap.action_add_event("attack", ev)
If you also wanted to add the left mouse button to the same action:

ev = InputEventMouseButton.new()
ev.button_index = MOUSE_BUTTON_LEFT
InputMap.action_add_event("attack", ev)
 Note
InputMap.add_action() will produce an error if the action already exists. You should check first with InputMap.has_action() before attempting to add a new action.

Practical Example
Let’s say you’ve made the platform character from Recipe: Platform character and you want to re-use it in another project. If you saved the scene, script, and assets in a single folder, you need only copy that folder to your new project. But you’d still need to edit the Input Map in order for the inputs to work.

Instead, you could add the following code to the player script and be sure that the necessary input actions will be added automatically:

var controls = {"walk_right": [KEY_RIGHT, KEY_D],
                "walk_left": [KEY_LEFT, KEY_A],
                "jump": [KEY_UP, KEY_W, KEY_SPACE]}

func _ready():
    add_inputs()

func add_inputs():
    var ev
    for action in controls:
        if not InputMap.has_action(action):
            InputMap.add_action(action)
        for key in controls[action]:
            ev = InputEventKey.new()
            ev.keycode = key
            InputMap.action_add_event(action, ev)
Related recipes
Input Actions
Platform Character


CAPTURING THE MOUSE
Problem
You want to hide the mouse cursor and keep the mouse from leaving the game window. This is common in many 3D games (and some 2D ones).

Solution
You can set the mouse state using Input.mouse_mode. There are four possible mouse modes:

MOUSE_MODE_VISIBLE: The mouse is visible and can move freely into and out of the window. This is the default state.

MOUSE_MODE_HIDDEN: The mouse cursor is invisible, but the mouse can still move outside the window.

MOUSE_MODE_CAPTURED: The mouse cursor is hidden and the mouse is unable to leave the game window.

MOUSE_MODE_CONFINED: The mouse is visible, but cannot leave the game window.

“Captured” is the most commonly used option. You can set the mouse mode at runtime using:

func _ready():
    Input.mouse_mode = Input.MOUSE_MODE_CAPTURED
When the mouse is captured, mouse input events will still be passed as normal. However, you will find there is a problem. If you want to close the game or switch to another window, you can’t. For this reason, you will want to also include a way to “release” the mouse. For example, to release when the player pressed the Escape key:

func _input(event):
    if event.is_action_pressed("ui_cancel"):
        Input.mouse_mode = Input.MOUSE_MODE_VISIBLE
So that the game doesn’t respond to mouse movement when you’re in another window, you can test for the capture state in your character controller using:

if Input.mouse_mode == Input.MOUSE_MODE_CAPTURED:
Once the mouse is released, that leaves the need to re-capture it to continue playing. Assuming you have an event in the Input Map for a mouse click, you can do the following:

    if event.is_action_pressed("click"):
        if Input.mouse_mode == Input.MOUSE_MODE_VISIBLE:
            Input.mouse_mode = Input.MOUSE_MODE_CAPTURED
Since you may also be using a mouse click to shoot or perform some other action, it’s probably a good idea to stop the event from propagating. Add this after setting the mouse mode:

get_tree().set_input_as_handled()



MOUSE: DRAG-SELECT MULTIPLE UNITS
Problem
You want to click-and-drag to select multiple units, RTS style.

Solution
Realtime strategy (RTS) games often require giving orders to many units at once. A typical style of selecting multiple units is to click-and-drag a box around them. Once the units are selected, clicking on the map commands them to move.

Here’s an example of what we’re going for:

alt
Unit setup
To test this out, we’ll need some basic RTS-style units. They are set up to move towards a target and to avoid running into each other. We won’t go into too much detail on them in this tutorial. The unit script is commented if you’d like to use it as a base for creating your own RTS units. See below for a link to download the project.

World setup
Processing the unit selection will happen in the world. We’ll start with a Node2D called “World” and add a few Unit instances in it. Attach a script to the World node and add the following variables:

extends Node2D

var dragging = false  # Are we currently dragging?
var selected = []  # Array of selected units.
var drag_start = Vector2.ZERO  # Location where drag began.
var select_rect = RectangleShape2D.new()  # Collision shape for drag box.
Note that once we’ve drawn the box, we’ll need a way to find what units are inside it. The RectangleShape2D will allow us to query the physics engine and see what we collided with.

Drawing the box
We’ll be using the left mouse button for this. Clicking starts a drag and then letting go ends it. During dragging, we’ll draw the rectangle for visibility.

func _unhandled_input(event):
    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
        if event.pressed:
            # If the mouse was clicked and nothing is selected, start dragging
            if selected.size() == 0:
                dragging = true
                drag_start = event.position
        # If the mouse is released and is dragging, stop dragging
        elif dragging:
            dragging = false
            queue_redraw()
    if event is InputEventMouseMotion and dragging:
        queue_redraw()

func _draw():
    if dragging:
        draw_rect(Rect2(drag_start, get_global_mouse_position() - drag_start),
                Color.YELLOW, false, 2.0)
Selecting the units
Now that we’ve got a selection box, we need to find the units that are inside it. When we release the button and the drag ends, we must query the physics space to find the units. Note that the units are CharacterBody2D, but Area2D or other bodies would work as well.

We’ll use PhysicsDirectSpaceState2D.intersect_shape() to find the units. This requires a shape (our rectangle) and a transform (our location). See Godot docs for details.

elif dragging:
    dragging = false
    queue_redraw()
    var drag_end = event.position
    select_rect.extents = abs(drag_end - drag_start) / 2
We start by recording the location when we released the button, and use that to set the RectangleShape2D’s extents (remember: extents are measured from the rectangle’s center, so they’re half the full width/height).

    var space = get_world_2d().direct_space_state
    var query = PhysicsShapeQueryParameters2D.new()
    query.shape = select_rect
    query.collision_mask = 2  # Units are on collision layer 2
    query.transform = Transform2D(0, (drag_end + drag_start) / 2)
    selected = space.intersect_shape(query)
Now we get a reference to the physics state and set up our shape query using PhysicsShapeQueryParameters2D, assigning it our shape, and using the center of the dragged area as the origin for the query’s transform. Our result after calling intersect_shape() is an array of dictionaries, which looks like this:

[{ "rid": RID(4093103833089), "collider_id": 32145147326, "collider": Unit2:<CharacterBody2D#32145147326>, "shape": 0 },
{ "rid": RID(4123168604162), "collider_id": 32229033411, "collider": Unit3:<CharacterBody2D#32229033411>, "shape": 0 }]
Each of those collider items is a reference to a unit, so we can use this to notify them that they’ve been selected, activating the outline shader:

    for item in selected:
        item.collider.selected = true
alt
Commanding the units
Finally, we can command the selected units to move by clicking somewhere on the screen:

func _unhandled_input(event):
    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
        if event.pressed:
            # If the mouse was clicked and nothing is selected, start dragging
            if selected.size() == 0:
                dragging = true
                drag_start = event.position
            # Otherwise a click tells the selected units to move
            else:
                for item in selected:
                    item.collider.target = event.position
                    item.collider.selected = false
                selected = []
The else clause here triggers if we click the mouse when selected is greater than 0. Each item’s target is set, and we make sure to deselect the units so we can start again.

Wrapping up
This technique can be expanded to a wide range of RTS or other game styles. Download the full project below and use it as a base for your own game.

 Download This Project
Download the project code here: https://github.com/godotrecipes/multi_unit_select

Related recipes
Mouse Input


 UI
Building user interfaces.

In this section:
Heart Containers: 3 Ways
Level Select Menu
Minimap/radar


HEART CONTAINERS: 3 WAYS
Problem
You need to display a heart container bar (or other icon-based bar).

Solution
A common way of displaying the player’s health is via a series of icons (typically hearts) that disappear as the player takes damage.

In this recipe, we’re going to explore three ways of displaying this information, which I’m labeling “simple”, “empty”, and “partial”:

alt
This image shows what the bar displays when the player has 3 health.

simple: Only the hearts are displayed.
empty: Empty heart containers are displayed.
partial: The player can have partially filled containers.
Setting up the bar
The heart images I’m using are 53x45. You can get them here:

Kenney.nl: Platformer Art Deluxe

Ideally, your heart bar will be easy to drop into your overall HUD/UI. It therefore makes sense to make it a separate scene. We’ll start with an HBoxContainer which will keep things aligned. Set the Theme Overrides/Constants/Separation to 5.

Add a TextureRect child. Drag your heart texture into the Texture property and set the Stretch Mode to “Keep”. Name the node “1” and then press “Ctrl-D” to duplicate the node for as many hearts as you need (5 in this example). Your node setup should look like this:

alt
Adding a script
The script below will cover all three bar configurations for flexibility. You’ll probably only need one in your game, so you can remove the code relating to the other modes.

To begin, we’re going to load the textures we need and define our three bar modes:

extends HBoxContainer

enum modes {SIMPLE, EMPTY, PARTIAL}

var heart_full = preload("res://assets/hud_heartFull.png")
var heart_empty = preload("res://assets/hud_heartEmpty.png")
var heart_half = preload("res://assets/hud_heartHalf.png")

@export var mode : modes

func update_health(value):
    match mode:
        MODES.simple:
            update_simple(value)
        MODES.empty:
            update_empty(value)
        MODES.partial:
            update_partial(value)
Calling update_health() on the bar will cause it to display the passed value, based on the selected mode.

 Note
We’re not going to do any bounds checking on the value input. There are many ways you may have health implemented in your game, and so that’s left to you.

First, the update_simple() method. Here, we loop through the heart containers and set the visibility of each TextureRect:

func update_simple(value):
    for i in get_child_count():
        get_child(i).visible = value > i
update_empty() is very similar, except instead of hiding the icon, we change its texture to the empty container:

func update_empty(value):
    for i in get_child_count():
        if value > i:
            get_child(i).texture = heart_full
        else:
            get_child(i).texture = heart_empty
Finally, for the partially filled containers, we have a third texture and twice the number of possible values:

func update_partial(value):
    for i in get_child_count():
        if value > i * 2 + 1:
            get_child(i).texture = heart_full
        elif value > i * 2:
            get_child(i).texture = heart_half
        else:
            get_child(i).texture = heart_empty
Here’s an example using each of the bar modes:

alt
Wrapping up
Use this heart bar setup as a basis for your own HUD. This technique can be expanded to support a wide variety of information displays.

 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/heart_bars


LEVEL SELECT MENU
Problem
Your game needs a “level select” menu, where the user can choose from a grid of options.

alt
Solution
As shown in the example above, we’ll make a scrolling grid of level “boxes” that the player can choose from. Let’s start with the individual level boxes:

1: Level box
Here’s the node setup:

LevelBox:  PanelContainer
     Label
     MarginContainer
         TextureRect
The  TextureRect is for displaying the lock icon, and the  Label for displaying the level number. When one is showing, the other is hidden.

You can style these as you like, here’s an example:

alt
Make sure to set the LevelBox’s Custom Minimum Size in the Inspector. We’re using (110, 110) in the example, but it depends on what size layout you’re going for.

Now add a script and connect the gui_input signal.

@tool
extends PanelContainer

signal level_selected

@export var locked = true:
    set = set_locked
@export var level_num = 1:
    set = set_level

@onready var lock = $MarginContainer/Lock
@onready var label = $Label

func set_locked(value):
    locked = value
    if not is_inside_tree():
        await ready
    lock.visible = value
    label.visible = not value

func set_level(value):
    level_num = value
    if not is_inside_tree():
        await ready
    label.text = str(level_num)


func _on_gui_input(event):
    if locked:
        return
    if event is InputEventMouseButton and event.pressed:
        level_selected.emit(level_num)
        print("Clicked level ", level_num)
We’re using @tool here so that we can make changes to the properties in the inspector and see them right away, without running the scene. Go ahead and try clicking the Locked property and verify that you see the lock appear/disappear.

Since we don’t have actual levels to load in this project, the print() statement can help test that the click is being detected.

2: Grid
Once you have the box scene completed, add a new scene with a GridContainer. Add any number of LevelBox instances under it, making sure to set the Columns value. Here’s one with 6 columns:

alt
In this example Theme Overrides/Constants/H Separation and V Separation are set to 10.

Save this scene as LevelGrid. In the menu, we’ll use multiple instances to display the desired number of levels.

3: Menu screen
Now we can put together the final menu.

Here’s the basic layout we’re going for:

alt
We’ll create it with these nodes:

LevelMenu: MarginContainer
     VBoxContainer
        Title:  Label
         HBoxContainer
            BackButton:  TextureButton
            ClipControl:  Control
            NextButton:  TextureButton
Adjust the node properties:

LevelMenu
Theme Overrides/Constants/Margins: 20
 VBoxContainer
Theme Overrides/Constants/Separation: 50
 Title
Style the font however you like
 BackButton / NextButton
Ignore Texture Size: On
Stretch Mode: Keep Centered
Layout/Container Sizing/Horizontal/Expand: On
 ClipControl
Layout/Clip Contents: On
Layout/Custom Minimum Size: (710, 350) (size of the LevelGrid)
The ClipControl node is where the grid goes. Enabling Clip Contents means that if the contents are larger than the control, they’ll be cropped. That will allow us to make a horizontally scrolling set of grids. Add an  HBoxContainer called GridBox to ClipControl, and instance 3 (or more) LevelGrids inside it.

Make sure to set Theme Overrides/Constants/Separation to 0.

Your layout should look something like this (we’ve disabled Clip Contents in order to show what’s happening):

alt
With Clip Content, the three grids are all there, but the ClipControl only shows one at a time.

Now, to scroll the menu, we need to shift the GridBox by 710 pixels to the left/right.

110 (width of each LevelBox)
    * 6 (grid columns)
    + 10 (grid spacing) * 5
    == 710
 Info
You may be wondering why we’re not using a ScrollContainer here. You certainly can, but we don’t want continuous scrolling, and we don’t want to see a scrollbar.

Add a script to the LevelMenu and connect the pressed signals of the two buttons.

extends MarginContainer

var num_grids = 1
var current_grid = 1
var grid_width = 710

@onready var gridbox = $VBoxContainer/HBoxContainer/ClipControl/GridBox

func _ready():
    # Number all the level boxes and unlock them
    # Replace with your game's level/unlocks/etc.
    # You can also connect the "level_selected" signals here
    num_grids = gridbox.get_child_count()
    for grid in gridbox.get_children():
        for box in grid.get_children():
            var num = box.get_position_in_parent() + 1 + 18 * grid.get_position_in_parent()
            box.level_num = num
            box.locked = false

func _on_BackButton_pressed():
    if current_grid > 1:
        current_grid -= 1
        gridbox.rect_position.x += grid_width

func _on_NextButton_pressed():
    if current_grid < num_grids:
        current_grid += 1
        gridbox.rect_position.x -= grid_width
When you run the scene, try clicking the “Next” and “Back” buttons and verify that it’s scrolling as expected. Clicking the individual level boxes should print to the console.

Download the example project to see the whole thing in action, including some tweens for the scrolling action (because tweens make everything better).

 Download This Project
Download the project code here: https://github.com/godotrecipes/ui_level_select


MINIMAP/RADAR
Problem
You want a minimap or radar-style UI item showing the locations of objects outside of the player’s view.

Solution
Here’s an example of what we are going for: 

Project setup
To illustrate this feature, we’ll start with a simplified top-down game using the Autotile recipe and a player based on the Top-down character recipe. See the linked recipes for details on how these parts work.

 Note
The art in this project comes from kenney.nl, which you can download here: Minimap Assets.

Our main scene setup looks like this:

alt
The CanvasLayer node is there to hold our UI, including the minimap/radar we’re making in this recipe.

UI Layout
The first step will be to create the layout for the minimap. In order to work with whatever other UI elements exist in the game, it must resize smoothly, and integrate well with a container-based layout.

Add a MarginContainer first. Set its Theme Overrides/Constants all to 5. This control will hold the rest of the nodes and ensure it doesn’t bleed over into any other elements. Name it “Minimap” and save the scene.

Next, add a NinePatchRect node. This node is similar to a TextureRect but handles resizing differently by not stretching the corners/edges. Drop the panel_woodDetail_blank.png image from the asset folder into the Texture property. This is a 128x128 image and if we scale the root MarginContainer, the image becomes stretched and ugly:

alt
Using the NinePatchRects’s properties, we can ensure that the frame remains the same size when stretched. You can define these properties graphically in the “TextureRegion” panel, but it’s sometimes easier to enter the values directly. Set all four properties in the Patch Margin section to 64 and change the node’s name to “Frame”.

Now observe what happens when we change the size:

alt
Next, we’d like to fill in the inner part of the frame with the grid pattern pattern_blueprintPaper.png:

alt
However, we need it to tile automatically no matter what size we make the frame. Also, since this grid area is where our minimap markers will appear, we don’t want the grid extending past the edges of the frame.

As a child of the MiniMap (and a sibling of the Frame), add another MarginContainer. Set all four margin properties in Theme Overrides/Constants to 20. As a child of this node, add a TextureRect and assign its Texture to the above image. Set its Stretch Mode to “Tile”. Name this node “Grid”.

Try changing the size of your root node to see the effect:

alt
For now, let’s leave the minimap’s size at (200, 200) - you can check the root node’s Size property in the Layout section to confirm.

At this point, your scene tree should look like the following:

alt
Map Markers
As a child of Grid, add a Sprite2D node named “PlayerMarker” and give it the minimapIcon_arrowA.png texture. Note the sprite’s Transform/Position property: (0, 0), which places it exactly in the top-left corner of the Grid:

alt
If our Grid size is currently (150, 150) (you can check this in its Size property), then its center will be (75, 75). Put the PlayerMarker’s Position there:

alt
Don’t worry, we’ll automate this later.

Add two more Sprite2D nodes: “MobMarker” and “AlertMarker”, using the minimapIcon_jewelRed.png and minimapIcon_exclamationYellow.png textures.

alt
These will represent two different types of objects in the game world. Click the “Toggle Visibility” button next to each so that they won’t appear by default.

Scripting the map markers
At this point, we have some decisions to make. How we approach populating the minimap with the objects in the world has a lot to do with how the game is set up. Since this is a very minimal demonstration project, we’re going keep the process simple. In a larger game, you may need to use a more robust approach.

For this demo, we have two game objects: a Mob, which wanders around the map randomly, and a Crate, which the player can pick up. Many of these are scattered around the main scene. Each will need to be represented by one of the map markers we made.

Add each item that you want to appear on the minimap to a group named “minimap_objects”. In each object’s script, assign it a minimap_icon property:

# In the mob's script:
var minimap_icon = "mob"

# In the crate's script:
var minimap_icon = "alert"
Now we can begin adding a script to the Minimap. First, a player reference that can be assigned in the Inspector when the minimap is added to the main scene and a zoom property to calibrate the scale - how far the minimap can “see”. We also have some @onready variables to make it more convenient to access the nodes we need.

extends MarginContainer
class_name Minimap

@export var player: Player
@export var zoom = 1.5

@onready var grid = $MarginContainer/Grid
@onready var player_marker = $MarginContainer/Grid/PlayerMarker
@onready var mob_marker = $MarginContainer/Grid/MobMarker
@onready var alert_marker = $MarginContainer/Grid/AlertMarker
Next, we’ll use a dictionary to map the minimap_icon tags we gave our units to the corresponding marker:

@onready var icons = {
    "mob": mob_marker,
    "alert": alert_marker
}
Then we need a variable to hold the calculated ratio of map size to world size. We’ll use another dictionary to assign active markers to each object. The key will be the object (ie the Mob or Crate instance) and the value the assigned marker.

var grid_scale
var markers = {}
In _ready() we’ll center the player’s marker at the center of the grid. and calculate the scale factor. (Note: you’ll need to connect the resized signal and do both of these things in the callback if you have a dynamically sized UI).

func _ready():
    await get_tree().process_frame
    player_marker.position = grid.size / 2
    grid_scale = grid.size / (get_viewport_rect().size * zoom)
 Nodes in Containers
Due to the way that Container nodes handle their children, at _ready() time you won’t get the correct value for the child’s size. For this reason, we need to wait until the next frame to get the Grid’s size.

We’ll also create markers for every game object (using the “minimap_objects” group) by duplicating the matching marker node and tying the marker to the object via the markers dictionary:

    var map_objects = get_tree().get_nodes_in_group("minimap_objects")
    for item in map_objects:
        var new_marker = icons[item.minimap_icon].duplicate()
        grid.add_child(new_marker)
        new_marker.show()
        markers[item] = new_marker
Now that we have created the markers and linked each one to an object, we can update their positions in _process(). If no player is assigned, we’ll do nothing:

func _process(delta):
    if !player:
        return
If there is a player, we’ll first rotate the player marker to match the player’s heading. Since our PlayerMarker sprite points upwards rather than along the x axis, we must add 90 degrees:

player_marker.rotation = player.rotation + PI/2
Next, we’ll find each object’s position relative to the player and use that to find the marker’s position (remembering to offset by grid.size / 2 because the control’s origin is in the top left corner).

for item in markers:
    var obj_pos = (item.position - player.position) * grid_scale + grid.size / 2
    markers[item].position = obj_pos
The problem with this is that markers can be placed outside the grid:

alt
To fix this, after calculating obj_pos, but before setting the marker’s position, clamp it to the grid’s rectangle:

obj_pos = obj_pos.clamp(Vector2.ZERO, grid.size)
alt
We can also decide what to do about markers that are “off-screen” - when they would be outside the grid’s rectangle. Choose one of the following options (do this also before using clamp()). The first option is to hide them:

if grid.get_rect().has_point(obj_pos + grid.position):
    markers[item].show()
else:
    markers[item].hide()
The second is to change their appearance, in this case we’ll make them smaller to show they’re at a farther distance:

if grid.get_rect().has_point(obj_pos + grid.position):
    markers[item].scale = Vector2(1, 1)
else:
    markers[item].scale = Vector2(0.75, 0.75)
alt
Removing objects
If a mob gets killed or a crate picked up, the game will crash because the marker reference is no longer valid. We need a way to ensure markers are removed when the object is. Here’s a quick way to do this in our rudimentary demo setup:

Add signal removed to any object that you’ve put in the “minimap_objects” group. Emit this signal when the object is destroyed (or collected), along with a reference to itself so the map can identify it:

removed.emit(self)
In the _ready() of the main script, connect these signals to the minimap:

func _ready():
    for object in get_tree().get_nodes_in_group("minimap_objects"):
        object.removed.connect(minimap._on_object_removed)
Now add the receiving function to the minimap script to free the marker and remove the reference:

func _on_object_removed(object):
    if object in markers:
        markers[object].queue_free()
        markers.erase(object)
Adjusting zoom
If you’ve stuck with it this far, we have one more feature to add: adjustable zoom level. With this, scrolling the mouse wheel when hovering over the map will zoom its scale in and out.

First, add a setter to the zoom property:

@export var zoom = 1.5:
    set = set_zoom

func set_zoom(value):
    zoom = clamp(value, 0.5, 5)
    grid_scale = grid.size / (get_viewport_rect().size * zoom)
On the MiniMap node, connect the _gui_input signal in the Inspector so we can process the scroll wheel events:

func _on_gui_input(event):
    if event is InputEventMouseButton and event.pressed:
        if event.button_index == MOUSE_BUTTON_WHEEL_UP:
            zoom += 0.1
        if event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
            zoom -= 0.1
That’s it - observe the effect of scrolling in and out:

alt
Wrapping up
While this is a pretty big recipe, I’ve tried to make it flexible enough for you to incorporate into whatever project you’re working on.

Some other things you might want to add:

More marker types for different game objects.
Adding new units when they’re spawned (hint: use a signal just like we did for removing units).
Clicking on a marker to get info about it.
Use a picture of your map as the minimap background instead of the grid.
 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/minimap

Related recipes
Top-down character


 GAMEDEV MATH
Math is a big part of game development. Some of it you may remember from school, or it may be something you’ve never encountered before. Here you’ll find guides to help you get up to speed and examples of how these concepts are applied to making games.

In this section:
Interpolation
Transforms
Vectors: Using Dot and Cross Product


INTERPOLATION
Linear Interpolation, or its commonly-used abbreviation lerp, is a term that comes up often in game development. If you’ve never come across it before it can seem mysterious and highly-technical, but as you’ll see in this tutorial, it’s actually a straightforward concept with a wide variety of applications in game programming.

Numeric Interpolation
The core formula for linear interpolation is this:

func lerp(a, b, t):
    return (1 - t) * a + t * b
In this formula, a and b represent the two values and t is the amount of interpolation, typically expressed as a value between 0 (which returns a), and 1 (which returns b). The function finds a value the given amount between the two. For example:

x = lerp(0, 1, 0.75)  # x is 0.75
x = lerp(0, 100, 0.5)  # x is 50
x = lerp(10, 75, 0.3)  # x is 29.5
x = lerp(30, 2, 0.75)  # x is 9
It’s called linear interpolation because the path between the two points is a straight line.

You can animate a node’s properties with lerp(). For example, if you divide the elapsed time by the desired duration, you’ll get a value between zero and one you can use to alter a property smoothly over time. This script scales a sprite up to five times its starting size while fading it out (using modulate.a) over two seconds:

extends Sprite2D

var time = 0
var duration = 2  # length of the effect

func _process(delta):
    if time < duration:
        time += delta
        modulate.a = lerp(1, 0, time / duration)
        scale = Vector2.ONE * lerp(1, 5, time / duration)
Vector interpolation
You can also interpolate between vectors. Both Vector2 and Vector3 provide linear_interpolate() methods for this.

For example, to find a vector that’s halfway between a Spatial node’s forward and left direction vectors:

var forward = -transform.basis.z
var left = transform.basis.x
var forward_left = forward.linear_interpolate(left, 0.5)
The following example moves a Sprite node towards the mouse click position. Each frame the node moves 10% of the way to the target. This results in an “approach” effect, where the object’s speed becomes slower the closer it gets to the target.

extends Sprite2D

var target

func _input(event):
    if event is InputEventMouseButton and event.pressed:
        target = event.position

func _process(delta):
    if target:
        position = position.linear_interpolate(target, 0.1)
For more advanced applications of interpolation, see Tween.


TRANSFORMS
Before reading this, make sure you have an understanding of vectors and how they’re used in game development. If you don’t, I recommend you read this introduction I wrote for the Godot documentation: Vector Math.

2D Transforms
In 2D space, we use the familiar X-Y coordinate plane. Remember that in Godot, as in most computer graphics applications, the Y axis points downward:

alt
To begin, let’s consider this spaceship floating in space:

alt
The ship is pointing in the same direction as the X axis. If we wanted it to move forward, we could add to its X coordinate and it would move to the right:

position += Vector2(10, 0)
But what happens when the ship rotates?

alt
How do we move the ship forward now? If you remember Trigonometry from school, you might be starting to think about angles, sine and cosine and doing something like position += Vector2(10 * cos(angle), 10 * sin(angle)). While this would work, there’s a much more convenient way: the Transform.

Let’s look at the rotated ship again, but this time, let’s also imagine that the ship has its own X and Y axes that it carries with it, independent of the global axes:

alt
These “local” axes are contained in the object’s transform.

Knowing this, we can move the ship forward by moving it along its own X axis and we won’t have to worry about angles and trig functions. To do this in Godot, we can use the transform property, which is available to all Node2D derived nodes.

    position += transform.x * 10
This code says “Add the transform’s x vector multiplied by 10.” Let’s break down what that means. The transform contains x and y properties that represent those local axes. They are unit vectors, which means their length is 1. Another term for unit vector is direction vector. They tell us the direction the ship’s x axis is pointing. We then multiply by 10 to scale it to a longer distance.

 Tip
The transform property of a node is relative to its parent node. If you need to get the global value, it’s available in global_transform.

In addition to the local axes, the transform also contains a component called the origin. The origin represents the translation, or change in position.

In this picture, the blue vector is the transform.origin. It is equal to the object’s position vector.

alt
Converting Between Local and Global Space
You can convert coordinates from local to global by applying the transform. For convenience, Node2D and Spatial include helper functions for this: to_local() and to_global():

    var global_position = to_global(local_position)
Let’s use the example of an object in the 2D plane and convert mouse clicks (global space) into coordinates relative to the object:

extends Sprite

func _unhandled_input(event):
    if event is InputEventMouseButton and event.pressed:
        if event.button_index == BUTTON_LEFT:
            printt(event.position, to_local(event.position))
See the Transform2D docs for a list of the available properties and methods.

3D Transforms
In 3D space, the concept of transforms applies in the same way as in 2D. In fact, it becomes even more necessary, as using angles in 3D can lead to a variety of problems, as we’ll see in a bit.

3D nodes inherit from the base node Node3D, which contains the transform information. The 3D transform requires more information than the 2D version. Position is still held in the origin property, but rotation is in a property called basis, which contains three unit vectors representing the body’s local X, Y, and Z axes.

When you select a 3D node in the editor, the gizmo that appears allows you to manipulate the transform.

alt
 Local Space Mode
In the editor, you can see and manipulate the body’s local orientation by clicking the “Local Space Mode” button.altWhen in this mode, the 3 colored axis lines represent the body’s local basis axes.

As in 2D, we can use the local axes to move an object forward. In Godot’s 3D orientation (Y-up), this means that by default the body’s -Z axis is the forward direction. To move forward:

    position += -transform.basis.z * speed * delta
 Tip
Godot has default vector values defined, for example: Vector3.FORWARD == Vector3(0, 0, -1). See Vector2 and Vector3 for details.


VECTORS: USING DOT AND CROSS PRODUCT
Problem
You’d like to understand what is meant by dot product and cross product.

Solution
In this recipe we’ll introduce the concept of vector dot product and cross product and how they might be used.

Dot product
Dot product is an operation on two vectors that returns a scalar. It is often visualized as the projection of vector A onto vector B:

alt
This is the formula for calculating the dot product:

alt
Where θ is the angle between the two vectors and ||A|| is the magnitude of A.

This is very useful when both vectors are normalized (i.e. their magnitudes are 1), then the formula simplifies to:

alt
This shows that the dot product is directly related to the angle between the two vectors. Since cos(0) == 1 and cos(180) == -1, the result of the dot product can tell you how closely aligned two vectors are:

alt
See below for how we can apply this fact in a practical example.

Cross product
The cross product of two vectors is a third vector that is perpendicular to both of them. Its magnitude is related to their magnitudes and the angle between them.

alt
Once again, if we’re using normalized vectors, the result is simplified: it will be directly related to the angle and its magnitude will range from -1 to 1.

 Note
Since the cross product is perpendicular to both vectors, we would need to be working in 3D. In most 2D frameworks, including Godot, the 2D Vector2.cross() method returns a scalar value representing the result’s magnitude.

Practical applications
Consider this animation, showing how the results of Vector2.dot() and Vector2.cross() change in relation to the changing angle:

alt
This demonstrates two common applications of these methods. If the red vector is our object’s forward direction, and the green shows the direction towards another object:

Dot product: Using the result, we can tell if the object is in front of (> 0) or behind (< 0) us.
Cross product: Using the result, we can tell if the object is to the left (> 0) or right (< 0).


 AI/BEHAVIOR
Automated behavior and (sometimes) smarter entities.

In this section:
Chasing the player
Homing missile
Pet Following


CHASING THE PLAYER
Problem
You want an enemy to chase the player.

Solution
The first step in getting an enemy to chase the player is to determine what direction the enemy needs to move. To get the vector pointing from A to B, you subtract: B - A. Normalize the result and you have a direction vector.

This makes the solution quite straightforward. Every frame, set the enemy’s velocity to point in the direction of the player.

velocity = (player.position - position).normalized() * speed
Godot’s Vector2 object has a built-in helper for this:

velocity = position.direction_to(player.position) * speed
However, this would allow the enemy to chase the player from any distance, even if it’s far away. To fix this, we can add an Area2D to the enemy, and only chase the player when it’s inside this “detect radius”.

alt
Here’s some example code:

extends CharacterBody2D

var run_speed = 25
var player = null

func _physics_process(delta):
    velocity = Vector2.ZERO
    if player:
        velocity = position.direction_to(player.position) * run_speed
    move_and_slide()

func _on_DetectRadius_body_entered(body):
    player = body

func _on_DetectRadius_body_exited(body):
    player = null
We’ve connected the body_entered and body_exited signals from the Area2D so that the enemy knows whether it’s in range or not.

 Note
The above assumes that the player is the only body that will enter/exit, which is usually done by setting the appropriate collision layers/masks.


This concept can be extended to other types of games as well. The key is to find the direction vector from the enemy to the player:

If, for example, your game is a side-scroller or has other constraints in movement, you can use only the x component of the resulting vector to determine movement.

Limitations
Note that this method results in very simplistic straight-line movement. The enemy will not move around obstacles such as walls, nor will it stop if it gets too close to the player.

What to do when the enemy gets close to the player depends on your game. You could add a second, smaller area that causes the enemy to stop and attack, or you could knockback the player on contact.

Another problem is more apparent with fast-moving enemies. As the player moves, the enemies using this technique will change direction instantly. For a more natural-looking movement, you might want to use a steering behavior.

For more advanced behaviors, see the other recipes in this chapter.

Related recipes
Top-down movement
Homing missile



HOMING MISSILE
Problem
You need a “homing missile” - a projectile that will seek a moving target.

Solution
For this example, we’ll use an Area2D node for the projectile. Areas are typically good choices for bullets because we need to detect when they contact something. If you also need a bullet that bounces/ricochets, one of the PhysicsBody type node might be a better choice.

The node setup and behavior of the missile is the same you would use for a “dumb” bullet. If you’re creating many bullet types, you can use inheritance to base all your projectiles on the same core setup.

The nodes we’ll use:

 Area2D: Missile
     Sprite2D
     CollisionShape2D
     Timer: Lifetime
For the texture, you can use any image you like. Here’s an example one:

alt
Set up the nodes and configure the sprite’s texture and the collision shape. Make sure to rotate the Sprite2D node by 90° so that it’s pointing to the right, ensuring it matches the parent’s “forward” direction.

Add a script and connect the Area2D’s body_entered signal and the Timer’s timeout signal.

Here’s the starting script:

extends Area2D

export var speed = 350

var velocity = Vector2.ZERO
var acceleration = Vector2.ZERO

func start(_transform):
    global_transform = _transform
    velocity = transform.x * speed

func _physics_process(delta):
    velocity += acceleration * delta
    velocity = velocity.clamped(speed)
    rotation = velocity.angle()
    position += velocity * delta

func _on_Missile_body_entered(body):
    queue_free()

func _on_Lifetime_timeout():
    queue_free()
This creates a “dumb” rocket that travels in a straight line when fired. To use this projectile, instance it and call its start() method with the desired Transform2D to set its position and direction.

See the related recipes section below for more information.

To change the behavior to seek a target, we’ll use the acceleration. However, we don’t want the missile to “turn on a dime”, so we’ll add a variable to control its “steering” force. This will give the missile a turning radius that can be adjusted for different behavior. We also need a target variable so that the missile knows what to chase. We’ll set that in start() as well:

export var steer_force = 50.0

var target = null

func start(_transform, _target):
    target = _target
    ...
To change the missile’s direction to move toward the target, it needs to accelerate in that direction (acceleration is change in velocity). The missile “wants” to move straight towards the target, but its current velocity is pointing in a different direction. Using a little vector math, we can find that difference:

alt
The green arrow represents the needed change in velocity (i.e. acceleration). However, if we turn instantly, that will look unnatural, so the “steering” vector’s length needs to be limited. This is the purpose of the steer_force variable.

This is the function to calculate that acceleration. Note that if there’s no target, there will be no steering, so the missile remains traveling in a straight line.

func seek():
    var steer = Vector2.ZERO
    if target:
        var desired = (target.position - position).normalized() * speed
        steer = (desired - velocity).normalized() * steer_force
    return steer
Finally, the resulting steer force must be applied in _physics_process():

func _physics_process(delta):
    acceleration += seek()
    velocity += acceleration * delta
    velocity = velocity.clamped(speed)
    rotation = velocity.angle()
    position += velocity * delta
Here’s an example of the results, with a little extra visual flair such as particle smoke and explosions:


Here’s the full script, including the above effects. See related recipes for details.

extends Area2D

export var speed = 350
export var steer_force = 50.0

var velocity = Vector2.ZERO
var acceleration = Vector2.ZERO
var target = null

func start(_transform, _target):
    global_transform = _transform
    rotation += rand_range(-0.09, 0.09)
    velocity = transform.x * speed
    target = _target

func seek():
    var steer = Vector2.ZERO
    if target:
        var desired = (target.position - position).normalized() * speed
        steer = (desired - velocity).normalized() * steer_force
    return steer

func _physics_process(delta):
    acceleration += seek()
    velocity += acceleration * delta
    velocity = velocity.clamped(speed)
    rotation = velocity.angle()
    position += velocity * delta

func _on_Missile_body_entered(body):
    explode()

func _on_Lifetime_timeout():
    explode()

func explode():
    $Particles2D.emitting = false
    set_physics_process(false)
    $AnimationPlayer.play("explode")
    await $AnimationPlayer.animation_finished
    queue_free()
Related recipes
Spritesheet animation
Top-down character
Transforms



PET FOLLOWING
Problem
You need to have a game entity such as a pet or minion, follow a character.


Solution
We start by adding a Marker2D to the character. This will represent the place where the pet wants to “hang out” near the character.

alt
In this example, we’ve made it a child of the Sprite2D, because the character’s code uses $Sprite2D.scale.x = -1 to flip the horizontal direction when the character moves left. Since the marker is a child of the sprite, it will flip too.

Pet script
Here’s the script for the pet.

extends CharacterBody2D

@export var parent : CharacterBody2D

var speed = 25

@onready var follow_point = parent.get_node("Sprite2D/FollowPoint")
The parent variable holds a reference to the character the pet should follow. We then get the FollowPoint node from that so we can get its position in _physics_process():

func _physics_process(delta):
    var target = follow_point.global_position
    velocity = Vector2.ZERO
    if position.distance_to(target) > 5:
        velocity = position.direction_to(target) * speed

    if velocity.x != 0:
        $Sprite2D.scale.x = sign(velocity.x)

    if velocity.length() > 0:
        $AnimationPlayer.play("run")
    else:
        $AnimationPlayer.play("idle")

    move_and_slide()
If it’s close to the target point, we stop the pet’s movement.

Navigating obstacles
Depending on your world, you may find the pet gets stuck on obstacles. For more robust following, you can use navigation. See TileMap Navigation for an example.

 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/ai_behavior_demos


 PHYSICS
Learn how to use Godot’s physics nodes.

In this section:
RigidBody2D: Look at Target
RigidBody2D: Drag and Drop
Character to Rigid Body Interaction
Asteroids-style Physics (using RigidBody2D)



RIGIDBODY2D: LOOK AT TARGET
Problem
You want a rigid body to rotate smoothly to look at a target.

Solution
Using RigidBody2D can be tricky. Because it’s controlled by Godot’s physics engine, you need to apply forces rather than moving it directly. Before doing anything with rigid bodies, I highly recommend looking at the RigidBody2D API doc.

To rotate a body, we need to apply a rotational force - a torque. Once the body is rotating, we want the torque to get smaller as we get closer to the final rotation.

This is the perfect situation to use the dot product. Its sign will tell us whether the target is to the left/right, and its magnitude will tell us how far away from the target direction we’re pointing.

 Tip
See Vectors: Using Dot and Cross Product for a brief review of the dot product.

extends RigidBody2D

var angular_force = 50000
var target = position + Vector2.RIGHT

func _physics_process(delta):
    var dir = transform.y.dot(position.direction_to(target))
    constant_torque = dir * angular_force
You may be wondering why we’re using the transform.y here, when transform.x is the body’s forward vector. Using transform.x, the dot product would be at its maximum when the body is directly pointing at the target, but we want the torque to be zero at that point. Using transform.y means that our torque will be higher when we’re not aligned with the target.

Skip the Rigid Body Entirely
You can avoid all of this entirely by not rotating your rigid body at all! Instead, change the child sprite’s rotation to point at the target. You can use lerp() or a Tween to make the rotation as smooth as you wish.

In many cases, this will be a great solution. Remember, the underlying body’s orientation doesn’t have to match the attached sprite!

Related recipes
Vectors: Using Dot and Cross Product



RIGIDBODY2D: DRAG AND DROP
Problem
You want to pick up and move rigid bodies with the mouse.

Solution
Working with rigid bodies can be tricky. Godot’s physics engine controls their movements, and interfering with that can often lead to unexpected results. The key is to make use of the body’s mode property. This applies equally well in 2D or 3D.

Body setup
We’ll start with our rigid body object, adding a Sprite2D and CollisionShape2D. You can also add a PhysicsMaterial if you want to set Bounce and Friction properties.

We’re going to use the rigid body’s freeze property to remove it from the control of the physics engine while we’re dragging it. Since we still want it to be movable, we need to set the Freeze Mode to “Kinematic”, rather than the default value of “Static”.

Place the body in a group called “pickable”. We’ll use this to allow for multiple instances of the pickable object in the main scene. Attach a script to the body and connect the its _input_event signal.

extends RigidBody2D

signal clicked

var held = false

func _on_input_event(viewport, event, shape_idx):
    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
        if event.pressed:
            print("clicked")
            clicked.emit(self)
We’ll emit a signal when a mouse click is detected, including a reference to the body. Since there can be many bodies, we’ll let the main scene manage whether a body can be dragged or if there’s already one in the held state.

If the body is being dragged, we update its position to follow the mouse.

func _physics_process(delta):
    if held:
        global_transform.origin = get_global_mouse_position()
Finally, these are the two functions to call when the body is picked up and dropped. Changing the freeze to true removes the body from physics engine processing. Note that other objects can still collide with it. If you don’t want that, you can disable the collision_layer and/or collision_mask here as well. Just remember to re-enable them when dropping.

func pickup():
    if held:
        return
    freeze = true
    held = true

func drop(impulse=Vector2.ZERO):
    if held:
        freeze = false
        apply_central_impulse(impulse)
        held = false
In the drop function, after we change freeze back to `false, the body will return to the physics engine’s control. By passing in an optional impulse value, we can add the ability to “throw” the object on release.

Main scene
Create a main scene with some static body obstacles or a TileMap and instance a few copies of the pickable body.

Here’s the script for the main scene. We start by connecting the clicked signal on any pickable bodies that are in the scene.

extends Node2D

var held_object = null

func _ready():
    for node in get_tree().get_nodes_in_group("pickable"):
        node.clicked.connect(_on_pickable_clicked)
Next, we have the function we connect the signal to. The connected function sets held_object so that we know something is currently being dragged, and calls the body’s pickup() method.

func _on_pickable_clicked(object):
    if !held_object:
        object.pickup()
        held_object = object
Lastly, when the mouse is released during dragging, we can perform the reverse actions.

func _unhandled_input(event):
    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
        if held_object and !event.pressed:
            held_object.drop(Input.get_last_mouse_velocity())
            held_object = null
Note the use of get_last_mouse_velocity() to pass the impulse to the object - be careful with this! You may find yourself launching the rigid bodies at high speeds, especially if the bodies have low mass values. It’s probably a good idea to scale this to a reasonable value and clamp() it to some maximum. Experiment to find out what works for you.


 Download This Project
Download the project code here: https://github.com/godotrecipes/rigidbody_drag_drop

Related recipes


CHARACTER TO RIGID BODY INTERACTION
Problem
You want your character body to interact with rigid bodies.

Solution
 Note
This recipe applies equally well in both 2D and 3D nodes.

By default, a CharacterBody2D moved with move_and_slide() or move_and_collide() will not push any RigidBody2D it collides with. The rigid body doesn’t react at all, and behaves just like a StaticBody2D.

alt
In some cases, this might be all you need. However, if you want to be able to push the bodies, you’ll need to make some changes.

For this example, we’ll use the 2D character described in the Platform character recipe. This example uses the most common movement method for character bodies: move_and_slide(). If you’re using move_and_collide(), you’ll need to adjust the examples below accordingly.

You have two options when deciding how to interact with rigid bodies:

You can just push them, ignoring physics. If you’re familiar with Godot 3.x, this is equivalent to the “infinite inertia” option.
You can give them a push based on the character’s imagined “mass” and velocity. This will give you a “realistic” result - pushing heavy bodies a little, and lighter bodies a lot.
We’ll try out both options below.

Infinite Inertia
This option has its pros and cons. The biggest pro is, you don’t need any extra code. You just need to correctly set the collision layers/masks of the objects. For this example, we’ve defined three physics layers:

alt
For the rigid body, we’ve placed it on the “items” layer (layer 3), and left the mask at the default (masking all layers):

alt
Then, we’ve placed the player on the “player” layer (layer 2), and configured the mask to ignore the “items”:

alt
Running the game, we now see we can push the boxes around. Note that the mass of the box doesn’t matter - they’ll all be pushed the same.

alt
Here, you can also see the downside of this option. Because the physics of the boxes is being ignored, they can clip through walls and you can’t jump on top of them.

For some games, this will be fine. If you want to prevent the clipping, you’ll need to go with option 2.

Applying impulses
To give the colliding body a “push” we’ll need to apply an impulse. An impulse is an instantaneous “kick” - think of a bat hitting a ball. This is as opposed to a force, which is a continuous “push” on an object.

# This represents the player's inertia.
var push_force = 80.0

func _physics_process(delta):
    # after calling move_and_slide()
    for i in get_slide_collision_count():
        var c = get_slide_collision(i)
        if c.get_collider() is RigidBody2D:
            c.get_collider().apply_central_impulse(-c.get_normal() * push_force)
The collision normal points out of the rigid body, so we reverse it to point away from the character and apply the push_force factor. Now pushing works again, but it won’t force the rigid bodies through walls:

alt
You’ll need to adjust the push_force in relation to the mass of your rigid bodies. Too high a force will still cause clipping, while too low will prevent pushing at all.

Experiment to find the settings that work for your particular game.

 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/character_vs_rigid

Related recipes
Platform character
 Watch Video



ASTEROIDS-STYLE PHYSICS (USING RIGIDBODY2D)
Problem
You want to use a RigidBody2D to create a semi-realistic spaceship, a la Asteroids.

Solution
Using RigidBody2D can be tricky. Because it’s controlled by Godot’s physics engine, you need to apply forces rather than moving it directly. Before doing anything with rigid bodies, I highly recommend looking at the RigidBody2D API doc, and we’ll refer to it as we work through this example.

For this example, we’ll use the following node setup:

 RigidBody2D (Ship)
      Sprite2D
      CollisionShape2D
 Sprite orientation
Don’t forget to orient your sprite correctly. An object that is not rotated should be pointing along the +X axis, i.e. to the right. If your sprite’s art is drawn facing in another direction, rotate the Sprite2D (not the parent body) to align it correctly.

We’ll use the following inputs in the Input Map:

Input	Key
thrust	w or ↑
rotate_right	d or →
rotate_left	a or ←
Add a script to the body, and let’s define some variables:

extends RigidBody2D

@export var engine_power = 800
@export var spin_power = 10000

var thrust = Vector2.ZERO
var rotation_dir = 0
The first two variables are how we’ll control the ship’s “handling”. engine_power is going to affect acceleration and top speed. spin_power controls how fast the ship rotates.

thrust and rotation_dir are going to be set by pressing the inputs. Let’s do that next:

func get_input():
    thrust = Vector2.ZERO
    if Input.is_action_pressed("thrust"):
        thrust = transform.x * engine_power
    rotation_dir = Input.get_axis("rotate_left", "rotate_right")
If we’re pressing the "thrust" input, we’ll set the thrust vector to the ship’s forward direction, while rotation_dir will be +/-1 based on the rotate inputs.

We can start flying by applying those values in _physics_process():

func _physics_process(_delta):
    get_input()
    constant_force = thrust
    constant_torque = rotation_dir * spin_power
It works, but you’ll notice that it’s very hard to control. The rotation is too fast, and it accelerates to a high speed before going offscreen. This is where we want to break from “real” space physics. In space, there’s no friction, but our Asteroids-style ship will be a lot easier to control if it coasted to a stop when we’re not thrusting. We can control this with damping.

In the RigidBody2D properties, you’ll find Linear/Damp and Angular/Damp. Set these to 1 and 2 respectively, and they’ll slow the movement/rotation as well as causing them to stop.

Feel free to experiment with these values and how they interact with the engine_power and spin_power

Screen wrapping
Wrapping around the screen is really teleportation: when the ship goes off the right side of the screen, you teleport it to the left side. However, if you just tried to change the position, you’d find that it instantly snapped back. This is because the physics engine is trying to control the position as well.

The solution to this is to use the _integrate_forces() callback of the rigid body. In this function, you can safely update the physics properties of the object without conflicting with what the physics engine is doing.

Let’s get the screensize at the top of the script:

@onready var screensize = get_viewport_rect().size
Then add the new function:

func _integrate_forces(state):
    var xform = state.transform
    xform.origin.x = wrapf(xform.origin.x, 0, screensize.x)
    xform.origin.y = wrapf(xform.origin.y, 0, screensize.y)
    state.transform = xform
As you can see, the _integrate_forces() function includes a parameter called state. This object is the PhysicsDirectBodyState2D of our body. It contains all of the current physics properties such as the forces, velocity, position, etc.

From the state, we grab the current transform, modify it to wrap around the screen using wrapf(), and then set it back to the current state.

Here’s how it looks:

alt
Warping
Let’s look at one more example of using _integrate_forces() to alter the body’s state without issues. Let’s add a “warp” mechanic - when the player presses the "warp" input, the ship will teleport to a random spot on the screen.

First, we’ll add a new variable for this:

var teleport_pos = null
Then, in get_input(), we’ll set a random position:

    if Input.is_action_just_pressed("warp"):
        teleport_pos = Vector2(randf_range(0, screensize.x), randf_range(0, screensize.y))
Finally, in _integrate_forces(), if there’s a teleport_position set, we’ll use it and then clear it:

    if teleport_pos:
        physics_state.transform.origin = teleport_pos
        teleport_pos = null
alt
 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/asteroids_physics


Helpful recipes for adding sound effects and music to your game.

In this section:
Audio Manager


AUDIO MANAGER
Problem
You’ve tried adding an AudioStreamPlayer to your mob/coin/etc. to play when the object dies or is collected. But the problem is that when you remove the object, the audio player goes with it, chopping off the sound. You need an easier way to manage playing audio.

Solution
We’ll solve this problem with a node that is available from anywhere in the SceneTree. This node manages a set of AudioStreamPlayer nodes and a queue of sound streams to play.

Create a new script in the script editor.

extends Node

var num_players = 8
var bus = "master"

var available = []  # The available players.
var queue = []  # The queue of sounds to play.


func _ready():
    # Create the pool of AudioStreamPlayer nodes.
    for i in num_players:
        var p = AudioStreamPlayer.new()
        add_child(p)
        available.append(p)
        p.finished.connect(_on_stream_finished.bind(p))
        p.bus = bus


func _on_stream_finished(stream):
    # When finished playing a stream, make the player available again.
    available.append(stream)


func play(sound_path):
    queue.append(sound_path)


func _process(delta):
	# Play a queued sound if any players are available.
    if not queue.empty() and not available.empty():
        available[0].stream = load(queue.pop_front())
        available[0].play()
        available.pop_front()
Set this script as an autoload in Project Settings. Give it an easily recognizable name, such as “AudioStreamManager”.

alt
Anywhere in your project that you want to play a sound, use:

AudioStreamManager.play("res://path/to/sound")
 Note
This audio manager is adapted with thanks from [SFXPlayer by TheDuriel] (https://github.com/TheDuriel/DurielsGodotUtilities).

Example project
Below you can download an example project showing the use of the audio manager node. This project reads a folder full of audio files and generates a grid of buttons. Click the button to play the sound.

alt
At the top, you can see the audio manager’s live statistics.

 Download This Project
Download the project’s example code here: https://github.com/godotrecipes/audio_manager


 YOUR FIRST 2D GAME
Get started with Godot by building a 2D shooter.
In this series, we’ll start with the basics and build a classic, old-school space shooter.

Here’s a screenshot of the finished game:

alt
In each part of the series, we’ll build a piece of the game, adding features and explaining the process along the way.

 Background
If you find that you’re struggling with the programming side of things, see these resources:

Godot 101: Introduction to GDScript - tutorial on this website.
Godot Official Documentation - official tutorial resources
 Download This Project on  GitHub
Download the project code here:

https://github.com/godotrecipes/classic_shmup

PROJECT SETUP
This first game project will guide you through making your first Godot Engine game. While you don’t need any previous experience, it’s expected that you’ve at least read through the Godot 101: Getting Started section. There, you’ll learn about the editor interface and how to get around the Godot UI.

 Why start with 2D?
In a nutshell, 3D games are much more complex than 2D ones. However, many of the underlying game engine features you’ll need to know are the same. You should stick to 2D until you have a good understanding of Godot’s workflow. At that point, the jump to 3D will feel much easier.

Open Godot and start a new project. You can name it anything you’d like - we’re going with “Classic Shmup”, since this is a traditional shoot-em-up style game.

Downloading the art
You can download the art we’ll be using for the game from itch.io: Mini Pixel Pack by Grafxkid

Unzip the art pack and copy it into your project by dropping the folder in the FileSystem tab.

alt
Project settings
Next, we need to set up some project-wide settings. Open Project Settings and check the “Advanced Settings” toggle in the upper-right.

In the Display/Window section:

Viewport Width & Viewport Height to 240, 320.
Window Width Override & Window Height Override to 480, 640.
Stretch/Mode to canvas_items.
These settings will ensure the game is the right size. Because we’re using pixel art, the images themselves are very small, so an old-school resolution like 240x320 is perfect. However, on a modern monitor, that’s a fairly small window, so the other settings let us scale that up proportionally. If you have a 1080p monitor, you can make the override values 720x960 instead. You’ll also be able to resize the window when the game is running.

In the Rendering/Textures section under Canvas Textures, set Default Texture Filter to Nearest. This will ensure that our beautiful pixel art stays nice and crisp, looking like the image on the right, not the one on the left:
alt
Click the Input Map tab at the top of the Project Settings window. This is where we can set up the inputs we want to use in the game. In the “Add New Action” box, type the following, hitting <enter> after each to add it to the list of actions: right, left, up, down, shoot. To assign key(s) to each named input, click the + button to its right and press the key on your keyboard. When you’re done, you should have something like this:
alt
Feel free to use other keys if you’d rather use a different setup.

Next steps
That takes care of setting up - now we’re ready to get started! In the next section, we’ll create the player-controlled spaceship.




DESIGNING THE PLAYER SCENE
In the last section, we configured the project and downloaded the game art. Now we’re ready to start coding - starting with the player-controlled ship.

Setting up the Ship Scene
A common part of the Godot workflow is creating scenes. As discussed earlier, a scene in Godot is nothing more than a collection of nodes. In most Godot projects, each game object is configured as a scene, with nodes that provide it with the desired functionality, and optionally some code to customize its behavior.

Choosing nodes
The first step is to decide what kind of node to start with. The first node you add to the scene is called the root node. A scene’s root node should generally be the one that primarily defines the game object’s behavior. Then you attach child nodes to add additional functionality.

So what should our game’s ship be? Let’s break down the requirements, and look at what nodes might be useful to meet them.

The ship needs to:

Move in 2D space. For this, a basic Node2D would suffice, as that’s the node that has position, rotation, and other 2D-related properties. However, it has no appearance.

Display an image. Sprite2D is the node for this. Since it’s also a Node2D, we’d still be able to move it around.

Detect getting hit. The enemies will be shooting and flying around on the screen, so we’ll need to know when the ship is hit. We don’t have a need for solid objects - they’re not going to bounce off each other or transfer momentum - we just need to know when they touch. For this, an Area2D would be perfect. It can detect touching other objects, has positional properties, but it has no appearance of its own.

Looking at this list, the Area2D provides the main functionality. We can attach a Sprite2D to display the ship image, and then we’ll have everything we need.

Building the scene
In the Scene tab, click the + button or the + Other Node button to add the first node. Start typing Area2D and choose it from the list. Once it’s in the Scene tab, click the node’s name to rename it to Player, and press <Ctrl+S> to save the scene.

Displaying the ship
With the Player node selected, add another node: a Sprite2D. To keep things organized, let’s rename this node to Ship.

From the FileSystem tab, drag the Player_ship (16x16).png file from the art pack and drop it in the Texture property of the Inspector.

alt
The first thing you’ll notice is that there seem to be three ships! The image from the art pack also includes versions of the ship going to the left/right. We can use this - in the Animation section of the Inspector, set Hframes to 3. Now, changing the Frame property will move between the three different versions. Leave it at 1 for now.

alt
Adding a collision shape
You may also have noticed the yellow warning triangle on the Area2D node. If you click it, you’ll see the warning is telling us that the area doesn’t have a shape. We need to define its shape, and we can do that by adding a CollisionShape2D node as a child of the Player.

In the Inspector for this node, you’ll see a Shape property that currently shows <empty>. If you click in this box, you’ll see a dropdown that allows you to select from a variety of shapes. Choose New RectangleShape2D and you’ll see a light blue square appear over the ship. You can adjust the size of the shape by dragging the orange circles, or you can click on the shape in the Shape property to expand it and fill in the Size manually.

alt
Exhaust
The ship will look much more dynamic with a little animation. Included in the art pack are some animations of exhaust flames named “Boosters”. There are three: one for each version of the ship (left, forward, and right).

To display these, select the Ship node and add a child AnimatedSprite2D node and name it “Boosters”.

In the Inspector, under the Animation section, you’ll find a property called Sprite Frames, which is currently <empty>. Click it to create a New SpriteFrames, then click the SpriteFrames item to open the animation panel at the bottom of the editor window.

alt
Double-click the “default” animation to rename it to “forward”. Then, to add the animation images, click the Add frames from sprite sheet button:

alt
Choose the Boosters (16 x 16).png image and you’ll see the Select Frames window, allowing you to choose the frames you want.

alt
There are only two frames in this animation, but the grid isn’t correct. Change the Size values to match the image sizes: 16 x 16. Then, click both frames to select them and click the Add 2 Frame(s) button.

alt
Now that you’ve added the two frames, press the Play button to run the animation. You can also toggle the Autoplay on Load button so that the animation will start automatically.

alt
It’s a little slow, so change the speed to 10 FPS.

Add two more animations by clicking the Add Animation button, naming them left and right.

alt
Repeat the process, adding the left and right “Booster” sprite sheets.

Gun cooldown
The last node we’ll need to complete the player setup is a Timer to control how fast the player can shoot. Add the Timer as a child of Player and name it GunCooldown. Set its One Shot property to “On”. This means that when the timer ends, it won’t automatically restart. In the player’s code, we’ll start the timer when the player shoots, and they won’t be able to shoot again until the timer runs out.

Next steps
That completes the player scene setup. We’ve added the nodes to give the player ship the functionality it will need in the game. In the next section, we’ll add some code to enable the player to control the ship, make it shoot, and detect when it collides with things.




CODING THE PLAYER
In the last section, we configured the project and downloaded the game art. Now we’re ready to start coding - starting with the player-controlled ship.

Adding a script
Writing scripts and attaching them to nodes and other objects is how you build behavior and game mechanics into your game. Our Player scene displays the ship, defines its collision hitbox, etc., but it can’t move, and nothing would happen if it collided. We’ll write code to add this functionality to the ship.

Select the Player node and click the Attach script button:

alt
You don’t need to change any of the options on the Attach Node Script window, so just click Create and you’ll be taken to the script editor.

Let’s look at the first line of the script, which has automatically been added.

extends Area2D
This line defines what type of object this script should be attached to. It means that the script will have access to all the functionality that an Area2D provides.

Your extends line should always match the type of node the script is attached to.

 Accessing scripts
A script on its own doesn’t do much of anything. Scripts define additional functionality for whatever object they’re attached to. You will never be accessing a variable in some script, you’ll be accessing a property of an object, which is defined by that script. This is a very important distinction.

Movement
We’ll start by making the ship move around the screen. Let’s start with some code that does the following:

Detect what input(s) the player is pressing
Move the ship in the direction of the input
@export var speed = 150

func _process(delta):
    var input = Input.get_vector("left", "right", "up", "down")
    position += input * speed * delta
Let’s break this down line-by-line:

Adding @export in front of a variable allows you to adjust its value in the Inspector.
alt
The _process() function is called once every frame by the engine. Any code we place in this function will be executed every frame.
Input.get_vector() checks the pressed state of the four given inputs and produces a vector pointing in that direction.
Finally, we move the ship’s position by adding that input vector, scaling it to the desired speed, and multipling by delta.
 Links to more information
Run the scene by clicking the Run Current Scene button, and try moving around.

alt
Staying on screen
One problem we have is that if you keep moving, you’ll go off the screen. We need to lock the player’s position property inside the bounds of the screen rectangle. Add this line at the top of the script:

@onready var screensize = get_viewport_rect().size
The @onready here tells Godot not to set the value of the screensize variable until the Player node has entered the scene tree. Effectively, it means “wait until the game starts”, because there’s no window to get the size of until the game is running.

The next step is to clamp the position within the bounds of that screensize rectangle. Vector2, which is what position is, has a clamp() method we can use. Put this line right after setting the position:

func _process(delta):
    var input = Input.get_vector("left", "right", "up", "down")
    position += input * speed * delta
    position = position.clamp(Vector2.ZERO, screensize)
Run the scene again and try moving off the edges. You’ll notice that half of the ship still goes off screen. This is because the ship’s position is the center of the Sprite2D. Since we know our ship is 16x16, we can change the clamp() to include 8 extra pixels:

position = position.clamp(Vector2(8, 8), screensize - Vector2(8, 8))
Matching animation to direction
Now that the ship is moving, we can choose the “tilted” ship images when moving left or right, as well as the matching “Booster” animation.

To tell which direction we’re moving, we can check the x value of the input vector. Depending on whether it’s positive (right), negative (left), or zero (not moving), we can choose the frame value of the Sprite2D and the animation of the AnimatedSprite2D.

func _process(delta):
    var input = Input.get_vector("left", "right", "up", "down")
    if input.x > 0:
        $Ship.frame = 2
        $Ship/Boosters.animation = "right"
    elif input.x < 0:
        $Ship.frame = 0
        $Ship/Boosters.animation = "left"
    else:
        $Ship.frame = 1
        $Ship/Boosters.animation = "forward"
    position += input * speed * delta
    position = position.clamp(Vector2(8, 8), screensize-Vector2(8, 8))
Once again, play the scene and verify that the images change when moving left/right. Verify that everything works as intended before moving to the next step.

The next step will be to create the Bullet scene and let the player shoot.




BULLET SCENE
Now that the player can move around the screen, our next step will be to implement shooting

Reusable objects
The player will fire many “bullets” during the game, but all of them will be identical. A bullet needs to do the following:

Appear just ahead of the player
Travel forward until going off the screen
Detect collisions with enemies
Since all bullets will do these same things, we can save ourselves a great deal of work by designing one “prototype” bullet, and using that as the blueprint for creating as many duplicates as we need. Godot’s scene system is ideal for this.

Bullet scene
Create a new scene by selecting Scene -> New Scene in the menu, or by clicking the + in the tabs on the top of the viewport.

Just like we did with the Player scene, we need to consider what nodes we’ll need to make the bullet work. We can again use an Area2D, since that will allow us to detect the bullet hitting things. This means we’ll need a collision shape, and a sprite to display the bullet image. Finally, we need a way to detect when the bullet goes offscreen so we can automatically remove it.

Here’s the node setup:

Area2D - name this Bullet
Sprite2D
CollisionShape2D
VisibleOnScreenNotifier2D
From the asset pack folder, drop the Player_charged_beam (16 x 16).png image on the Texture of the Sprite2D.

As with the ship image, there are multiple versions here, so set the *Hframes to 2 so we’ll only see one at a time.

Set the shape of the CollisionShape2D just like you did earlier in the Player scene.

Bullet script
Attach a script to the Bullet node and let’s start with the movement:

extends Area2D

@export var speed = -250

func start(pos):
    position = pos

func _process(delta):
    position.y += speed * delta
This should look fairly familiar, as it’s similar to the player script. We’re only changing the position.y since the bullet should travel straight up.

Note the start() function we defined. That will let us set the bullet’s starting position, since the player will move around and spawn the bullets at different locations.

Connecting signals
Now select the Bullet node and then click the Node tab next to the Inspector.

alt
This is a list of all the signals this node can emit. Signals are how Godot lets you know that something has happened. In this case, we can use the area_entered signal to tell us whenever this bullet touches another Area2D node.

Select the area_entered signal and click the Connect… button (you can also double-click the signal name). In the dialog that opens up, just click Connect - we don’t need to change anything there.

You’ll notice that you’re back in the script editor, looking at bullet.gd, and a new function as been added. It has a green “connected” icon next to its name to show that a signal is connected to it. This function will be called whenever the area touches something, so let’s add some code here:

func _on_area_entered(area):
    if area.is_in_group("enemies"):
        area.explode()
        queue_free()
Here we’ll check if the bullet hit an enemy (more about that later), and if it did, we tell the enemy to explode and then delete the bullet.

Do the same thing to connect the screen_exited signal of the VisibleOnScreenNotifier2D.

func _on_visible_on_screen_notifier_2d_screen_exited():
    queue_free()
Next steps
This completes the bullet scene, so now we can go back and add shooting to the player.




SHOOTING
The Bullet scene provides us with a reusable object we can instantiate whenever the player shoots.

Adding to the player
Let’s head back to the Player script and add a few new variables:

@export var cooldown = 0.25
@export var bullet_scene : PackedScene
var can_shoot = true
The two @export variables let you configure them in the Inspector so that you can adjust the cooldown time. Set the bullet_scene by clicking the property and choosing the bullet.tscn file.

can_shoot is what programmers call a flag - a Boolean variable that controls a certain condition. In this case it determines whether the player is allowed to shoot or not. During the cooldown period, this variable will be false.

Next, we’ll add a start() function similar to the one we made for the Bullet. This will let us set initial values for the player, as well as resetting them when the game restarts.

func _ready():
    start()

func start():
    position = Vector2(screensize.x / 2, screensize.y - 64)
    $GunCooldown.wait_time = cooldown
This places the player at the bottom center of the screen - a good place to start. It also ensures that the cooldown timer has the correct wait time.

The shoot() function will be called whenever we press the “shoot” input.

func shoot():
    if not can_shoot:
        return
    can_shoot = false
    $GunCooldown.start()
    var b = bullet_scene.instantiate()
    get_tree().root.add_child(b)
    b.start(position + Vector2(0, -8))
The first thing this function does is check if the player is allowed to shoot. If it isn’t, return will end the function immediately.

If the player is allowed to shoot, then we set the flag to false, and start the cooldown timer. Then we create a new bullet and add it to the game, calling its start() function to make sure it’s placed in the correct position (just above the player’s ship).

We can call this function when the player is pressing the key. Add this to the end of the _process() function, after the position.clamp() line:

if Input.is_action_pressed("shoot"):
    shoot()
We’ll also need to connect the timeout signal of GunCooldown.

func _on_gun_cooldown_timeout():
    can_shoot = true
When the cooldown ends, we can allow shooting again.

Go ahead and run the scene and try pressing the shoot action.

alt
 Adding instances to the tree
Notice that we’ve added the new bullets as children of the SceneTree root (get_tree().root), and not to the player ship. This is important because if we made the bullets children of the ship, then they would be “attached” to it when it moves.

Next steps
Shooting’s no fun without something to shoot at. We’ll start making the enemies soon, but first we need a scene where we can bring the player, enemies, and other game objects together.




MAIN SCENE
Before we can make enemies, powerups, or any other game objects, we need a place where they can all exist together with the player. In most games, this would be called a “level” or “main” scene, and that’s what we’ll call it here.

Start the scene with a Node2D called “Main” and save it.

Creating the background
Add a Sprite2D child. Name this sprite “Background” and add the Space_BG (2 frames) (64 x 64).png as its texture.

This image has two frames, each 64x64 pixels in size. We’d like the image to tile across the full size of the screen, so start with the following settings:

Under Offset set Centered to “off”. This makes the image’s top left corner start at the origin rather than its center.

Under Region, turn Enabled “on”, and then set the Rect to a width of 240 and a height of 320. This makes the image stretch to the size of the screen.

Under Texture change Repeat to Enabled. This causes the image to repeat over the full size of the screen.

Now add the player to the scene by selecting the Main node and clicking the Instantiate Child Scene button.

alt
Animating the background
We can make the scene more dynamic by animating the background. While we could do this in code by changing the region_rect property every frame, we’ll use an AnimationPlayer node instead; add one as a child of Main.

At the bottom of the editor window, you’ll see the Animation panel. There’s a lot of information there, so let’s look at how it’s laid out:

alt
Click the Animation button and choose New Animation. You can name the new animation scroll. Set its Length to 2 and toggle the Looping and Autoplay buttons.

Animations work by adding tracks that represent properties that you want the AnimationPlayer to control. In the timeline of the player, you’ll add keyframes that define what value you want the property to have at that particular time.

We can add keyframes to the animation by clicking the key icon that now appears next to every property in the Inspector. Make sure the scrubber (the blue indicator on the timeline) is at time 0, then select the Background and click the key next to Region/Rect. You’ll be asked if you want to create a new track and then you’ll see the new track added to the animation panel, with a small dot representing the keyframe you’ve just added. Drag the scrubber to time 2 and then change the y value of the Region/Rect property to 64. Click the key to add another keyframe.

Now when you press Play on the animation, you should see the background slowly scrolling behind the player.

Next steps
The main scene is now ready for us to add enemies. In the next step we’ll make a single enemy scene, as we did with the bullets, and then instantiate that multiple times.




ENEMIES
Now that our player can shoot, let’s give them something to shoot at.

Setting up the scene
We’ll use an Area2D for the enemy, since we need it to detect overlap - either with the player’s bullets, or with the player itself.

Here’s are the nodes we’ll need:

Enemy:  Area2D
     Sprite2D
     CollisionShape2D
     AnimationPlayer
    MoveTimer:  Timer
    ShootTimer:  Timer
Select the area node and click the Node tab next to the Inspector. Under Groups, type “enemies” an click Add. Remember the code we wrote on the bullet? It looks for objects in the “enemies” group.

In the sprite’s Texture, add Bon_Bon (16 x 16).png and set its Animation/Hframes to 4.

As you’ve done before, add a rectangular collision shape and size it to fit. Enable One Shot on both timer nodes.

In the AnimationPlayer, add an animation called “bounce” and set it to looping and autoplay. Set the Snap at the bottom of the animation panel to 0.05.

Select the sprite node and press the key icons next to Texture and Hframes to create tracks for them. We’re doing this because later we’ll add an “explosion” animation that will use different values for these properties.

Now we’ll key the individual Frames values we want. Start with keying Frames each .1 seconds to values in this order2, 1, 0, 3. Finally, key 0 again and put it immediately after. This will make a “pulsing” animation where the sprite grows and then bounces a little at the end. The animation setup should look like this:

alt
Press the play button to see it in action. Feel free to adjust it if you’d like.

Now add another animation called “explode”. Set its length to 0.4 seconds.

Change the sprite’s Texture to Explosion (16 x 16).png and keyframe that property. Since this image has a different number of frames than the enemy image, we also need to change Hframes to 6 and keyframe that.

Now keyframe Frame to 0 at time 0 and to 5 at time 0.4. Play the animation to see it in action.

Enemy script
The enemies will spawn at the top of the screen in a grid. After a random amount of time, they’ll descend toward the player and then return to the top if they weren’t destroyed. Periodically, they’ll also shoot at the player.

Add a script, and start with the variables:

extends Area2D

var start_pos = Vector2.ZERO
var speed = 0

@onready var screensize  = get_viewport_rect().size
The start_pos variable is going to keep track of the enemy’s starting position so that after it moves, it can return to its original location. We’ll set it when the enemy is spawned and we call its start() function.

func start(pos):
    speed = 0
    position = Vector2(pos.x, -pos.y)
    start_pos = pos
    await get_tree().create_timer(randf_range(0.25, 0.55)).timeout
    var tween = create_tween().set_trans(Tween.TRANS_BACK)
    tween.tween_property(self, "position:y", start_pos.y, 1.4)
    await tween.finished
    $MoveTimer.wait_time = randf_range(5, 20)
    $MoveTimer.start()
    $ShootTimer.wait_time = randf_range(4, 20)
    $ShootTimer.start()
When we spawn our enemies we’ll call this function and pass it a position vector representing where on the screen the enemy should go. Note that we actually spawn it above the top of the screen (negative y value). This is so that we can animate it coming onto the screen using a tween. We also randomize the two timers so that all enemies won’t be moving and shooting at the same time.

Connect both of the timers’ timeout signals.

func _on_timer_timeout():
    speed = randf_range(75, 100)

func _on_shoot_timer_timeout():
    $ShootTimer.wait_time = randf_range(4, 20)
    $ShootTimer.start()
We can start moving when the timer runs out, and we’ll also shoot, but we haven’t made a bullet yet, so that part will come later. Now that we’re changing the speed, we can move using it.

func _process(delta):
    position.y += speed * delta
    if position.y > screensize.y + 32:
        start(start_pos)
Now if the speed isn’t 0, we’ll see the enemy move down the screen. When it goes off the bottom, we start it all over again.

We’ve already written the code in the bullet scene that calls explode() on the enemies it hits, so let’s add that too.

func explode():
    speed = 0
    $AnimationPlayer.play("explode")
    set_deferred("monitoring", false)
    died.emit(5)
    await $AnimationPlayer.animation_finished
    queue_free()
In this function, we stop moving, play the explosion animation, and then delete the enemy when it’s finished. The set_deferred() call makes sure to turn off monitoring on the enemy. This is so that while the enemy is exploding, another bullet can’t hit it again.

Add the died signal at the top of the script:

signal died
We’ll use that signal to let the main scene know that the player just earned some points.

Spawning enemies
Now let’s go to the Main scene and add these enemies to the game. Add a script to Main and start by loading the enemy scene:

extends Node2D

var enemy = preload("res://enemy.tscn")
var score = 0
Spawning enemies ordinarily won’t happen until we’ve pressed the “Start” button to begin the game, but since we haven’t made that yet, we’ll just spawn them immediately:

func _ready():
    spawn_enemies()

func spawn_enemies():
    for x in range(9):
        for y in range(3):
            var e = enemy.instantiate()
            var pos = Vector2(x * (16 + 8) + 24, 16 * 4 + y * 16)
            add_child(e)
            e.start(pos)
            e.died.connect(_on_enemy_died)
This makes 27 enemies and positions them in a grid in the top half of the screen. We also make sure to connect the died signal of each, so we need to create that function:

func _on_enemy_died(value):
    score += value
We don’t have a way to display the score yet, but we’ll get to that soon.

Play the scene and you should see a bunch of enemies appear at the top and periodically fall down the screen. Next, we’ll make them shoot.




ENEMY SHOOTING
Now that our enemy can shoot, let’s give them something to shoot at.

Enemy bullet scene
Make a new EnemyBullet scene just like you made the player bullet earlier. We won’t go into all the steps here, but you can refer back to that part if you’re stuck. The only difference here is that you can use the Enemy_projectile (16 x 16).png image instead.

The script will be a little bit different:

extends Area2D

@export var speed = 150

func start(pos):
    position = pos

func _process(delta):
    position.y += speed * delta
Connect the screen_exited and area_entered signals of the VisibleOnScreenNotifier2D and Area2D, respectively:

func _on_visible_on_screen_notifier_2d_screen_exited():
    queue_free()

func _on_area_entered(area):
    if area.name == "Player":
        queue_free()
Notice that we’re detecting the hit on the player, but it’s not doing anything yet. We’ll come back to that once we add a way for the player to take damage.

Adding shooting to the enemy
At the top of the enemy’s script, load the new bullet:

var bullet_scene = preload("res://enemy_bullet.tscn")
Then update the shooting function:

func _on_shoot_timer_timeout():
    var b = bullet_scene.instantiate()
    get_tree().root.add_child(b)
    b.start(position)
    $ShootTimer.wait_time = randf_range(4, 20)
    $ShootTimer.start()
Play the Main scene again and you should have some random enemy bullets appearing.




UI AND SCORE
The last main piece of our game is the user interface (UI). We need a way to show the player the score and other information. To do this, we’ll use a variety of Control nodes - the nodes Godot provides for building UIs.

UI scene
Start the scene with a MarginContainer and name it UI.

Containers are Control nodes that are designed to control the size and position of their children. Using them makes it easier to position and move Control nodes without having to do it manually. The MarginContainer makes sure its children don’t get too close to the edge.

In the Inspector under Theme Overrides/Constants set all four Margin values to 10. Then, in the menu bar at the top of the viewport, set the anchors to the Top Wide preset.

alt
Next, we’ll add an HBoxContainer. This type of container organizes its children horizontally. Under that, add a TextureProgressBar, which will represent our ship’s shield level. Name it ShieldBar.

Unfortunately, there’s not a good image in the art pack to use for a progress bar (there is one, but it isn’t formatted in an easy way to work with). Instead, we’ll use the two images below. One is a green bar and the other is a white outline. Save them in your project folder.

altalt
In the Texture section, drag the foreground image to the Progress and the background image to the Under texture. The first thing you’ll notice is that it’s very small. Let’s first under Layout set Custom Minimum Size to (80, 16). You’ll notice that the orange selection rectangle got bigger, but the image didn’t. Well, we don’t want the image to just stretch, or it would look bad. Instead we’ll check the Nine Patch Stretch box, and then set the four Stretch Margin values to 3.

You should now see a long, unfilled bar. To see what it looks like when filled, change the Value property in the Range section to anything between 0 and 100.

alt
On the right side, we’d like to show the score. Now, we could just use a Label node and add a font, but that’s not very fun. The art pack includes a lovely pixel set of digits that we could use instead. We’ll just need to do a little coding to chop it up and show the corect digit(s).

Score counter
Start a new scene and add an HBoxContainer. Name it ScoreCounter then set it to Top Wide and set the Alignment to “End”. Also, set the Theme Overrides/Constants/Separation to 0 (you need to check the box next to the property).

In this container, we’ll have a string of TextureRect nodes showing each digit. We’ll start by adding one and then duplicating it.

Name the TextureRect Digit0. Under Texture, select “New AtlasTexture”, then click the box to open it. Drag Number_font (8 x 8).png into the Atlas property, then set the Region to (32, 8, 8, 8). Set Stretch Mode to “Keep Aspect Centered”.

Select the Digit0 node and press Ctrl-D 7 times to create duplicates of the node. The picture below shows what you should see after this step:

alt
We now have an issue, though. Even though we’ve duplicated the TextureRect to create 8 unique copies, they are all using the same AtlasTexture in the Texture property. This means that when we change the Region to show a different digit, it will change on all the digits.

This is because Resource objects (such as Texture) are loaded into memory and then shared - there’s really only one texture. While this is very efficient, because you don’t waste memory loading the same image multiple times, it means that when we do want things to be unique, we have to specify it.

On each of the nodes, click the down arrow next to the AtlasTexture and select “Make Unique”.

alt
Now we’ll add a script to ScoreCounter that will choose the correct Region values for whichever digit it needs to display.

extends HBoxContainer

var digit_coords = {
    1: Vector2(0, 0),
    2: Vector2(8, 0),
    3: Vector2(16, 0),
    4: Vector2(24, 0),
    5: Vector2(32, 0),
    6: Vector2(0, 8),
    7: Vector2(8, 8),
    8: Vector2(16, 8),
    9: Vector2(24, 8),
    0: Vector2(32, 8)
}

func display_digits(n):
    var s = "%08d" % n
    for i in 8:
        get_child(i).texture.region = Rect2(digit_coords[int(s[i])],
                Vector2(8, 8))
We start by making a list of the coordinates in the image where each digit is found. Then, display_digits() will format the number to an 8 digit number (for example, 258 would become "00000258"). Then, for each digit, we can apply the correct coordinates from the array.

Scripting the UI
Go back to the UI scene and add the ScoreCounter to the HBoxContainer, then add a script to UI.

extends MarginContainer

@onready var shield_bar = $HBoxContainer/ShieldBar
@onready var score_counter = $HBoxContainer/ScoreCounter

func update_score(value):
    score_counter.display_digits(value)


func update_shield(max_value, value):
    shield_bar.max_value = max_value
    shield_bar.value = value
We’ll call these functions from Main whenever we need to update the score or the shield.

Adding the UI to main
Now in the Main scene add a CanvasLayer node, and instance the UI as its child. The CanvasLayer node creates another drawing layer, so our UI will be drawn on top of the rest of the game.

Change this function in main.gd:

func _on_enemy_died(value):
    score += value
    $CanvasLayer/UI.update_score(score)
Run the game and see that your score goes up when shooting enemies.

Player shield
We can also add the shield to the player’s script. Add these new lines at the top of player.gd:

signal died
signal shield_changed

@export var max_shield = 10
var shield = max_shield:
    set = set_shield
This set = syntax tells Godot that we want to call the set_shield() function whenever the shield variable has its value set.

func set_shield(value):
    shield = min(max_shield, value)
    shield_changed.emit(max_shield, shield)
    if shield <= 0:
        hide()
        died.emit()
We can also connect the ship’s area_entered signal so that we can detect when an enemy hits the ship:

func _on_area_entered(area):
    if area.is_in_group("enemies"):
        area.explode()
        shield -= max_shield / 2
And in the enemy bullet, add some damage to the shield when it hits:

func _on_area_entered(area):
    if area.name == "Player":
        queue_free()
        area.shield -= 1
Finally, we need to connect the player’s shield_changed signal to the function in the UI that updates the shield bar. You can do this in the Inspector by selecting the Player node in the Main scene. Under the Node tab, double-click the shield_changed signal to open the “Connect a Signal” window. In this window, select the UI node and type update_shield in the Receiver Method box.

alt
Run the game again and check that your shield depletes when you get hit by a bullet or an enemy.

Next steps
We’re almost done with the basic functionality. We just need a way to start and end the game.



STARTING AND ENDING THE GAME
Our last step is to add a start button and a “game over” state to the game.

Starting the game
Currently when we run the game, it starts immediately. Let’s add a button to start it.

In Main as a child of the CanvasLayer, add a CenterContainer and set its layout to Full Rect. Then add a TextureButton child. Name this button Start and add the START (48 x 8).png image as its Normal texture.

Add a reference at the top of the script:

@onready var start_button = $CanvasLayer/CenterContainer/Start
Connect this button’s pressed texture to Main and add this code:

func _on_start_pressed():
    start_button.hide()
    new_game()
The new_game() function handles starting the game, so change _ready() so that it no longer spawns enemies, but just ensures the button is showing:

func _ready():
    start_button.show()
#	spawn_enemies()
Now add the new_game() function:

func new_game():
    score = 0
    $CanvasLayer/UI.update_score(score)
    $Player.start()
    spawn_enemies()
Now the button should show when you run the scene, and pressing it starts the game.

Ending the game
Add a TextureRect as a child of the CenterContainer and name the node GameOver. Use the GAME_OVER (72 x 8).png image. It will overlap with the start button, but that’s ok, we’re only ever going to show one at a time.

Add another reference at the top of the script:

@onready var game_over = $CanvasLayer/CenterContainer/GameOver
And add game_over.hide() to _ready().

Connect the player’s died signal in Main.

func _on_player_died():
    get_tree().call_group("enemies", "queue_free")
    game_over.show()
    await get_tree().create_timer(2).timeout
    game_over.hide()
    start_button.show()
This will show the “game over” image for 2 seconds, then switch back to the start button so you can play again. Try it out and see if you can play a few games.




WRAPPING UP
If you’ve been following along, you’ve learned a lot of the fundamentals of building games in Godot. We’re going to end the tutorial here, since we’ve completed the basic game.

 The secret to learning effectively
Here’s my big secret for getting the most out of tutorials like this and others you may find online. At the end, once you’ve finished building the project, immediately delete it and start over. This time, try and re-create it without looking at the tutorial. If you get stuck, look at just that part, then close it again.

It may sound repetitive, but that is how we learn: by doing things repeatedly. If you follow this tip, you’ll be amazed at how quickly you level up your gamedev skills.

Adding to the game
If you’re feeling comfortable with the techniques used to make this game, then you’re ready to branch out. Try adding a single new feature to this game.

If you’re stuck coming up with an idea, here are some suggestions:

Additional enemy types - there is art for other enemies in the art pack. How do they move and shoot?

Waves - make more enemies spawn every time you clear the screen

Boss enemies - what if a big enemy appears?

Boosts - powerups could appear for the player to collect. There’s some art for those too.

Shield recharge - collect these to power up the shield
Weapon upgrades - shoot more bullets, patterns, etc.
Sound and music - give everything a lot more personality with some sound effects and background music.

Learning more
Ready for more? Here are some suggestions for your next learning adventure:

Godot 101: Getting started in 3D - if you’re interested in making things in 3D, check out this introduction to Godot’s 3D features.

Check out the rest of the content on this website. There are lots of examples, tutorials, and code snippets to help you learn how to make your dream game.

 Download This Project on  GitHub
Download the project code here:

https://github.com/godotrecipes/8_direction_animation






and here are some other tutorials i found


Custom Resources are OP in Godot 4
Using custom resources in Godot has been a massive game changer for me. With Godot 4.0 just being released what could be a better time to share a guide? Recently, a friend of mine who also uses Godot asked how I was handling the customization options in my game EzGuy Creator. I explained that I was using custom resources. After this he told me he was not aware they were a thing, so naturally I decided on that as the topic of a guide. In this post I will be going over what resources in Godot are exactly, how they work and when/how to make your own.

Note: This guide is written for Godot 4. The included examples and script snippets will not work in Godot 3.x versions.

What exactly is a resource?
A resource in Godot is an object that represents data and properties. A resource and its data can be saved to and loaded from files. Godot's documentation refers to them as data containers. When you import images, sounds, fonts and models they become resources. You can see all the types of resources Godot offers in the documentation. They can keep track of multiple values, references to other resources and can contain functions to manipulate its data. After a resource is loaded, the engine will cache it as long as you keep a reference to it. This can improve performance if the same resources are requested multiple times. The best part is that you can create your very own resource classes!

A gif displaying the create resource window in Godot 4

Why Custom Resources Classes Are So Useful
It can be very convenient and useful to create your own resource class for several reasons. Compared to something like dictionaries or arrays, they offer a much more structured and organized way to keep track of data. Resources have all of their properties and their types predefined. When you edit a resource its properties are shown and are able to be manipulated in the Godot editor's inspector dock. Resources can also be saved and loaded to/from files, making management of all this data very easy and simple.

An image showing a custom resource in Godot's inspector dock

This is an advertisement. Get Ezcha Elite to remove ads.

When You Should Use Them
There are many use cases for custom resources. Specific examples may include saving/storing item information such as descriptions and textures, item systems, player save data, random level generator options and much more. It is better to use custom resources to store data compared to nodes. They are much more lightweight and will consume less processing time and memory, increasing your game's performance.

Creating a Custom Resource Class
To get started making your own resource class you will need to create a script that extends the base Resource class.

A gif showing the script creation window

You can also give a custom name to the class the script represents. It is not required but it can come in handy for checking types and other things. To give it a name, make a new line that begins with class_name followed by the name you want to give it.

extends Resource
class_name CharacterAttributes
Now you can define its properties/values! They work just like any other variable in gdscript, except you prefix it with @export. This is called an annotation, which are new to Godot 4. Exporting a variable will allow you to edit its value in the editor's inspector tab when you use your resource. You need to either specify the type of the variable or give it an initial value so the type can be inferred. I recommend specifying the type. Exporting variables is not exclusive to resources. This works with any script/node and is a great way to specify scene-specific values.

@export var title: String = ""
@export var first_name: String = "Person"
@export var last_name: String = "McHuman"
@export var invulnerable: bool = false
@export var overworld_texture: Texture
This is an advertisement. Get Ezcha Elite to remove ads.

Fun fact: Specifying the type of your variables can speed up your game! It allows Godot to do some optimizations when running your scripts. Check out some numbers from a recent update here.

You can also give it functions just like any other script. These can be helper functions to manipulate the resource's properties.

func has_title() -> bool:
	return (title != "")

func get_full_name() -> String:
	if (title == ""):
		return "%s %s" % [first_name, last_name]
	return "%s %s %s" % [title, first_name, last_name]
Here is our final result, a custom resource class.

# character_attributes.gd
extends Resource
class_name CharacterAttributes

@export var title: String = ""
@export var first_name: String = "Person"
@export var last_name: String = "McHuman"
@export var invulnerable: bool = false
@export var overworld_texture: Texture

func has_title() -> bool:
	return (title != "")

func get_full_name() -> String:
	if (title == ""):
		return "%s %s" % [first_name, last_name]
	return "%s %s %s" % [title, first_name, last_name]
How To Use And Save Your Resource
Now that you have set up your custom resource class you can now use it! There are two ways to create a new resource. There is a button in the inspector dock, or you can right click a directory/folder in the file browser and use the context menu.

Godot's inspector dock with the create resource button circled

Godot's file browser with the "create" context menu opened

This is an advertisement. Get Ezcha Elite to remove ads.

You will be greeted by a window containing a list of resource classes to choose from along with a search box.

Godot's inspector panel with the create resource button circled

After you select and create your resource it will be displayed inside the inspector dock. Here you are able to see and manipulate its properties. Once you are done, you can save the resource by pressing the save button or with the trusty old CTRL+S keyboard shortcut.

Godot's inspector panel with the save resource button circled

Loading And Referencing Your Resource
It should now be fairly simple to load and reference our resource. There are four different ways you can do this. This guide will be going over three of them, skipping over the ResourceLoader class because it's not as straight forward as the others. The way I usually find myself loading resources is by adding a @export variable in the class that needs it. Just like when you make a custom resource, this tells Godot to show the variable as a property in the inspector dock when the class is selected. This allows you to to quickly define and update the resource it references.

# character.gd
extends CharacterBody2D
class_name Character

signal damage_taken
signal death

@export var attributes: CharacterAttributes :
	set(value):
		attributes = value
		sprite.texture = value.overworld_texture
@export var health: int = 100

@onready var sprite: Sprite2D = $Sprite

func _ready():
	print("Hello! My name is %s." % [attributes.get_full_name()])

func damage(amount: int):
	if (attributes.invulnerable): return
	health -= amount
	if (health > 0):
		emit_signal("damage_taken", amount)
		return
	emit_signal("death")
Alternatively, you can use both preload and load to get your resource without all the fancy editor stuff.

const ATTRIBUTES_LIST: Array[CharacterAttributes] = [
	preload("res://objects/character/attributes/john_doe.tres"),
	preload("res://objects/character/attributes/jane_doe.tres")
]
This is an advertisement. Get Ezcha Elite to remove ads.

func _ready():
	attributes = load("res://objects/character/attributes/jane_doe.tres")
Extra Tips & Tricks
As this guide comes to a close, there are a few extra tips and tricks you may want to know about. This includes an explanation on how Godot caches/shares resources to reduce memory usage, and how that can occasionally cause a certain issue. However there is way to fix this. Another tip is that there are other annotations that can be used in place of @export that can indicate more specific values. The full list of annotations can be found in Godot's documentation and I have included some examples as well.

Local To Scene
Say we have a new scene called Box containing a MeshInstance3D node. There's a point to this, I promise. We give this node a cube mesh and set its material_override property to a new StandardMaterial3D resource. Now we go to a separate scene and instance Box several times. Godot will create a singular copy of the resources Box uses and will share it across all of its instances. This is great for performance, but you may find yourself having a certain issue. Go back to our Box scene. We need the mesh to change its color to red when interacted with, so we give it a script that sets the albedo_color property of the mesh's material. When we run the other scene and interact with one Box you will quickly realize all the other instances change colors too! However, there is a solution to this. You can find a "local to scene" property in the inspector for every resource. When this is enabled Godot will make the resource unique in every scene it is instanced in. At the cost of some memory usage and drawing performance, we can now change the color of each Box individually.

An image showing the "local to scene" property in the inspector

Additional Export Annotations
There are several additional types of export annotations. While the standard @export will work in most cases, you can use the additional annotations to indicate more specific values. You can export file paths, multi-line strings, enum strings, add categories and more! The full list of annotations can be found here in Godot's documentation. Below is a small, handpicked list of annotations I believe to be some of the most useful. I have included their descriptions and examples from the documentation.

@export_category ( String name )
# Define a new category for the following exported properties.
# This helps to organize properties in the Inspector dock.
@export_category("Statistics")
@export var hp = 30
@export var speed = 1.25
This is an advertisement. Get Ezcha Elite to remove ads.

@export_file ( String filter="", ... )
# Export a String property as a path to a file.
# The path will be limited to the project folder and its subfolders.
# See @export_global_file to allow picking from the entire filesystem.
# If filter is provided, only matching files will be available for picking.
@export_file var sound_effect_path: String
@export_file("*.txt") var notes_path: String
@export_multiline ( )
# Export a String property with a large TextEdit widget instead of a LineEdit.
# This adds support for multiline content and makes it easier to edit large amount of text stored in the property.
@export_multiline var character_biography: String
@export_range ( float min, float max, float step=1.0, String extra_hints="", ... )
# Export an int or float property as a range value.
# The range must be defined by min and max, as well as an optional step and a variety of extra hints.
# The step defaults to 1 for integer properties.
@export_range(0, 20) var number: int
@export_range(-10, 20) var number: int
@export_range(-10, 20, 0.2) var number: float
Thank you!
Thank you for making it to the end of my guide about resources in Godot 4. If this has been helpful, you can support me by checking out the rest of my website! It has games, some devlogs about my game Scribble Surfer, and even forums that include a game dev section. 👋

This is an advertisement. Get Ezcha Elite to remove ads.

 Related games

EzGuy Creator
 Comments
Join the Ezcha Network!
You must be logged in to comment.

Login or register
FireCatMagic
 a year ago
so awesome

1ris
 a year ago
custom resources might be cool and all but can it run crysis? i didnt think so.

Brett
 a year ago
abuse it before it gets nerfed

John_Freeman
 a year ago
too op, pls nerf



How to load and save things with Godot: a complete tutorial about serialization
Resources
Tutorials
godot-4
godot-3
Jan 26
7d

AnidemDex

1
Jan 26
The thing with Godot is that there’s no only one solution, you had many solutions.

But before seeing these solutions, you must know what you want to save first.

I’ll help you defining how and where you can use these saved methods, and you decide what to use, deal? Deal.

Before actually starting coding something…
Define what you want to save first
Don’t say:

“I’m going to use [Format Name Here] to save my things”

This will probably over-complicate the process for you and your team. Decide what you really want to save first, and then say:

“That data is going to be saved using [Format Name Here]”

If you want

Why? Because is easier to define what tools do you need according your requirements than having the tools first and then meet the requirements.

For this example, let’s assume that we want to save the player health, player name and player points. An integer, a string and a real(float) value.

Decide what format do you want to use to save your data
This step may be tricky, specially for new users. You know what you want to save, but what kind of file are you going to use? Godot let you use whatever you want, so from all file formats that exist, what would be the “ideal” format?

A while ago I made a little flowchart 165 to help you to decide what you need according what you want to save, here’s an updated version:
flowchart

It can always be modified and improved based on community suggestions.

But should I save nodes?
Most of the time you don’t want to save a node, you want to save the data that node contains.

Save nodes when you want to save the node structure itself, with the current applied values.

Where do I save my data files?
Save to user:// folder.

res:// folder will be read-only when you export the game, but is the perfect path if you’re working with @tool stuff (like plugins).

You can read more about file paths in Godot on its official documentation page 39.

Available built-in formats
Using ConfigFile
ConfigFile 26 is a helper class that helps you writing INI (.ini) 1 style format, which its structure looks like:

[section]
variable_name = <variable value>
This is widely used when you want to save configuration files, I’ve also seen the usage of this format on some mod loaders, where they define the assets and workflow of the mod.

With Godot, you only need to define a ConfigFile object to save or load the data, and each data/section you need to save or load:

# Let's assume the PlayerNode is the node where we save the player data in game
var PlayerNode:Node

var save_path := "user://player_data.ini"

# To save data
func save() -> void:
  var config_file := ConfigFile.new()

  config_file.set_value("Player", "health", PlayerNode.health)
  config_file.set_value("Player", "name", PlayerNode.name)
  config_file.set_value("Player", "points", PlayerNode.points)

  var error := config_file.save(save_path)
  if error:
    print("An error happened while saving data: ", error)

# To load data
func load() -> void:
  var config_file := ConfigFile.new()
  var error := config_file.load(save_path)

  if error:
    print("An error happened while loading data: ", error)
    return

  PlayerNode.health = config_file.get_value("Player", "health", 1)
  PlayerNode.name = config_file.get_value("Player", "name", "UNDEFINED")
  PlayerNode.points = config_file.get_value("Player", "points", 0.0)
The usage from Godot 3 and Godot 4 is practically the same with code. In Godot 3, you’ll need to use an external text editor to see the saved data, Godot 4 let you see your ConfigFile in editor, through Script editor, loading it as plain text.

The main advantage of using ConfigFile is that Godot knows what is saved to a ConfigFile, so data types are preserved, even if is an Object.

Using JSON
JSON stands for JavaScript Object Notation* 6, and is widely used for data transference between things that are not directly related but needs and easy and human readable way to transfer that data.

In a file, it may look like a GDScript dictionary:

{
  "variable_name": <variable value>
}
There’s no scenario apart from the data transference that I should recommend this format. Its usage really depends on you, and is ok if you don’t use it for data transference.

# Let's assume the PlayerNode is the node where we save the player data in game
var PlayerNode:Node

var save_path := "user://player_data.json"

# To save data
func save() -> void:
  var data := {
    "name": PlayerNode.name,
    "health": PlayerNode.health,
    "points": PlayerNode.points
  }

  var json_string := JSON.stringify(data)

  # We will need to open/create a new file for this data string
  var file_access := FileAccess.open(save_path, FileAccess.WRITE)
  if not file_access:
    print("An error happened while saving data: ", FileAccess.get_open_error())
    return

  file_access.store_line(json_data)
  file_access.close()

# To load data
func load() -> void:
  if not FileAccess.file_exists(save_path):
    return
  var file_access := FileAccess.open(SAVE_PATH, FileAccess.READ)
  var json_string := file_access.get_line()
  file_access.close()

  var json := JSON.new()
  var error := json.parse(json_string)
  if error:
    print("JSON Parse Error: ", json.get_error_message(), " in ", json_string, " at line ", json.get_error_line())
    return
  # We saved a dictionary, lets assume is a dictionary
  var data:Dictionary = json.data
  PlayerNode.name = data.get("name", "UNDEFINED")
  PlayerNode.health = data.get("health", 1)
  PlayerNode.points = data.get("points", 0.0)
JSON has some limitations* 7 which can be summarized on:

It doesn’t recognize what a real (float) or integer (int) value is, it saves a number.
It can’t save all data types, only arrays, dictionaries, numbers and strings.
But, at the other hand, since is widely used across the whole internet, there are very good editors for this format, not only your notepad app.

Note: Since Godot 4, you can also edit it with Script editor, editor will load it as plain text (even if it’s defined as resource)

Using FileAccess (File)
FileAcess 10 (or just File in Godot 3) is a helper class to write and read files. No fancy stuff, you’re dealing directly with the file itself.

Usually, you use FileAccess in complex scenarios, where you need total control about how the stuff in the file is read or written. Note that most of the FileAcess functions reads and write binary files, only string/text related functions writes and read from human readable text.

This may be useful when you want to write your own format.

# Let's assume the PlayerNode is the node where we save the player data in game
var PlayerNode:Node

var save_path := "user://player_data.dat" # <- custom format

func save(content):
  var file = FileAccess.open(save_path, FileAccess.WRITE)
  file.store_line(PlayerNode.name)
  file.store_32(PlayerNode.health)
  file.store_float(PlayerNode.points)
  file.close()
  

func load():
  var file = FileAccess.open(save_path, FileAccess.READ)
  # Order matters. The same order you use to write, is the order you use to read
  PlayerNode.name = file.get_line()
  PlayerNode.health = file.get_32()
  PlayerNode.points = file.get_float()
  file.close()

If you try to read the generated file with a text editor you’ll see this:

image of binary data displayed as plain text

Your text editor tries to convert the binary data into unicode characters, resulting in that weird looking characters. The real data may look like this:
image of binary data

Using Resources
Resource 11 is a class that you can serialize directly to a file using Godot ResourceSaver and deserialize using ResourceLoader. They were made for data, they live for data.

Majority (if not all) files you see in editor FileSystem are a Resource.

Resources are something that Godot engine can easily understand, and the way that it loads or save stuff can be modified/extended, so it gives you the same power as if you were writing it with other methods.

Additional to that, since is an Object, this data can:

Be shared between instances.
Hold methods.
Emit signals.
Define setter and getter for their variables.
Be inspected in editor and manipulated with custom tools.
According to docs:

“… their main advantage is in Inspector-compatibility. While nearly as lightweight as Object/RefCounted, they can still display and export properties in the Inspector. This allows them to fulfill a purpose much like sub-Nodes on the usability front, but also improve performance if one plans to have many such Resources/Nodes in their scenes.” - Link to documentation 6.

Creating a Resource
@tool
extends Resource
class_name PlayerData

@export var name:String = "Default"
@export var health:int = 1
@export var points:float = 0.0
That’s our data class. class_name is optional, but would help us to:

Use it in other scripts.
Make it appear in the resource creation list.
Static type.
Using the Resource
Using our current configuration, saving data would look like this:

# Let's assume the PlayerNode is the node where we save the player data in game
var PlayerNode:Node

var save_path := "user://player_data.tres" # <- tres is Text RESource

func save() -> void:
  var data := PlayerData.new()
  data.name = PlayerNode.name
  data.health = PlayerNode.health
  data.points = PlayerNode.points

  var error := ResourceSaver.save(data, save_path)
  if error:
    print("An error happened while saving data: ", error)

func load() -> void:
  var data:PlayerData = load(save_path)
  PlayerNode.name = data.name
  PlayerNode.health = data.health
  PlayerNode.points = data.points
This works, but we miss the power of sharing the data between instances, what we can do is to update the data hold in the node:

# node script
@export data:PlayerData = PlayerData.new()
and now we can just do on our save/load script:

func save() -> void:
  ResourceSaver.save(PlayerNode.data, save_path)

func load() -> void:
  PlayerNode.data = load(save_path)
This way you keep your data and your node code separated, so the data doesn’t rely on the node and you can share/modify it and let other node handle it.

Notice that PlayerData is not your data, is just your data structure. The actual data is on data variable, that we exported on the PlayerNode

This is because PlayerData is a Script. By itself, it doesn’t do anything and, just like the script of your nodes, it needs to be created (similar to what you do when you attach the script to the node).

But I heard from someone that “resources are insecure”
Image about game encription

Generally, you don’t worry about security.

“… there’s no good reason to prevent malicious users from running arbitrary code, even if you did not provide an official way to do it. But there’s also no good way.” - xananax)

Yes, is true that Resources can execute arbitrary code 14, but this is true for all resources, not only yours. This is even true for the files you see in FileSystem, and all things loaded from FileAcess that allows to bind complete objects (which includes the script). Is a more complex topic than just “I don’t want to be hacked”, a topic that we don’t need to deal with.

Your resource files are not something that you’ll share with the user, and if you’ll do, you can write custom format parsers to read/write from file, so there’s no problem at the end. This is a long and delicate issue, experts on the matter are discussing about it, but you can still use the resources in the mean time.

I still want to use resources, but I’m worried about security
This is a personal note, but if my previous statement didn’t convinced you, you can still use another advantage of resources: the ability to be able to load and save from custom formats.

Using FormatLoader and FormatSaver
From here I will touch an “advanced” scenario, so I will assume that you will look into documentation when something is not explained and that you knows the basics already.

Godot let you use your custom custom format as if it were a resource, letting you define the steps that it requires to load or save that resource.

Long ago I’ve made an example repository to try this feature: GitHub - AnidemDex/Godot-CustomResource: This is a repository where I make experiments with custom resources in Godot. Hope you may find it informative and useful 7

Why use a ResourceFormat?
Because you want to use resources, but also want to define the steps it takes to save it or load it.

Is this safe?
As safe as loading/saving plain text files.

Before creating a ResourceFormat we need to define the Resource. Since we have already made one for our examples, we’ll use PlayerData as our Resource.

To achieve this tutorial goal:

We will save a plain text file with a custom format.
The file extension will be .custom.
To keep tutorial “simple”, the format style will be Comma-Separated Values (csv), where:
<player name>, <player health>, <player points>
Creating a ResourceFormatLoader
ResourceFormatLoader 1 is used by the engine with ResourceLoader 1 to determine how to load something.

@tool
extends ResourceFormatLoader # <- Class we need to define the loader
class_name PlayerDataFormatLoader # <- Required in order to register it in engine.

## Define which extensions (the file ending, after the "." character) you can handle
## with this loader.
func _get_recognized_extensions() -> PackedStringArray:
	return PackedStringArray(["custom"])

## Return the type of resource this loader will return.
## Since is a custom resource, we must return "Resource"
func _get_resource_type(path: String) -> String:
    return "Resource"

## Return the class name registered for our custom resource if any.
func _get_resource_script_class(path:String) -> String:
  return "PlayerData"

## Return if we handle that type of object.
## Since we handle a custom resource, we check against ClassDB
func _handles_type(type: String) -> bool:
	return ClassDB.is_parent_class(type, "Resource")

## Define how to load our resource, or return an ERROR if something went wrong.
func _load(path:String, original_path:String, use_sub_threads:bool, cache_mode:int):
  var file = FileAccess.open(path, FileAccess.READ)
  if file == null:
    return FileAccess.get_open_error()
  
  var line = file.get_line()
  var properties = line.split(",")
  if properties.size() != 3:
	return ERR_PARSE_ERROR
  
  var data := PlayerData.new()
  data.name = properties[0]
  data.health = int(properties[1])
  data.points = float(properties[2])
  return data
Now you should be able to do:

func load() -> void:
  PlayerNode.data = load("custom_player_data.custom")
The previous script defines a loader for a specific file, in a specific format for our custom resource. All defined methods must be implemented in order to be able to work.

The most important part here is the _load method. This is the part where you define how to read the file, and what is its resource equivalent.

Creating a ResourceFormatSaver
Just as ResourceFormatLoader, engine uses many ResourceFormatSaver 2 to determine how to save the resource through ResourceSaver 1.

@tool
extends ResourceFormatSaver # <- Class we need to define a saver
class_name PlayerDataFormatSaver # <- Required in order to register it in engine

## Return which extension does that `resource` takes.
## Since we just handle one type and one format, we return "custom"
## for all types.
func _get_recognized_extensions(resource:Resource) -> PackedStringArray:
  return PackedStringArray(["custom"])


## Here we see if that resource is the type we need.
##
## Multiple resources can inherit from the same class,
## and they can even modify the structure of the class or be pretty similar to it,
## so you must verify if that resource is the actual kind of resource
## you can save, and if it's not you let other ResourceFormatSaver deal with it.
##
## Since we just assumes that our type will be the same always, we just handle
## it as is, but ideally you should filter it.
func _recognize(resource:Resource) -> bool:
  return resource is PlayerData

## Save the actual resource to disk and return OK, or return an Error if something fails.
func _save(resource:Resource, path:String, flags:int):
  if not(resource is PlayerData):
    return ERR_INVALID_DATA

  var data_string:String = "{player_name},{player_health},{player_points}"
  var data = {
    "player_name":resource.name,
    "player_health":resource.health,
    "player_points":resource.points,
  }
  data_string = data_string.format(data)
  
  var file = FileAccess.open(path, FileAccess.WRITE)
  if file == null:
    return FileAccess.get_open_error()
  
  file.store_string(data_string)
  file.close()
  return OK
Now you should be able to do:

func save() -> void:
  ResourceSaver.save(PlayerNode.data, "custom_player_data.custom")
What we do is to verify the resource type and the file extension, and then define how the resource of our type is saved in the given path.

The most important part is _save, where we define the file equivalent of the given Resource.

Going further with a ResourceImporter
A resource importer is an extra step in the resource load, were we first create a new file from a given file, save it to disk and tell godot to use that created file as the resource instead of the original file. See for example png/jpg (image) files, engine import them as ctex files and then returns a Texture from that generated ctex file. You can read more about this in:

Godot Engine documentation
Import plugins 8
Introduction: An import plugin is a special type of editor tool that allows custom resources to be imported by Godot and be treated as first-class resources. The editor itself comes bundled with a ...

Summary
Godot can load and save from and to many formats.

It includes some tools to load and save from JSON and INI style files. You can also load and save custom file formats using FileAcess (File in Godot 3).

Godot has its own data type for handling data, Resource, which can be used as an object and modified the way the engine saves and load it from disk.

And… that’s it, hope you find it useful. If you had any feedback, something that you think can be improved or just want to say anything don’t be afraid of doing so.

I have been seeing many questions about how to “properly” save things with Godot in the discord server, so I wanted to write a complete tutorial about how to save stuff, from easy to advanced solutions, for beginners and advanced users, hoping this help for future humans.

Edit: Whoops, forgot to mention, the original post 6 was made in godotforums, but I reviewed and expanded it a little here



Stupid Shader Tricks: Fun with Arrows in Godot
Posted on June 17, 2024 by Keith Jones — No Comments ↓
Table of Contents

Introduction – Gettin’ Shady
Motivation
What’s Inside
What is a shader? A tiny intro about Godot shaders
Some Shader Arrows
Preliminary – Setting up a Godot Shader
A simple start
Fancy Arrows
Gettin’ Fancier
More Stupid Tricks?
Conclusion & Discussion
Introduction – Gettin’ Shady
Motivation
I’ve been having a blast experimenting with shaders in Godot, which are programs that run on the GPU to accomplish visual effects (and more!) in games. Specifically, I’ve been exploring CanvasItem shaders, which are Godot’s special shaders for 2D, but the principles involved are the same as in 3D, since even in 3D, shaders generally determine what a surface will look like.

I had been exploring some game development projects recently, first with Unity and now with Godot, and while I have loved learning about visual arts and using GIMP to create sprites, I got it in my head that I wanted to see how far I could go using only graphics generated by the game engine and shader code.

What I love about shaders is probably what most folks who are new to game development hate: shaders are inherently mathematical. There’s no getting around it. Shader language is inherently a vector language, and this is wildly powerful and also, at times, mind-bending.

What’s Inside
First, I give my version of a very brief intro to shaders, but point (and rely on) some great links for getting started for those who don’t already know, rather than try to improve on the great resources already out there.

Then I show a few shaders of increasing complexity, which illustrate how we can connect our understanding of linear equations in mathematics to draw straight lines in shaders, including how to get a straight line through the center of a texture at any angle. I make some observations that will hopefully be useful for folks who are new(ish) to shaders. Ultimately, this shows off a handle of the basic concepts used in fragment shaders. The shaders were written using Godot 4.2.2.

What is a shader? A tiny intro about Godot shaders
I am not going to fully explain how shaders work here, but there are tons of great intros, and I highly recommend reading more about them. For example, the Godot Shader Introduction is great. For shaders more generally, The Book of Shaders is probably one of the best resources around for newcomers; it is truly one of the treasures of the internet. For video introductions, check out the FencerDevLog and Godotneers Youtube channels. I also highly recommend the videos of Freya Holmér (note: Freya is using Unity in the linked video, so that video doesn’t provide Godot specific info, but is still a great general resource.)

But here is a two-minute overview: GPUs (essentially) run on all your pixels at once. A shader program gets a rectangle, called a Texture, to draw on, and typically that rectangle already has something drawn on it. A shader can modify what is already there, or completely overwrite it. Probably the most important variable in shader coding is UV — this is coordinate of the pixel in the texture, except normalized. This means no matter what dimensions the texture really is, both U and V only range between 0 and 1, just like the square with 
0
<
x
<
1
 and 
0
<
y
<
1
 in the 
x
,
y
 plane. This “squeezing” is done by just scaling down, so if the image is, say 256×128, then the 
(
u
,
v
)
 coordinates of a point with “actual” coordinates 
(
x
,
y
)
 will be given by the functions 
u
=
x
256
 and 
v
=
y
128
. One thing to note, though, is that in Godot shaders, 
(
0
,
0
)
 is at the upper-left, and V increases toward 1 as you move downward. Godot shaders have a built-in input vector UV, representing the coordinates of the pixel currently being rendered. Since this is two dimensional, it’s called a vec2. When you are working on a shader, you’re focusing on just that single UV pixel. It may seem counterintuitive, but since UV is a variable, it’s more accurate to say that you are writing code for a generic pixel in that texture. This enables you to determine what to do with all pixels in the texture in one fell swoop. Your code never knows a specific “constant” coordinate pair for (U,V); it has to be written so that the same bit of code works for all pixels in the texture at the same time. That can be tricky to get used to, relative to “normal” coding, but it is also one reason shaders are so powerful.

Shaders calculate a variety of things in rendering a pixel, but I’m only going to use fragment shaders here, which just determine what color (and transparency) a pixel should have. This is done in RGBA (reg, green, blue, alpha) format. Each of these four values is represented as a floating point number from 0 to 1. As is typical, an alpha of 0 means fully transparent and 1 means fully opaque. The Godot fragment function has a built-in input called COLOR, which is a vec4, since it needs to represent these four values.

Now’s a good time to warn you that I am not an expert on shaders; so feel free to let me know if I say something you think is off-the-wall or misleading.

Some Shader Arrows
Preliminary – Setting up a Godot Shader
If you’ve never used a shader in Godot, it’s worth checking one of the aforementioned intros to see how to get to the point where you can actually apply a shader to an object. You’ll need to create a scene and add something with a texture to that scene. A ColorRect works, or you can use either a Sprite2D or a TextureRect (with a CanvasTexture subresource, and scaled large enough so that you can see it) works great. You don’t need to import any image into the project to do this, but you could always use the lovable icon.svg that comes with every Godot project as your base texture. You’ll want to click on the object you’ve created, and in the inspector, scroll down to Material, select “New Shader Material”, and then within that select “New Shader.”

A screenshot showing the CanvasItem area of the Godot Inspector, with "Material" and "New Shader" option.
A simple start
Below is the full shader code for a blue arrow arrow facing upward. If you are not familiar with the shader function smoothstep, be sure to read up on that first. It’s one of the first things you need to learn about shaders. (You might want to read about step first.)

shader_type canvas_item;

void fragment() {
	COLOR.rgb = vec3(0.,0.,1.);
		
	COLOR.a = max(smoothstep(.05,.0,abs(UV.x-.5)), 
			      max(smoothstep(.05,.0, abs(UV.x-.5-UV.y)), 
				      smoothstep(.05,.0, abs(UV.y-.5+UV.x))));
}

We get a picture like this:

A screenshot of the "Material" entry of a desmos resource with an arrow pointing up.
Some notes:

We first set COLOR.rgb to the vector <0,0,1>. Those decimal points in the code are crucial; a shader does not convert between integer and floating point representation for you, and the shader compiler will not compile this. COLOR vector is a vec4, and the entries of a vec4 are floats, not integers. Shaders need to be fast, so they make sure they’re not doing that busy work for you. This can be really frustrating, but (I’m sure) it helps ensure shaders operate as efficiently as possible. (I’m probably going to render that moot by doing stupid things with shaders.)
But notice we used a vec3 in that first line, not a vec4. This is because we’re only overwriting the values of the first three components of the color vector: r, g, and b. We do this by writing COLOR.rgb = ... . Shaders taketh away, but they also giveth. It’s really easy to refer to, and assign to, the components of vectors, which makes it easier to write shader code when you know what you’re doing.
Interestingly, vectors commonly refer to both points in space and also colors. Points in space up to four dimensions are typically referred to as x,y,z, and w. Colors coordinates, as we noted, are r, g, b, and a. The shader doesn’t inherently know or care what a particular vector you’ve created represents, so shader language conviently lets you use either xyzw notation or rgba notation interchangeable. It makes sense to try to coordinate your choice with the meaning of the vector, but part of the fun of shaders is about translating coordinates into colors, so that can become ambiguous depending on what you write. With the vector UV, we use UV.x and UV.y. (It’s a bit weird since “UV” is so-named because it thinks of its coordinates as the normalized vectors u and v, but this is how we refer to the first and second components — it would be intuitive to say UV.u to mean the same as UV.x or UV.r, which we noted both refer to the same value, but UV.u is not defined.)
I then just assign a value to COLOR.a. This is a single line of code that takes the maximum value over 3 smoothstep calls. Each smoothstep call essentially just checks how far the point UV is away from a certain line, and blends between alpha=1 (opaque) when the UV point is on the line and alpha=0 (transparent) when it is at least distance .05 away from the line. (Remember, the total width of the rectangle is 1, so 0.05 is 5% of the width. The lines we check are first, the vertical line with 
x
=
.5
, second the diagonal line with x+y=.5, and finally, the diagonal line with 
x
−
y
=
.5
. In the code I don’t want to write the equation; rather, I’ve moved everything to the same side of the equation to obtain an expression such as 
x
−
y
−
.5
 , and the second smoothstep parameter being 0 then corresponds to 
x
−
y
−
.5
=
0
.
It can be helpful sometimes to use a graphing tool like Desmos to quickly see what is what different equations may give, but remember that in the shader, the 
y
-coordinate increases as we move downward, which is not uncommon in computing but not the norm for graphing calculators.
A screenshot of Desmos with the equations x = .5 { 0 < y < 1}, x - y = .5 {.5 <x < 1}, and y+x =.5 {0<x<.5} graphed.
When drawing the lines in Desmos, the arrow points down because y points up.
Fancy Arrows
I wanted to draw arrows to indicate the velocity of some object, and my idea was to have one in each of the four cardinal directions. Each of the four arrows would be “on” or “off” depending on whether the object has a positive component in that direction. The following shader adds some features so that an active arrow is thicker and in green, while an inactive area is thinner and red. It lets you choose a “facing” 1, 2, 3, or 4, each corresponding to one of the cardinal directions:

shader_type canvas_item;

uniform bool active = false;
uniform vec4 inactive_color : source_color;
uniform vec4 active_color : source_color;
uniform float inactive_width : hint_range(0.0,0.3,.01) = .05;
uniform float active_width : hint_range(0.0, 0.3, .01) = 1;
uniform int facing : hint_range(0,4,1) = 0; // 0 = up, 1 = left, 2 = right, 3 = down;


void fragment() {
	COLOR.rgb = active ? active_color.rgb : inactive_color.rgb;
	float line_width = active ? active_width : inactive_width;
	vec2 uv = UV;
	if (facing == 1)
		uv.y = 1.-uv.y;
	if (facing == 2)
	{
		uv.x=1.-UV.y;
		uv.y=UV.x;
	}
	if (facing == 3) 
	{
		uv.x=UV.y;
		uv.y=1.-UV.x;
	}
		
	COLOR.a = max(smoothstep(line_width,.0,abs(uv.x-.5)), 
				+ max(smoothstep(line_width,.0, abs(uv.x-.5-uv.y)), 
				+ smoothstep(line_width,.0, abs(uv.y-.5+uv.x))));
}

And here are the parameters I used for that:

Screenshot showing the shader with an arrow pointing left.
Gettin’ Fancier
You might decide you want the arrow to point any direction. An astute linear algebra student will notice that the modifications used above to point left, down, or right, correspond to certain transformations — all reflections. These are almost linear transformations, except the point which is “preserved” (held fixed) under the change is the middle of the texture, which is 
(
.5
,
.5
)
, not the origin 
(
0
,
0
)
. Due to the symmetry of the arrow, the reflections give the same result as rotating by 1, 2, or 3 “clicks” of 90 degrees.

To rotate the arrow by an arbitrary angle 
θ
, linear algebra gives us the lovely rotation matrix
[
c
o
s
(
θ
)
−
sin
(
θ
)
sin
(
θ
)
cos
(
θ
)
]
. To represent this matrix in the Godot shader language, we need to use the mat2 type. We perform this rotation through matrix multiplication in the code below.

[Mathy Side Note] My friend, multiplying by that matrix gives you the angle sum formulas. If you’re familiar with matrix multiplication, try it out. That’s why this matrix performs a rotation — it’s literally just giving you a new vector corresponding to adding the angles.

However, the rotation matrix only rotates around the origin. As noted, we need to rotate around the point 
(
.5
,
.5
)
. Fortunately, it is as easy as first subtracting that point from UV, then rotating, then adding back. Geometrically, we shift our desired center to the origin, rotate, then shift back.

shader_type canvas_item;

uniform vec4 active_color : source_color;
uniform float active_width : hint_range(0.0, 0.3, .01) = 1;
uniform float angle : hint_range(0, 6.28318, .01) = 0;

void fragment() {
	COLOR.rgb = active_color.rgb;
	float line_width = active_width;
	mat2 rotation = mat2(vec2(cos(angle), -sin(angle)), vec2(sin(angle), cos(angle)));
	vec2 uv = (UV-vec2(.5))*rotation + vec2(.5);

	COLOR.a = max(smoothstep(line_width,.0,abs(uv.x-.5)), 
				+ max(smoothstep(line_width,.0, abs(uv.x-.5-uv.y)), 
				+ smoothstep(line_width,.0, abs(uv.y-.5+uv.x))));
	COLOR.a -= smoothstep(.5,.52, length(uv - vec2(.5)));
}

At the end, we also added one extra line — since the arrow now won’t have it’s “tip” at the edge of the texture, this rotation reminds us that we haven’t “restricted” those lines in any way — it’s really trying to draw the full line, and so you get a kind of “x” or asterisk shape as those lines continue past the arrow point. So we add another smoothstep to cut them off at the point of the arrow by making anything too far from the center transparent.


More Stupid Tricks?
One of the best questions to ask is “where can we go from here; how can we push this?”

How can you tweak the above to rotate the other direction? What if we want the “four cardinal” to have the background be maybe a highly transparent black? Or if we want the “any direction” arrow to have a circular transparent color; what changes can we make? What other fun things can we do with this? What other natural extensions? What about arrows not passing through the center?

Conclusion & Discussion
Is it stupid to try to draw your images with shaders rather than importing static images? I’m no expert, but I think it depends on a few factors. If you won’t be modifying an image, except maybe scaling or translating it, then it is surely more efficient import static images. It’s likely easier to maintain them with sprite atlases, etc. Also, in professional cases involving dedicated artists who are not coders or mathematicians, their workflow uses artist tools like Photoshop, and it doesn’t make sense to even consider something like this. But if you (a) have highly dynamical images, (b) are much more comfortable with math than traditional avenues to art, and/or (c) will be placing rather involved shaders on top of images anyway, then maybe it makes sense to just create your images with shaders when it is easy from a work-effort perspective.

Do you have a favorite shader trick, stupid or otherwise?

This entry was posted in Computer Graphics, Game Dev, Godot, Mathematics, Shader Programming and tagged Godot, shaders by Keith Jones. Bookmark the permalink.


Godot 4.2 Custom signals for beginners
![](https://public.images.stashpad.live/6wBaBtQcS-sSvtpIOpaZ6MZG)
Rotate the **_yellow gate_** by sending a signal from the **_red button_**.

**red_button.gd:**
```
extends Area3D
signal trigger(degrees_sent : int, player_color_sent : Color)

func _on_body_entered(body):
    if body == %Player
        trigger.emit(90, Color.GOLD)
```

**yellow_gate.gd**
```
extends StaticBody3D

func _ready():
    %RedButtonArea3D.trigger.connect(_on_trigger_p~~ress)

func _on_trigger_press(degrees_received, player_color_received):
    rotation.x = -deg_to_rad(degrees_received)
    %"Player/Mesh".mesh.material.albedo_color = player_color_received
```

Just to reiterate:
- signal _trigger_ is **=defined=** in sender (red button)
- signal _trigger_ is **=emitted=** in sender (red button)
- signal _trigger_ is **=connected=** in receiver (yellow gate), but pointing to the sender object first

- **_degrees_sent_** and **_degrees_received_** (first argument) don't need to have the same name and
- _**player_color_sent**_ and _**player_color_received**_ (second argument) don't need to have the same name.
- Just make them so that you understand what's going on.
- But make sure the arguments are in correct order in both sent or received signals:
- Like so: _**signal(first_argument, second_argument)**_
- You don't have to put any arguments for the signal, like so: _**signal trigger**_ , but you must have the same amount of arguments for all of the signals of that name.


Procedural Eyebrow Shader in Godot
May 25, 2024

godot
 
gamedev
Shaders can be a mysterious topic for game developers not yet familiar with them. And seeing some of the wild things people can create with them (for example, on Shadertoy), they can even be ominous. It’s a whole new language and framework you have to learn in addition to Godot!

In this tutorial, I want to breakdown the process I used to create a simple procedural eyebrow shader for TriEdge Hack to help those who are learning about shaders but aren’t sure of the process of creating one from scratch. Specifically, we will look at how to do this in a Godot 2D environment.

Example eyebrows from TriEdge Hack

Here is what we want to accomplish:

This is a nice shader to create as a beginner because it does not depend on time. Let’s get started!

Node setup
In my setup, I use two Sprite2D nodes: One for the white part of the eyes, and the other for the pupils. I do this for TriEdge Hack so I can animate the pupils separately, though for this tutorial you could also use just a single image like this one:

An image of the node inspector after our steps.

It’s important for the image to be symmetric for our shader, so if you are using your own image make sure each eye is spaced accordingly.

First steps
I’ll cover some shader basics as we go, but for those who are looking for a more comprehensive resource I highly recommend The Book of Shaders and the official documentation’s Your first 2D shader.

For this tutorial, we are going to create a fragment shader. This kind of shader runs on every pixel of your sprite and determines what color it is. Let’s attach a shader to our sprite node now. Select your sprite, and under the inspector find the Material property in the CanvasItem -> Material group. Give it a New ShaderMaterial. Under that material, give it a New Shader. You should end up with something like this:

An image of the node inspector after our steps.

Once you click on the circled Shader, the Shader text editor should open and we can start experimenting! Let’s start with the beginner shader from the Godot tutorial, and build up to the eyebrow shader.

shader_type canvas_item;

void fragment(){
  COLOR = vec4(0.4, 0.6, 0.9, 1.0);
}
The first line just tells Godot what kind of shader we are writing. What we really want to focus on is fragment(), which is a special function we can overwrite to set the color of individual pixels by setting the COLOR. For every pixel in our sprite (even the transparent ones), the shader tells that pixel to be this color.

At this point your sprite containing the eye texture should just look like a blue rectangle. Next, let’s look at some other useful building blocks before building our final shader.

Building Blocks
One of the things that can be intimidating about shaders is the many functions available for you to use. We’ll just focus on the ones we need.

We don’t have usual print statements to debug our shader. Instead, we can use the COLOR output as we are constructing our shader to visualize what is going on. Let’s use this to understand our building blocks.

UV
Our current shader is blue everywhere. How can we adjust the shader’s behavior depending on which pixel it’s running on? That’s where UV comes in. UV is a normalized coordinate system we can use in our shader. The U coordinate corresponds to the X coordinate of our image, but instead of being expressed in number of pixels, it’s expressed in a range from 0 to 1. Similarly, V corresponds with Y.

If we update our shader code to use this snippet from the Godot tutorial, we can visualize what’s happening to help understand:

shader_type canvas_item;

void fragment() {
  COLOR = vec4(UV, 0.5, 1.0);
}
Note that we are taking advantage of the fact that shader vector constructors are “smart”. The vec4 we construct is shorthand for vec4(UV.x, UV.y, 0.5, 1.0)

How our image looks with the UV shader.

In this example, the red channel of our color is set based on U, while the green channel is based on V. We can see the image getting redder as U increases further right in the image. Likewise, we can see things get greener as V increases. At the bottom right of the image, both U and V are large, so we have a mix of red and green to give us yellow.

Transforming UVs
One very handy trick for UVs is transforming them using shifts and scaling. This can make the math easier for some tasks. For example, what if we want to adjust our current shader to fade out on the left and right sides?

We need a float to adjust our opacity, and a function that increases from [0.0, 0.5] and then decreases from [0.5, 1.0] (to correspond with our UV.x coordinate). Symmetry around 0.5 sounds annoying, it would be nice if we could use symmetry around zero…

Well, we can! Let’s create a variable to store our “shifted” UV: vec2 UV2 = vec2(UV.x - 0.5, UV.y);

A symmetric function we could use with it is absolute value abs. This gives us an output that’s larger on the edges and 0 at U=0, so we can do 1 - abs(UV2.x) as our function for the alpha channel:

shader_type canvas_item;

void fragment() {
  vec2 UV2 = vec2(UV.x - 0.5, UV.y);
  COLOR = vec4(UV, 0.5, 1.0 - abs(UV2.x));
}
If you look at the editor output for this shader, you’ll see that the edges are only semi-transparent. This is because our new UV goes from -0.5 to 0.5. We need to scale it to the range [-1, 1]: vec2 UV2 = vec2(2.0*(UV.x - 0.5), UV.y);. Now, our colors fade in and out:

Our adjusted UV shader with the edges fading.

TEXTURE
We’re going to need access to the original opacity of our texture. To do this in our shader, we can use:

COLOR = texture(TEXTURE, UV);
If we make this the last line in our shader, you’ll see that it simply leaves the image unchanged since the shader is just reading and outputting the texture unchanged.

Step
This appropriately named function will help us step up our shader game! The float version of it is simple:

step(float a, float b): If a > b, return 1.0 else return 0.0
To visualize what it’s doing, let’s update our shader to output this COLOR:

shader_type canvas_item;

void fragment() {
  COLOR.rgb = vec3(step(0.5, UV.x));
}
How our image looks with the step shader.

We can see how how the step function varies with our U coordinate. Our RGB is black (0,0,0) when U <= 0.5, and then becomes white (1,1,1) when U > 0.5.

Shader Params
For our final building block, we are going to use Shader params. This is a nifty feature in Godot shaders to let us control our shader parameters from the editor or regular Godot code. This can be helpful for debugging how a parameter behaves, and for controlling it via code. Let’s update our step shader to use a shader param:

shader_type canvas_item;
uniform float fac = 0.5;

void fragment() {
  COLOR.rgb = vec3(step(fac, UV.x));
}
The uniform float fac = 0.5 will expose the shader param to our editor:

The shader param &lsquo;fac&rsquo; exposed in the editor.

Now, we can slide around the value of fac and immediately see how our shader responds!

Putting it all together
We have everything we need to build our eyebrow shader, but how should we approach actually building it? First, let’s think of what we are actually trying to accomplish for one eye:

Diagram of what we are trying to accomplish.

We want to have a line (that we can adjust) where everything above the line is transparent (i.e. we want to set the opacity of the pixels in the red shaded region to 0 to form our “eyebrow”). The step function is perfect for this. Let’s take a simple line without an offset, putting u and v on the same side of the equation:

𝑚
𝑢
−
𝑣
=
0
mu−v=0

The two sides of this equation give us the two input arguments to our step function. If the left hand side is smaller than zero, then we make the pixel transparent. 
𝑚
m will correspond to our shader param fac, so our shader code looks like

shader_type canvas_item;
uniform float fac = 0.5;

void fragment() {
  COLOR = texture(TEXTURE, UV); 
  COLOR.a = COLOR.a * step(fac*UV.x-UV.y, 0.0);
}
We also multiply by COLOR.a so pixels that were originally transparent remain so

We can adjust the fac shader param to control the slope and slope and see that it works as intended:

Making it symmetric
We were only considering a single eye to make the initial reasoning simpler. Now, we need to adjust our shader to use the same angle for both eyes. For our end result we want something like 
𝑦
=
𝑚
∗
𝑎
𝑏
𝑠
(
𝑥
)
y=m∗abs(x) (which looks way too suspiciously like angry eyebrows)

Plot of the above equation for m=0.5

We can use our UV shifting trick to move our U values to the [-0.5, 0.5] range, and update our shader to use the absolute UV2.x value:

shader_type canvas_item;
uniform float fac = 0.5;

void fragment() {
  COLOR = texture(TEXTURE, UV); 
  vec2 UV2 = vec2(UV.x - 0.5, UV.y);
  COLOR.a = COLOR.a * step(fac*abs(UV2.x)-UV2.y, 0.0);
}
But, if you adjust the fac shader param for this shader, you will notice a pretty large issue. Negative fac values will give “sad” eyebrows, but positive fac values don’t appear to do anything. What’s going on?

Up until now we’ve ignored the offset of our “eyebrow line”, but now we’ll need to address it. As fac changes, we’ll need to adjust the offset value to put the center of the eyebrows at the desired y position. The exact number will depend on how you want the end result to look. In this case, I like using abs(fac) for the offset. Adding that offset to our line equation gives our final shader:

shader_type canvas_item;
uniform float fac = 0.5;

void fragment() {
  COLOR = texture(TEXTURE, UV); 
  vec2 UV2 = vec2(UV.x - 0.5, UV.y);
  COLOR.a = COLOR.a * step(fac*-1.0*abs(UV2.x)-UV2.y+abs(fac), 0.0);
}
It’s very simple, but can add a lot of extra expressiveness to a game. And it saves us time and space compared to creating different sprites for each desired variation. Here’s how the final result looks:

Looking pretty sad at the end! If you want to randomly set the shader parameter at runtime, it’s easy to do so. Just attach a script to the same node as your shader:

func _ready() -> void:
    self.material.set_shader_param("fac", rand_range(-1.0, 1.0))
You could even tween the shader param to animate animate between happy and sad eyebrows!

Give TriEdge Hack a try to see it (and some other fun shaders) in action.



https://github.com/dandeliondino/godot-4-tileset-terrains-docs

Creating terrain sets (autotiling) documentation
This repo contains a PDF and resources from an archived PR that updated the Using TileSets: Creating terrain sets (autotiling) documentation for Godot 4. It is available here as a resource to help new users set up terrain tiles.

It contains content edited from the main Godot docs, and so is distributed here under that same license: © Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

Links
Github can be weird about displaying such a long PDF, so I recommend either clicking the Download raw file button on the PDF page, or using Code -> Download zip from the main repo page.

PDF of the Creating terrain sets (autotiling) manual section
Godot 4 "starter" project that contains all the examples from these docs with the TileSets and terrains set up
Templates in png and svg format
Contents
Creating terrain sets (autotiling)
Understanding how terrains work
Choosing a terrain mode
Match Sides
Match Corners
Match Corners and Sides
Setting up a new terrain set
Setting up terrain tiles in Paint mode
Setting up terrain tiles in Select mode
Special cases
Animating terrain tiles
Using probabilities for multiple tiles with the same bitmask
Using alternative tiles for one tile with multiple bitmasks
Why this is here
In 2023, I responded to a request to update the Godot 4 docs section for Using TileSets: Creating terrain sets (autotiling). While I received feedback that the PR I created had been submitted correctly, there wasn't interest in reviewing or merging it. I ended up closing the PR as it was blocking others from making edits that might be more likely to get merged.

I am guessing my PR might not have fit the goals the core team had for these docs, and I have tremendous respect for all of the Godot docs maintainers -- they've done an amazing job in establishing a standard of highly accessible documentation.

For a time, Godot users could still access the content in this original PR on Github as a reference. However, Github seems to have recently changed how the Sphinx (rst) file previews are displayed, so the images are no longer inline. And the images are particularly important for understanding these docs.

As of 5/2024, the official docs have yet to be updated, and I still see almost-daily requests on social media for explanations of Godot 4's terrain sets (particularly what the center bits are for!). So I decided to repost the docs here as a PDF. It is not as accessible as the original format, but I hope it will still be useful.

This documentation was created in Godot 4.0/4.1. There have been minor changes to the UI since then, but the tutorials in this these docs should work the same for 4.2/4.3.

I welcome anyone who wants to use any of the content from the original PR #7789 to create a new PR for the terrain sets section. See the commit for the original rst file and webp images.


Making a Clock
your first steps with Godot Engine 4

published 2023-11-06 with Godot 4.1.2


A 2D analog clock made in the Godot Engine.
This is the first tutorial in a series that introduces you to the Godot Engine, version 4. It starts at the absolute beginning and guides you through the process of creating a simple analog clock. In this tutorial we get to know the Godot editor and build a visual representation of a clock. The next tutorial will introduce programming to animate the clock, but for now we focus of the basics of the editor.

At the bottom of my tutorials you'll find links to their license and an online repository containing the finished project.

Creating a Project
Before we can create anything we need to get the Godot editor application and create a project with it. There are various ways to get the editor. I recommend getting it directly from the official website and installing it on your system. This gives you the most control and has the least overhead, but this tutorial works no matter how you got Godot running.

Throughout my tutorials you you will encounter question-answer sections that provide supplementary information that isn't essential. On webpages they are collapsed by default, only showing the question. Clicking the question will reveal the answer.

How do you pronounce Godot?
Getting the Editor
If you don't already have it, go to godotengine.org and click Download Latest or the Download link shown at the top of the page. This will take you to a page where you can download Godot 4 for your system, if you are using a desktop or laptop computer.

You will be offered two choices: Godot Engine and Godot Engine - .NET. The latter is an alternative version of the engine that supports the .NET environment, which allows programming in C#.

We won't be using C# for the first few tutorials, so you can grab the regular editor version. That version just works while the .NET version might require additional setup. Both versions should be unified in the future, after which this will no longer be an issue.

Which exact version should I get?
Project Manager
Once you have Godot installed on your system open the app. You will be presented with a window titled Godot Engine - Project Manager.


Project Manager window, as shown in OS X.
This is the project manager hub, where you can create and keep track of your Godot projects. If you have never opened Godot before the project list will be empty. Also, the window will use Godot's default editor theme, which is dark. This theme is independent of your system's theme.

To create a new project click the New Project button on the right side of the window. This pops up a Create New Project window. Here you can give your project a name and select a location on your system to store the project that you are about to create, via the Browse button. The project name and folder name don't need to match and you can change the project name later.


Creating a new project.
Besides that you are also offered a choice for the renderer that your project will use. This determines how Godot visualizes your project. As mentioned, this can be changed later. We keep the default Forward+ option.

There is also a Version Control Metadata option, set to Git by default. It is a good idea to use version control for serious projects, but even then you do not need to use this option. It enables some in-editor version control features like difference-checking that stand-alone version control apps also provide. So let's set it to None.

Click the Create & Edit button to generate the project and open it in the Godot editor. From now on when you open Godot your project will be listed by the project manager and you can open it from there.

Selecting a Theme
Once the editor has loaded it will be presented to you with its default layout. We will keep this layout throughout the tutorials, but you can customize it as you like. There are various areas and toolbars that we will describe as needed. Most prominent is the central viewport, which shows a 3D view by default.


Godot editor window.
Before we do anything else, let's select a different editor theme. One of the app's main menu items, shown under its title bar, or in the menu bar on a Mac, is Editor. Clicking it reveals its submenu items, the first being Editor Settings.... Click that, or use the keyboard shortcut displayed for it. That opens the Editor Settings window.

The window has two tabs, with General selected by default. You can filter for settings by name here, or browse to the desired category via the collapsible list on the left side. Select Theme under Interface. Then pick a theme for the Preset option in the panel on the right.


Picking a theme via the editor settings.
The Default theme is the one we used to far. You can select another preset theme here or use the other options to create a custom one. From now on, which theme is shown in the tutorial screenshots depends on the theme that you have selected for this website. Godot's Default theme is used for dark and Light is used for light web pages. This applies to all screenshots that are significantly affected by the theme.

How can I change this website's theme?
Output Messages
There is a bar at the bottom of the editor, below the viewport, that lists a few options. The first is Output. It has an obvious colored dot in front of it that is designed to draw our attention to it. Clicking Output will expand a panel, showing Godot's output log.


Output with Blend file import warning.
Godot logs messages, warnings, and errors in here. It starts with an initialization message, followed by a warning concerning some Blend file import option. After that follows some more initialization and then a log of things that we did in the editor. Set preset refers to selecting a preset theme.

You can use the buttons at the right of the log to filter and clear it, but the Blend file warning will pop up every time we open our project. It warns us that our project is set to import Blend files, but no path is configured for it. As we're not going to import Blend files let's turn it off so we won't see the warning again.

Open the Project Settings window via the Project › Project Settings... main menu item. Under FileSystem › Import, turn off Blender › Enabled, by unchecking On.


Blender import disabled.
The window notifies us that this setting will take effect after restarting the editor. You can verify this by clicking Save & Restart. After the project is opened again the Blend file warning will not be logged.

What does the circular arrow next to the option mean?
Creating a Scene
Now that we have a project open in Godot, have selected a theme to our liking, and have gotten rid of the warning, it is time to create something. But before we can start to build our clock we have to get familiar with the concept of scenes.

In Godot things are not created in a vacuum, everything is contained in a scene. A scene is typically thought of as either a place where something happens, like a movie scene, or a view of something, like a picture. In the case of Godot a scene could have either or both, it's a container for anything.

We will create a single scene for our clock.

Root Node
There must always be an open scene, which is shown in the viewport. As we haven't created a scene yet the tab of the current viewport displays [Empty].

A valid scene requires a root node. The panel to the left of the viewport, known as a dock, contains a Scene tab that currently asks us to create a root node, offering four options: 2D Scene, 3D Scene, User Interface, and Other Node. We're going to make a 2D clock, so create a 2D scene.


Waiting for a root node.
This does a few things. First, the root node options are replaced by a node list, containing a single Node2D item. Second, the viewport switched from 3D to 2D. This is obviously visible in the viewport itself, and also by the selection change at the top of the editor. Third, the scene's tab has been renamed to [unsaved], with (*) appended to it to indicate that it has changes that haven't been saved yet.


Unsaved scene with Node2D root node.
Node2D is the root node of our scene. The default name of a node is its type name. Because it will represent a clock let's give it an appropriate name. Renaming a node is done by pressing the RETURN key while it is focused, or by double-clicking it, or by picking Rename from its context menu. Change its name to Clock.

We could name nodes however we want, but Godot's convention is to capitalize them and not use spaces. This is known as PascalCase.

How do you open a context menu?
Saving the Scene
To persist our work we have to save the scene. This can be done via the Scene › Save Scene main menu item or its indicated keyboard shortcut. This pops up a Save Scene As... window with clock.tscn already filled in. The convention is to not capitalize scene file names and not use spaces, so save it as it is.

What does TSCN mean?

Saved clock scene.
The scene file got saved in the project root folder, which is internally indicated with res://. So the scene's file path inside the project is res://clock.tscn. The project files can be browsed via the FileSystem tab, which sits in a panel at the bottom left of the editor.


Project file system.
Besides our scene the project also contains the default Godot icon as an SVG image. The file system folder contains some more stuff, but that's internally used by Godot and not shown here.

Making the Clock Face
We're creating a standard round analog clock. The round background of the clock is known as its face. To build it we'll need to create a child node and some resources.

Child Node
A scene contains a hierarchy of nodes, forming a tree graph with its root node at the top. Nodes are the building blocks used to make things in scenes.

Our Clock node is the root of the scene, containing everything in it. It is a Node2D, which means that it represents a 2D thing. We'll use a separate node to represent its face.

Open the context menu of the Clock root node and pick the Add Child Node option, or use its indicated keyboard shortcut. This pops up a Create New Node window.

Search for sprite2d. That filters the node type hierarchy shown so we only see the portion that leads to Sprite2D.

What's a sprite?

Searching for the sprite2d node type.
This shows us that there is a generic root Node type, under which we find the CanvasItem type, under which there is the Node2D type. That's the type of our scene's root node. Node2D has multiple subtypes under it, including AnimatedSprite2D and Sprite2D. Select the latter and click Create or press the RETURN key to create the node.

We now have a second node in our scene, listed as a child of the root node. It's name is its type, but let's rename it to Face.


Face child node of Clock.
The dock to the right of the viewport contains three tabs, one of which is Inspector. It shows the configuration options for the currently selected node, which should be Face. As our node is a Sprite2D the properties of that type are shown at the top. Below that are shown the properties of its other types, going back through the type hierarchy from specific to generic. So first Sprite2D, then Node2D, then CanvasItem, and finally Node.


Face inspector.
The properties are collapsed by default, indicated by the arrow icon on the left of each option, pointing right. Clicking the option expands or collapses it. When expanded the arrow icon points down. Many hierarchies in the editor can be collapsed or expanded.

Note that there is an icon to the right of Face at the top of the inspector, looking like a magnifying glass with the word Doc below it. Clicking it will open the in-editor documentation for the node's type in the viewport. That switches the viewport to Script mode. You can change it back to 2D mode via the options shown at the top of the editor.

Texture Resource
Our sprite is current invisible because it doesn't have any image data. Our clock face is a Sprite2D and thus has a Texture property. The term texture can refer to many surface properties, but in this case it only refers to its visual appearance.

The sprite currently has no texture, showing <empty> for its value. The value is a dropdown menu, which can be expanded by clicking the downward-pointing arrow to the right of it. Doing so opens a list of options, from which we pick New GradientTexture2D.


Linear gradient texture resource.
This has created a 2D gradient texture resource, a GradientTexture2D, which is stored in the scene. Resources are bits of data that can be shared between nodes. In this case we got a linear horizontal gradient that goes from black on the left to white on the right. Our sprite has also become visible in the viewport, displaying the gradient in a rectangle. You can pan around and zoom the viewport by dragging and scrolling or pinching, in combination with holding various buttons, to get a better look at it. The editor behavior can be adjusted via Editor › Editor Settings.. › Editors › Panning and the Shortcuts tab.

The default gradient doesn't look like a clock at all. To configure it, click the gradient itself. This expands its options. Alternatively, select the texture resource from the dropdown list at the top of the inspector, replacing Face.


Expanded gradient resource.
Let's first make the sprite bigger, by increasing both Width and Height to 256. This gives us a 256×256 texture, containing 65.536 color data points known as pixels. Our sprite will resize to match.

Why 256?
Our clock is supposed to be round. Under Fill, change Fill to Radial. Its From property is a 2D position with X and Y coordinates. X is the horizontal and Y is the vertical coordinate, going from 0 to 1. Set both to 0.5 so the gradient starts at the center of the texture. Then give To coordinates 1 and 0.5.


Radial gradient.
At this point we have a radial gradient, but it doesn't look like a clock face yet. We'll turn it into a simple solid white clock face by making part of the texture transparent.

Gradient Resource
Our texture's Gradient is a resource as well, of type Gradient. Expand it, or select the Gradient resource from the inspector's dropdown menu.


Gradient with Interpolation expanded.
We have a default linear gradient in sRGB color space, which is fine. We only have to change its two color keys, which are displayed as vertical bars on top of the gradient. Selecting one shows its solid color to the right of the gradient. Double-clicking it pops up a color picker for it. Do this for the black key and change it to white.


Color picker.
Regardless of the color picker's display mode, colors are defined by a combination of red, green, and blue components. Each has a value in the 0–255 range, which in hexadecimal notation is 0–ff. You can set it to white by typing ffffff in its Hex field.

What does the # button do?
Both color keys are now white. But colors also have an fourth component, known as alpha, which is used to control transparency. Select the key on the right of the gradient and set its A component to zero. Alternatively, type ffffff00 in its Hex field.

This gives us a solid white texture that linearly fades out. To turn it into a solid disk drag the left key to the right until both keys almost entirely overlap. This can be done more precisely by expanding Raw Data, then expanding Offset by clicking its PackedFloat32Array and setting its first element to 0.98.


Solid disk gradient.
Our sprite now looks like a solid white disk, which is a fine face for a simple clock. It has a slightly fuzzy edge where it transitions from opaque to transparent across a few pixels.


Clock face.
Could we get rid of the fuzzy edge?
Adding Hour Indicators
A solid white face could suffice for a minimal clock, but usually the face contains indicators to make reading the time easier, one per hour. These could explicitly display the hour numbers, but we'll use simple wedges.

Polygons
Rather that using a sprite again, we use a different approach to create an hour indicator. Add a child node to Face, selecting the Polygon2D node type. Rename it to Hour0. We don't put a space between Hour and 0 to stick to Godot's PascalCase naming convention for nodes.


Hour0 child node of Face.
As a Polygon2D our node has a Color property. Set it to black, hex 000000.


Polygon inspector.
The polygon is initially empty and invisible. It is formed by placing a sequence of points in the viewport. Tools for that show up in the viewport toolbar when a Polygon2D is selected.

default toolbar toolbar with polygon selected
Toolbar without and with polygon node selected.
We're going to create a small downward-pointing triangle at the top of the clock face. To do so, first make sure that Select Mode is active, which can be done via the leftmost toolbar button that looks like a pointer. Also enable Use Grid Snap, via the button that looks like grid with a small horseshoe magnet. This turns on a grid that makes our points snap to increments of 8 pixels by default. The grid can be configured via the toolbar button with three vertical dots.

Place three points to form the triangle in a 16×16 area, 16 pixels below the top of the face sprite. After placing the points you can close the polygon by clicking on the first point or by pressing the RETURN key. If a point is in the wrong place you can move it to the correct position by dragging it.

Creating a triangle.
We now have our first hour indicator. Because it is a child of the face it is draw on top of the disk. Parent nodes are drawn first, then their child nodes, from top to bottom as they are ordered in the scene hierarchy.


Clock face with hour indicator.
Make sure that the polygon's position is at the center of its parent. You can verify this by checking the small cross icon in the viewport that shows its pivot point. It should be in the center of the disk. You can also verify that its Node2D › Transform › Position property is set to zero for both X and Y.

If the polygon is misplaced move it to where it should be and adjust its points by dragging them if needed. You can undo and redo actions via the Scene › Undo and Scene › Redo menu items or their keyboard shortcuts.

Many operations have keyboard shortcuts. I will no longer point out that they exist.

Twelve Hours
We create the other eleven hour indicators by duplicating and rotating the first one. Via its scene context menu, Duplicate Hour0. This creates a clone of the node and places it underneath the original. The duplicate has been automatically renamed to Hour1.


Duplicated hour indicator.
Currently the two indicators overlap. To move Hour1 to the next hour set its Node2D › Transform › Rotation property to 30. This makes the node rotate 30 degrees clockwise around its pivot point, 30° for short.

Why 30°?

Rotated 30°.
We can also rotate by switching the viewport to Rotate Mode, via the third toolbar button from the left that looks like an arrow curving around a point. Then dragging anywhere in the viewport will perform a rotation. By holding down CONTROL after starting rotating it snaps to 15° increments by default.

Rotation.
Keep duplicating and rotating the hour indicators until we have all twelve. Using keyboard shortcuts and snapping rotation mode is a convenient way to do this.


All twelve hour indicators.
Is this an efficient way to draw the indicators?
Clock Arms
In order to display the time our clock needs arms, one for the current hour, one for the current minute, and one for the current second.

Hour Arm
We'll also use Polygon2D nodes to create the arms. Either create a new one or duplicate Hour0 and change its name to HourArm. The arm isn't part of the face so make it a direct child of Clock if it isn't already. You can change its parent and position in the scene hierarchy by dragging it, or via its Reparent and Move Up and Move Down context menu items to have more precise control.


HourArm child node, Face hierarchy collapsed.
Make sure that the viewport is in Select Mode, then create a simple short thick arrow pointing at the Hour0 indicator, using five points. If you started with a duplicated hour indicator you can drag the nodes to reposition them and add new ones by clicking the polygon edges in between points.


Hour arm polygon.
Make the arrow overlap its pivot point so it appears to have a counterweight when rotating. This gives is a little visual balance. Make it one step wider than the hour indicators.

Minute and Second Arms
Duplicate HourArm and name it MinuteArm. Make it a longer and narrower arrow, with its tip touching Hour0. Also give it a different color. I used slightly darkened blue, hex 0000e5. You can temporarily hide the hour arm by clicking the eye-like icon next to it in the scene hierarchy. Then do the same for a SecondArm, giving it a sharper point that overlaps Hour0 and has a smaller counterweight. I colored it red, hex a50000.

hour arm minute arm second arm all arms
Hour, minute, and second arm, and all three together.
Of course you can design your clock arms in a different way, but this is the reference design for the tutorial.

Our clock hierarchy is now complete. It has a face with hour indicators and three arms to show the time.


All clock nodes.
Special Hour Indicator
We used Hour0 as a reference point for designing our arms, but now that we're done with that let's give it a slightly difference appearance. By making the zero or twelfth hour stand out it is easier to tell the time, especially when the clock itself is rotated. Make it one step larger, dragging its points left, right, or down. I also gave it the same color as SecondArm.


Special hour indicator.
Running the Scene
With our clock design complete let's see how it looks when running it as a stand-alone app.

Running the Current Scene
We can instantly run a debug version of it by clicking the Run Current Scene button in the toolbar at the top right of the editor, which looks like a movie clapperboard with a play icon.


Editor toolbar.
After a short delay this opens a separate app showing our scene. Its title bar contains our project name with (DEBUG) added to indicate that it is running in debug mode.


Clock stuck in top left corner.
Quit the app, either the normal way or by pressing the stop button in the editor toolbar.

Repositioning the Clock
Currently our clock is stuck in the top left corner of the window, so we only see its bottom right quadrant. The top left corner is the origin of the scene's viewport. The scene viewport rectangle is shown in the editor viewport as a dark purple rectangle. Its size is configured via Project › Project Settings... › Display › Window, where you can see and adjust Viewport Width and Viewport Height.

The default viewport size is 1152×648 pixels. Let's keep that size and put our clock in the center, by setting the Transform › Position of our Clock root node to X 576 and Y 324. As children are positioned relative to their parent all child nodes will move along with it.


Clock moved to middle of viewport.
I cannot see the viewport rectangle, where is it?
If we run our scene now the clock will show up in its center.


Running with centered clock.
Setting a Time
We will program our clock to display the time in the next tutorial, but we can already set it to a fixed time by rotating its arms. For example, I set it to indicate roughly 01:49:27.


Manually set time.
Anti-Aliasing
You may have noticed, while in the editor or while running the scene, that the hour indicators and arms have jagged edges. That's because the polygons have sharp edges. This is more obvious when zooming in.


Screenshot of clock in running app, zoomed in.
This visual appearance is caused by the limited pixel resolution of the display and is commonly known as aliasing. It can be especially obvious when things are in motion.

To combat these visual artifacts let's turn on MSAA, in the project settings window, under Rendering › Anti Aliasing. Set MSAA 2D to 4x (slow), which is the typical setting used for MSAA.

What is MSAA?

Anti-aliased clock with MSAA 4x.
Although the editor indicates that it is slow, MSAA 4x is often a fair trade-off between rendering speed and quality. It offers a significant visual improvement for our clock scene. You could also experiment with different anti-aliasing options.

The next tutorial is Programming a Clock.

License | Repository



this one is important, because with it could generate biomes! like we split a map with some shapes then we pick points to put certain assets like different trees or something

How To Pick A Random Point From Triangles, Hexagons and Squares
Resources
Tutorials
gdscript
Apr 23
Apr 23

bforbiggy
Apr 23
This tutorial will cover multiple shapes, each comprising of two parts: an explanation of how the triangle formula is used then an usable example script to place on a Node2D object.

The recommended reading order for learners is [Triangles] → [SHAPE_OF_CHOICE] → [Making Code Cleaner]

Triangles
The triangle formula simply requires the positions of the three corners.
Here, the points form an equilateral triangle with a side length of one

extends Node2D

func random_triangle_point(a, b, c):
	return a + sqrt(randf()) * (-a + b + randf() * (c - b))

func _ready():
	var a = Vector2(0,0)
	var b = Vector2(1,0) 
	var c = Vector2(0.5,sqrt(3.0)/2.0)

	var point = random_triangle_point(a,b,c)
	print(point)
In game
extends Node2D

func random_triangle_point(a, b, c):
	return a + sqrt(randf()) * (-a + b + randf() * (c - b))
	
func _draw():
	var a = Vector2(0,0)
	var b = Vector2(1,0) 
	var c = Vector2(0.5,sqrt(3.0)/2.0)
	var triangleSize = 100
	
	for i in range(10000):
		var pos = random_triangle_point(a,b,c) * triangleSize
		draw_circle(pos, 1, Color.AQUAMARINE)

image
image
1152×648 2.5 KB
Hexagons
Hexagons are just 6 equilateral triangles in disguise, each rotated 60 degrees
All we need to do is pick a random equilateral triangle point, and rotate it

extends Node2D

func random_triangle_point(a, b, c):
	return a + sqrt(randf()) * (-a + b + randf() * (c - b))

func _ready():
	var a = Vector2(0,0)
	var b = Vector2(1,0) 
	var c = Vector2(0.5,sqrt(3.0)/2.0)

	var point = random_triangle_point(a,b,c)
	print(point.rotated(randi_range(0, 5) * deg_to_rad(60)))
In game
Notice that this code is the same as the triangle’s code with the exception of an extra line that simply rotates the triangle 60 degrees a random amount of times.

extends Node2D

func random_triangle_point(a, b, c):
	return a + sqrt(randf()) * (-a + b + randf() * (c - b))
	
func _draw():
	var a = Vector2(0,0)
	var b = Vector2(1,0) 
	var c = Vector2(0.5,sqrt(3.0)/2.0)
	var triangleSize = 100
	
	for i in range(10000):
		var pos = random_triangle_point(a,b,c) * triangleSize
		pos = pos.rotated(randi_range(0, 5) * deg_to_rad(60))
		draw_circle(pos, 1, Color.AQUAMARINE)
image
image
1152×648 6.73 KB
Square
Squares are a little more difficult because they are made of two right isosceles triangles that are rotated 180 degrees from each other (aka mirror opposites) but they don’t rotate in place so it ends up looking like this:
image

These two triangles do make up a square, but one of the triangles is in the wrong spot. If we’re on the rotated triangle, we should also move it by a set amount to the correct location. One side length to the right, One side length down.

extends Node2D

func random_triangle_point(a, b, c):
	return a + sqrt(randf()) * (-a + b + randf() * (c - b))
	
func _draw():
	var a = Vector2(0,0)
	var b = Vector2(1,0) 
	var c = Vector2(1,1)
	var triangleSize = 100
	
	var pos = random_triangle_point(a,b,c) * triangleSize
	var shouldRotate = randi_range(0, 1) == 0
	if shouldRotate:
		pos = pos.rotated(deg_to_rad(180))
		pos += Vector2(1, 1) * triangleSize
In game
extends Node2D

func random_triangle_point(a, b, c):
	return a + sqrt(randf()) * (-a + b + randf() * (c - b))
	
func _draw():
	var a = Vector2(0,0)
	var b = Vector2(1,0) 
	var c = Vector2(1,1)
	var triangleSize = 100
	
	for i in range(10000):
		var pos = random_triangle_point(a,b,c) * triangleSize
		
		var shouldRotate = randi_range(0, 1) == 0
		if shouldRotate:
			pos = pos.rotated(deg_to_rad(180))
			pos += Vector2(1, 1) * triangleSize
		draw_circle(pos, 1, Color.AQUAMARINE)
image
image
1152×648 4.17 KB
Making Code Cleaner
While I actively avoided making named functions so the logic can be followed sequentially, it is probably not a good idea to have unexplained a,b,c points as well as a seemingly random rotation.

For this reason, it is better to make a function that generates a random hexagon instead.

extends Node2D

func random_triangle_point(a, b, c):
	return a + sqrt(randf()) * (-a + b + randf() * (c - b))

func random_hexagon_point():
	var a = Vector2(0,0)
	var b = Vector2(1,0) 
	var c = Vector2(0.5,sqrt(3.0)/2.0)
	var randomRotation = randi_range(0,5) * deg_to_rad(60)
	return random_triangle_point(a,b,c).rotated(randomRotation)

func _ready():
	var point = random_hexagon_point(a,b,c)
	print(point)




VOL1 - CREATING A CHARACTER IN MAKEHUMAN
vol1_01
Creating a character in MakeHuman
Creating a character for the game with a change of clothes and several animations.

Introduction. MakeHuman Overview
What is MakeHuman?

MakeHuman is a completely free, innovative and professional software for the modelling of 3-Dimensional humanoid characters.

MakeHuman is an open source (AGPL3) tool designed to simplify the creation of virtual humans using a Graphical User Interface, also commonly referred to as a GUI.

Humans are created through the manipulation of controls that allow for the blending of different human attributes to create unique 3D human characters. The controls are intended to provide the user with a simple way to create characters that give expression to the widest possible range of human forms.

The MakeHuman project strives to provide a complete tool that allows for the management of all things needed to create realistic virtual humans.
Distinguished by a large number of settings and easily expandable features. There is a plugin for mass character creation “Mass produce”. Has a lot of ready-made clothing and accessories. You can create new ones yourself. Easy to integrate with Blender.

Has options not found in other similar programs:

Allows you to change the age of a character. It is enough to create a model and you can change the age with one parameter. Very convenient if you are making a game about growing up.
Allows you to assign different rigs to characters. Large selection of ready-made skeletons or you can make your own.
Sliders do not have the ability to enter a numerical value, which is sometimes not very convenient.

The program is mainly aimed at artists who create static images or videos. It is still little adapted for use in games, but has a lot of opportunities in this regard.

I will try to show how you can make a character with a change of clothes and assign him animation.

Programs used:
MakeHuman 1.2.0
Blender 2.93.9
Godot 3.4.4 (3.5 compatible)
Addons:
For Blender:

Retarget BVH
MHX2
For Godot:

Blender Importer Addon for Godot

The additional viewport in the screenshots is Camera Monitor

Program Installation
Download the program, install it.

User data is located in the folder:

Windows: C:\Users\[Name]\Documents\makehuman\v1py3\data
Linux: ~/Documents/makehuman/v1py3/data
This is where you install additional assets: clothes, hair, poses ect.

You can install them directly from the program, tab “Community”. Or manually from the site — User contributed assets.

They are very well represented in the gallery, but it’s a bit difficult to get there.

The following assets were used in the tutorial:

By punkduck:

sport briefs 01
sport bra 01
sun visor
Short jeans female
Sleeveless Shirt
Tennis shoes
Martial-Arts Shoes, Kill Bill
By Elvaerwyn:

Ladies Sunglass1 by Elv
By RehmanPolanski:

Scalp Viking
By callharvey3d:

Fangs
By sonntag78:

Orkifyhead
Orkifyheadtarget custom skin
By Hatshj:

Alien Eyes
By blindsaypatten:

Fully close mouth
By Joel Palmius:

Elf ears
Animations used from the cgspeed:

MotionBuilder-friendly version 2010 RE-RELEASE
BVH directories 01-09
02_01.bvh [walk]
02_03.bvh [run]
Modeling
Run the program and customize the character. By default, it offers a middle-gendered and middle-aged character.

Since there are no numeric values to enter, you have to move the sliders, like this:

vol1_02
General body settings, head, torso, arms, legs…

vol1_03
Apply the modifiers
Under “custom”:

Orkifyhead
Elf ears
Fully close mouth
vol1_04
Geometry
Choose clothing

The following sequence is not important, we need to equip our character with everything necessary for life and combat: hair, teeth, tongue, eyebrows, eyelashes… if it is supposed that the character will not open his mouth, you can skip the teeth and tongue setup.

Hair: Scalp Viking
Fangs: Fangs (from the Clothes[Accessory] tab)
vol1_05
Making the body parts modifiable is possible, but difficult. At the end I’ll tell you how.

Materials
Assigning textures.

Body: Orkifyheadtarget custom skin
Eyes: Alien Eyes
vol1_06
Dress up your character
If a change of clothes is expected, then we put all the necessary clothes on the character. In this case there are 2 sets: casual and sports.

Casual:

Short jeans
Sleeveless Shirt
Martial-Arts Shoes
Ladies Sunglass
vol1_07
Sporty:

port briefs 01
sport bra 01
sun visor (sports visor)
tennis shoes
vol1_08
The option “Hide face under clothing”
If you don’t intend to change clothes, it’s better to leave this option. If this option is disabled, then it will be visible when the body goes beyond the clothes. When exporting, this function will be enabled in any case.

vol1_09
Pose/Animate
Assign a rig.

The rig should match the animation. For this example I use the CMU Motion Capture animation and assign the corresponding rig CMU mb.

vol1_10
The character is ready for export.

Export to Blender
You can put the character from MH into Blender in several ways.

The most reliable one is exporting to .mhx2 (MHX2 - MakeHuman eXchange format 2). This is the only way to correctly transfer the textures to the game engine.
If you use export to Blender via Socket (tab in MH “Community”), you will have to assign textures in the engine manually
It is desirable not to forget to switch “Scale units” to a meter.

vol1_11


its here https://static.makehumancommunity.org/relatedsystems/godot/tomcat/tomcat1.html


VOL2 - IMPORTING IN BLENDER AND GODOT
Importing into Blender and assigning animations. Importing into Godot
Need two addons for Blender:

Retarget BVH
MHX2
Import
The import panel can be called in 2 ways:

File –> Import –> MakeHuman (.mhx2)
N-панель –> Import MHX2
result is identical:

vol2_01
If you need facial animation, you can:
to enable the “Face Shapes” option for emotions via shape keys;
if you choose a rig with face bones, then the emotions can be realised by poses.
In Rigging turn on Add Rig and choose Rig Type [Exported].

The rig assigned to the MH will be imported.

[Import MHX2]

vol2_02
Remove all the masks:

vol2_03
If the clothes will be the only one, it’s better to leave masks.

Assignment of animation
*A little note. For the game, the animation must be played without moving the character. Moving the character is done in the game engine by moving the object itself. As the animation in the example contains movement, you need to get rid of it (or take the animation already prepared). You can choose any convenient way for the character to stay in place. In my opinion, the easiest is to tie the Hips(root) bone to the position at rest. The way is not the best, but simple and fast. To do this, I make a copy of the skeleton at rest position. This is only necessary for binding.

To assign the animation use Retarget BVH plugin finalized by punkduck [MakeHuman Team] (for which he is very thankful).

vol2_04
[Load And Retarget] allows you to load animation and immediately apply to the character.

Select animation (02_01.bvh) and load it.

vol2_05
vol2_06
*Now bind the Hips animation bone to the rest pose bone for the character to walk in place.

vol2_06
Add the running animation (02_03.bvh).

vol2_07
Now the file is ready to be exported to Godot.

vol2_08
The documentation for the engine recommends that you triangulate the models.

But Blender does not allow you to triangulate an object that contains shape keys:

Modifier cannot be applied to a mesh with shape keys

Godot. Import
The Blender Importer Addon for Godot allows you to open Blender files as Godot scenes.

This feature is built into Godot 4, but it doesn’t work correctly there.

Just save the .blend file in your project folder and it will be automatically imported into the engine.

In an open scene, you can remove the resting pose skeleton you don’t need anymore and separate clothes by scene for easy switching:

vol2_09
Video

Face morphs will be transferred, but you must remember to set the same Shapes settings for different body parts.

vol2_09
The main part of the tutorial is finished.

Translated with http://www.DeepL.com/Translator (free version)


VOL3 - CHANGING HAIR AND SHAPE KEYS
Change of hair and Body Shapes
Change of hair (eyebrows, eyelashes, teeth).
Body Shapes (Shape Keys).
It is assumed that there are already:

the original MakeHuman model, which needs to be modified;
a Blender file derived from this model.
Part 1. Change of hair (eyebrows, eyelashes, teeth)
Changing body parts is somewhat different from choosing clothes. Since you can’t have a character with several hairstyles (unlike clothes), you have to work with each hairstyle individually.

Load the model for which you want to change the hairstyle. Choose the hairstyle you want:

vol3_01
bob02 (In the standard installation)
author
Joel Palmius
Jonas Hauquier

If you want, you can add eyebrows, eyelashes, teeth to transfer. It is better to remove unnecessary things.

The model is exported in .mhx2 format (“Scale units” in meters).

Blender
Opens the previously saved file with the original model.

The file with the new hairstyle is imported into it.

vol3_02
The hairstyle is transferred to the collection to the original model and linked (with a Shift).

The armature from the original model is assigned.

The entire new collection should be deleted.

The file is saved to the Godot project folder.

vol3_03
Godot
The Blender file imported into Godot can be saved as a new scene. If the previous file was already saved as a scene, the hair can be transferred to it as a node.

vol3_04
Body Shapes (Shape Keys)
Assignment of shape keys

MakeHuman
Load the model into which you want to add the shape key. The model should have clothes, to which a key will be applied to the form. Apply the modifier:

vol3_05
The operation must be repeated for each key.

The model is exported in .mhx2 format (units in meters).

Blender
Opens the previously saved file with the original model.

Triangulation

The engine documentation recommends triangulating the models.

But Blender does not allow you to triangulate an object that contains shape keys. [code]Modifier cannot be applied to a mesh with shape keys[/code] If the model does not contain shape keys, then that model can be triangulated before they are assigned.

Choice of modifiers for shape keys

You may only assign modifiers that do not change the size of the model skeleton! If the modifier changes the dimensionality of the skeleton (e.g. arm/leg length, shoulder width etc.), the result of the animation will be unpredictable.

The modified model is imported into the file with the original model.

The part (body) of the modified model is selected first.

Then the same part of the original model is selected (with CTRL).

Assign a shape key (Object Data Properties –> Shape Keys –> Join as shapes)

vol3_06
The procedure is repeated with the clothing elements.

The entire new collection should be deleted.

The file is saved in the Godot project folder.

Godot
The Blender file imported into Godot is saved as a new scene.

There is a bug: if “Bland Shape” is set to 1, artifacts appear:

vol3_07
It is desirable to set the value to less than 1.0:

vol3_08

Translated with http://www.DeepL.com/Translator (free version)VOL3 - CHANGING HAIR AND SHAPE KEYS
Change of hair and Body Shapes
Change of hair (eyebrows, eyelashes, teeth).
Body Shapes (Shape Keys).
It is assumed that there are already:

the original MakeHuman model, which needs to be modified;
a Blender file derived from this model.
Part 1. Change of hair (eyebrows, eyelashes, teeth)
Changing body parts is somewhat different from choosing clothes. Since you can’t have a character with several hairstyles (unlike clothes), you have to work with each hairstyle individually.

Load the model for which you want to change the hairstyle. Choose the hairstyle you want:

vol3_01
bob02 (In the standard installation)
author
Joel Palmius
Jonas Hauquier

If you want, you can add eyebrows, eyelashes, teeth to transfer. It is better to remove unnecessary things.

The model is exported in .mhx2 format (“Scale units” in meters).

Blender
Opens the previously saved file with the original model.

The file with the new hairstyle is imported into it.

vol3_02
The hairstyle is transferred to the collection to the original model and linked (with a Shift).

The armature from the original model is assigned.

The entire new collection should be deleted.

The file is saved to the Godot project folder.

vol3_03
Godot
The Blender file imported into Godot can be saved as a new scene. If the previous file was already saved as a scene, the hair can be transferred to it as a node.

vol3_04
Body Shapes (Shape Keys)
Assignment of shape keys

MakeHuman
Load the model into which you want to add the shape key. The model should have clothes, to which a key will be applied to the form. Apply the modifier:

vol3_05
The operation must be repeated for each key.

The model is exported in .mhx2 format (units in meters).

Blender
Opens the previously saved file with the original model.

Triangulation

The engine documentation recommends triangulating the models.

But Blender does not allow you to triangulate an object that contains shape keys. [code]Modifier cannot be applied to a mesh with shape keys[/code] If the model does not contain shape keys, then that model can be triangulated before they are assigned.

Choice of modifiers for shape keys

You may only assign modifiers that do not change the size of the model skeleton! If the modifier changes the dimensionality of the skeleton (e.g. arm/leg length, shoulder width etc.), the result of the animation will be unpredictable.

The modified model is imported into the file with the original model.

The part (body) of the modified model is selected first.

Then the same part of the original model is selected (with CTRL).

Assign a shape key (Object Data Properties –> Shape Keys –> Join as shapes)

vol3_06
The procedure is repeated with the clothing elements.

The entire new collection should be deleted.

The file is saved in the Godot project folder.

Godot
The Blender file imported into Godot is saved as a new scene.

There is a bug: if “Bland Shape” is set to 1, artifacts appear:

vol3_07
It is desirable to set the value to less than 1.0:

vol3_08

Translated with http://www.DeepL.com/Translator (free version)

VOL4 - ANIMATION
Adding animation
It is assumed that there are already:

Blender file with animation;
a scene in Godot derived from this file.
Blender
Opens a previously saved file with the original model and animations.

A new animation is imported.
The file is saved in the Godot project folder.
Note. In this example, the jump animation is applied in place. In general, it is desirable to move the model in the game engine, as a node, then it will be possible to change the height of the jump. But in this case, I will show a fixed jump. To do this, leave the constraint of the bone fixed on the X-axis only. This change will affect the existing animations, but they are already in the scene file in Godot.

vol4_01
Godot
From the new file imported into Godot, only a new animation is needed:

vol4_02
It can be copied or saved for future use:

vol4_03
Open AnimationPlayer in an existing scene and load the new animation file there by copying or exporting:

vol4_04
That’s it, the animation is added to the scene file.


A huge grateful thanks to those who have helped and supported me:

punkduck (MH team)
Raphael

Translated with http://www.DeepL.com/Translator (free version)





Godot 4 Game Development Cookbook
Copyright © 2023 Packt Publishing
All rights reserved. No part of this book may be reproduced, stored in a
retrieval system, or transmitted in any form or by any means, without the prior
written permission of the publisher, except in the case of brief quotations
embedded in critical articles or reviews.
Every effort has been made in the preparation of this book to ensure the
accuracy of the information presented. However, the information contained in
this book is sold without warranty, either express or implied. Neither the
author, nor Packt Publishing or its dealers and distributors, will be held liable
for any damages caused or alleged to have been caused directly or indirectly by
this book.
Packt Publishing has endeavored to provide trademark information about all of
the companies and products mentioned in this book by the appropriate use of
capitals. However, Packt Publishing cannot guarantee the accuracy of this
information.
Group Product Manager: Rohit Rajkumar
Publishing Product Manager: Nitin Nainani
Content Development Editor: Abhishek Jadhav
Technical Editor: Simran Ali
Copy Editor: Safis Editing
Project Coordinator: Aishwarya Mohan
Proofreader: Safis Editing
Indexer: Manju Arasan
Production Designer: Nilesh Mohite
Marketing Coordinator: Nivedita Pandey
First published: June 2023
Production reference: 1100523
Published by Packt Publishing Ltd.
Livery Place
35 Livery Street
Birmingham
B3 2PB, UK.
ISBN 978-1-83882-607-9
www.packtpub.com
To Juan Linietsky and Ariel Manzur for creating Godot.
Contributors
About the author
Jeff Johnson is a game developer who started using Unity 4.0 in 2014 and
released a couple of games on itch.io. In 2018, he created 999 Dev Studio.
Toward the end of developing Escape from 51, he changed engines to Godot
3.0.2. He ported over almost the whole game to Godot from Unity. He released
Escape from 51 on itch.io, as well as some mobile games on Google Play, all
made with Godot.
About the reviewers
Yogendra Manawat is a bachelor’s student in computer science. He is an indie
game developer and a product designer. Though he primarily learned
development skills, he has acquired knowledge in programming languages such
as C++, Python, C#, and GDScript.
Yogendra’s interest in games and movies led him to start making 3D animation
with Blender, and he continues to work on game development projects while
also contributing to the Godot Engine community.
With over three years of experience in game development, Yogendra has
developed multiple small games and is currently focused on creating his
original RPG game, TALKAD, using the Godot Engine. He continuously learns
about new technologies and experiments with different game development
techniques to create unique and engaging games. Yogendra is also an active
participant in game development forums and communities, where he exchanges
ideas and collaborates with other game developers.
Simon Dalvai is a free and open source game developer from Italy. You can
find the source code for his games, such as Ball2Box and Pocket Broomball, on
GitHub under the username dulvui. As a solo developer, Simon enjoys
automating repetitive tasks, including taking screenshots and exporting and
uploading games to publishing platforms with scripts and CI/CD tools such as
GitHub Actions.
He learned to program in school and is currently working full-time as a
software architect. Simon taught himself game development and has created
games in his free time since 2018. He follows a strict policy of not including ads
or user tracking in his games.
Initially, he used libGDX to develop his first games but switched to the Godot
Engine in 2019.
Daniel Fulton has been a professional programmer since 2011. He has worked
on a wide variety of iOS apps and games.
He has given tech talks on augmented reality, 3D game programming in
SceneKit, software architecture, image performance, test-driven development,
and readable code.
His hobbies include building games in Godot, Unity, and Unreal Engine,
tinkering with electronics, rock climbing, and natural farming. In the past, he
received a bachelor’s degree in photography and worked as a freelance
photographer.
Table of Contents
Preface
1
Exploring the Godot 4 Editor
Technical requirements
Navigating in the new Godot 4 Editor
How to do it…
How it works…
Exploring the new features in the Project Settings
dialog
How to do it…
How it works…
What’s new in the Editor Settings dialog
How to do it…
How it works…
2
Transitioning to GDScript 2.0
Technical requirements
Investigating annotations in Godot 4
Getting ready
How to do it…
How it works…
Using properties with getters and setters
Getting ready
How to do it…
How it works…
Using the new await keyword and coroutines
Getting ready
How to do it…
How it works…
Using the super keyword to call a function
Getting ready
How to do it…
How it works…
Working with typed arrays
Getting ready
How to do it…
How it works…
Working with lambda functions
Getting ready
How to do it…
How it works…
Using callables with signals
Getting ready
How to do it…
How it works…
3
2D and 3D Rendering with Vulkan
Technical requirements
Showing off SDFGI
Getting ready
How to do it…
How it works…
Using Volumetric Fog to enhance your games
Getting ready
How to do it…
How it works…
Understanding the FogVolume node
Getting ready
How to do it…
How it works…
Working with particle nodes in Godot 4
Getting ready
How to do it…
How it works…
Using decals in your game
Getting ready
How to do it…
How it works…
4
Practicing Physics and Handling Navigation in
Godot 4
Technical requirements
Using Heightmap for 3D terrain
Getting ready
How to do it…
How it works…
Setting up and moving the CharacterBody in 2D
Getting ready
How to do it…
How it works…
Setting up and moving the CharacterBody in 3D
Getting ready
How to do it…
How it works…
Using the new NavigationServer for 3D
Getting ready
How to do it…
How it works…
Using NavigationServer2D for 2D projects
Getting ready
How to do it…
How it works…
Using SoftBody for 3D games
Getting ready
How to do it…
How it works…
5
Playing with Shaders in Godot 4
Technical requirements
Creating shaders with the Shader Creation dialog
Getting ready
How to do it…
How it works…
Exploring Uniform Arrays in the Godot 4 shader
language
Getting ready
How to do it…
How it works…
How to use Global Uniforms
Getting ready
How to do it…
How it works…
Using Instance Uniforms with shaders
Getting ready
How to do it…
How it works…
Exploring the Visual Shaders Context menu
Getting ready
How to do it…
How it works…
Working with Integer and Comment nodes
Getting ready
How to do it…
How it works…
Creating nodes using Texture3D and CurveTexture
Getting ready
How to do it…
How it works…
Using the Billboard node
Getting ready
How to do it…
How it works…
Using the UVFunc node
Getting ready
How to do it…
How it works…
Improving the Sky Shader mode
Getting ready
How to do it…
How it works…
What the Fog Shader mode can do
Getting ready
How to do it…
How it works…
6
Importing 3D Assets in Godot 4
Technical requirements
Importing Blender blend files into Godot 4
Getting ready
How to do it…
How it works…
Importing FBX files into Godot 4
Getting ready
How to do it…
How it works…
Importing glTF files into Godot 4
Getting ready
How to do it…
How it works…
Using the Import dialog
Getting ready
How to do it…
How it works…
7
Adding Sound and Music to Your Game
Technical requirements
Working with AudioStreamPlayer
Getting ready
How to do it…
How it works…
Exploring directional sound in 2D
Getting ready
How to do it…
How it works…
Using directional sound in 3D
Getting ready
How to do it…
How it works…
8
Making 2D Games Easier with TileSet and TileMap
Technical requirements
Using the new TileSet editor
Getting ready
How to do it…
How it works…
Examining TileMap layers
Getting ready
How to do it…
How it works…
Playing with the new TileMap tools
Getting ready
How to do it…
How it works…
Playing with Tile Atlas editing
Getting ready
How to do it…
How it works…
Exploring the TileSet physics
Getting ready
How to do it…
How it works…
Exploring the TileSet navigation
Getting ready
How to do it…
How it works…
Creating Custom Data Layers with the TileSet
Getting ready
How to do it…
How it works…
Painting terrains in TileMap
Getting ready
How to do it…
How it works…
Transitioning TileSet terrains
Getting ready
How to do it…
How it works…
Organizing isometric tiles into fixed-sized grids using
the TileSet resource
Getting ready
How to do it…
How it works…
9
Achieving Better Animations Using the New
Animation Editor
Technical requirements
Exploring changes with transform tracks
Getting ready
How to do it…
How it works…
Investigating the new Bezier curve workflow
Getting ready
How to do it…
How it works…
Playing with 3D rotation animations
Getting ready
How to do it…
How it works…
Working with bone poses
Getting ready
How to do it…
How it works…
Triggering a transition
Getting ready
How to do it…
How it works…
Playing with the new Movie Maker mode
Getting ready
How to do it…
How it works…
10
Exploring New Multiplayer Features in Godot 4
Technical requirements
Using the new MultiplayerSpawner node
Getting ready
How to do it…
How it works…
Using the new MultiplayerSynchronizer node
Getting ready
How to do it…
How it works…
How to use the Headless mode
Getting ready
How to do it…
How it works…
How to use UPnP with P2P networking
Getting ready
How to do it…
How it works…
Index
Other Books You May Enjoy
Preface
Want to transition from Godot 3 to 4? Look no further than the Godot 4 Game
Development Cookbook. This comprehensive guide covers everything you need
to become proficient with the latest GUI, GDscript 2.0, Vulkan 2D/3D
rendering, shaders, audio, physics, TileSet/TileMap, importing, sound/music,
animation, and multiplayer workflows. With its detailed recipes, the book
leaves no stone unturned.
The Godot 4 Cookbook begins by exploring the updated graphical user
interface and helps you familiarize yourself with the new features of GDscript
2.0. Next, it delves into the efficient rendering of 2D and 3D graphics using the
Vulkan renderer. As it guides you in navigating the new Godot 4 platform, the
book offers an in-depth understanding of shaders, including the latest
enhancements to the shader language. Moreover, it covers a range of other
topics, including importing from Blender, working with audio, and demystifying
the new Vulkan Renderer and the physics additions for 2D and 3D. The book
also shows you how the new changes to TileSet and TileMap make 2D game
development easy. Advanced topics such as importing in Godot 4, adding sound
and music to games, making changes in the Animation editor, and including
workflows for multiplayer in Godot 4 are covered in detail.
By the end of this game development book, you’ll have gained a better
understanding of Godot 4 and will be equipped with various powerful
techniques to enhance your Godot game development efficiency.
Who this book is for
The Godot 4 Game Development Cookbook is for seasoned game developers
who want to acquire skills in creating games using a contemporary game
engine. It is an invaluable resource for indie game developers and Godot
developers who are familiar with Godot 3 and have some level of expertise in
maneuvering the interface.
What this book covers
Chapter 1, Exploring the Godot 4 Editor, covers the changes to the Godot
Editor from Godot 3.x to Godot 4.0, and the new features in the Project settings
and Editor settings.
Chapter 2, Transitioning to GDScript 2.0, teaches you about annotations,
properties, the await keyword and coroutines, the super keyword, typed arrays,
lambda functions, and using callables with signals.
Chapter 3, 2D and 3D Rendering with Vulkan, helps you understand SDF Global
Illumination, volumetric fog, the FogVolume node, and particle nodes, using
decals.
Chapter 4, Practicing Physics and Handling Navigation in Godot 4, teaches you
how to use the Heightmap for 3D terrain, set up and move a
CharacterBody2D/3D body, use NavigationServer3D/2D, and use SoftBody for
3D games.
Chapter 5, Playing with Shaders in Godot 4, helps you to create shaders with
the Shader Creation dialog, and covers uniform arrays in the shader language,
global and instance uniforms, the Visual Shader context menu, Integer and
Comment nodes, creating nodes using Texture3D and CurveTexture, and using
the Billboard and UVFunc nodes, Sky Shader, and Fog Shader mode.
Chapter 6, Importing 3D Assets in Godot 4, teaches you how to import Blender
blend files, FBX files, and glTF files, and use the Import dialog.
Chapter 7, Adding Sound and Music to Your Game, helps you to understand
how to use the polyphonic support in the AudioStreamPlayer and directional
sound with 2D and 3D.
Chapter 8, Making 2D Games Easier with TileSet and TileMap, helps you
understand the new TileSet editor, TileMap layers, TileMap tools, Tile Atlas
Editing, TileSet physics, and navigation, creating custom data layers with
TileSet, painting and transitioning terrain in TileMap, and organizing isometric
tiles with TileSet.
Chapter 9, Achieving Better Animations Using the New Animation Editor,
teaches you about the changes with transform tracks, the new Bezier Curve
workflow, 3D rotation animations, bone posses, triggering a transition, and the
new Movie Maker mode.
Chapter 10, Exploring New Multiplayer Features in Godot 4, helps you
understand the new multiplayer spawner, multiplayer synchronizer, and how to
use Headless mode and port forwarding on a peer-to-peer network using the
UPNP class.
To get the most out of this book
You will need the latest version of Godot 4. All code examples have been tested
using Godot 4.0.2 on the Windows OS. However, they should work with future
version releases.
Software/hardware covered in
the book
Operating system requirements
Godot 4.0.2 Windows, macOS, Linux, Android, or
Web Editor
If you are using the digital version of this book, we advise you to type
the code yourself or access the code from the book’s GitHub repository
(a link is available in the next section). Doing so will help you avoid any
potential errors related to the copying and pasting of code.
Download the example code files
You can download the example code files for this book from GitHub at
https://github.com/PacktPublishing/Godot-4-Game-Development-Cookbook. If
there’s an update to the code, it will be updated in the GitHub repository.
We also have other code bundles from our rich catalog of books and videos
available at https://github.com/PacktPublishing/. Check them out!
Download the color images
We also provide a PDF file that has color images of the screenshots and
diagrams used in this book. You can download it here: https://packt.link/5fnG6.
Conventions used
There are a number of text conventions used throughout this book.
Code in text: Indicates code words in text, database table names, folder names,
filenames, file extensions, pathnames, dummy URLs, user input, and Twitter
handles. Here is an example: “The super keyword refers to the parent class
object and makes it easier to call the parent class methods.”
A block of code is set as follows:
5     var value: int = 10: set = set_value, get = get_value
6
7    func set_value(new_value: int) -> void:
8         value = new_value
9         print('setter', str(value))  
Bold: Indicates a new term, an important word, or words that you see
onscreen. For instance, words in menus or dialog boxes appear in bold. Here is
an example: “Click the Add Environment to Scene tab at the bottom right of
the dropdown.”
TIPS OR IMPORTANT NOTES
Appear like this.
Get in touch
Feedback from our readers is always welcome.
General feedback: If you have questions about any aspect of this book, email
us at customercare@packtpub.com and mention the book title in the subject of
your message.
Errata: Although we have taken every care to ensure the accuracy of our
content, mistakes do happen. If you have found a mistake in this book, we
would be grateful if you would report this to us. Please visit
www.packtpub.com/support/errata and fill in the form.
Piracy: If you come across any illegal copies of our works in any form on the
internet, we would be grateful if you would provide us with the location address
or website name. Please contact us at copyright@packt.com with a link to the
material.
If you are interested in becoming an author: If there is a topic that you
have expertise in and you are interested in either writing or contributing to a
book, please visit authors.packtpub.com.
Share Your Thoughts
Once you’ve read Godot 4 Game Development Cookbook, we’d love to hear your
thoughts! Please select https://www.amazon.in/review/create-review/error?
asin=1838826076 for this book and share your feedback.
Your review is important to us and the tech community and will help us make
sure we’re delivering excellent quality content.
Download a free PDF copy of this book
Thanks for purchasing this book!
Do you like to read on the go but are unable to carry your print books
everywhere?
Is your eBook purchase not compatible with the device of your choice?
Don’t worry, now with every Packt book you get a DRM-free PDF version of
that book at no cost.
Read anywhere, any place, on any device. Search, copy, and paste code from
your favorite technical books directly into your application.
The perks don’t stop there, you can get exclusive access to discounts,
newsletters, and great free content in your inbox daily
Follow these simple steps to get the benefits:
1. Scan the QR code or visit the link below
https://packt.link/free-ebook/9781838826079
2. Submit your proof of purchase
3. That’s it! We’ll send your free PDF and other benefits to your email directly
1
Exploring the Godot 4 Editor
Godot is a free open source game engine that was created by Juan Linietsky
and Ariel Manzur in 2007. It was released under the MIT License in 2014. You
can download Godot from https://godotengine.org/. The following is from the
Press Kit on the website:
The name Godot Engine should always be written in Title Case. Also, Godot
should be written with only one capital letter – it’s not “GoDot”. Godot is
named after the play Waiting for Godot, and is usually pronounced like in
the play... For native English speakers, we recommend “GOD-oh”; the “t” is
silent like in the French original.
Godot uses a tree of nodes inside a scene. A scene can be instanced in many
different scenes. Godot’s integrated language, GDScript, is a Python-like
language that is very easy to learn.
Godot is written in C++, which you can use to edit the Godot Engine or
contribute to the engine itself. Godot also officially supports C#; to use C# with
Godot 4, you need to download Godot Engine - .NET. There are communitysupported languages, such as Rust, Nim, Haskell, Clojure, Swift, and D, that
you can use: https://godotengine.org/.
Godot 4 is the newest version of the Godot Engine. It uses the Vulkan renderer,
which is more powerful for 3D and 2D games than OpenGL, which was used in
Godot 3.x. In this book, we will learn what was changed or added to Godot 4
and how to use these features to create games whether to sell or just for fun.
In this chapter, we’ll look at the changes between Godot 4 and Godot 3.x in the
Inspector tab under Node | Process | Mode. We will also look at the new
preview Sun and Environment dialog. In the Project Settings dialog in
Godot 4, we’ll look at the Advanced Settings button, and in the Input Map
tab, we’ll look at the Show Built-in Actions button as well as the Shader
Globals tab. In the Editor Settings dialog, we’ll look at the differences
between the Interface | Editor tab and the Interface | Text Editor tab.
This chapter is a little different in that we are looking at the differences
between Godot 3.x and Godot 4, so there is not much to do except to show the
differences. The reason we’ve included this chapter is that some things have
changed, and you might find it difficult to find what you are looking for; for
example, now you need to click a button to show you the Input Map options.
In this chapter, we will cover the following recipes:
Navigating in the new Godot 4 Editor
Exploring new features in the Project Settings dialog
What’s new in the Editor Settings dialog
Technical requirements
For this chapter, you need the standard version of Godot 4.0 or later running
on one of the following:
Windows 64-bit or 32-bit
macOS
Linux 64-bit or 32-bit
Android
Web Editor
Navigating in the new Godot 4 Editor
For this recipe, open up Godot 4 and follow along. To have a look at the
process_mode property, select the new preview Sun and Environment
dialogs and then select Inspector | Node | process_mode. We’ll then look at
the three renderer options in Godot 4.
How to do it…
Let’s execute the following steps:
1. Open a new project in Godot 4.
2. In the Scene tab, click on 3D Scene.
3. Click the three vertical dots on the viewport toolbar to the left of Transform. You can see them
highlighted in a blue box in Figure 1.1.
4. Click the Add Environment to Scene tab on the bottom right of the dropdown.
You can preview the Sun or Environment nodes when you import models, or
you can add them to the scene.
Figure 1.1 – Edit Godot 4 Sun and Environment settings
5. Click on World Environment under Node3d in the Scene tab.
6. In Inspector, click on the Environment type and then click on Sky. The two resources are now
highlighted in different colors.
Figure 1.2 – Godot 4 Inspector highlights
The following screenshot shows what it looked like in Godot 3.x.
Figure 1.3 – Godot 3.x Inspector highlights
7. Click on the Node3d node in the Scene tab and hit the Delete key, or right-click and select Delete.
8. In the Scene tab, click 2D Scene.
9. In Inspector, under Node, you will see Process. Open it by clicking on it and notice Mode with
Inherit to the right with a drop-down arrow.
Figure 1.4 – Godot 4 Inspector with Process opened, showing the default values
10. Click on the down arrow on the far right or on Inherit to open the options.
Figure 1.5 – Godot 4 Inspector with Process and Mode opened
NOTE
Pause Mode | Process in Godot 3.x is now Process | Mode, and you can now disable a node. If you do,
the node will be grayed out on the SceneTree.
The Godot 3.x Pause Mode option can be seen in the following figure.
Figure 1.6 – Godot 3.x Pause Mode
In the top right-hand corner of the Godot Editor is a green Forward+ button. If
we click on this, we will see Forward+, Mobile, and Compatibility.
Figure 1.7 – Change the renderer
How it works…
We opened the new Sun and Environment dialogs, which can be used to
preview imported assets or when editing 3D scenes to see how they look when
lighting is added. You can also add the Sun and/or the environment to the game
easily from the Sun and Environment dialogs.
We looked at how resources and sub-resources are highlighted in Inspector
and how they stand out because of the different colors, which makes it easier to
see a sub-resource over a resource. In Godot 3.x, it was all one color, so
sometimes, you didn’t know where a sub-resource stopped and another began.
Then, we saw how the process and pause settings are now in a single menu and
you can disable a node as well. Once disabled, the node is grayed out on the
SceneTree. The node and any children of the node will not be processed at all.
We clicked on Forward+ in the top right-hand corner of the Editor and a dropdown list with Forward+, Mobile, and Compatibility appeared. These are the
renderers that we can use in a project. Forward+ is a high-end renderer that
scales well with complex scenes for desktop devices. Mobile is for mobile
devices that do not scale as well to large scenes with many elements like
Forward+ does. Compatibility is for older devices that need to use a low-end
renderer.
Exploring the new features in the Project Settings
dialog
In this recipe, we will look at the Advanced Settings button in Project
Settings, which opens all of the options available for all of the project settings
listed. The Input Map Show Built-in Actions button opens all of the available
user input actions that can be set for your game. The Shader Globals tab in
Project Settings is for global uniforms.
How to do it…
To find the Project Settings Advanced Settings button, the Input Map
Show Built-in Actions button, and the Shader Globals tab, execute the
following steps:
1. Open a new or any existing project in Godot 4.
2. In the top-left menu, click Project, and then click Project Settings.
The default settings now only show the basic settings.
Figure 1.8 – Godot 4 Project Settings default settings
3. On the right of the Search box, click the Advanced Settings button.
Figure 1.9 – Godot 4 Project Settings Advanced Settings button clicked
Now all of the settings options are viewable like in Godot 3.x.
4. Click the Input Map tab to the right of the General tab. Notice that there is nothing shown.
Figure 1.10 – Godot 4 Input Map default settings
5. Click the Show Built-in Actions button to the right of the search field. Notice that it now has many
more options than Godot 3.x. Scroll down to see all of the options.
Figure 1.11 – Godot 4 Input Map Show Built-in Actions button clicked
6. Click the Shader Globals tab, which is the third tab to the right of Input Map. This is a new addition
in Godot 4 to use with global uniforms.
Figure 1.12 – Shader Globals tab in Project Settings
How it works…
We opened the Project Settings dialog and noticed that there was not much
showing like in Godot 3.x. We saw that a new Advanced Settings button was
added that showed everything.
Next, we opened the Input Map tab and found there was nothing showing by
default. We learned that a new Show Built-in Actions button was added and
when pressed, all of the user input options of Godot 3.x and more are shown.
We opened the new Shader Globals tab, which is used for global uniforms and
allows you to change many shader behaviors at the same time.
What’s new in the Editor Settings dialog
In this recipe, we will look at the differences in the Editors and Text Editors in
Editor Settings between Godot 3.x and Godot 4.
How to do it…
To find the Editors and Text Editors in Editor Settings, execute the following
steps:
1. Open a new or any existing project in Godot 4.
2. In the top-left menu, click Editor, and then click Editor Settings.
3. On the left, where you see Interface, scroll down to Text Editor.
4. Click Theme under Text Editor.
Figure 1.13 – Godot 4 Text Editor – Theme
The following screenshot shows what it looked like in Godot 3.x.
Figure 1.14 – Godot 3.x Text Editor – Highlighting
Notice that the Highlighting settings in Godot 3.x are now under Theme in
Godot 4.
5. Scroll down to the next section, called Editors, and click on Panning, which is new to Godot 4.
Figure 1.15 – Godot 4 Editor – Panning
The following screenshot shows what it looked like in Godot 3.x.
Figure 1.16 – Godot 3.x Editor – no panning
Notice the new Panning and Bone Mapper settings.
How it works…
In this recipe, we looked at Theme in the Text Editor settings in steps 2-4 and
noticed that there are fewer settings compared to Godot 3.x. The Highlighting
settings can now be found under Theme.
We looked at the new Panning settings, where we can change the 2D Editor's,
Sub Editors', and Animation Editors' Panning Schemes to make the mouse
scroll wheel pan or zoom in those editors. We saw that Bone Model was also
added to the Godot 4 Editor settings. Go through all of the Project Settings
and Editor Settings tabs to see what has changed.
2
Transitioning to GDScript 2.0
In Godot 4, the GDScript language backend was rewritten, allowing the
runtime to be faster and more stable than it was in Godot 3.x. Some additions
to the language were also implemented, which we will look at in this chapter:
annotations that replace some keywords, such as export; the set and get
properties, which replace setget; the await keyword, which replaces yield; and
the super keyword, which refers to the parent class object and makes it easier to
call the parent class methods.
Typed arrays now allow us to create arrays of a specific type such as all strings,
which helps to cut down on errors. We will look at two ways to write a lambda
function with a button signal along with other examples using lambda
functions. We will also look at two callable static methods and how to use
callables with signals.
In this chapter, we will cover the following recipes:
Investigating annotations in Godot 4
Using properties with getters and setters
Using the new await keyword and coroutines
Using the super keyword to call a function
Working with typed arrays
Working with lambda functions
Using callables with signals
Technical requirements
For this chapter, you need the standard version of Godot 4.0 or later running
on one of the following:
Windows 64-bit or 32-bit
macOS
Linux 64-bit or 32-bit
Android
Web Editor
You can find the code and the project files for the projects in this chapter on
GitHub: https://github.com/PacktPublishing/Godot-4-Game-DevelopmentCookbook/tree/main/Chapter%202.
Investigating annotations in Godot 4
In this recipe, we will first look at @export and some of the variations associated
with that annotation and then show how to use @onready.
Getting ready
For this recipe, open Godot 4 and start a new project called Chapter 2.
How to do it…
To investigate annotations, we will use each in a script by doing the following:
1. Open a new project in Godot.
2. In the Scene tab, click 2D Scene.
3. Click on the paper icon above Node2D and to the right of the filter Search box or in the Inspector
tab under Node | Script. Click <empty>, then select New Script, and name the script Annotations.
4. Click on Script at the top of the editor to look at the new script we added.
5. @export is the same as export in Godot 3.x, so we will add a score to the node so we can see it in the
Inspector tab:
1  extends Node2D                           
2     
3  @export var score = 0
6. As you saw from the auto-completion, there are new @export options available now. Let’s add
@export_range() to line 4:
4  @export_range(0, 100, .1) var input_range
NOTE
This gives a range from 0 to 100 in increments of .1 to the input_range variable, which you can change in
the Inspector tab.
7. We can show named enum values in the Inspector tab by adding the following to lines 5 and 6:
                                                      
5    enum WeatherEnum {Sunny, Rainy, Cloudy = -1}
                                                   
6    @export var weather: WeatherEnum
8. On line 7, let’s add a file to show up on the Inspector tab using @export_file:
7    @export_file("*.txt") var file
9. Click on Node2D in the Scene tab. Then, click on + under Scene in the Scene tab to bring up the
Create New Node window.
10. Then, type camer2d in the Search box. Select and add Camera2D to Node2D.
11. The onready keyword is now @onready. We will add a Camera2D node and use @onready with the
camera on line 7:
8    @onready var camera = $Camera2d
12. Click on Node2D at the top of the tree in the Scene tab to see everything we used with @export in
the Inspector tab.
Figure 2.1 – Annotations.gd
How it works…
We added a score variable so we can could see it in the Inspector tab using
@export instead of the export keyword.
We added @export_range(0, 100, .1) var input_range to show a range of 0 to 100 that
snapped the value in .10 increments. You could also just use @export_range (0, 100)
var input_range or @export_range (0, 100) var input_range: float.
We created an enum and then we used @export var weather: WeatherEnum to put the
enum into the weather variable so we could see it in the Inspector tab. You could
also do @export_enum(Sunny, Rainy, Cloudy) var weather.
We used the @export_file("*.txt") var file to show how a file is seen in the
Inspector tab.
We added a Camera2D node to Node2D so we could use @onready with it. First,
we just used @onready var camera = $Camera2d to add the Camera2D node to the
camera variable.
Using properties with getters and setters
In Godot 4, the setget keyword is gone and has been replaced by using
properties, so you don’t have to use dedicated functions. We will go through
some examples of how to use getters and setters.
Getting ready
For this recipe, create a new scene by clicking + to the right of the current
Scene tab and add Node2D. Click on the word Scene in the top menu next to
Project, then select Save Scene As, and name it Properties.
How to do it…
There are two ways we can use getters and setters. The first is like Godot 3.x,
where we assign get and set to functions. The second way is to define get and set
after we declare the variable. First, let’s create a button:
1. In the new scene named Properties that you created, add a Button node and make it big enough to
see.
Figure 2.2 – Creating a Button node
2. Add a script named Properties.gd to the Button node and delete everything except for line 1.
3. At the top center of the editor, left-click on 2D in the Workspace section. Add a signal to the Button
node by going to the Node tab to the right of the Inspector tab located under BaseButton and
selecting pressed():
1  extends Button       
2                                                 
3     
4. The setget keyword used in Godot 3.x is now gone. We will assign get and set to functions as was
done in Godot 3.x:
5  var value: int = 10: set = set_value, get = get_value                         
6                                                   
7  func set_value(new_value: int) -> void:            
8     value = new_value                          
9     print('setter', str(value))               
10             
11 func get_value() -> int:                         
12    print('getter', str(value))               
13    return value                              
14            
15 func _on_pressed():                              
16    value -= 1                              
5. Now click the Run the current scene button or hit the F6 key. Look at the Output section in the
bottom panel.
6. Highlight lines 5–13 and hit Ctrl + K to comment out these lines.
7. Now we will try using a variable declaration and no functions. Let’s start on line 15. Lines 23 and 24
should still be there from step 4. They were lines 15 and 16:
15 var value: int = 10:            
16     set(new_value):             
17        value = new_value                         
18        print('setter', str(value))          
19     get:                                        
20        print('getter', str(value))          
21        return value                              
22             
23 func _on_pressed():                             
24     value -= 1                         
8. Now click the Run the current scene button or hit the F6 key.
How it works…
We added a button and connected the pressed() signal so we could see that the
getters and setters were working.
In lines 7–9, we created the set_value setter function with an integer parameter
called new_value. This function does not return a value so we used -> void:. We
then made value equal to new_value, and finally, we printed setter with value.
In lines 11–13, we created the get_value getter function, which returns an
integer, so we used -> int:. We printed getter with value and then we returned
value. In line 16, we added value = value – 1 to the _on_pressed() function that was
created when we hooked up the signal in step 3.
We entered the code to call the get and set functions as was done using the
getset keyword in Godot 3.x. In line 5, we created a variable called value, which
is an int value equal to 10. We then assigned set to the set_value function and get
to the get_value function.
Figure 2.3 – The GDScript and console output results
When the button was clicked, the value variable in the setter was decreased by
one and then printed on the console, as well as the value getter variable before
and after the button was pushed, to show that the getter and setter were
working.
We commented out lines 5–13 so we could use the get and set properties with
the variable declaration.
On line 15, we created an integer variable called value and assigned it to equal
10. Then, on line 16, we used the set property with new_value as the parameter.
On lines 17–18, we made value equal to new_value and printed setter with value. On
line 19, we saw the get property. On lines 20–21, inside of the get property, we
printed getter with value.
Figure 2.4 – The GDScript and console output results
We select Run the current scene and notice that we get the same output on
the console as we did when we used functions. The value variable in the setter is
decreased by one and then printed on the console, as well as the value getter
variable before and after the button was pushed.
Using the new await keyword and coroutines
The yield keyword has been removed and replaced by the await keyword. You
can use await with coroutines or signals. It pauses the function it is in and waits
for a signal to be emitted, or if a called coroutine is finished, it then resumes
the function where it was originally called.
Getting ready
For this recipe, create a new scene by clicking + to the right of the current
Scene tab and adding Node2D. Select Save Scene As and name it Await.
How to do it…
We will go through a very simple example of how await works with a coroutine
using a button as a character dialogue box. When the button is clicked, it skips
to the next character dialogue box:
1. In the new scene named Await that you have created, add a Button node and make it big enough to
see the text that we are going to place in it with code.
2. Add a script named Await to Node2D and delete all of the default lines except line 1.
3. Let’s use @onready and create a variable called button to reference our Button node:
1  extends Node2D                                   
2                                                  
3  @onready var button = $Button
4. On line 5, we will create a new function called game_dialogue() and call it in the _ready() function:
4                                          
5  func _ready():                               
6     game_dialogue()                         
7      
8  func game_dialogue():                          
9     button.text = "Dialogue text."               
10    print("In the game_dialogue function.")     
11    var next_dialogue = await skip_dialogue()    
12    if next_dialogue:                    
13       print("At the end of game_dialogue function.")
5. On line 15, we created a new function called skip_dialogue():
15 func skip_dialogue():              
16    print("Now in the skip_dialogue() function.")
17    await button.button_up                    
18    button.text = "New dialogue text."          
19    print("At the end of skip_dialogue function."
20    return true
6. Now click the Run the current scene button or hit the F6 key.
Figure 2.5 – GDScript for steps 3 to 5 (the code for Await.gd)
How it works…
We added a Button node and made it big enough for us to read the text on the
button that we will code in later. Then we added a script called Await to
Node2D and deleted all of the default lines except line 1.
We used @onready with the button variable so we could load the reference when
the _ready() function was called.
We created a function called game_dialogue(). In line 9, we added text to the
button. In line 10, we printed that we were in this function so we could see it in
the console to see how the await keyword works. In line 11, we declared a
variable called next_dialogue equal to the skip_dialogue() function written in step 5.
This is where the program will pause and go to the coroutine of the
skip_dialogue() function. In lines 12–13, we have an if statement that checks that
next_dialogue is true, and if so, then prints that we are back in the game_dialogue()
function. For it to be true, the skip_dialogue() function has to run and return true.
We created the function called skip_dialogue(). In line 16, we printed to the
console that we were now in this function. In line 17, we waited for the user to
click the button. In line 18, we changed the text on the button. In line 19, we
printed to the console that we were at the end of the skip_dialogue() function. In
line 20, we return true so that when we go back to the game_dialogue() function,
we can print the last print statement.
We selected Run the current scene.
You see In the game_dialogue function. and Now in the skip_dialogue() function. on the
console before you click the button. The default text on the button is Dialogue
text.. After you click the button, you see At the end of skip_dialogue function. and At
the end of game_dialogue function. on the console and the text on the button is New
dialogue text..
Using the super keyword to call a function
In Godot 3.x, we used to call a function of the parent class from a subclass by
using the .function of the parent class. Now we use the super keyword. In the
example, we will use in this recipe, we have SniperEnemyClass, which is inherited
from DefaultEnemyClass. If we wanted to call the rifle function in DefaultEnemyClass
from SniperEnemyClass, we would use the super keyword, but in Godot 3.x, we use
.rifle().
Getting ready
For this recipe, create a new scene by clicking + to the right of the current
Scene tab and clicking Node2D. Select Save Scene As and name it Super.
How to do it…
We will create two classes called SniperEnemyClass, which is inherited from
DefaultEnemyClass. The DefaultEnemyClass class has two functions called rifle and
orders. We will use the super keyword from SniperEnemyClass to call the two
functions:
1. Add a script named Super to Node2D and delete all of the default lines except line 1.
2. Let’s start on line 11 and create DefaultEnemyClass:
11 class DefaultEnemyClass extends Node2D:          
12     func rifie():                   
13        print("Basic rifle")                        
14     func orders():                              
15        print("Guard the front gate.")
3. Now let’s create SniperEnemyClass starting on line 17:
17 class SniperEnemyClass extends DefaultEnemyClass:
18     func rifle():                              
19        print("Sniper rifle")                   
20        super.orders()                          
21        super()
4. We need to add a couple of variables to the _ready() function so we can see the output of the print
statement on the console. Let’s start on line 3:
3  func _ready():                           
4      var enemy = DefaultEnemyClass.new()          
5      var sniper = SniperEnemyClass.new()          
6  
7      enemy.rifle()                                
8      enemy.orders()                              
9      sniper.rifle()
5. Now click the Run the current scene button or hit the F6 key.
Figure 2.6 – super keyword code (GDScript for steps 2–4)
How it works…
We added a script to Node2D and named it Super. Then we deleted all of the
lines in the script except line 1.
We made a class called DefaultEnemyClass, which extends Node2D so, later, we
can see the output on the console. In lines 12–13, we made a function called
rifle to print out a rifle. In lines 14–15, we made a function called orders to print
out the orders.
We made a class called SniperEnemyClass, which extends DefaultEnemyClass. In lines
18–19, we created a rifle function, which prints out a sniper rifle. In line 20, we
called the orders function in the DefaultEnemyClass class using the super keyword. In
line 21, we called the rifle function in DefaultEnemyClass from SniperEnemyClass using
the super() keyword. As long as you are in a function that is in both parent and
child classes, you can use super(). If you want to call a different function in
DefaultEnemyClass, then you have to use super.function.
In lines 4–5, we created enemy and sniper instances for the two classes. In line 7,
we called the rifle() function in DefaultEnemyClass to see which rifle was set as the
default. In line 8, we called the orders() function in DefaultEnemyClass to see the
enemy orders. In line 9, we called the rifle() function in SniperEnemyClass.
We ran the current scene. We saw Basic rifle, Guard the front gate., Sniper
rifle, Guard the front gate., and Basic rife on the console.
We get the following console output when we run the current scene:
Figure 2.7 – super keyword console output
Working with typed arrays
In Godot 4, we can use typed arrays so if you are only going to use an array of
strings, you can set the element type to String and Godot will throw an error if
you try to put anything other than a string in that array. Types are validated at
runtime and not when compiling, which causes slightly faster performance.
Getting ready
For this recipe, create a new scene by clicking + to the right of the current
Scene tab and adding Node2D. Select Save Scene As and name it TypedArray.
How to do it…
In this recipe, we are going to set up three arrays. The first is not a typed array,
the second is a typed array, and the third infers the type of the array:
1. Add a script named TypedArray to Node2D and delete all the default lines except line 1 and the
_ready() function.
2. On line 3, let’s create a regular array:
1  extends Node2D  
2                                                  
3  var regular_array = [4, "hello",434]         
3. On line 4, we will create a typed array of int. Try adding a string to this array:
4  var typed_array: Array[int] = [16, 32, 64]        
4. On line 5, we will create an inferred array of string. Try adding an integer to this array:
5  var inferred_array := ["hi", "hello"]     
5. On lines 7–10, in the _ready() function, we print out all the arrays to the console:
                                                  
7  func ready():                                   
8      print(regular_array)                         
9      print(typed_array)                             
10     print(inferred_array)                    
6. Now click the Run the current scene button or hit the F6 key.
Figure 2.8 – GDScript for steps 2 to 5
How it works…
We added a script to Node2D and named it TypedArray. Then we deleted all of
the lines in the script except line 1 and the _ready() function. We created a
regular array with two integers and one string value. We can put anything in
this array.
We created a typed array of int and tried to enter a string in the array to see
the resulting error. In step 4, we created an inferred array of String and tried
to enter an integer into the array to see the resulting error.
We printed out all of the arrays to the console. We ran the current scene. We
saw [4, "hello", 434], [16, 32, 64], and ["hi", "hello"] printed on the console.
Working with lambda functions
In this recipe, we are going to go through some examples of how to use
lambdas in Godot 4. First, we create a lambda that takes a greeting parameter,
then we will call the lambda and pass in "hello" to the parameter. In the next
example, we declare a variable called health outside of the player_health lambda
and call the variable inside of the lambda. We will learn two ways to write a
lambda function with a button signal. Finally, we use a lambda function, moving
the button across the screen with a tween.
Getting ready
For this recipe, create a new scene by clicking + to the right of the current
Scene tab and adding Node2D. Select Save Scene As and name it Lambda.
How to do it…
Let’s start by creating a Button node and referencing it to the button variable:
1. Add a script named Lambda to Node2D and delete all of the default lines except line 1 and the
_ready() function.
2. In the new scene named Lambda that you created, add a Button node and make it big enough to see.
3. Let’s use @onready and create a variable called button to reference our Button node:
1  extends Node2D                                   
2                                                  
3  @onready var button = $Button
4. On line 5, in the _ready() function, we create a lambda that will pass in "hello" to the lambda
parameter greeting:
5  func _ready():            
6      var lambda = func(greeting):                   
7          print(greeting)                         
8      lambda.call("hello")                        
5. On line 10, we declare a variable called health:
10     var health = 100
6. On line 11, we create a lambda function called player_health:
11     var player_health = func(): print("Current health ", health)
7. On line 12, we call the player_health lambda function:
12     player_health.call()                    
8. On line 14, we create a lambda function to run when the button is pressed:
14     button.pressed.connect(func(): print("button was pressed"))
9. On lines 16–18, we create a lambda to run when the button is released:
16     var button_released = func():               
17         print("Button released")                  
18     button.button_up.connect(button_released)
10. On lines 20–21, we create a tween to move the button across the screen:
20     var tween = create_tween()        
21     tween.tween_method(func(pos): button.position.x = pos, 0, 500, 1)
11. Now click the Run the current scene button or hit the F6 key.
Figure 2.9 – Lambda code (GDScript for steps 3–10)
How it works…
We added a script called Lambda to Node2D and deleted everything in the script
except line 1 and the _ready() function. Then, we created a Button node in the
Scene tab. In the Lambda script, we used @onready to declare a variable called
button to the Button node.
We created a variable called lambda equal to the lambda function with the
greeting parameter, which prints the greeting. Since lambdas are a type of
callable, we call the lambda variable with the "hello" string to be used as the
greeting.
We declared a variable called health and gave it a value of 100 in line 10. You can
use variables from the outer class or outer function inside the lambda. In line
11, we created a lambda called player_health, which prints out Current health
and the value of the health variable. In line 12, we call the player_health lambda to
print out ("Current health ", health) to the console.
We pass the lambda as a function argument. When the pressed() button signal is
emitted, Button was pressed will be printed to the console.
We essentially do the same thing we did last in the step except we use more
than one line. When the button_up() signal is emitted, Button released is
printed to the console.
On line 20, we create a tween. On line 21, we use a lambda in tween_method() to
move the Button node from position (0) to position (500) with a duration of (1). If
we wanted the button to go slower, we would increase the duration number.
We run the current scene. It shows the button move across the screen and on
the console, you will see "hello" and "Current health 100". After you click the
button, you will see Button was pressed and Button released.
Figure 2.10 – Button and console output
Using callables with signals
In this recipe, we will see how callables can be used with signals. We will also
look at the call and bind callable methods. Callables can be held in variables and
passed into functions. As such, you can use them in arrays and in dictionaries
as the key or the value.
Getting ready
For this recipe, create a new scene by clicking + to the right of the current
Scene tab and adding Node2D. Select Save Scene As and name it Callables.
How to do it…
Let’s start by creating a Button node and referencing it to the button variable:
1. Add a script named Callables to Node2D and delete all of the default lines except line 1 and the
_ready() function.
2. In the new scene named Callables that you created, add a Button node and make it big enough to
see.
3. Let’s use @onready and create a variable called button to reference our Button node:
1  extends Node2D                                   
2       
3  @onready var button = $Button
4. On line 8, we create a function called signal_callable():
8  func signal_callable():             
9      print("This method was called by the button pressed signal.")
5. On line 5, in the _ready() function, we connect a callable signal to the signal_callable() function:
5  func _ready():                                    
6      button.pressed.connect(signal_callable)
6. Now click the Run the current scene button or hit the F6 key.
7. Let’s use the .bind method when we connect the signal. On line 6, add .bind after signal_callable:
6      button.pressed.connect(signal_callable.bind("binding_"))
8. We need to add a parameter to the signal_callable function:
8  func signal_callable(param):         
9      print(param, "This method was called by the button pressed signal.")
9. Now click the Run the current scene button or hit the F6 key.
10. Let’s add a new function on line 11 called player_text:
10 func player_text(param: String):                
11     print(param)              
11. Go to line 7, hit the Tab key, and add more code to the ready function.
12. Let’s create a variable called pt equal to player_text:
7      var pt = player_text      
8      pt.call("Hello, NPC!")          
13. Now click the Run the current scene button or hit the F6 key.
How it works…
We added a script called Callables to Node2D and deleted everything in the
script except line 1 and the _ready() function. Then we created a Button node in
the Scene tab. In the Callables script, we used @onready to declare a variable
called button to the Button node.
We created a function that we want to run when the button pressed signal is true.
Notice that we don’t have to connect the signal in the editor. We can use any
method that we want.
In the _ready() function, we used the button reference to connect the
signal_callable function when the signal pressed is true, which happens when the
button is pressed.
We ran the current scene. In the console, we saw This method was called by
the button pressed signal. after we clicked the button.
Figure 2.11 – Using callables with signals (code for steps 4–6)
We used the callable bind method. In line 6, we added .bind like this:
button.pressed.connect(signal_callable.bind("binding_")).
We needed to add a parameter to the function and inside of the print statement
to see what we added with bind.
We ran the current scene. In the console, we saw binding_This method was
called by the button pressed signal. printed after we clicked the button.
Figure 2.12 – Using callable with the bind method (code for steps 7–9)
We added a function called player_text, which takes a parameter called param that
only accepts strings. It prints out the parameter that will be passed in when we
use .call.
We created a variable for the player_text() function When you enter var pt =
player_text, autocomplete wants to add the () at the end – make sure you delete
it. We converted the function into a variable, so now we can use the function in
arrays, dictionaries, or in any other way you can use a variable.
We ran it to see Hello, NPC! printed in the console.
Figure 2.13 – Using .call() with a variable of the function (code for steps 10–13)
3
2D and 3D Rendering with Vulkan
In this chapter, we’ll take a look at the new Vulkan renderer for 2D and 3D.
We’ll start by looking at the new global illumination systems. Signed distance
field global illumination (SDFGI) can be used in 3D open-world games; we’ll
look at how we can use it in this chapter. Then, we’ll look at Volumetric Fog in
3D games, as well as how to use the FogVolume node to make our games look
realistic. After, we’ll look at the GPU-based particles node, attractors, collision,
trails, and 2D particles. Decals can be used to project a texture onto a mesh,
which we will look at in the last recipe.
In this chapter, we will cover the following recipes:
Showing off SDFGI
Using Volumetric Fog to enhance your games
Understanding the FogVolume node
Working with particle nodes in Godot 4
Using decals in your game
Technical requirements
For this chapter, you need the standard version of Godot 4.0 or later running
on one of the following systems:
Windows 64-bit or 32-bit
macOS
Linux 64-bit or 32-bit
Android
Web Editor
You can find the code and the project files for the projects in this chapter on
GitHub at https://github.com/PacktPublishing/Godot-4-Game-DevelopmentCookbook/tree/main/Chapter%203.
Showing off SDFGI
In this recipe, we will download a 3D asset so that we can see how signed
distance field global illumination (SDFGI) looks and go through all of the
settings to see what they do. SDFGI is a real-time global illumination method
that uses Signed Distance Fields (SDFs) to create lighting in real time.
We will also look at Screen-Space Indirect Lighting (SSIL), which works
with SDFGI or VoxelGI and is indirect lighting that allows diffuse light to
bounce off of nearby objects.
Getting ready
For this recipe, open Godot 4 and start a new project called Chapter 3. Go to the
https://polyhaven.com/a/ship_pinnace website and download the free glTF 2.0
file using the drop-down arrow. Double-click the ZIP file and extract the file to
a new folder called Ship Pinnace or whatever you want to call it:
Figure 3.1 – glTF file download
You can also download the project from this book’s GitHub repository.
Make sure the renderer is set to Forward+. In the top-right corner of the
Editor area, you should see a green Forward+ button. If you don’t, then click
on Mobile or Compatibility and select Forward+ from the drop-down list.
How to do it…
In this recipe, we will set up a 3D environment and add a free 3D asset. We will
then add a camera to put into the model and go through the SDFGI settings to
see how they look:
1. In the new project, click on 3D Scene and rename Node3D to World. Then, save the scene as SDFGI.
2. As we saw in Chapter 1, Exploring the Godot 4 Editor, click on the three vertical dots to the left of the
Transform view on Viewport Toolbar to edit the Sun and Environment settings.
3. Add Sun and Environment to the scene by left-clicking the Add Sun to Scene button at the bottom
while holding down the Shift key.
4. Click on DirectionalLight3D in the Scene tab. In the Inspector tab, under Transform | Position,
enter 210 for x, 650 for y, and –265 for z:
Figure 3.2 – Transform | Position values
5. Take the folder you saved the ship in and drag it into the FileSytem tab.
6. Open the folder and drag the ship_pinnace_4k.gltf file onto the World node in the Scene tab.
7. Add a Camer3D and place it in the boat. I put it by the stairs:
Figure 3.3 – Camera3D position by the left stairs
8. Click on the AssetLib tab to the right of Script to go to the Godot Asset Library area.
9. In the Search box, type camera and look for Free Look Camera; download it.
10. Add the free_look_camera.gd script to Camera3D.
11. Add a MeshInstance3D and rename it Orb.
12. Click on <empty> to the right of the mesh in the inspector. A drop-down list will appear. Now, click
New SphereMesh.
13. To the right of the mesh, where we just clicked <empty>, click on SphereMesh.
14. Click on <empty> to the right of Material in the Inspector area. A drop-down list will appear. Now,
click New StandardMaterial3D.
15. In the Inspector area, click on Material to open the options. Click on Metallic, then change the
value of Metallic from 0 to 1.
16. In the Inspector area, click on Roughness to open the options. Change the value of Roughness
from 1 to 0.
17. Bring the Editor camera somewhere behind Camera3D, which we placed earlier.
18. Click View, which is to the right of Transform, to make a drop-down list appear. Click on 2
Viewports (Alt):
Figure 3.4 – All viewport options
19. Click WorldEnvironment in the Scene tab. Then, at the top of the Inspector area, to the right of
Environment, click Environment to see the available options.
20. In the Inspector area in WorldEnvironment, click on SDFGI to open the options menu. Click on
Enabled and notice the differences between off and on.
21. Click on Use Occlusion to see how this looks. If it doesn’t look right, use the mouse wheel to zoom in
and out to fix it.
22. Go through each of the options below Read Sky Light to see how it looks. In the How it works…
section, I have explained each option. Run Current Scene (by pressing F6) to see how it looks in a
game while you change the settings.
23. Click on SSIL at the top of SDFGI and click Enabled.
24. Go through each of these options and see how they look in the editor and game.
25. Open the Project Settings area (make sure the Advanced Settings button is on) and, under
Rendering, click Global Illumination.
26. In the Project Settings area under Rendering, click Environment to see the SSIL properties.
How it works…
In this recipe, we created a new project by clicking on 3D Scene, which added
a Node3D root node. We renamed it World. You don’t have to do that, but I
wanted to rename the root node of my 3D project.
We added the DirectionalLight3D and WorldEnvironment nodes by clicking
on the three vertical dots to open the Sun and Environment settings. We
changed the position of the light source by changing Position under
Transform in the Inspector area.
Then, we took the ship model that we saved to a folder when we extracted it
from the ZIP file and moved the folder to the World node in the Scene tab. We
added a Camera3D to the World scene and placed it in the boat so that we
could see how the SDFGI options look when applied.
After, we went to the Godot Asset Library area to get a free script called Free
Look Camera so that we could move the camera around the model to see how
the lighting looks. We can use the W, A, S, and D keys to move and press and
hold the right mouse button and move the mouse to position the view of the
camera.
Next, we created a sphere mesh named Orb by adding MeshInstance3D to the
scene. By changing the Metallic and Roughness values, we created a mirrorlike surface for the sphere so that we could see how the lighting reflects off of
the sphere.
Then, we moved the default Editor camera under the deck behind Camera3D,
which we added earlier. After, we changed the viewport to show the default
camera view and outside of the view so that we could see how SDFGI looks in
the editor in real time.
Next, we checked out all of the properties in SDFGI. Using Occlusion reduces
light leaking. Bounce Feedback is a multiplier that’s applied to the light each
time it bounces off of a surface. There are no performance impacts when using
it.
When using brighter materials, anything over the default value of 0.5 could
cause feedback loops, which could make everything white because of so much
light. Cascades display SDFGI further away, keeping detail up close, but you
will have a hit on performance.
If you have smaller levels, using one to four cascades will improve
performance. Min Cell Size allows SDFGI updates to be more accurate up
close with a higher hit on performance when using lower values.
Higher values decrease the performance hit and SDFGI is more diffuse.
Cascade 0 Distance is linked to Min Cell Size and Max Distance (all three
are linked). Max Distance is the maximum distance that SDFGI is visible. The
Y Scale 50% Compact setting is used for better quality, while 100% Sparse is
used for very vertical games and how fast the camera moves on the Y-axis.
Energy is an SDFGI multiplayer such as Bounce Feedback. The higher values
will be brighter. Normal Bias is for normal SDFGI probes. Higher values can
reduce visible streaking artifacts on sloped surfaces but could increase light
leaking. Probe Bias is the constant bias on SDFGI probes.
After, we enabled SSIL and checked out its properties. Radius is the distance
that bounced lighting will travel. Intensity is a brightness modifier for SSIL.
The higher the value, the brighter the light. Sharpness is the amount that SSIL
is allowed to blur objects. Normal Rejection is used to avoid light leaking
when only one side of an object is illuminated.
Then, we looked at the Global Illumination advanced settings. To improve
performance with Voxel GI and SDFGI, turn on Use Half Resolution. Voxel GI
| Quality can be set to Fast at lower quality (fewer cones) or Slow at higher
quality (more cones). SDFGI Probe Ray Count, Frames To Converge, and
Frames To Update Lights can also change the speed and quality settings.
Finally, we looked at the SSIL properties in the Environment advanced
settings. Here, you can change the Quality property. Half Size is when SSIL is
rendered at half size and upscaled before entering the scene. Adaptive Target
has values of 0 to 1, where a value of 1 is high quality but slower while 0 has a
speed and quality that’s medium in quality.
Blur Passes is the number of blur passes when computing SSIL. A high
number is smoother but slower. Fadeout From is the distance at which SSIL
starts to fade out. Fadeout To is the distance at which SSIL is fully faded out.
Using Volumetric Fog to enhance your games
In this recipe, we will use Volumetric Fog in the scene from the previous recipe
and go through each property and see what they do. Volumetric Fog reacts to
light and shadow in real time throughout the scene. It makes your 3D scenes
more realistic.
Getting ready
For this recipe, we will use the SDFGI scene that we made in the preceding
recipe. You can also download the project from this book’s GitHub repository.
Like the previous recipe, make sure the renderer is set to Forward+.
How to do it…
In this recipe, we will use the same scene from the previous recipe to add
Volumetric Fog:
1. In the Scene tab, click on WorldEnvironment. Then, in the Environment options, click Volumetric
Fog in the Inspector area.
2. To the right of Enabled, click On.
3. Move the slider of the Density property to the right and left to see its effects. After, click to the left of
the slider to return to the default setting of 0.05.
4. Click on the white box to the right of Albedo to change the color of the fog.
5. Click on the black box to the right of Emission to change the light emitted from the fog.
6. Move the slider of Emission Energy to change the brightness of the emitted light. Change it back to
the default setting of 1.
7. Move the slider of GI Inject to change the strength of Global Illumination in the Albedo color.
Change it back to the default setting of 1.
8. Move the Anisotropy sliders around to change the direction of the light as it goes through the fog.
Change it back to the default setting.
9. Let’s move the Length slider to determine how far the Volumetric Fog is computed. Change it back to
the default setting.
10. Move the Detail Spread slider to see how it looks. Change it back to the default setting.
11. Move the Ambient Inject slider to change the strength of the ambient light used in the Volumetric
Fog. Change it back to the default setting.
12. Move the Sky Affect slider to 0 and then back to 1.
How it works…
In this recipe, we turned on Volumetric Fog and then moved the various
sliders to change the density of the fog. Notice that the closer we came to the
value of 1, the fog in the left viewport was closer to the camera. The opposite
happened when the value was 0. Then, we set it back to its default to get some
fog for the next step.
When we clicked the color box to the right of Albedo, we changed the color of
the fog when the fog interacted with light. We also changed the Emission and
Emission Energy properties. Emission is the light coming off of the fog, while
Emission Energy is how much light is coming off of the fog.
We also changed GI Inject to look at how the strength of Global Illumination
changes how the fog looks. A value of 0 will not change the fog. There is a slight
performance hit when you set it above 0.
After, we changed the direction of the light when it goes through the
Volumetric Fog. If a value is close to a value of 1, then the light is scattered
forward. If the value is 0, then the light goes in all directions equally. If the
value is close to –1, then the light is scattered backward.
Next, we changed the Length property. The higher the number, the greater
the range; a lower number adds more detail. We also adjusted the Detail
Spread property. If the value is higher, more detail is closer to the camera.
Then, we adjusted the Ambient Inject property to change the strength of the
ambient light used in the Volumetric Fog. If the value is 0, there is no effect on
the Volumetric Fog. There is a small performance hit when the value is over 0.
Finally, we moved the Sky Affect slider from 1 to 0 and then back to 1. When
the value was 0, there was no fog in the scene except on the ship itself. This is
because, at the default value of 1, the fog fully obscures the sky, while at 0, it
doesn’t but the fog on the ship is not affected.
Understanding the FogVolume node
The FogVolume node adds fog to a specific area. You can use many shapes to
hold the fog, including a box, cones, cylinders, ellipsoids, as well as the world.
In this recipe, we will create a FogVolume node and use it on the ship.
Getting ready
For this recipe, we will use the SDFGI scene that we used in the preceding two
recipes. You can also download the project from this book’s GitHub repository.
Like the previous recipes, make sure the renderer is set to Forward+.
How to do it…
In this recipe, we will create a FogVolume node and see how it looks:
1. Click World in the Scene tab and then click + to add the FogVolume node.
2. Enable Volumetric Fog in the WorldEnvironment node.
3. In the Inspector area, click <empty> to the right of Material and select New FogMaterial:
Figure 3.5 – New FogMaterial
4. Click on FogMaterial to the right of Material to open the Properties area.
5. Above Shape, change the box to x 4m, y 4m, z 4m.
6. Go to the Height Falloff property under Emission in the Inspector area. Left mouse click the box to
the right of Height Falloff and drag it to the left until the number is 100 or more to see the fog on the
ground.
7. Left mouse click the right of Edge Fade and drag it to the left and right to see the fog thin out when
the value is high.
How it works…
In this recipe, we enabled Volumetric Fog so that we could see the fog in the
cube. We added a FogVolume node to the scene and then added New
FogMaterial to our Material. We changed the cube size to 2x2x2.
We also changed the value of Height Falloff to bring the fog to the ground.
The Density, Albedo, and Emission properties do the same thing as the
Volumetric Fog properties in the WorldEnvironment node. We changed the
value of Edge Fade and noticed that the edge is thicker with a lower value and
thinner with a higher value.
Working with particle nodes in Godot 4
In this recipe, we’ll look at GPU-based particles node. We’ll look at attractors,
which attract particles toward the GPUParticlesAttractorSphere3D node, as
well as collisions, where we create a ramp. When the particles hit the ramp,
they collide and then fall down the ramp.
Next, we will create a second particle and use sub-emitters so that once the
particles fall off the ramp or collide with the ramp, they change to the second
particle. We will use trails to make a very basic explosion effect with the builtin TubeTrailMesh. Finally, we will look at the new GPUParticles2D node by
making a cloud that shoots lighting using sub-emitters and trails.
Getting ready
For this recipe, we need to add a new 3D Scene and save the scene as
Particles. Click View, then 1 Viewport. Rename Node3D to World and add a
WorldEnvironment node to the Scene tab.
Download this free particle pack from Kenny here:
https://www.kenney.nl/assets/particle-pack. We will use this later.
You can also download the project from this book’s GitHub repository.
How to do it…
In this recipe, we will start by adding a GPUParticles3D node and then look at
all the things we can do with particles in Godot 4:
1. Click the World node and then add a GPUParticles3D node to the Scene tab.
2. Click on Process Material and Draw Passes in the Inspector area to see the options for the
properties.
3. Click <empty> to the right of Pass 1 under Draw Passes and select New SphereMesh from the
drop-down list.
4. Click <empty> to the right of Process Material under Process Material and select New
ParticleProcessMaterial from the drop-down list:
Figure 3.6 – Particle Material and Draw Passes Inspector settings
5. Click on ParticleProcessMaterial to the right of Process Material to open the options for
ParticleProcessMaterial. Click Emission Shape and then left-click Point to change it to Sphere.
6. Click on the World node and click + to add a GPUParticlesAttractorSphere3D node. Right-click the
node and rename it AttractorSphere.
7. Change the GPUParticlesAttractorSphere3D radius to 5m and Strength to 60. Now, move it around
to see the particles moving toward the new node.
8. In the Scene tab, toggle off the visibility of the AttractorSphere node.
9. In GPUParticles3D in the Inspector area, click Time to open the options. Then, change the value of
Lifetime to 2s and Amount to 64.
10. In the Inspector area, change the Scale Min and Max properties of the GPUParticles3D | Process
Material property to 0.2. While we are here, click Collision to see the options and click Disabled to
the right of Mode. Then, click Rigid.
11. Click World in the Scene tab and add a GPUParticlesCollisionBox3D. Right-click and rename this
CollisionBox.
12. Click on CollisionBox in the Scene tab and change the x, y, and z values of Size to 8, 2, and 8,
respectively. In the Transform area, change the y value to –3 and the rotation value of z to 30:
Figure 3.7 – GPUParticlesCollisionBox3D Inspector settings
13. Click on the GPUParticles3D node in the Scene tab and then click Transform in the Inspector area
to change the value of y in Position to 2m.
14. Click on the GPUParticles3D node in the Scene tab and then press Ctrl + D (Cmd + D on Mac) to
duplicate the node. Alternatively, you can right-click the node and click Duplicate in the drop-down
list.
15. Click on the GPUParticles3D2 node that we just created and, in the Inspector area, click on Draw
Passes to open the options.
16. In Pass 1, click on the down arrow on the far right to open a list of new meshes. Select New
BoxMesh.
17. Click on the original GPUParticles3D node and, at the top of the Inspector area, click Assign... to
the right of Sub Emitter. Then, click GPUParticles3D2.
18. Go to the Process Material section and click Sub Emitter to see the options. Then, click Disabled,
which is to the right of Mode, and select At Collision.
Trails
We are going to make a very basic explosion effect with the built-in
TubeTrailMesh using particle trails. We will start by creating a new scene:
1. Let’s create a new 3D Scene by clicking the + button to the right of the Particles scene. Save the
scene as Trails.
2. Add a GPUParticles3D node to the scene and click Draw Passes in the Inspector area.
3. Click <empty> to the right of Pass 1 and select New TubeTrailMesh in the dropdown.
4. Left-click the tube that appeared where <empty> was and change Radius to .1m and Section
Length to .1m:
Figure 3.8 – Draw Passes Inspector settings
5. At the moment, we are still in Draw Passes. Click on Material and select New
StandardMaterial3D. Left-click the material that appeared where <empty> used to be.
6. Click Transform to show the available options and click on Use Particle Trails.
7. Click Process Material in the Inspector area to see its properties. Click on <empty> and then New
ParticleProcessMaterial. Then, left-click ParticleProcessMaterial where <empty> used to be to
see its properties.
8. Click on Direction to open its properties and change x to 0 and y to 1.
9. Click on Gravity to open its properties and change y to 0.
10. Click on Initial Velocity to open its properties and change both Velocity Min and Max to 1:
Figure 3.9 – Inspector settings for Process Materials
11. In the Inspector area, click Trails to open its properties. Then, click Enabled so that it is on and
change Length Secs to 4s.
12. In the Inspector area, click Time to open its properties and change Lifetime to 5s.
13. In the Inspector area, change Amount to 50:
Figure 3.10 – Inspector settings for Time and Trails
Particles2D
In this part, we will make a cloud that shoots lighting using sub-emitters and
trails with GPUParticles2D. We will start by creating a new scene:
1. Let’s create a new 2D Scene by clicking the + button to the right of the Trails scene. Save the scene
as Particles2D.
2. Add GPUParticles2D to the scene. Rename it Cloud.
3. If you have not downloaded the free particle pack from Kenny, then go to the website in the Getting
ready section and download it.
4. Once you’ve extracted and opened the PNG(Transparent) folder, move the smoke_07.png and
spark_05.png files into the res:// folder in Godot.
5. Click Textures under Process Material in the Inspector area, and drag the smoke_07.png file over
to <empty> to add the texture.
6. Click Process Material, then click <empty> and select New ParticleProcessMaterial from the
dropdown.
7. Left-click on ParticleProcessMaterial, which you just selected, to open its properties.
8. Click Time in the ParticleProcessMaterial properties and change the Lifetime Randomness
property to .2.
9. Click Emission Shape and change Point to Sphere by clicking on Point. Change Sphere Radius to
150.
10. Click Direction and change the x value to 0 and the y value to 1.
11. Click Initial Velocity and change both Velocity Min and Max to 250.
12. Click Scale and change Scale Min to 1 and Scale Max to 2.
13. Click Sub Emitter and change the Mode property to At End and Amount At End to 20. Turn on
Keep Velocity.
14. Click Collision and change the Mode property to Rigid.
15. At the top of the Inspector area, change the Amount value to 100.
16. Click Time to open the properties and then change the Randomness value to .5.
17. Add another GPUParticles2D node to the scene as a child of Cloud. Rename it Lightning.
18. Click on the Cloud node. Then, at the top of the Inspector area, click Assign…, which is to the right
of Sub Emitter, and add the Lightning node you just created. Then, click on the Lightning node so
that we can start to set up the sub-emitter.
19. Click Textures, which is under Process Material in the Inspector area, and drag the spark_05.png
file to <empty>.
20. Click Process Material in the Inspector area to open its properties. Click <empty> and select New
ParticleProcessMaterial. Click ParticleProcessMaterial, which you just added, to see its
properties. Click on Gravity in the Inspector area and change the y value to 500.
21. Click Trails in the Inspector area and click to the right of Enabled. Change Lifetime to 4.
22. At the top of the Inspector area, change Amount to 1. Then, click Time to open its properties.
Change the value for Lifetime to 2 and the value of Speed Scale to 3:
Figure 3.11 – Time and Trails Inspector settings for the Lightning node
How it works…
In this recipe, we added a GPUParticles3D node to the scene. After clicking
on GPUParticles3D in the Scene tab, we looked in the Inspector area and
clicked on Process Material and Draw Passes to show the options for these
properties.
Then, we added New SphereMesh from the Pass 1 drop-down box. We also
added New ParticleProcessMaterial from the Process Material dropdown,
we could see a sphere particle rendering eight particles per pass. If we wanted
to have more particles per pass, we could change the Amount property located
just under the Emitting On checkbox in the Inspector area. Finally, we
changed the Emission Shape property so that the particles are rendered in a
sphere instead of a point.
Next, we added a GPUParticlesAttractorSphere3D node and renamed it
AttractorSphere. We changed the values of Radius and Strength. So long as
the radius is touching the particles and the strength is high enough, the
particles will go to the AttractorSphere node. Then, we toggled the visibility
of the node off so that we could look at collisions.
We changed the particle amount to 64 and made the particles smaller at 0.2. We
also increased the lifetime of the particles to see how GPUParticleCollision
works. We went to Collision and changed it to Rigid from Disabled so that
our collisions worked.
We also added a GPUParticlesCollisionBox3D and changed its name to
CollisionBox. We made it a little bigger and set Rotation so that the particles
hit the collision box and rolled down. We also moved the GPUParticles3D
node higher so that the particles didn’t sit on the slope we created.
We duplicated the GPUParticles3D node and changed the mesh to a box
instead of a sphere so that we could see a difference when we turned on Sub
Emitter. You could child the GPUParticles3D2 node to the GPUParticles3D
node, but this isn’t required.
We went back to the GPUParticles3D node to add the new particle as a Sub
Emitter. We set Sub Emitter to At Collision so that the new particle would
appear when the first particle collides with something. If you change Mode to
At End, the new particles will appear after they leave our ramp as they fall. If
you change Mode to Constant and turn on Keep Velocity, it will change to a
cube when it collides and will keep going down the ramp.
Trails
Next, we created a new scene and named it Trails. We added a
GPUParticles3D node to the scene and clicked Draw Passes in the Inspector
area to open its properties.
In Pass 1, we clicked <empty> to add a New TubeTrailMesh. We could have
also selected New RibbonTrailMesh if we wanted to use a ribbon trail. Then,
we changed the radius and section length to .1m to make it a little smaller.
In Draw Passes, we clicked the Material property and added a New
StandardMaterial3D. After clicking on the material we just added, we went to
the Transform property and clicked on Use Particle Trails. If you wish to add
a texture, then click on Albedo and drag it into the Texture property.
We also added a new ParticleProcessMaterial and opened its properties. We
changed the Direction, Gravity, and Initial Velocity values so that the tube
goes up into the air.
We then changed the trails to make longer trails by adjusting the Length Secs
and Lifetime properties. We added the number of particles that are emitted so
that it could simulate an explosion.
Particles2D
In this final part, we created a new 2D Scene and then added a
GPUParticle2D node. We moved the two texture files that we wanted to use
into Godot. We clicked on Textures under Process Material in the Inspector
area and moved the smoke_07.png file to <empty> so that the particle texture
looked like a storm cloud.
We changed the Time, Emission Shape, Direction, Initial Velocity, and
Scale properties to make the cloud. We also turned on our Sub Emitter and
added collision to set up our particle to use a sub-emitter later that will appear
at the end of the cloud particle’s life.
We made the cloud fuller by changing the Amount value and adding some
randomness. We also created a new GPUParticles2D node as a child of the
Cloud node and renamed it Lightning. In the Cloud node, we added the
Lightning node as a Sub Emitter.
Next, we added the spark_05.png texture to the Lightning node we just added
and changed the y value of Gravity to 500 so that the lightning would go down
far enough past the cloud.
Finally, we turned on Trails and increased the lifetime of the lightning. We also
changed the Amount property to 1 so that we only have one lightning bolt.
Changing the Speed Scale property causes the lightning to go faster.
Using decals in your game
Decals are projected to a mesh, so you could use them for laser sight dots since
it doesn’t change the mesh they’re projected on and can move. You can also use
decals for when the player shoots a gun at a wall and bullet holes appear.
In this recipe, we will create a mesh and project the Godot icon onto it. We will
make a wall and programmatically add the Godot icon to the wall so that you
can add some bullet holes or spray paint tags, as a player could do in a game.
Getting ready
For this recipe, add a new 3D Scene by clicking the + button to the right of the
Particles2D scene. Then, save the scene as Decals.
You can also download the project from this book’s GitHub repository.
How to do it…
Let’s create a box mesh and project the Godot icon onto it so that you can use it
for shadows or to add details to any background mesh:
1. Add a Decal node to the scene. Then, click Textures in the Inspector area to open its properties.
2. From the resource folder, drag the icon.svg file in the FileSystem tab to each of the <empty>
boxes for Albedo, Normal Orm, and Emission in the Textures properties.
3. Click on Node3D and add a MeshInstance3D to the scene.
4. Click on <empty> to the right of the mesh in the Inspector area and select New BoxMesh. Click on
Transform in the Inspector area to open the properties. Then, look to the right of z and click the
chain icon to unlock the Scale settings. Change x to 3, y to 1, and z to 3:
Figure 3.12 – MeshInstance3D Inspector Scale settings
5. Click on Decal in the Scene tab and then click Parameters, Vertical Fade, and Distance Fade in
the Inspector area so that we can see what the properties do in the How it works… section.
Decals_World
We will make a wall and add a camera to use with the Lightning_Decal section.
We will start by creating a new scene:
1. Let’s create a new 3D Scene and save it as Decals_World.
2. Rename Node3D to World. Then, add Sun and World Environment to the scene, as we did in the
first recipe.
3. Click World and then add a MeshInstance3D to the scene. Rename it Ground.
4. In the Inspector area, click on <empty> to the right of Mesh. Click New PlaneMesh and then click
on Transform in the Inspector area and change the Scale settings to x 10, y 10, and z 10.
5. Add a Camera3D to the World node in the Scene tab. Drag the free_look_camera.gd script to
<empty> to the right of Script in the Camera3D Inspector area.
6. Click on World then add a MeshInstance3D to the scene and rename it Wall.
7. Click on <empty> to the right of the mesh and select New BoxMesh. Click on the BoxMesh
property that was created to open its properties and click on <empty> to the right of Material. Then,
select New StandardMaterial3D:
Figure 3.13 – Adding a New StandardMaterial3D to the wall
8. In the Inspector area, click on Transform under Node3D to open the properties. Under Position,
change the y value to 2.46 and the z value to –5. Under Scale, make sure that you’ve clicked the link
button on the right so that we can change each value separately. Change x to 15, y to 5, and z to 2.
9. In the top row, to the right of View and under the Decals_World tab, click on Mesh and select
Create Trimesh Static Body:
Figure 3.14 – Creating a Trimesh Static Body on the wall
10. Click Camera3D in the Scene tab and add a RayCast3D as a child to the camera. In the Inspector
area, change the Target Position property of y to 0 and z to –20.
Lightning_Decal
In this part, we will create a lightning decal and a script so that we can see our
lighting decals when we press the spacebar and point at the wall. We will start
by creating a new scene:
1. Create a new 3D Scene by clicking on the + button to the right of Decals_World. Save it as
Lightning_Decal.
2. Add a Decal node to the scene. Click Textures in the Inspector area to open the texture’s properties.
Drag the spark_05.png file into Albedo, Normal, and Emission.
3. Change the ESize x value to 1, the y value to .356, and the z value to .471.
4. Click Transform in the Inspector area to open the properties. Change the Rotation x value to 90,
the Scale x value to .1, the Scale y value to .5, and the Scale z value to .2. Save the scene.
5. Go back to the Decals_World scene and click on RayCast3D. Add a new script named Player.
6. Now, we are going to write some code that will get the Lightning_Decal node we just created. When
the spacebar is pressed, the lightning PNG will be projected onto the wall. On line 3, drag RayCast3D
in the Scene tab into the code after the equals (=) sign; it will apply $".". Don’t type that in because
it won’t work:
1   extends RayCast3D   
2                                                  
3   @onready var raycast = $"."                     
4   @export var decal: PackedScene                    
5                                                  
6   func _unhandled_input(event):                    
7      if event.is_action_pressed("ui_select") and
is_colliding():                                        
8         var new_decal = decal.instantiate()     
9         raycast.get_collider().add_child(new_decal)
10        new_decal.global_transform.origin =
raycast.get_collision_point()                           
7. Click on RayCast3D in the Scene tab. Then, in the Inspector area, click on <empty> to the right of
Decal. Select Load from the drop-down list and select Lightning_Decal.tsn to pack that scene into
the variable decal in our code.
8. Click the Run the Current Scene (F6) icon. In the game window that appears, right-click and drag
to move it and hit the spacebar to print the decal on the wall:
Figure 3.15 – Lightning decals on the wall
How it works…
In this recipe, we added a Decal node to the scene and added the Godot icon.svg
file to the Albedo, Normal, Orm, and Emission properties. The Albedo or
Emission properties must have a texture for the decal to be visible. The
Normal and Orm textures add extra details to the texture.
Next, we added a MeshInstance3D to the scene. We opened the Transform
properties in the Inspector area and clicked on the chain icon, which is to the
right of z. We did this so that when we change the Scale values, they can have
different values. We changed the Scale values to x 3, y 1, and z 3 to create a
cube that is not as tall as its sides.
We also looked at the properties of the Decal node. In Parameters, the
Emission Energy property changes the light intensity. The Modulate
property changes the color of the decal. Finally, the Albedo Mix property
blends the albedo color of the decal with the albedo color of the mesh.
Normal Fade will fade the decal if the angle of the decal and the target’s
surface is too large. The Vertical Fade property sets the fade as the surface
goes over the center decal. The Distance Fade property sets how far away the
decal will start fading before it disappears.
Then, we created a new scene and named it Decals_World. We added the
WorldEnvironment and DIrectionalLight3D nodes. Then, we added a new
PlaneMesh and named it Ground. We resized it to 10x10x10 so that we had some
room to add a wall and a player to the scene later.
We added a Camera3D as a child and added the free_look_camera.gd script to the
camera. We created a wall and adjusted its height and width. We moved back a
bit so that our player has some room to move and shoot. We created a Trimesh
Static Body on the wall so that we could detect collisions with ray casting.
We also added a RayCast3D node to Camera3D and changed the position of
the raycast so that it points ahead of the player. We did this by changing the y
position to 0 and the z position to –20.
Next, we created a new scene called Lightning_Decal and added the lightning
PNG file to the Albedo, Normal, and Emission textures. We flipped the
rotation of the x value to 90 so that the decal will face the wall when we add the
decal to the wall. We adjusted the scale values so that the decal would be
smaller.
After this, we went back to the Decals_World scene and added a script to the
RayCast3D node. We created a variable named raycast equal to the RayCast3D
node, and then a variable called decal as a PackedScene, where we hooked it up by
loading the Lightning_Decal scene into the decal variable that we exported using
@Export var decal: PackedScene so that we could see it in the Inspector area.
We also created an _unhandled_input event that looks for ui-select and whether the
raycast is colliding with something. ui-select can be found under Project
Settings | Input Map and is activated when the spacebar is pressed or joypad
button 3 is pressed.
Finally, we instantiated a new decal and added it to the raycast. By doing this,
the new decal is moved to where the raycast was when the spacebar is pressed:
Figure 3.16 – Code for Player.gd and RayCast3D Inspector properties
We ran the current scene and pressed the spacebar to see the lightning decal
project on the wall where our raycast was pointing. This is how you create
bullet holes.
4
Practicing Physics and Handling Navigation in
Godot 4
In this chapter, we start by looking at the effect that the
GPUParticlesCollisonHeightField3D node has on 3D terrain. We will use the
GPUParticlesCollisonHeightField3D node with some 3D terrain and create
snow with particles to see how it interacts with the 3D terrain. With the new
CharacterBody2D and CharacterBody3D that replaced kinematic bodies, we
will create a 2D and 3D player.
We will see how easy scripting the CharacterBody is compared to Godot 3.x.
We will look at the NavigationServer for 3D and 2D projects. Lastly, we will
make a banner to show how the SoftBody3D nodes work.
In this chapter, we will cover the following recipes:
Using Heightmap for 3D terrain
Setting up and moving the CharacterBody in 2D
Setting up and moving the CharacterBody in 3D
Using the new NavigationServer for 3D
Using NavigationServer2D for 2D projects
Using SoftBody for 3D games
Technical requirements
For this chapter, you need the standard version of Godot 4.0 or later running
on one of the following:
Windows 64-bit or 32-bit
macOS
Linux 64-bit or 32-bit
Android
Web Editor
You can find the code and the files for the projects in this chapter on GitHub at
https://github.com/PacktPublishing/Godot-4-Game-Development-
Cookbook/tree/main/Chapter%204.
Using Heightmap for 3D terrain
In this recipe, we'll make a basic 3D scene with ground and cubes of various
heights. We'll use the GPUParticlesCollisonHeightField3D node to add a 3D
heightmap to the scene. We'll create snow using particles and see how the
GPUParticlesCollisonHeightField3D node interacts with the particles on the
ground and on top of the cubes in the scene.
Getting ready
For this recipe, open Godot 4 and start a new project called Chapter 4. In the
Scene tab, click 3D to add a 3D scene. Click on the word Scene in the top-left
corner next to Project, then select Save Scene As and name it Heightmap.
How to do it…
In this recipe, we will create a 3D scene with cubes of various heights and snow
using particles. When we add the GPUParticlesCollisonHeightField3D node,
the snow will land on all of the surfaces no matter how tall:
1. Right-click on Node3D in the Scene tab and rename it World.
2. Left-click the three vertical dots to the left of the Transform View on the viewport toolbar.
3. Add the Sun and Environment nodes to the scene by left-clicking the Add Environment to Scene
button at the bottom while holding down the Shift key.
4. Left-click on the World node and then click the + sign in the Scene tab. In the Create New Node
window, type mesh in the Search box and then select MeshInstance3D to create the node in the
scene.
5. Right-click the MeshInstance3D node in the Scene tab and rename it Ground.
6. In the Inspector, click on <empty> to the right of Mesh and select New PlaneMesh.
7. Left-click on the same place to open the properties of the Ground mesh.
8. In the Inspector, change the Size property of x and y to 15.
9. Click on <empty> to the right of Material in the Inspector and select New StandardMaterial3D
from the drop-down list.
10. Click on the same place that you did in step 9 to open the Material properties.
11. In the Material properties, click Albedo and then click the white bar on the right of Color.
12. Leave the R value at 255. Change the G value to 0 and the B value to 0.
13. Make sure Ground in the Scene tab is still selected and then click + to add a new MeshInstance3D,
as we did in step 4.
14. Click <empty> to the right of Mesh and select New BoxMesh.
15. Left-click on the same place to open the properties of the BoxMesh.
16. Click on <empty> to the right of Material in the Inspector and select New StandardMaterial3D
from the drop-down list.
17. Left-click on the same place that you did in step 16 to open the Material properties.
18. In the Material properties, click Albedo and then click the white bar on the right of Color.
19. Leave the B value at 255. Change the G value to 0 and the R value to 0.
20. Left-click on Mesh, which is to the right of the Transform View in the toolbar at the top of the
viewport and select Create Trimesh Static Body.
21. You can click to the left of MeshInstance3D to hide the StaticBody3D and CollisionShape3D
children we just added.
22. Click MeshInstance3D, which we just created, and then Ctrl + D to duplicate it four more times so
that we have five cubes.
23. Move each of the cubes around to space them out. Click Select Mode (Q) located at the top left of
the viewport with an icon that looks like a mouse pointer or press the Q button.
24. For each of the cubes, click on Scale Mode (R) located at the top of the viewport or press the R
button and resize each cube to different sizes—for instance, some taller, some smaller, and others
wider:
Figure 4.1 – Various cube sizes to demonstrate the Heightmap
25. Left-click on the World node and then click + in the Scene tab. In the Create New Node window,
type GPU in the Search box and then select GPUParticles3D to create the node in the scene.
26. Right-click on GPUParticles3D and select Rename to rename this node Snow.
27. In the Inspector, under Emitting, change Amount to 500.
28. Click Time to open the properties and change Lifetime to 2 s.
29. In the Inspector, click Process Material to open its properties.
30. Click <empty> to the right of Process Material and select New ParticleProcessMaterial.
31. Left-click on ParticleProcessMaterial, which is in the same place as in step 30. This opens its
properties.
32. Left-click Emission Shape to open its properties. To the right of Shape, left-click Point and select
Box.
33. Change the Box Extents values on x and z to 5.
34. Left-click on Direction to see its properties and change the value of x to 0 and the value of y to –1.
35. Left-click on Scale to open its properties and change the values of Scale Min and Scale Max to 0.2.
36. Left-click Collision to open its properties and left-click Disabled, which is to the right of Mode, and
select Rigid in the drop-down list.
37. Click on Draw Processes to open its properties.
38. Click on <empty> to the right of Pass 1 and select New SphereMesh.
39. Left-click on SphereMesh to the right of Pass 1, which is in the same place as in step 38. This opens
its properties.
40. Click on <empty> to the right of Material in the Inspector and select New StandardMaterial3D
from the drop-down list.
41. In the Inspector, scroll down toward the bottom, and under Node3D, click Transform to open its
properties.
42. Under Position, change the y value to 10.
43. Under Scale, make sure the link icon to the right of the z value is clicked so that you can change each
value individually. Then, change the x value to 1.8, the y value to 3, and the z value to 1.8.
44. Left-click on the World node and then click on + in the Scene tab. In the Create New Node window,
type GPU in the Search box and then select GPUParticlesCollisionHeightField3D to create the
node in the scene.
45. In the Size properties, change the x, y, and z values to 20. Notice that the snow is stopping on the
different-sized cubes.
How it works…
We renamed the Node3D that was created when we added a 3D scene to
World. Then, we added the WorldEnvironment and DirectionalLight3D
nodes to the scene. If you hold down the Shift key and left-click on either of the
buttons at the bottom, you can add both nodes at the same time. We have light
in the scene so that we can see better.
We added a MeshInstance3D node as a child to World. We renamed the node
Ground. We changed the size of the ground to 15 x 15 to give us some room to
add cubes later. We added a new StandardMaterial3D so that we can change
the color of the ground to red. We did that so that we can easily see the snow
particles, which we will create later.
We added a MeshInstance3D node to the scene as a child of Ground. We
added a new BoxMesh to the Mesh property and then added a new
StandardMaterial3D to the Material property. In the StandardMaterial3D
properties, we changed the Albedo material to the color blue.
We added a StaticBody3D and CollisionShape3D by clicking on Create
Trimesh Static Body when we left-clicked on Mesh, which is to the right of
the Transform View at the top of the Viewport. This is easier to do by only
clicking on Create Trimesh Static Body.
We also clicked on the down arrow to the left of MeshInstance3D to hide the
StaticBody3D and CollisionShape3D children because we will duplicate this
cube later and it saves space in the Scene tab.
We duplicated the cube we created four times so that we have five cubes. We
then moved them using Select Mode (Q) to space them out on the ground
area. We changed to Scale Mode (R) to change the height and width of the
cubes so that we can see after adding the Heightmap that the particles will stay
on the top of each surface of the cube, no matter the height of the cube.
We created a GPUParticles3D as a child of the World node and renamed it
Snow. In the Inspector, we changed the value of Amount to 500, and in the
Time properties, we changed the Lifetime value to 2 s. The Amount value is
how many particles we will emit, and the Lifetime value is how long the
particles will last.
We clicked Process Material to see its properties. We added a new
ParticleProcessMaterial to the Process Material. We changed Emission
Shape to Box and changed the Box Extents x and z values to 5. This is so that
the snow will fall in the same area as the ground. We changed the Direction
property value of y to –1 so that the particles will fall downward. We changed
the Scale property Min and Max values to 0.2 to decrease the size of the
particles. We changed the Collision property Mode type to Rigid so that the
GPUParticlesCollisionHeightField3D node will work.
We clicked on Draw Passes in the Inspector to see its properties. Then, we
clicked on <empty> to the right of Pass 1 and selected a new SphereMesh
for the shape of our snow. We added a StandardMaterial3D to the Material
property.
Toward the bottom of the Inspector, we clicked Transform to open its
properties. We changed the Position property of y to 10 to raise the snow
higher. We changed the Scale x, y, and z properties to expand the snow to
cover the area of the ground. Remember to click the link icon, which is to the
right of the z value. If you don’t click that, all of the values will change to the
one that you selected.
We left-clicked on the World node and then added a
GPUParticlesCollisionHeightField3D node to the scene. We changed the
Size property values to 20 on x, y, and z. This increased the area of the
GPUParticlesCollisionHeightField3D node to cover the Ground node. Now,
we can see the snow hitting the tops of the cubes when it collides with them, no
matter how tall the cube is.
Setting up and moving the CharacterBody in 2D
In this recipe, we set up a 2D player character with the new
CharacterBody2D node that replaced the kinematic bodies used in Godot 3.x.
We will use free assets by Kenney for the player’s idle, jump, fall, and walk
animation.
The CharacterBody2D node has a basic default movement script that we will
add to the player and modify the script to show the animations.
Getting ready
For this recipe, click the + sign to the right of the Heightmap scene we just
completed to add a new scene. In the Scene tab, click on Other Node, and in
the Search box that appears, type cha and select CharacterBody2D, then click
the Create button. Now, we have CharacterBody2D as the base node for this
scene. Click on the word Scene in the main menu next to Project, then select
Save Scene As and name it Player2D.
Download Platformer Characters by Kenney from
https://www.kenney.nl/assets/platformer-characters and extract it to a new
folder.
How to do it…
We will create a player character using CharacterBody2D and use the default
script that you can use to move the player:
1. In the FileSystem tab, right-click on res:// and select New Folder. Name the folder Art.
2. After downloading the Platformer Characters files to a new folder, open the folder you created.
3. Open the PNG folder and then open the Player folder. You can use whichever one you want but I will
use Player for this recipe.
4. Open the Poses folder and drag player_idle, player_stand, player_fall.png, player_jump.png,
player_walk1, and player_walk2 into the Art folder that we created in the FileSystem tab.
5. Left-click on the + sign above the CharacterBody2D node to bring up the Create New Node
window.
6. In the Search box, type anim and select AnimatedSprite2D.
7. Click on Animation in the Inspector, then click on <empty> to the right of Frames and New
SpriteFrames.
8. Left-click on SpriteFrames, which is now where <empty> was, so that we can see the
SpriteFrames Animations at the bottom.
9. Under Animations, left-click on Default to rename the animation and type idle.
10. If the Art folder is not open, then double-click on the folder to open it.
11. Select player_idle.png, hold the Shift key, and then select player_stand.png. Drag the files into the
space under Animation Frames.
12. Left-click on 5 FPS located above Filter Animations to change Speed to 10:
Figure 4.2 – Bottom panel: SpriteFrames animation
13. Under Animations, click the icon to add a new animation.
14. Click new_animation and rename it walk.
15. Select player_walk1.png, hold the Shift key, and then select player_walk2.png. Drag the files into
the space under Animation Frames.
16. Left-click on 5 FPS located under Walk to change Speed: to 10.
17. To see the animation running, click on the Play selected animation from start button located four
icons to the right of 10 FPS above the first animation sprite or press Shift + D.
18. Click on the icon, then click new_animation and rename it jump.
19. Select the player_jump.png file in the Art folder and drag it into the space under Animation Frames.
20. Left-click on 5 FPS located under walk to change Speed to 10.
21. Click on the icon, then click new_animation and rename it fall.
22. Select the player_fall.png file in the Art folder and drag it into the space under Animation
Frames.
23. Left-click 5 FPS located under walk to change Speed to 10.
24. To look at the other animations in the Inspector, left-click on walk, which is to the right of
Animation, and select idle in the drop-down list of animations. You can also click on the animation in
the SpriteFrames editor and run the animation.
25. Left-click on CharacterBody2D in the Scene tab.
26. Left-click on the + sign above the CharacterBody2D node to bring up the Create New Node
window.
27. In the Search box, type coll and select CollisionShape2D to create a CollisionShape2D node.
28. In the Inspector, for CollisionShape2D, click <empty> to the right of Shape and select New
CapsuleShape2D.
29. Using the dots at the bottom and on the right, resize the CapsuleShape2D to fit the player.
30. Resize the CapsuleShape2D:
Figure 4.3 – Resizing the CapsuleShape2D
31. Left-click on the + sign above the CharacterBody2D node to bring up the Create New Node
window.
32. In the Search box, type cam and select Camera2D to create a Camera2D node.
33. In the Inspector, to the right of Enabled, left-click on On.
34. Right-click CharacterBody2D in the Scene tab and select Rename and then rename it Player.
35. In the Inspector, at the bottom, to the right of Script, click on <empty> and select New Script.
36. In Path, name the file Player.gd. Click on the Template checkbox to the right of Template. Notice
to the right of Template is CharacterBody2D Basic Movement. Click Create at the bottom:
Figure 4.4 – CharacterBody2D Basic Movement template
37. Click the + sign to the right of Player2D, then in the Scene tab, left-click Node2D.
38. Click on the word Scene in the main menu next to Project, then select Save Scene As or press Ctrl
+ Shift + S and name it Platform2D.
39. In the FileSystem tab, grab the Player2D.tscn file and drag it into the scene.
40. Grab the Icon.svg file in the FileSystem tab and drag it into the scene. Position and stretch the icon
under the player so that we have a platform.
41. Left-click on the + sign above the Node2D node to bring up the Create New Node window.
42. In the Search box, type static and select StaticBody2D to create a StaticBody2D node as a child
of Icon.
43. Left-click on the + sign above the Node2D node to bring up the Create New Node window.
44. In the Search box, type coll and select CollisionShape2D to create a CollisionShape2D node as a
child of StaticBody2D.
45. In the Inspector for CollisionShape2D, click <empty> to the right of Shape and select New
RectangleShape2D.
46. Use the dots at the top, bottom, right, and left to resize the RectangleShape2D to fit the Icon we are
using as a platform:
Figure 4.5 – Platform with RigidBody2D and CollisionShape2D
47. Click on Script at the top of the screen to see the player.gd script.
48. Under var gravity = ProjectSettings.get_setting("physics/2d/default_gravity") on line 8,
enter the following code:
9 @onready var animated_sprite = $AnimatedSprite2D
49. We will add the following to the func _physics_process(delta): function:
11 func _physics_process(delta):
12    # Add the gravity.
13    if not is_on_floor():
14       velocity.y += gravity * delta
15       if velocity.y <= 0:
16          animated_sprite.animation = "jump"
17       else:
18          animated_sprite.animation = "fall"
19    else:
20       if velocity.x == 0:
21          animated_sprite.animation = "idle"
22       else:
23          animated_sprite.animation = "walk"
24    # Handle Jump.
25   if Input.is_action_just_pressed("ui_accept") and is_on_floor():
26       velocity.y = JUMP_VELOCITY
27
28   # Get the input direction and handle the movement/deceleration.
29   # As good practice, you should replace UI actions with custom gameplay actions.
30   var direction = Input.get_axis("ui_left", "ui_right")
31   if direction:
32      velocity.x = direction * SPEED
33      if velocity.x < 0:
34         animated_sprite.flip_h = true
35      elif velocity.x > 0:
36         animated_sprite.flip_h = false
37  
38   else:
39      velocity.x = move_toward(velocity.x, 0, SPEED)
40
41   move_and_slide()
In the Platform2D scene, click the Run the current scene button in the
upper-right corner of the editor or hit the F6 key. Use the arrow keys to move
the player and the spacebar to jump.
How it works…
We created a new folder called Art under the FileSystem tab so that we can
place our player_idle, player_stand, player_walk1, and player_walk2 PNG files that we
downloaded in the Getting ready section of this recipe.
We added AnimatedSprite2D as a child node to CharacterBody2D so that we can
add idle and walk animations for our player.
We added a new SpriteFrames to Frames in the AnimatedSprite2D
Inspector. We renamed default to idle. We dragged the player_idle.png and
player_stand.png files at the same time by holding Shift after selecting the first
PNG file. As long as the second PNG file is right behind the first, it will select
both. If the files are spread out, you can hold down the Ctrl (Cmd on Mac)
button and select each file.
We then added a new animation named walk. Dragging player_walk1.png and
player_walk2.png into Animation Frames, we created a walking animation. We
added a jump and fall animation by creating a new animation and dragging the
PNG files into the respective animations.
We changed all of the animation speeds to 10 to make it look better. Lastly, we
looked at the animations by clicking the Play selected animation from start
button in the animation editor or pressing Shift + D. To change which
animation is showing, click to the right of Animation in the Inspector to
select the animation you want to see.
We selected the CharacterBody2D parent node so that we could add a
CollisionShape2D node as a child. We added the CollisionShape2D and
resized it to fit the player. We also added a Camera2D node as a child of the
CharacterBody2D node. In the Inspector, we left-clicked on On in the
Enabled property. Now, if we run the current scene (by pressing F6), the
camera will center on the player we just created.
We renamed the CharacterBody2D parent node Player. We added a new
script called Player.gd. We saw that when we created the script, there was a
default template called CharacterBody2D Basic Movement that already has
very basic movement code that we can use without writing code from scratch.
We created a new scene called Platform2D. We dragged the Player2D scene
into the Platform2D scene to use the player in this scene. We dragged the
Icon.svg file into the scene and then stretched it so that there is room for the
player to run. We added a StaticBody2D as a child to the Icon.svg file so that it
will react to physics. We then added a CollisionShape2D as a child to the
StaticBody2D to give the player something to stand on.
We edited the Player.gd script to get the animations to work. We added an
@onready annotation to line 9 to assign the AnimatedSprite2D node to the
animated_sprite variable. Lines 15-18 check to see if the velocity.y value is
negative and, if so, then it shows the jump animation.
If it is positive, then it shows the fall animation. Lines 19-23 check to see if the
velocity.x value is 0, in which case it shows the idle animation, but if it’s not,
then it shows the walk animation. Lines 33-36 check to see if the velocity.x
value is less than 0 or going to the left, then flip the animation by assigning true
to flip_h.
If the velocity.x value is greater than 0 or going to the right, then show the
default animation by assigning false to flip_h. We clicked Run in the
Platform2D scene to see how it looks.
Setting up and moving the CharacterBody in 3D
In this recipe, we set up a third-person 3D player character prototype with the
new CharacterBody3D node. We will create a scene with ground and the
player prototype, for which we use a CapsuleMesh with a BoxMesh for the
gun. We place a camera behind the player for a third-person perspective. We
add to the CharacterBody3D node the new CharacterBody3D: Basic
Movement template found in the Template section when creating a new
script.
Getting ready
For this recipe, click the + sign to the right of the Platform2D scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Right-click
on Node3D and select Rename in the drop-down list and rename it World. Click
on the word Scene in the main menu next to Project, then select Save Scene
As and name it Ground3D.
How to do it…
Let’s create a world scene with ground and a player with a camera following
the player:
1. Left-click the three vertical dots on the left of the Transform View on the Viewport toolbar.
2. Add the Sun and Environment nodes to the scene by left-clicking the Add Environment to Scene
button at the bottom while holding down the Shift key.
3. Left-click on the World node and then the + sign in the Scene tab. In the Create New Node window,
type mesh in the Search box and then select MeshInstance3D to create the node in the scene.
4. Right-click the MeshInstance3D node in the Scene tab and rename it Ground.
5. In the Inspector, click on <empty> to the right of Mesh and select New PlaneMesh.
6. Left-click on the same place to open the properties of the Ground mesh.
7. In the Inspector, change the Size property of x and y to 20.
8. Left-click on Mesh, which is to the right of the Transform View in the toolbar above the Viewport.
9. Select Create Trimesh Static Body from the drop-down list.
10. Click the + sign to the right of the Ground3D scene we just completed to add a new scene. In the
Scene tab, click Other Node, and in the Search box that appears, type cha and select
CharacterBody3D, then click the Create button.
11. Right-click on CharacterBody3D and select Rename from the drop-down list to rename it Player.
12. Click on the word Scene in the main menu next to Project, then select Save Scene As and name it
Player3D.
13. Left-click on the Player node and then the + sign in the Scene tab. In the Create New Node window,
type mesh in the Search box and then select MeshInstance3D to create the node in the scene.
14. Right-click on MeshInstance3D and select Rename from the drop-down list and rename it Body.
15. In the Inspector, click on <empty> to the right of Mesh and select New CapsuleMesh.
16. Left-click on the Player node and then the + sign in the Scene tab. In the Create New Node window,
type mesh in the Search box and then select MeshInstance3D to create the node in the scene.
17. Right-click on MeshInstance3D and select Rename from the drop-down list to rename it Gun.
18. In the Inspector, click on <empty> to the right of Mesh and select New BoxMesh.
19. Left-click Scale Mode (R) on the toolbar above the viewport or press the R key.
20. Shape the BoxMesh into a long rectangle and position it in the middle and to the right side of the
body by left-clicking Select Mode (Q) or pressing the Q key:
Figure 4.6 – BoxMesh shape and position
21. Left-click on the Player node and then the + sign in the Scene tab. In the Create New Node window,
type coll in the Search box and then select CollisionShape3D to create the node in the scene.
22. Click on <empty> to the right of Shape in the Inspector and select New CapsuleShape3D.
23. Left-click on the Player node and then the + sign in the Scene tab. In the Create New Node window,
type cam in the Search box and then select Camera3D to create the node in the scene.
24. Click on Camera3D in the Scene tab, making sure Select Mode (Q) is selected. Left-click and drag
the blue z arrow so that the camera is behind the player.
25. Use the green y arrow to pull the player up so that its y value is 1. Or, you could click Transform in
the Inspector and change the y value in Position to 1.
26. Click on the Player node, and in the Inspector, at the bottom, click <empty> on the right of Script
and select New Script from the drop-down list.
27. In the Path, change the name of the script to Player3D.gd and click on the Template checkbox to the
right of Template if it isn’t already checked. Notice to the right of Template: is CharacterBody3D:
Basic Movement, then click Create.
28. Click on the Ground3D scene, and in the FileSystem tab, select Player3D.tsn and drag it to World
in the Scene tab.
29. In the Ground3D scene, click the Run the current scene button in the upper-right corner of the
editor or hit the F6 key. Use the arrow keys to move the player and the spacebar to jump.
How it works…
We added DirectionalLight3D and WorldEnvironment to the scene by
clicking on the three vertical dots in the toolbar above the Viewport. We added
a MeshInstance3D and assigned the type of the mesh as PlaneMesh. We
renamed it Ground and created a Trimesh Static Body by left-clicking on
Mesh in the toolbar, which added a StaticBody3D and CollisionShape3D to
the Ground so that our player won’t fall through the ground.
We created a new CharacterBody3D scene and named it Player3D. We added
a MeshInstance3D node as a child to the CharacterBody3D and gave it a
CapsuleMesh, then we renamed it Body. We added another
MeshInstance3D and shaped it into a small rectangle and moved it to the
middle and to the right of the body capsule to simulate a gun. We also renamed
the rectangle Gun.
We created a CollisionShape3D for the Body to detect collisions. We created
a Camera3D and then moved it behind the player so that we have a thirdperson game instead of a first-person one. The camera follows the player
wherever it goes because it is a child of the Player node.
We moved the player up to ground level by changing the y Transform value to
1 in the Inspector or by selecting Select Mode (Q). We did this so that when
we use this scene in the Ground3D scene, it will be on the ground and not in
the middle.
We added a new script to the Player node that includes the
CharacterBody3D: Basic Movement template and named it Player3D.gd. As
long as the script is on a CharacterBody3D, the template will be available to
use instead of writing your own code from scratch.
You can use the template for a quick basic movement system that allows the
player to move left, right, up, and down, along with the ability to jump. You can
change the SPEED and JUMP_VELOCITY constant variables to move faster and jump
higher. The gravity variable in the template is tied to the default gravity setting
in Project Settings.
This means it is using the same gravity value as RigidBody nodes. You will
want to change the variable input direction to joysticks or to different keys
besides just the arrow keys. We dragged the Player3D.tsn scene into the
Ground3D scene from the FileSystem tab to the Scene tab. Then, we ran the
current scene to see how the movement and jump felt.
Using the new NavigationServer for 3D
In this recipe, we will create a scene with obstacles and create a
CharacterBody3D capsule to navigate from one end of the world to the other.
We will use the NavigationRegion3D node to set up the area on the map
where we can travel. We will use NavigationAgent3D on the
CharacterBody3D to interact with NavigationRegion3D to move along the
navigation path.
Getting ready
For this recipe, click the + sign to the right of the Player3D scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Right-click
on Node3D and select Rename in the drop-down list and rename it World. Click
on the word Scene in the main menu next to Project, then select Save Scene
As and name it NavServer3D.
How to do it…
First, we will create an area with obstacles so that we can set up an area that
we can travel in on the map:
1. Left-click the three vertical dots on the left of the Transform View on the Viewport toolbar.
2. Add the Sun and Environment nodes to the scene by left-clicking the Add Environment to Scene
button at the bottom while holding down the Shift key.
3. Left-click on the World node and then the + sign in the Scene tab. In the Create New Node window,
type mesh in the Search box and then select MeshInstance3D to create the node in the scene.
4. Right-click the MeshInstance3D node in the Scene tab and rename it Ground.
5. In the Inspector, click on <empty> to the right of Mesh and select New PlaneMesh.
6. Left-click on the same place to open the properties of the Ground mesh.
7. In the Inspector, change the Size property of x and y to 20.
8. Left-click on Mesh, which is to the right of the Transform View in the toolbar above the Viewport.
9. Select Create Trimesh Static Body from the drop-down list.
10. Click on <empty> to the right of Material in the Inspector and select New StandardMaterial3D
from the drop-down list.
11. Click on the same place that you did in step 10 to open the Material properties.
12. In the Material properties, click Albedo and then click the white bar to the right of Color.
13. Leave the R and G values at 255. Change the B value to 60.
14. Left-click on the down arrow on the left of Ground in the Scene tab to hide the child nodes of
Ground.
15. Left-click on the World node and then the + sign in the Scene tab. In the Create New Node window,
select the white node at the very top of Matches under the Search box.
16. Right-click on the white node and select Rename from the drop-down list and rename it Walls.
17. Left-click on Walls in the Scene tab and then the + sign in the Scene tab. In the Create New Node
window, type mesh in the Search box and then select MeshInstance3D to create the node in the
scene.
18. Right-click the MeshInstance3D node in the Scene tab and rename it Wall.
19. In the Inspector, click on <empty> to the right of Mesh and select New BoxMesh.
20. Left-click on Mesh, which is to the right of the Transform View at the top of the Viewport, and select
Create Trimesh Static Body.
21. Using Scale Mode (R) and Select Mode (Q), resize and position the walls around the edges of the
ground. After the first wall is positioned, press Ctrl + D on that wall and move on to the next wall, and
continue until the walls look like the ones shown in Figure 4.7:
Figure 4.7 – Wall positions for a navigation path
22. Click the arrow to the left of the white Walls node in the Scene tab to hide the child nodes of Wall.
23. Left-click on World in the Scene tab, then the + sign in the Scene tab. In the Create New Node
window, type nav in the Search box and then select NavigationRegion3D to create the node in the
scene.
24. Left-click the Ground and Walls nodes in the Scene tab and drag them onto the
NavigationRegion3D node.
25. In the Inspector, to the right of NavMesh, click on <empty> and select New NavigationMesh.
26. To the right of the Transform View, in the toolbar above the Viewport, left-click on Bake NavMesh.
27. Left-click on the World node and then the + sign in the Scene tab. In the Create New Node window,
type char in the Search box and then select CharacterBody3D to create the node in the scene.
28. Left-click on the CharacterBody3D node and then the + sign in the Scene tab. In the Create New
Node window, type mesh in the Search box and then select MeshInstance3D to create the node in
the scene.
29. In the Inspector, click on <empty> to the right of Mesh and select New CapsuleMesh.
30. Left-click on the CharacterBody3D node and then the + sign in the Scene tab. In the Create New
Node window, type coll in the Search box and then select CollisionShape3D to create the node in
the scene.
31. Click on <empty> to the right of Shape in the Inspector and select New CapsuleShape3D.
32. Left-click on the CharacterBody3D node and then the + sign in the Scene tab. In the Create New
Node window, type nav in the Search box and then select NavigationAgent3D to create the node in
the scene.
33. Left-click on the CharacterBody3D node, and in the Inspector, click Transform to open the
properties.
34. Change the Position x value to 8.5, the y value to 1, and the z value to 8.
35. Left-click on World in the Scene tab then the + sign in the Scene tab. In the Create New Node
window, type cam in the Search box and then select Camera3D to create the node in the scene.
36. In the Inspector, click Transform to see the properties.
37. In Position, change the value of y to 14.
38. In Rotation, change the value of x to –90.
39. Left-click on the CharacterBody3D node in the Scene tab.
40. In the Inspector, at the bottom, to the right of Script, click on <empty> and select New Script.
41. In the Attach Node Script window to the right of Path, change the name of the script to PathAI, and
to the right of Template, click the check mark to get rid of the template. It should say Empty now:
Figure 4.8 – Attach Node Script window
42. Click on the Create button to create the new script.
43. Enter the following code to the empty PathAI script:
   1   extends CharacterBody3D
   3   const SPEED = 15
   5   @onready var nav_agent = $NavigationAgent3D
   7   var target = Vector3(8.5, 1, -7)
   9   func _ready():
 10         nav_agent.set_target_position(target)
 12    func _physics_process(delta):
 13         if nav_agent.is_target_reachable():
 14              var next_location = nav_agent.get_next_path_position()
 15              var direction =
global_transform.origin.direction_to(next_location).normalized() * SPEED
 16              global_position += direction * delta
 17              move_and_slide()
44. In the NavServer3D scene, click the Run the current scene button in the upper-right corner of the
editor or hit the F6 key:
Figure 4.9 – PathAI script for CharacterBody3D
How it works…
We added DirectionalLight3D and WorldEnvironment to the scene by
clicking on the three vertical dots in the toolbar above the Viewport. We added
a MeshInstance3D and assigned the type of the mesh as PlaneMesh.
We renamed it Ground and created a Trimesh Static Body by left-clicking on
Mesh in the toolbar, which added a StaticBody3D and CollisionShape3D to
the Ground so that our player won’t fall through the ground. We added a
StandardMaterial3D to the ground so that we could change the color of the
ground.
We changed the color to yellow so that we can see the area we can navigate
and where we can’t. Then, we hid the child nodes of Ground so that we can
have more room in the Scene tab.
We created a container to hold our wall by selecting the white node in the
Create New Node window that comes up when we select the + sign in the
Scene tab. We renamed it Walls. We added a MeshInstance3D as a child of
the Walls container and added a BoxMesh to it so that we don’t get an error
when we add a Trimesh Static Body. We created a Trimesh Static Body on
it so that it will react to physics.
We renamed it Wall, and using Scale Mode (R) and Select Mode (Q), we
resized and positioned the walls around the edges of the ground. We duplicated
Wall by pressing Ctrl + D on the wall and resized and repositioned the walls
until they looked like those shown in Figure 4.7. Now, we have a navigational
path that we can use.
We closed the Walls container that we created to give us more room in the
Scene tab. We created a NavigationRegion3D node as a child to World. We
selected the Ground and Walls nodes and moved them onto
NavigationRegion3D so that Ground and Walls are a child of
NavigationRegion3D. We selected New NavigationMesh for NavMesh in
the Inspector. We clicked Bake NavMesh in the toolbar above the viewport to
show a navigation path that we will use later.
We created a CharacterBody3D as a child to this node we created a
MeshInstance3D and gave that a capsule shape. We clicked
CharacterBody3D to add a CollisionShape3D as a child to
CharacterBody3D and gave the CollisionShape3D a capsule shape. We
clicked on CharacterBody3D to add a NavigationAgent3D as a child of
CharacterBody3D. We will use this to interact with the NavigationRegion3D
that we created. We clicked on CharacterBody3D, and in the Inspector, we
changed the Transform Position values to start the CharacterBody3D in the
bottom-right corner.
We created a Camera3D node. We moved the camera up 14 on the y axis and
rotated the camera so that it looks down on the whole scene. Now, when we
run the current scene, we can see something.
We created a new empty script called PathAI with no CharacterBody3D
template so that we can code the capsule to move from the bottom of the
screen to the top using the NavigationRegion3D and NavigationAgent3D
nodes.
We added code to the PathAI script. In line 3, we have a constant variable named
SPEED set to 5. In line 5, we use @onready on the nav_agent variable that references
the NavigationAgent3D node, which is a child of the CharacterBody3D
node.
In line 7, we created a variable named target and gave it a Vector3 location,
which is in the top-right corner of the scene that we want to navigate. In lines
9-10, the _ready() function, we set the target location of nav_agent to the target
variable. In lines 12-17 in the _physics_process(delta) function, we first checked to
see if it was reachable, and if so, then we created a next_location variable equal
to nav_agent.get_next_position().
This is how the CharacterBody3D is going to move a step. We created a
variable called direction that references global_transform_origin, which is where
the CharacterBody3D is currently located.
direction_to(next_location).normalized() * SPEED calculated the next location to move
to by using the next_location variable in line 14. We used .normalized() to set the
vectors at a value of 1, then we multiplied the speed variable to move it at the
speed desired.
Line 16 moved the CharacterBody3D by updating global_position by
multiplying the direction variable with delta, which is the time elapsed in one
frame. In line 17, move_and_slide() actually moved the CharacterBody3D. Then,
we ran Current Scene (by pressing F6) to see the CharacterBody2D
navigate to the target.
Using NavigationServer2D for 2D projects
In this recipe, we are going to create a background using a MeshInstance2D
and four Shape2D instances as walls. We will create a CharacterBody2D with
a NavigationAgent2D node to interact with the NavigationRegion2D node
that we will add as a parent to the background so that we can create a
navigational area where the player can move. We will create a script to move
the CharacterBody2D to a target location on the opposite side of the map.
Getting ready
For this recipe, click the + sign to the right of the NavServer3D scene we just
completed to add a new scene. In the Scene tab, click 2D Scene. Click on the
word Scene in the top-left corner next to Project, then select Save Scene As
and name it NavServer2D.
How to do it…
Let’s create a background and walls as a child to the NavigationRegion2D
node:
1. Left-click on the Node2D node and then the + sign in the Scene tab. In the Create New Node
window, type nav in the Search box and then select NavigationRegion2D to create the node in the
scene.
2. In the Inspector, to the right of Navigation Polygon, click on <empty> and select New
NavigationPolygon.
3. Left-click on the NavigationRegion2D node and then the + sign in the Scene tab. In the Create
New Node window, type mesh in the Search box and then select MeshInstance2D to create the
node in the scene.
4. Right-click the MeshInstance2D node in the Scene tab and rename it Background.
5. In the Inspector, click on <empty> to the right of Mesh and select New BoxMesh.
6. Left-click on the same place to open the properties of the Background mesh.
7. In the Inspector, change the Size property of x and y to 100.
8. In the Inspector, left-click on Transform to show the transform properties.
9. To the right of Position, change the x value to 600px and the y value to 340px.
10. To the right of Scale, left-click the link icon so that the link is gray and broken.
11. Change the value of x to 12 and the value of y to 7 in Scale.
12. Left-click on the NavigationRegion2D node and then the + sign in the Scene tab. In the Create
New Node window, type sprite in the Search box and then select Sprite2D to create the node in
the scene.
13. Right-click the Sprite2D node in the Scene tab and rename it Wall.
14. In the FileSystem tab, drag icon.svg into <empty> to the right of Texture in the Inspector.
15. Click on Transform in the Inspector to show the Properties values.
16. To the right of Position, change the x value to 219px and the y value to 142px.
17. To the right of Scale, left-click the link icon so that it is gray, then change the x value to 1.75 and the
y value to 1.
18. Left-click on the Wall node we just added and then the + sign in the Scene tab. In the Create New
Node window, type static in the Search box and then select StaticBody2D to create the node as a
child of the Wall node.
19. While StaticBody2D is still selected, click on the + sign in the Scene tab. In the Create New Node
window, type coll in the Search box and then select CollisionShape2D to create the node in the
scene.
20. In the Inspector to the right of Shape, click <empty> and select New RectangleShape2D from the
drop-down list and adjust the shape to cover the whole Sprite2D Wall.
21. Click on the Wall node in the Scene tab and then Ctrl + D to duplicate the wall.
22. Click on Transform in the Inspector to see the properties of the Wall2 node.
23. Change the Position value of x to 346.5px and the value of y to 446px.
24. To the right of Scale, click on the link icon to turn it gray, then change the x value to 3.66 and the y
value to 1.
25. Click on the Wall2 node in the Scene tab and then Ctrl + D to duplicate the wall.
26. Click on Transform in the Inspector to see the properties of the Wall3 node.
27. Change the Position value of x to 680px and the value of y to 143px.
28. To the right of Scale, click on the link icon to turn it gray, then change the x value to 3.98 and the y
value to 2.28.
29. Click on the Wall3 node in the Scene tab and then Ctrl + D to duplicate the wall.
30. Click on Transform in the Inspector to see the properties of the Wall4 node.
31. Change the Position value of x to 970px and the value of y to 471px.
32. To the right of Scale, click on the link icon to turn it gray, then change the x value to 1.28 and the y
value to 2.08.
33. Click on the NavigationRegion2D node, and to the right of the view in the toolbar above the
viewport, there are three buttons: Create Points, Edit Points, and Erase Points. Click on Create
Points and click in the top-left corner, and click around the area the default camera can see and also
around the walls:
Figure 4.10 – Setting up the navigation path in the scene
34. Left-click on the Node2D node and then the + sign in the Scene tab. In the Create New Node
window, type char in the Search box and then select CharacterBody2D to create the node in the
scene.
35. Click on Transform in the Inspector to see the properties of the CharacterBody2D node.
36. Change the Position value of x to 13px and the value of y to 18px.
37. Left-click on the CharacterBody2D node and then the + sign in the Scene tab. In the Create New
Node window, type sprite in the Search box and then select Sprite2D to create the node in the
scene.
38. In the FileSystem tab, drag icon.svg into <empty> to the right of Texture in the Inspector.
39. Click on Transform in the Inspector to see the properties of the Sprite2D node.
40. To the right of Scale, click on the link icon to turn it gray, then change the x value to .16 and the y
value to .21.
41. Left-click on the CharacterBody2D node and then the + sign in the Scene tab. In the Create New
Node window, type coll in the Search box and then select CollisionShape2D to create the node in
the scene.
42. Click <empty> to the right of Shape and select New CapsuleShape2D.
43. Left-click on the CharacterBody2D node and then the + sign in the Scene tab. In the Create New
Node window, type nav in the Search box and then select NavigationAgent2D to create the node in
the scene.
44. Left-click on the CharacterBody2D node, and at the bottom of the Inspector, click on <empty> to
the right of Script, then select New Script.
45. In the Attach Node Script window to the right of Path, change the name of the script to Nav2D.
Check to the right of Template to see if it is empty. If it is not, then click the check mark to get rid of
the template. It should say Empty now.
46. Click on the Create button to create the new script.
47. Enter the following code to the empty Nav2D.gd script:
1   extends CharacterBody2D
3   const SPEED = 100
5   @onready var nav_agent = $NavigationAgent2D
7   @export var target = Vector2(1125, 525)
9   func _ready():
10      nav_agent.set_target_position(target)
12  func _physics_process(delta):
13      if nav_agent.is_target_reachable():
14           var next_location = nav_agent.get_next_path_position()
15           var direction =
global_transform.origin.direction_to(next_location).normalized() * SPEED
16           global_position += direction * delta
17           move_and_slide()
48. In the NavServer2D scene, click the Run the current scene button in the upper-right corner of the
editor or hit the F6 key.
How it works…
We added a NavigationRegion2D node to the scene and added a new
NavigationPolygon in the Navpoly property. We added a MeshInstance2D
node as a child of the NavigationRegion2D node and renamed it
Background. We added a BoxMesh to the Mesh property. We changed the
Size values of x and y to 100.
We opened the Transform properties in the Inspector to change the Position
x value to 600px and the y value to 340px to center it so that the default camera
can see the background. We left-clicked the link icon so that we can change
both x and y values to the values we want. We changed the Scale of value x to
12 and y to 7 so that it covers the area that the default camera will show.
We made our first wall shape by creating a Sprite2D as a child of the
NavigationRegion2D node and renaming it Wall. We dragged the icon.svg file
into <empty> to the right of Texture in the Inspector so that we can see it.
We changed the Position value of x to 219 and the value of y to 142.
Then, we changed the values of Scale of the wall to x – 1.75 and y to 1. Clicking
on the Wall node, we added a StaticBody2D as a child of Wall. Then, we
added a CollisionShape2D as a child to StaticBody2D with a new
RectangleShape2D, which will cover the area of the Wall node.
We duplicated the Wall node and changed its position three times so that we
have a total of four walls. This is so that we have some walls in between the
start position of our CharacterBody2D that we will build later and a target
position we will program the CharacterBody2D to navigate to.
Then, we clicked the NavigationRegion2D node and noticed that in the
toolbar above the viewport on the right of View are three buttons, which we
used to add the navigation area to be used by our CharacterBody2D that we
will create next. Figure 4.10 shows where to add the points.
We created a CharacterBody2D as a child of Node2D. We changed the x and
y positions in Transform so that they will start in the top left-hand corner. We
added a Sprite2D as a child of CharacterBody2D and added the icon.svg file to
the Texture property so that we can see it.
We scaled it down to .16 on x and .21 on y so that it will be smaller than the
walls and fit through some of the narrower paths. We added a
CollisionShape2D as a child of CharacterBody2D and used a
CapsuleShape2D for the Shape property. Then, we added a
NavigationAgent2D as a child of CharacterBody2D so that it can react with
the NavigationRegion2D and move in the navigation path we set up
previously.
We created a new script and named it Nav2D.gd. We did not include the
CharacterBody2D default template. In line 3, we created a constant variable
named SPEED and set its value to 100. In line 5, we used @onready on the nav_agent
variable that references the NavigationAgent2D node, which is a child of the
CharacterBody2D node.
In line 7, we used @export so that we can change the target location in the
Inspector. The variable target is equal to Vector2(1125, 525), which is located on
the far-right side of the screen. In lines 9-10, the _ready() function, we set the
target location of nav_agent to the variable target.
In lines 12-17, in the _physics_process(delta) function, we first checked to see if it
was reachable, and if so, then we created a next_location variable equal to
nav_agent.get_next_position(). This is how the CharacterBody2D is going to move
a step. We created a variable called direction that references
global_transform_origin, which is where the CharacterBody2D is currently
located.
direction_to(next_location).normalized() * SPEED calculated the next location to move
to by using the next_location variable in line 14. We used .normalized() to set the
vectors at a value of 1, then we timed the speed to move it at the speed desired.
Line 16 moves the CharacterBody2D by updating global_position by multiplying
the direction variable with delta, which is the time elapsed in one frame.
In line 17, move_and_slide() actually moved the CharacterBody2D. We ran
Current Scene (by pressing F6) to see the CharacterBody2D navigate to the
target. If you want, you can change the target values in the Inspector to see it
pick a path to get to the new target.
Using SoftBody for 3D games
In this recipe, we will create a banner using SoftBody3D. We are going to
create a ground with two poles that we will attach to the banner, and when we
play the scene the banner will fall, and you can see how the SoftBody3D
reacts.
Getting ready
For this recipe, click the + sign to the right of the NavServer2D scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on the
word Scene in the main menu next to Project, then select Save Scene As and
name it SoftBody3D. Right-click Node3D and select Rename, and rename it World.
How to do it…
Let’s first create a basic area with the ground and two poles along with a
camera:
1. Left-click the three vertical dots on the left of the Transform View on the Viewport toolbar.
2. Add the Sun and Environment nodes to the scene by left-clicking the Add Environment to Scene
button at the bottom while holding down the Shift key.
3. Left-click on the World node and then the + sign in the Scene tab. In the Create New Node window,
type mesh in the Search box and then select MeshInstance3D to create the node in the scene.
4. Right-click the MeshInstance3D node in the Scene tab and rename it Ground.
5. In the Inspector, click on <empty> to the right of Mesh and select New PlaneMesh.
6. Left-click on the same place to open the properties of the Ground mesh.
7. In the Inspector, change the Size property of x and y to 10.
8. Left-click on the World node and then the + sign in the Scene tab. In the Create New Node window,
type mesh in the Search box and then select MeshInstance3D to create the node in the scene.
9. Right-click the MeshInstance3D node in the Scene tab and rename it Pole.
10. In the Inspector, click on <empty> to the right of Mesh and select New CylinderMesh.
11. Left-click on the same place to open the properties of CylinderMesh.
12. Change the Top Radius and Bottom Radius property values to .2m on each.
13. Change the Height property value to 6m. If the pole is below the ground, then click and drag the y
arrow to bring it level with the ground.
14. Scroll down in the Inspector and click on Transform to open the properties.
15. Change the Position property of the y and z values to 3.
16. Left-click on Mesh, which is to the right of the Transform View in the toolbar at the top of the
Viewport, and select Create Trimesh Static Body.
17. Click on Pole and then Ctrl + D to duplicate the Pole we just created.
18. Scroll down in the Inspector and click on Transform to open the properties.
19. Change the Position property of the z value to 0.
20. Left-click on the World node and then the + sign in the Scene tab. In the Create New Node window,
type soft in the Search box and then select SoftBody3D to create the node in the scene.
21. In the Inspector, click on <empty> to the right of Mesh and select New PlaneMesh.
22. Left-click on the same place to open the properties of the PlaneMesh.
23. Change the Size properties of the x value to 2.6m and the y value to 1.5m.
24. Change the Subdivide Width value to 7 and the Subdivide Depth value to 7.
25. Change Orientation to Face X.
26. In the Inspector, click on <empty> to the right of Material right under Orientation and select New
StandardMaterial3D.
27. Left-click on the same place to open the properties of the StandardMaterial3D.
28. Click on Transparency to open its properties.
29. To the right of Cull Mode, select Disabled in the drop-down list.
30. Click on Albedo to open its properties.
31. Click on the white box to the right of Color.
32. In the Hex field, enter 89ffff.
33. Using Select Mode (Q), click on the y arrow and move the banner up in between the two poles so
that the bottom of the banner is even with the tops of the poles.
34. Click on the bottom-left and bottom-right dots, which are also touching the poles.
35. Place the banner above the poles and attach the banner to the two poles:
Figure 4.11 – Banner placement
36. At top of the Inspector, change the value of Simulation Precision to 10.
37. Change the value of Total Mass to 0.
38. Change the value of Linear Stiffness to .01.
39. Left-click on the box to the right of Pinned Points to see the two points we clicked on in step 34.
40. In the Inspector, click Attachments and then on the down arrows to the left of 0 and 1 to see the
properties of each attachment.
41. In 0, click on Assign, which is to the right of Spatial Attachment Path, and select
CollisionShape3D in Pole.
42. In 1, click on Assign, which is to the right of Spatial Attachment Path, and select
CollisionShape3D in Pole2.
43. Left-click on the World node and then the + sign in the Scene tab. In the Create New Node window,
type cam in the Search box and then select Camera3D to create the node in the scene.
44. In the Inspector, change the value of FOV to 100.
45. Click on Transform to see its properties.
46. Change the Position values of x to 5 and y to 1.
47. Change the Rotation value of y to 90.
48. In the SoftBody3D scene, click the Run the current scene button in the upper-right corner of the
editor or hit the F6 key.
How it works…
We added the WorldEnvironment and DirectionalLight3D nodes to the
scene. If you hold down the Shift key and left-click either button at the bottom,
you can add both nodes at the same time. We added a MeshInstance3D node
as a child to World. We renamed the node Ground. We changed the size of the
ground to 10 x 10 to give us some room to add two poles.
We created two poles that will hold up our banner. We created a
MeshInstance3D, renamed it Pole, and added a CylinderMesh. We opened
the CylinderMesh properties in the Inspector and changed the values of Top
Radius and Bottom Radius to .2m. We changed the Height value to 6m and
made sure the bottom of the pole was set on the ground. In the Transform
section of the Inspector, we changed the y and z Position values to 3.
We created a Trimesh Static Body by left-clicking on Mesh located to the
right of the Transform View in the toolbar at the top of the Viewport. This
added a StaticBody3D and a CollisionShape3D to interact with the physics
engine. Then, we duplicated the pole and changed its Transform z value to 0 to
move it over so that we could put the banner in between the two poles.
We created a SoftBody3D node, and for the Mesh, we selected a PlaneMesh
to simulate the fabric of a banner. We changed the size so that it could fit in
between the two poles. We changed the Subdivide Width and Subdivide
Depth values to give the banner flexibility. We changed the Orientation value
to Face X so that the banner can be seen along the x axis.
We added a new StandardMaterial3D to Material so that we can see a
banner. In the Transparency properties, we disabled Cull. Since we used a
PlaneMesh for the Mesh, only one side can be seen by default. When we
disabled Cull, we could then see both sides of the banner. We clicked Albedo
and changed the color of the material so that we can see the banner more
easily.
We dragged the banner to the top of the poles so that the bottom of the banner
could attach to each pole. When we run the scene after we are done, the
banner will fall down so that we can see how the SoftBody3D banner reacts to
gravity.
Changing the values of Simulation Precision, Total Mass, and Linear
Stiffness makes the banner flexible. Simulation Precision can affect
performance while improving the simulation, so when making your own
projects, you might want to try values until it feels right.
We only clicked on the box to the right of Pinned Points to show you the
points that were added when we clicked on the bottom two dots to connect the
banner to the poles.
We clicked Attachments in the Inspector to see the properties. We clicked
the down arrows to the left of 0 and 1 to show the two points we added that
connected the banner to the two poles. In 0, we assigned the
CollisionShape3D of Pole to the left point, which was the first point we
clicked on. In 1, we assigned the CollisionShape3D of Pole2 to the right point,
which was the second point we clicked on. 0 and 1 in Attachments correspond
to 0 and 1 in Pinned Points, which we looked at previously.
We added a Camera3D node so that we can see the scene when we run the
current scene. We changed the FOV value to 100 so that the camera can see
more of the scene from its position. We changed the rotation value of y to 90 so
that the camera can see the banner. Then, we clicked the Run the current
scene button to see how the banner reacts when it falls while it is connected to
each pole.
5
Playing with Shaders in Godot 4
In this chapter, we start with looking at the Shader Creation dialog to create
shaders and also look at the new features in the shader language in Godot 4.
We will examine how to use Global Uniforms and Instance Uniforms with
shaders. With visual shaders, we start by looking at the Visual Shaders
Context menu.
We will work with Integer and Comment nodes. We create nodes using
Texture3D and CurveTexture. We look at the Billboard and UVFunc nodes.
We play with the Sky Shader mode to create sky shaders. We will examine the
Fog Shader mode to see what we can do with it.
In this chapter, we will cover the following recipes:
Creating shaders with the Shader Creation dialog
Exploring Uniform Arrays in the Godot 4 shader language
How to use Global Uniforms
Using Instance Uniforms with shaders
Exploring the Visual Shaders Context menu
Working with Integer and Comment nodes
Creating nodes using Texture3D and CurveTexture
Using the Billboard node
Using the UVFunc node
Improving the Sky Shader mode
What the Fog Shader mode can do
Technical requirements
For this chapter, you need the standard version of Godot 4.0 or later running
on one of the following:
Windows 64-bit or 32-bit
macOS
Linux 64-bit or 32-bit
Android
Web Editor
You can find the code and project files for the projects in this chapter on
GitHub at https://github.com/PacktPublishing/Godot-4-Game-DevelopmentCookbook/tree/main/Chapter%205.
Creating shaders with the Shader Creation dialog
In this recipe, we take a look at the new Shader Creation dialog and the
options you can select when you create shaders in Godot 4 such as Spatial,
Canvas Item, Particles, Sky, and Fog.
Getting ready
For this recipe, open Godot 4 and start a new project called Chapter 5. In the
Scene tab, click 3D to add a 3D scene. Click on Scene in the main menu next
to Project, then select Save Scene As, and name it Creationdialog.
How to do it…
Let’s add a PlaneMesh to the scene and then add a new ShaderMaterial in
the Material property where we can create a shader and see the new Shader
Creation dialog:
1. Left-click on the Node3D node and then press the + sign in the Scene tab. In the Create New Node
window, type mesh in the Search box and then select MeshInstance3D to create the node in the
scene.
2. In the Inspector, click on <empty> to the right of the mesh and select New PlaneMesh.
3. Left-click on the same place to open the properties of MeshInstance3D.
4. Click on <empty> to the right of Material in the Inspector and select New ShaderMaterial from
the drop-down list.
5. Click on <empty> to the right of Shader in the Inspector and select New Shader from the dropdown list. A Create Shader dialog box appears:
Figure 5.1 – Material Shader location in the Inspector
6. Left-click the down arrow to the right of Type: Shader to select either a Shader or a VisualShader
to create.
7. Left-click the down arrow to the right of Mode: Spatial to select Spatial, Canvas Item, Particles,
Sky, and Fog:
Figure 5.2 – Create Shader dialog mode: options
8. Left-click the down arrow to the right of Template: Default to select either a Default or an Empty
script.
9. Below that, see the Built-in Shader button and Path: where the script is saved.
How it works…
We created a new MeshInstance3D, and for the Mesh property, we selected a
PlaneMesh. For the Material property, we selected a new ShaderMaterial,
and in the Shader property, we selected New Shader from the drop-down to
bring up the Create Shader dialog.
We look at the Create Shader dialog box and its options. In Type:, we can
select Shader or VisualShader. Shader is selected when you want to program
a shader using shader language. VisualShader is selected when you want to
use visual shaders where you program shaders with a visual editor.
Selecting the Spatial mode is for shading 3D objects. The Canvas Item
selection is for shading 2D objects. The Particles selection is used to calculate
particle properties such as color, position, and rotation for both 2D and 3D. The
Sky selection is used for drawing sky backgrounds and updating radiance
cubemaps, which are used for image-based lighting. The Fog selection is used
to define how fog is added or subtracted in an area with FogVolume or
volumetric fog.
We see in Template: that we can start the shader script with a default
template or an empty shader script. Below Template: is the checkbox for
Built-in Shader. Path: is where you can edit the name of the shader.
Exploring Uniform Arrays in the Godot 4 shader
language
In this recipe, we create a shader on a MeshInstance3D that uses the new
Uniform Array, which is a Vector3 array and holds three colors—red, green, and
blue—in the array.
Getting ready
For this recipe, open Godot 4 and open the project from the last recipe, called
CreationDialog.
How to do it…
Let’s use the new Uniform Arrays and structs in the shader language with the
plane we created in the last recipe:
1. Left-click on MeshInstance3D in the Scene tab.
2. Click on <empty> to the right of Material in the Inspector and select New ShaderMaterial from
the drop-down list.
3. Click on <empty> to the right of Shader in the Inspector and select New Shader from the dropdown list, as shown in Figure 5.1.
4. To the right of Path:, rename CreationDialog.gdshader to Recipe2.gdshader and click the Create
button.
5. Left-click on Recipe2.gdshader, which is to the right of Shader in the Inspector.
6. In the Shader Editor, at the bottom, enter the following code:
1   shader_type spatial;
2
3   uniform vec3 array[3];
4   
5   void fragment() {
6      ALBEDO = array[2];
7   }
7. In the Inspector under Shader Parameters | Array, click the + Add Element button three times to
match the array size:
In the 0 position, change the x value to 1
In the 1 position, change the y value to 1
In the 2 position, change the z value to 1:
Figure 5.3 – The Shader parameters in the Inspector
How it works…
We left-clicked on MeshInstance3D so that we can add a shader. In the
Material properties in the Inspector, we selected a new ShaderMaterial
from the drop-down list that appeared when we clicked on <empty>. In the
Material properties in the Inspector, we clicked on <empty> to the right of
Shader to bring up the Shader Creation dialog. We changed the name of the
shader script to Recipe2 and then left-clicked on Recipe2.gdshader so that we
could see the gdshader script.
We wrote the shader code. In line 1, we see that the shader_type value is spatial,
which is for 3D. In line 3, we used the new Uniform Array. We created a
uniform Vector3 array that holds three values. In the fragment function, we assign
ALBEDO to the array, pointing to [2], which is the last value in the array.
After we changed the values in the Inspector, we could come back and change
these values to [0] and [1]. Remember to add a semicolon at the end of each
line so that you don’t get any errors. The Shader language is different from
GDScript.
We looked in the Inspector for shader parameters that appear because we
created the Vector3 array. We clicked on the + Add Element button at the
bottom of Size so that we can change the three Vector3 values.
In the first position of this array, [0], we changed the x value to 1. This will
change the MeshInstance3D to the color red. In the second position of this
array, [1], we changed the y value to 1. This will change the MeshInstance3D
to the color green. In the third position of the array, [2], we changed the z value
to 1. This will change the MeshInstance3D to the color blue.
How to use Global Uniforms
In this recipe, we go into Project Settings and create a Shader Global
Uniform that is a red color. We create a PlaneMesh and call the Shader
Global Uniform from a shader script to change the plane color to red, then we
create a script and change the color to blue using GDScript.
Getting ready
For this recipe, open Godot 4 and open the project from the last recipe, called
CreationDialog.
How to do it…
We start by removing the Recipe2.gdshader script from MeshInstance3D and
then create the global shader:
1. Left-click on MeshInstance3D, and in the Inspector in the Material section, click on the Set to
default icon to the right of Shader and to the left of Recipe2.gdshader, as seen in Figure 5.3 just
below the blue ball.
2. Click on Output on the bottom panel of the editor to the right of the FileSystem tab.
3. Click on Project in the main menu located on the top left of the editor.
4. Select Project Settings in the drop-down list.
5. Select the Shader Globals tab.
6. In the Name field, type Red.
7. In the Type field, select Color.
8. Click on the Add button.
9. Left-click on the black bar on the right of Red and change the R value to 255:
Figure 5.4 – The Shader Globals tab
10. Click on the Close button.
11. Click on the Set to default icon to the right of Shader and then on <empty> to the right of Shader
in the Inspector and select New Shader from the drop-down list.
12. To the right of Path:, rename CreationDialog.gdshader Recipe3.gdshader and click the Create
button.
13. Left-click on Recipe3.gdshader, which is to the right of Shader in the Inspector.
14. In the Shader Editor, at the bottom, enter the following code.
1   shader_type spatial;
2
3   global uniform vec4 Red;
4   
5   void fragment() {
6      ALBEDO = Red.xyz;
7   }
15. Left-click on the Node3D node and then press the + sign in the Scene tab. In the Create New Node
window, type cam in the Search box and then select Camera3D to create the node in the scene.
16. Left-click on Transform in the Inspector and change the Position y value to 1 and the z value to 3.
17. Left-click on Node3D in the Scene tab.
18. In the Inspector, click on <empty> to the right of Script and select New Script.
19. In Path, rename the script Recipe3.gd:
1 extends Node3D                     
2                              
3 func _ready():                     
4   RenderingServer.global_shader_parameter_set("Red", Color.BLUE)
20. In the CreationDialog scene, click the Run the current scene button in the upper-right corner of
the editor or hit the F6 key.
How it works…
We removed the Recipe2.gdshader script from MeshInstance3D so that we can
use a new script. We clicked on Output at the bottom panel of the editor so
that we don’t see the Shader Editor since we removed it.
We opened Project Settings, located in the Project menu of the editor. We
selected the Shader Globals tab to add a new global shader. We named the
shader Red and selected Color as the Type value. Then, we clicked on the Add
button and left-clicked the black bar that appeared and changed the R value to
255 so that it was red. We clicked the Close button to close the Project
Settings window.
We looked in the Material properties in the Inspector, and we clicked on
<empty> to the right of Shader to bring up the Shader Creation dialog. We
changed the name of the shader script to Recipe3 and then left-clicked on
Recipe3.gdshader so we could see the gdshader script.
In line 1, we saw that the shader_type value is spatial, which is for 3D. In line 3,
we used the vec4 Global Uniform to get the Red global shader that we set up
earlier. In the fragment function, we assign ALBEDO to the Red global shader
that we set up in Project Settings. We see the plane is red in the scene.
We added a Camera3D to the scene and changed its Transform position so
that it is behind and above the MeshInstance3D. We can see it change its
color when we run the scene after we create a new GDScript script and add the
code.
We created a new script on the Node3D node called Recipe3.gd. In the _ready()
function, we call the global_shader_parameter_set method in RenderingServer. We use
Red and Color.BLUE as parameters. Red gets the global shader we set up and
Color.BLUE changes the shader to use the color blue.
We click the Run the current scene button and see the MeshInstance3D is
now blue. If you take the script off of Node3D and click on 3D in the
Workspaces section of the editor (the top center) to look at the scene, you can
see the MeshInstance3D is back to the color red because the shader is not
overwritten now.
Using Instance Uniforms with shaders
In this recipe, we will create two instance uniform variables—color and
alphachannel—in a shader script. We see that the variables that we created can
now be seen in Inspector and changed from there, not from the script.
Getting ready
For this recipe, click the + sign to the right of the CreationDialog scene we
just completed to add a new scene. In the Scene tab, click 3D Scene. Click on
Scene in the top-left corner next to Project, then select Save Scene As, and
name it InstanceUniforms.
How to do it…
Let’s add MeshInstance3D with a PlaneMesh and then write a shader script
with the two Instance Uniforms:
1. Left-click on the Node3D node and then press the + sign in the Scene tab. In the Create New Node
window, type mesh in the Search box and then select MeshInstance3D to create the node in the
scene.
2. In the Inspector, click on <empty> to the right of Mesh and select New PlaneMesh.
3. Left-click on the same place to open the properties of the MeshInstance3D.
4. Click on <empty> to the right of Material in the Inspector and select New ShaderMaterial from
the drop-down list.
5. Click on ShaderMaterial, then click on <empty> to the right of Shader in the Inspector and select
New Shader from the drop-down list.
6. To the right of Path:, rename InstanceUniforms.gdshader to Recipe4.gdshader and click the
Create button.
7. Left-click on Recipe4.gdshader, which is to the right of Shader in the Inspector.
8. In the Shader Editor, at the bottom, enter the following code.
1   shader_type spatial;
2
3   instance uniform vec3 color;
4   instance uniform float alphachannel = 1;
5
6   void fragment() {
7       ALBEDO = color.xyz;
8       ALPHA = alphachannel;
9   }   
9. In the Inspector, at the bottom of the GeometryInstance3D section, click on Instance Shader
Parameters. If you don’t see this, then click on the CreationDialog tab and then go back to the
Instance Uniforms tab.
10. In the Color section, change the x value to 1 and the y value to 1.
11. Change the value of Alphachannel to .1.
How it works…
We created a new MeshInstance3D, and for the Mesh property, we selected a
PlaneMesh. For the Material property, we selected a new ShaderMaterial,
and in the Shader property, we selected New Shader from the dropdown to
bring up the Create Shader dialog. We changed the name to Recipe4.gdshader.
We left-clicked on Recipe4.gdshader in the Inspector to bring up the Shader
Editor. Line 1 states that this shader is spatial, which is for 3D. In line 3, we
created an Instance Uniform that is a Vector3 array called color. We used a
Vector3 array because of the red, green, and blue values of a color. In line 4, we
created an Instance Uniform that is a float called alphachannel.
With this, we can give a float value to the alphachannel Instance Uniform of the
color. If we set it at 0, you can see through it. In the fragment function on line 7,
we set the ALBEDO value of the MeshInstance3D to the Instance Uniform
color. In line 8, we set the ALPHA value to the alphachannel Instance Uniform.
These now show up in the Inspector under Instance Shader Parameters,
where we can change the values.
We looked at Instance Shader Parameters in the Inspector at the bottom of
the GeometryInstance3D section. We changed the Color x and y values to 1
to make it yellow. We changed the alphachannel value to .1, and now we can see
through it.
Exploring the Visual Shaders Context menu
In this recipe, we use visual shaders to change the color of the panel to yellow
with Vector3Parameter and ColorOp, which we create using the Visual
Shaders Context menu.
Getting ready
For this recipe, click the + sign to the right of the InstanceUniforms scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on
Scene in the top-left corner next to Project, then select Save Scene As, and
name it VSContextMenu.
How to do it…
We start with MeshInstance3D with a PlaneMesh and then create a visual
shader:
1. Left-click on the Node3D node and then press the + sign in the Scene tab. In the Create New Node
window, type mesh in the Search box and then select MeshInstance3D to create the node in the
scene.
2. In the Inspector, click on <empty> to the right of Mesh and select New PlaneMesh.
3. Left-click on the same place to open the properties of the MeshInstance3D.
4. Click on <empty> to the right of Material in the Inspector and select New ShaderMaterial from
the drop-down list.
5. Click on ShaderMaterial, then click on <empty> to the right of Shader in the Inspector and select
New Shader from the drop-down list.
6. To the right of Type:, click the down arrow on the far right and select VisualShader, then click the
Create button.
7. Click VSContextMenu.tres to the right of Shader.
8. In the bottom panel where Output is on the left, on the far right, click the Expand Bottom Panel
(Shift + F12) button:
Figure 5.5 – Visual Shader fullscreen
9. Right-click on anywhere outside of the Output box to bring up the Create Shader Node menu and
select Color | Common | ColorOp, then press the Create button:
Figure 5.6 – Create Shader Node menu
10. In ColorOp to the right of Op, click the down arrow.
11. To the left of a, left-click on 0,0,0, then click on y, and change the value to 1.
12. Left-click on the dot on the right side and drag it to the dot to the left of Albedo.
13. Left-click on ColorOp to select the node. Right-click on ColorOp to see the new Visual Shaders
Context menu and select Add Node at the top of the menu:
Figure 5.7 – Visual Shaders Context menu
14. In the Create Shader Node menu, select Vector | Variables | Vector3Parameter.
15. In the Vector3Parameter node to the right of Qualifier, left-click on the down arrow on the far right
and select Instance from the drop-down list.
16. For the Default Value Enabled: value, check the On checkbox.
17. In Default Value:, change the x value to 1.
18. In the Vector3Parameter node, left-click on the dot on the right side and drag it to b in the ColorOp
node:
Figure 5.8 – Vector3Parameter node
19. Click on the button at the bottom right of the viewport to see that the MeshInstance3D MeshPlane
is yellow as well as Material in the Inspector.
How it works…
We created a new MeshInstance3D, and for the Mesh property, we selected a
PlaneMesh. For the Material property, we selected a new ShaderMaterial,
and in the Shader property, we selected New Shader from the dropdown to
bring up the Create Shader dialog. In the Create Shader dialog, we selected
VisualShader as the type of shader we want to create. We clicked
VSContextMenu.tres to the right of Shader to open the Visual Shader
screen and then clicked the Expand Bottom Panel (Shift + F12) button to see
it in fullscreen.
We clicked anywhere outside of the Output node to bring up the Create
Shader Node menu, where we selected ColorOp. We clicked on the down
arrow to the right of 0,0,0 a op to unhide the shader. Then, we clicked on 0,0,0
to change the value of y to 1. We clicked on the dot on the right side of the
ColorOp node and dragged it to the dot to the left of Albedo. This connects
ColorOp to Albedo for the shader. The color of our MeshInstance3D is now
green. We can confirm that by clicking on the button at the bottom right of the
viewport.
We left-clicked on the ColorOp node to select that node. The ColorOp node
should be highlighted in blue. We right-clicked on the very top of ColorOp to
see the new Visual Shaders Context menu and selected Add Node at the top
of the menu to add the Vector3Parameter node. The other new things in the
new Visual Shaders Context menu are Cut, Copy, Paste, Delete, Duplicate,
and Clear Copy Buffer. In some nodes, such as the Vector3Parameter node,
there is an option to convert parameters in to constants.
For the Vector3Parameter node’s Qualifier value, we selected Instance. We
enabled Default Value Enabled: by checking the On checkbox. A Default
Value box appeared, and we changed the value of x to 1. Then, we connected
the Vector3Parameters node by dragging the dot on the right of this node to
the ColorOp node’s dot on the left of b. Then, we clicked the button on the
bottom right of the viewport to confirm the MeshInstance3D is yellow.
The ColorOp node displays an error that it can’t show the result retrieved from
the Instance parameter, which means there is no preview color shown in the
ColorOp node. The MeshInstance3D changed from green to yellow.
Working with Integer and Comment nodes
In this recipe, we use the IntConstant, IntFunc, and IntOp nodes to input
values that will connect to a VectorCompose node, which will connect to the
Albedo material of the MeshInstance3D PlaneMesh. We also use the
Comment node to group all of the Integer nodes together and type a comment
about the nodes.
Getting ready
For this recipe, we will stay in VSContextMenu from the last recipe. In the Material
section in the Inspector, to the right of Shader, click on the counterclockwise
circle to the left of the VSContextMenu.tres file to make the field empty. Click on
<empty> and select New Shader from the drop-down list. In the Type section,
select Visual Shader and then name it IntComNodes.
How to do it…
To see how the Integer nodes work, we are going to create more than you
would normally use and also use the new Comment node:
1. Click on the Distraction Free Mode (Ctrl + Shift + F11) button located just to the left of the word
Inspector at the top of the Inspector.
2. Right-click anywhere to the left of the Output node in the Visual Shader Editor and type vectorc or
go to Vector | Common | VectorCompose and then select VectorCompose from the Create Shader
Node menu. Click the Create button.
3. Under VectorCompose, make sure Vector3 is selected. If not, click on the down arrow on the right
and select Vector3 from the drop-down list.
4. Left-click and drag the dot on the right to the dot to the left of Albedo in the Output node.
5. Right-click anywhere to the left of VectorCompose node in the Visual Shader Editor and type int or
go to Scaler | Variables | IntConstant and then select IntConstant from the Create Shader Node
menu.
6. Left-click on 0 and change the value to 1.
7. Press Ctrl + D twice so that we have three IntConstant nodes, each with a value of 1.
8. Move all three nodes to the left. We will add more nodes that will go between these nodes and the
VectorCompose node, so leave some space, as shown in Figure 5.9.
9. Right-click anywhere to the left of the VectorCompose node and to the right of the three
IntConstant nodes in the Visual Shader Editor. Type int or go to Scaler | Common | IntFunc, then
select IntFunc from the Create Shader Node menu. Click the Create button.
10. Left-click on Sign below IntFunc to bring up the drop-down list and then select Abs.
11. Press Ctrl + D one time and move both of the IntFunc nodes to the right of the top two IntConstant
nodes, as shown in Figure 5.9.
12. Connect the dot on the right side of the IntConstant node to the dot on the left side of the IntFunc
node for both copies.
13. For IntConstant | IntFunc in the middle, connect the dot on the right to the y value in
VectorCompose.
14. Right-click anywhere to the left of the VectorCompose node and to the right of the three
IntConstant nodes in the Visual Shader Editor. Type int or go to Scaler | Common | IntOp, then
select IntOp from the Create Shader Node menu. Click the Create button.
15. Press Ctrl + D one time and move one of the IntOp nodes to the right of the top two IntFunc nodes
and the other under the middle IntFunc node.
16. The operator for the top node should be Add. Connect the right dot of the top IntFunc node to b in
the IntOp node.
17. Connect the right dot of the top IntOp node to x in the VectorCompose node.
18. Left-click on Add in the InOp node at the bottom and select Subtract in the drop-down list of
operators.
19. Connect the right dot of the bottom IntConstant node to b in the IntOp node.
20. Connect the right dot of the bottom IntOp node to z in the VectorCompose node.
21. Right-click anywhere to the top left of the three IntConstant nodes in the Visual Shader Editor.
Type comm or go to Special | Comment, then select Comment from the Create Shader Node menu.
Click the Create button.
22. Click on the arrow in the bottom-right corner and drag it to cover all of the IntConstant, IntFunc,
and IntOp nodes that we created.
23. Right-click on the word Comment in the Comment node, and at the bottom, select Select Comment
Description.
24. Left-click in the box that pops up and type Three int values going into VectorCompose then to
Albedo:
Figure 5.9 – IntConstant, IntFunc, and IntOp nodes
How it works…
We clicked on the Distraction Free Mode (Ctrl + Shift + F11) button to give
us some room to create and move the visual shaders we are going to use in this
recipe while also viewing the plane mesh. You could click Expand Bottom
Panel (Shift + F12) to only see the Visual Shader Editor.
We right-clicked to the left of the Output node to bring up the Create Shader
Node menu and selected the VectorCompose node by typing vectorc or went to
Vector | Common | VectorCompose in the Create Shader Node menu. We
checked to see that Vector3 was selected, and if it was not, we selected it by
clicking on the down arrow on the right and selecting it in the drop-down list.
We left-clicked the dot on the right side of the node and dragged it to the dot
next to Albedo in the Output node. After we add nodes to connect to the x, y,
and z inputs of the VectorCompose node, it will output to the Albedo material
of the PlaneMesh and change its color.
We right-clicked to the left of the VectorCompose node to bring up the Create
Shader Node menu and selected the IntConstant node by typing int or went
to Scaler | Variables | IntConstant in the Create Shader Node menu. We
changed the value to 1 by left-clicking on 0 to highlight it and then entering 1.
We duplicated this node two times by making sure the IntConstant node was
selected and then using Ctrl + D. We then had three IntConstant nodes each
with a value of 1, which we moved over to the left side, leaving space between
them and the Output node so that we could add more nodes to place between
them.
We right-clicked to the left of the VectorCompose node and to the right of the
three IntConstant nodes in the Visual Shader Editor. We typed int or went to
Scaler | Common | IntFunc and then selected IntFunc from the Create
Shader Node menu. We left-clicked on Sign below IntFunc to bring up a
drop-down list and then selected Abs, which is the absolute value of the
parameter.
The Negate option negates the value of the parameter. Sign extracts the sign
of the parameter. Bitwise NOT returns the Bitwise NOT operation on the integer.
We duplicated it one time, giving us two nodes. We connected it to the top
IntConstant node and to the middle IntConstant node. We connected the
middle IntConstant and IntFunc nodes to the y value of the VectorCompose
node. The PlaneMesh was now green.
We right-clicked to the left of the VectorCompose node and to the right of the
three IntConstant and IntFunc nodes in the Visual Shader Editor. We typed
int or went to Scaler | Common | IntOp, then selected IntOp from the Create
Shader Node menu. We duplicated the IntOp node once and moved one to the
top and the other to the bottom. The one on the top has the Add operator.
The top IntConstant -> IntFunc node’s right dot is connected to the b value
of the top IntOp node. For the bottom IntOp node, we left-clicked on Add to
select Subtract from the drop-down list. The list shows mathematical operators
such as Add, Subtract, Multiply, Divide, and Remainder, just to name a few.
We selected Subtract so that after we connect the IntOp node on the bottom
to the z value of the VectorCompose node, the z value would be 0. The Vector3
values going into the Albedo material of the PlaneMesh are 1 for x and y and 0
for z, which produce the color yellow, as we have seen in previous recipes.
We right-clicked to the top left of the three IntConstant nodes in the Visual
Shader Editor. We typed comm or went to Special | Comment, then selected
Comment from the Create Shader Node menu. We clicked on the arrow in
the bottom-right corner and dragged it to cover all of the nodes we created.
We right-clicked on Comment in the Comment node, and at the bottom, we
saw Set Comment Title and Set Comment Description. We selected the Set
Comment Description option from the drop-down list and entered some text.
You can change the title too if you wish. If you left-click on Comment at the top
and hold then move the mouse, everything in the Comment node moves as a
group.
Creating nodes using Texture3D and CurveTexture
In this recipe, we will add a CurveTexture node to the IntComNodes.tres visual
shader file. We will use the CurveTexture node to control how much alpha we
have on MeshInstance3D.
Getting ready
For this recipe, we will stay in VSContextMenu from the last recipe. If you’d like to
keep the recipes separate, then continue with the rest of the Getting ready
section. Otherwise, use the existing IntComNodes.tres visual shader. Right-click on
the IntComNodes visual shader file and select Duplicate from the drop-down list.
In the popup that appears, change the name to CurveTexture.tres and left-click on
the Duplicate button. In the Inspector, in the Material section, click on the
counterclockwise circle to the right of Shader. Click on <empty> to the right
of Shader and select Load from the drop-down menu. Select CurveTexture.tres,
then click the Open button.
How to do it…
Let’s add a CurveTexture node and hook it up to the Alpha channel in the
Visual Shader Editor:
1. Right-click anywhere to the left of the Output node and not in the Comment section from the last
recipe.
2. In the Search box, type cur and select CurveTexture.
3. Left-click the Create button.
4. Left-click on the blue dot on the right side of the CurveTexture node and drag it to the blue dot to the
left of Alpha in the Output node.
5. In the CurveTexture node, click on <empty> and select New CurveTexture.
6. In the Inspector, click on <empty> to the right of Curve. If the Inspector is not visible, exit
Distraction Free Mode by pressing Ctrl + Shift + F11.
7. Left-click on New Curve.
8. In the CurveTexture node, right-click and select Add Point from the popup.
9. Left-click the point and drag it to the 1 instance on the left side.
10. In the CurveTexture node, right-click and select Add Point from the popup.
11. Left-click the point and drag it to the 1 instance on the bottom-right side:
Figure 5.10 – CurveTexture node
12. Left-click on the point on the top left and drag down and up.
How it works…
We right-clicked to the left of the Output node and under the Comment node.
In the Create Shader Node menu, we clicked on CurveTexture located in
Textures| Functions by entering cur in the Search box. We dragged the blue
dot on the right side of the CurveTexture node to the blue dot to the right of
Alpha in the Output node.
We clicked on <empty> and selected New CurveTexture. This added
properties of CurveTexture in the Inspector. In the Inspector, we clicked on
<empty>, which was to the right of Curve. We left-clicked New Curve to add
a curve texture to the CurveTexture node.
We added two points to the CurveTexture node and positioned them at the 1
instance on the top left and the 1 instance on the bottom right. To see it change
the Alpha value, we left-clicked on the top right point and pulled it down to 0,
which made the MeshInstance3D disappear. We then brought the same point
back to 1, and the MeshInstance3D appeared.
Using the Billboard node
In this recipe, we will create a MeshInstance3D with a BoxMesh. We use the
visual shader Billboard node so that the MeshInstance3D will always face
the camera.
Getting ready
For this recipe, click + to the right of the VSContextMenu scene we just completed
to add a new scene. In the Scene tab, click 3D Scene. Click on the word
Scene in the top-left corner next to Project, then select Save Scene As, and
name it Billboard.
How to do it…
Let’s create MeshInstance3D and then add the visual shader:
1. Left-click on the Node3D node and then press the + sign in the Scene tab. In the Create New Node
window, type mesh in the Search box and then select MeshInstance3D to create the node in the
scene.
2. In the Inspector, click on <empty> to the right of Mesh and select New BoxMesh.
3. Left-click on the same place to open the properties of the MeshInstance3D.
4. Click on <empty> to the right of Material in the Inspector and select New ShaderMaterial from
the drop-down list.
5. Click on <empty> to the right of Shader in the Inspector and select New Shader from the dropdown list.
6. To the right of Type:, click the down arrow on the far right and select VisualShader.
7. Name the shader Billboard.tres and then click the Create button.
8. Left-click on Transform in the Inspector.
9. In Transform, left-click on the link icon to the right of z under Scale and change the z value to .2.
10. Click Billboard.tres to the right of Shader.
11. In the Shader Editor on the top and to the right of Add Node, left-click on Fragment.
12. Select Vertex from the drop-down list.
13. Right-click to the left of the Output node.
14. In the Search box of the Create Shader Node menu, type get.
15. Select GetBillboardMatrix located in Transform | Functions.
16. Left-click the Create button.
17. In the GetBillboardMatrix node for Billboard Type, make sure Enabled is selected on the right. If
not, left-click and select Enabled from the drop-down list.
18. In the GetBillboardMatrix node, check the On checkbox for Keep Scale.
19. Left-click the orange dot on the bottom right and drag it to the orange dot labeled Model View
Matrix in the Output node:
Figure 5.11 – GetBillboardMatrix node
20. Move your mouse cursor into the viewport.
21. Press and hold the scroll wheel of the mouse, then move the mouse around, and notice that one face
of the BoxMesh follows the camera.
How it works…
We created a new MeshInstance3D, and for the Mesh property, we selected a
BoxMesh. For the Material property, we selected a new ShaderMaterial,
and in the Shader property, we selected New Shader from the drop-down to
bring up the Create Shader dialog. For Type:, we selected Visual Shader and
named it Billboard.tres.
We left-clicked Transform in the Inspector. We changed the scale of the box
by left-clicking the link icon to the right of z under Scale in the Transform
section in the Inspector. The values in Scale should be x 1, y 1, and z .2. We
did this so that we can see more of a side of the box so that when we add the
shader, we will notice that one side of the BoxMesh will follow the camera.
We clicked on Billboard.tres located to the right of Shader in the Inspector to
see the visual shader in the Shader Editor. On the top left of the Shader
Editor, we clicked on Fragment and selected Vertex from the drop-down list.
We right-clicked to the left of the Output node to bring up the Create Shader
Node menu, then typed get in the Search box. We selected
GetBillboardMatrix located in Transform | Functions.
We changed the settings in the GetBillboardMatrix node. To the right of
Billboard Type, we made sure Enabled was selected. If it wasn’t, then we leftclicked what was selected, and from the drop-down list, we selected Enabled.
We checked the On checkbox to the right of Keep Scale. We left-clicked the
orange dot on the bottom right of the GetBillboardMatrix node and dragged
it to the orange dot on the bottom of the Output node named Model View
Matrix.
We moved the mouse cursor into the viewport around MeshInstance3D. We
pressed and held the mouse wheel while we moved the mouse around to see
that the face of the MeshInstance3D that is looking at the camera will always
look at the camera, no matter where we move the camera.
Using the UVFunc node
In this recipe, we use the UVFunc node with the Texture2D node to scale and
pan the icon.svg picture using visual shaders.
Getting ready
For this recipe, click + to the right of the Billboard scene we just completed to
add a new scene. In the Scene tab, click 2D Scene. Click on Scene in the topleft corner next to Project, then select Save Scene As, and name it UVFunc.
How to do it…
We will move the icon.svg file into the scene and then add a ShaderMaterial in
the CanvasItem property:
1. Left-click and hold the left mouse button, then drag icon.svg anywhere in the viewport.
2. In the CanvasItem section of the Inspector, left-click on Material.
3. Click on <empty> to the right of Material and select New ShaderMaterial.
4. Left-click on ShaderMaterial to the right of Material.
5. Click on <empty> to the right of Shader and select New Shader.
6. To the right of Type, select Visual Shader.
7. To the right of Mode, select Canvas Item.
8. To the right of Path name, rename the file UVFunc.tres, and then click the Create button.
9. Left-click UVFnc.tres in the Inspector to see the shader in the Shader Editor.
10. Right-click anywhere to the left of the Output node in the Shader Editor.
11. In the Create Shader Node menu, type texture2D and left-click Texture2D in Textures |
Functions.
12. Left-click the Create button.
13. In the Texture2D node, click on Texture at the top and select Texture2D from the drop-down list.
14. Left-click on the dot on the right side of the node and drag it to the dot to the left of Color in the
Output node.
15. Right-click anywhere to the left of the Texture2D node in the Shader Editor.
16. Click Add Node from the popup.
17. In the Create Shader Node menu, type uvf and left-click UVFunc in Textures | Common.
18. Left-click the Create button.
19. Left-click on the dot on the right side of UV in the UVFunc node and drag it to the dot to the left of
UV in the Texture2D node.
20. In the UVFunc node, left-click to the left of scale and then enter .5, .5.
21. In the UVFunc node, left-click to the left of pivot and then enter .25 , .25:
Figure 5.12 – UVFunc and Texture2D nodes
22. In the UVFunc node to the left of Function, left-click on Scaling and look at the icon in the viewport.
23. In the UVFunc node to the left of Function, left-click on Panning and look at the icon in the
viewport.
How it works…
We dragged the icon.svg file into the viewport. In the CanvasItem section of the
Inspector, we left-clicked on Material and then on <empty> to the right of
Material so that we could create a new shader material. We selected New
ShaderMaterial from the drop-down list.
Then, we left-clicked on ShaderMaterial, which appeared in the place of
<empty> to reveal its properties. We left-clicked on <empty> to the right of
Shader and selected New Shader. We made sure that it was a visual shader
and that it was a Canvas Item type—these should have been the default. In the
Path field, we named the shader UVFunc.tres.
We clicked on UVFunc.tres, which is on the left of Shader in Material in the
CanvasItem section of the Inspector. This shows the Shader Editor on the
bottom panel under the viewport. We right-clicked in the Shader Editor to the
left of the Output node. We selected the Texture2D node by searching for
texture2d and selecting Texture2D under Textures | Functions and then leftclicking on the Create button.
In the Texture2D node, we clicked on Texture at the top and selected
Texture2D from the drop-down list. Then, we left-clicked and dragged the dot
on the right side of Color in the Texture2D node to the dot on the left of Color
in the Output node.
We added the UVFunc node by right-clicking anywhere to the left of the
Texture2D node and clicking Add Node in the popup. In the Search box, we
typed uvf and clicked on UVFunction, located in Textures | Common. Then,
we left-clicked on the Create button. We left-clicked on the dot on the right
side of UV in the UVFunc node and dragged it to the dot to the left of UV in
the Texture2D node.
In the UVFunc node, we changed the x and y values of Scale to .5 each and the
x and y values of Offset to .25 each. We changed the Function values to
Scaling and Panning to see how the icon.svg file changed. Change the values
to something different to see what happens.
Improving the Sky Shader mode
In this recipe, we are going to create a custom sky using the Sky Shader mode
in the Visual Shader Editor. Using sky shaders in Godot 4, you can update the
sky in real time to create dynamic skies.
Getting ready
For this recipe, click on the + sign to the right of the UVFunc scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on
Scene in the top-left corner next to Project, then select Save Scene As, and
name it SkyShader.
How to do it…
First, we will add the WorldEnvironment node to the Scene tab so that we
can create a shader on Sky Material:
1. Left-click on the three vertical dots in the toolbar above the viewport and left-click on Add
Environment to Scene.
2. Left-click on the WorldEnvironment node in the Scene tab.
3. In the Inspector, left-click on Environment to the right of Environment to open its properties.
4. Left-click on Sky in the Inspector to open its properties.
5. Left-click on Sky to the right of the Sky property in the Inspector.
6. To the right of Sky Material, right-click on ProceduralSkyMaterial.
7. Select New ShaderMaterial from the drop-down list.
8. To the right of Sky Material in the Inspector, left-click on ShaderMaterial to see its properties.
9. Click on <empty> to the right of Shader and select New Shader.
10. To the right of Type, select Visual Shader.
11. To the right of Mode, select Sky.
12. To the right of Path, name the file SkyShader.tres, and then click the Create button.
13. Left-click SkyShader.tres to see the shader in the Shader Editor.
14. Right-click anywhere to the left of the Output node in the Shader Editor.
15. Click Add Node from the popup.
16. In the Create Shader Node menu, type mix and left-click Mix under Scalar | Functions.
17. Left-click the Create button.
18. Left-click on Scalar and select Vector3Scalar from the drop-down list.
19. Left-click the dot on the right side of the Mix node and drag it to the dot to the left of Color in the
Output node.
20. Right-click anywhere to the left of the Mix node in the Shader Editor.
21. Click Add Node from the popup.
22. In the Create Shader Node menu, type smo, and left-click SmoothStep under Scalar | Functions.
23. Left-click the Create button.
24. Left-click on 0 to the left of edge0 and change the value to -.2.
25. Left-click on 1 to the left of edge1 and change the value to .4.
26. Left-click the dot on the right side of the SmoothStep node and drag it to the dot to the left of
Weight in the Mix node.
27. Right-click anywhere to the left of the SmoothStep node in the Shader Editor.
28. Click Add Node from the popup.
29. In the Create Shader Node menu, type dot, and left-click Dot under Vector | Functions.
30. Left-click the Create button.
31. Left-click on 0, 0, 0 to the left of a and change the y value to 2.
32. Left-click the dot on the right side of the DotProduct node and drag it to the dot to the left of x in the
SmoothStep node.
33. Right-click anywhere to the left of the DotProduct node in the Shader Editor.
34. Click Add Node from the popup.
35. In the Create Shader Node menu, type eye, and left-click EyeDir under Input | Sky.
36. Left-click the Create button.
37. Left-click the dot on the right side of the eyedir Input node and drag it to the dot to the left of b in
the DotProduct node.
38. Right-click anywhere to the left of the Output node and above the SmoothStep node in the Shader
Editor.
39. Click Add Node from the popup.
40. In the Create Shader Node menu, type vec, and left-click Vector3Constant under Vector |
Variables at the bottom of the drop-down list.
41. Left-click the Create button.
42. Left-click 0 in x and change the value to .2.
43. Left-click 0 in y and change the value to .4.
44. Left-click 0 in z and change the value to .9.
45. Left-click the dot on the right side of the Vector3Constant node and drag it to the dot to the left of b
in the Mix node.
46. Right-click anywhere to the left of the Output node and above the Vector3Constant node in the
Shader Editor.
47. Click Add Node from the popup.
48. In the Create Shader Node menu, type col, and left-click Light1Color under Input | Sky at the
bottom of the drop-down list.
49. Left-click the Create button.
50. Left-click the dot on the right side of the Light1Color Input node and drag it to the dot to the left of
a in the Mix node:
Figure 5.13 – SkyShader.tres
How it works…
We clicked on the three vertical dots to add the WorldEnvironment node to
the Scene tab. In the Inspector, we left-clicked on Environment to open its
properties. In the Inspector, we left-clicked on Sky to open its properties. In
the Inspector underneath Sky is SkyMaterial. We right-clicked on
ProceduralSkyMaterial and selected New ShaderMaterial from the dropdown list.
We left-clicked on ShaderMaterial located on the right of Sky Material in the
Inspector. Now, we can see its properties. We clicked on <empty> located to
the right of Shader and selected New Shader. When we created a new shader,
we made sure that the type was a visual shader, and that the Mode setting was
Sky. In the Path field, we named the shader SkyShader.tres.
We left-clicked SkyShader.tres to see the shader in the Shader Editor. We added
a Mix node on the left side of the Output node. We left-clicked on Scalar and
selected Vector3Scalar from the drop-down list. We dragged the dot on the
right side of the Mix node to the dot to the left of Color on the Output node.
We added a SmoothStep node to the left of the Mix node and moved the node
down toward the bottom-left corner of the Mix node to give us some room to
create new nodes later. We left-clicked on 0 to the left of edge0 and changed
the value to -.2. Then, we left-clicked on 1 to the left of edge1 and changed the
value to .4. We left-clicked the dot on the right side of the SmoothStep node
and dragged it to the dot to the left of Weight in the Mix node.
We added a DotProduct node to the left of the SmoothStep node. We leftclicked on 0,0,0 to the left of a and changed the y value to 2. We left-clicked the
dot on the right side of the DotProduct node and dragged it to the dot to the
left of x in the SmoothStep node. We added an eyedir Input node to the left
of the DotProduct node. We left-clicked the dot on the right side of the eyedir
Input node and dragged it to the dot to the left of b in the DotProduct node.
We added a Vector3Constant node above the SmoothStep node and to the
left of b of the Mix node. We changed the x value to .2, the y value to .4, and
the z value to .9. This gave us a blue-sky color. We left-clicked the dot on the
right side of the Vector3Constant node and dragged it to the dot to the left of
b in the Mix node.
We then added a Light1Color Input node above the Vector3Constant node.
We left-clicked the dot on the right side of the Light1Color Input node and
dragged it to the dot to the left of a in the Mix node. We now have a blue sky
using visual shaders.
What the Fog Shader mode can do
In this recipe, we are going to create custom fog in the FogVolume node using
visual shaders. We will make a greenish fog, which could be used for a
poisonous area in a game.
Getting ready
For this recipe, click the + sign to the right of the UVFunc scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on
Scene in the top-left corner next to Project, then select Save Scene As, and
name it FogShader.
How to do it…
First, we will add a FogVolume node to the Scene tab and then add a visual
shader to Material:
1. Left-click on the three vertical dots in the toolbar above the viewport and left-click on Add
Environment to Scene.
2. Left-click on the WorldEnvironment node in the Scene tab.
3. In the Inspector, left-click on Environment to the right of Environment to open its properties.
4. Left-click on Volumetric Fog in the Inspector to open its properties.
5. Check the On checkbox to the right of Enabled.
6. To the right of Density, change the value to 0.
7. Left-click on the Node3D node and then the + sign in the Scene tab. In the Create New Node
window, type fog in the Search box and then select FogVolume to create the node in the scene.
8. In the Inspector, click on <empty> to the right of Material and select New ShaderMaterial.
9. In the Inspector, click on ShaderMaterial to the right of Material to open the ShaderMaterial
properties.
10. In the Inspector, click on <empty> to the right of Shader and select New Shader.
11. To the right of Type, select Visual Shader.
12. To the right of Mode, select Fog.
13. To the right of Path, name the file FogShader.tres and then click the Create button.
14. Left-click FogShader.tres in the Inspector to see the shader in the Shader Editor.
15. Right-click anywhere to the left of the Output node in the Shader Editor.
16. In the Create Shader Node menu, type col and left-click ColorConstant under Color | Variables in
the drop-down list.
17. Left-click the Create button.
18. Left-click on the white box and enter 65ff39 in the box to the right of Hex.
19. Left-click on the dot on the right side of the ColorConstant node and drag it to the dot on the left
side of Albedo.
20. Right-click anywhere to the left of the Output node in the Shader Editor.
21. In the Create Shader Node menu, type floa and left-click FloatConstant under Scalar | Variables
at the bottom of the drop-down list.
22. Left-click the Create button.
23. Left-click on 0 and change the value to 2.
24. Left-click on the dot on the right side of the FloatConstant node and drag it to the dot on the left side
of Density:
Figure 5.14 – FogShader.tres
How it works…
We clicked on the three vertical dots to add the WorldEnvironment node to
the Scene tab. In the Inspector, we left-clicked on Environment to the right
of Environment to open its properties. In the Inspector, we left-clicked on
Volumetric Fog to open its properties. We checked the On checkbox to the
right of Enabled to use volumetric fog. We changed the value of Density to 0
because we are going to use a shader for our fog.
We created a FogVolume node in the Scene tab. We clicked on <empty> to
the right of Material in the Inspector and selected New ShaderMaterial. We
clicked on ShaderMaterial to open its properties. In the Inspector, we saw
<empty> on the right of Shader, and we clicked on it to bring up the Create
Shader dialog box. We checked to see that the Type value was Visual Shader,
the Mode value was Fog, and in the Path field, we changed the name to
FogShader.tres. We left-clicked FogShader.tres in the Inspector to see the shader in
the Shader Editor.
We created a ColorConstant node in the visual Shader Editor. We clicked on
the white box and changed the Hex # value to 65ff39. This gave us a green
color. We left-clicked the dot on the right side of the ColorConstant node and
dragged it to the dot on the left of Albedo in the Output node. We created a
FloatConstant node and changed its value to 2. We left-clicked the dot on the
right side of the FloatConstant node and dragged it to the left of Density.
6
Importing 3D Assets in Godot 4
In this chapter, we will start by connecting the Blender and FBX2glTF paths to
Godot 4 in Editor Settings. We will then import blend files into Godot 4 and
see how the models change in Godot when they're updated in Blender. Because
Godot does not have FBX support, we will import a FBX2glTF.exe file, which we
are going to download from GitHub.
This file is going to change the FBX file into a glTF file so that we can use FBX
files. We will also import a glTF file into Godot. Finally, we will use the Import
dialog to extract a .tres file from a texture and add that texture to the copy of
the glTF file we downloaded previously.
In this chapter, we will cover the following recipes:
Importing Blender blend files into Godot 4
Importing FBX files into Godot 4
Importing glTF files into Godot 4
Using the Import dialog
Technical requirements
For this chapter, you need the standard version of Godot 4.0 or later running
on one of the following operating systems:
Windows 64-bit or 32-bit
macOS
Linux 64-bit or 32-bit
Android
Web Editor
You can find the code and the project files for the projects in this chapter on
GitHub: https://github.com/PacktPublishing/Godot-4-Game-DevelopmentCookbook/tree/main/Chapter%206.
Blender can be downloaded for free here: https://www.blender.org/download.
Importing Blender blend files into Godot 4
In this recipe, we will connect the Blender path to Godot 4 in Editor Settings.
We will import a blend file into Godot and change the file in Blender to see that
the imported file changes in Godot without having to reimport the file.
Getting ready
For this recipe, open Godot 4 and start a new project called Chapter 6. In the
Scene tab, click 3D to add a 3D scene. Click on Scene in the main menu next
to Project, then select Save Scene As, and name it Blend.
How to do it…
In this recipe, we will start by connecting the Blender path to Godot 4 in Editor
Settings:
1. In the main menu, at the top left of Godot, select Editor | Editor Settings.
2. On the left, under Filter Settings | FileSystem, click Import.
3. Click on the folder icon to the far right of Blender 3 Path:
Figure 6.1 – Editor Settings
4. Select the correct path where you installed Blender 3 and then click the Close button.
5. Download Lefty jack Truck 3D Model from https://www.cadnav.com/3d-models/model-53400.html.
6. Extract the files from the ZIP file to anywhere on your computer.
7. Double-click the cadnav.com_model folder that you just extracted from the ZIP file.
8. Click and drag the Model_G0402A160 folder into the FileSystem tab in Godot.
9. Click on the arrow to the left of the Models_G0402A160 folder in the FileSystem tab.
10. Click and drag the LeftyJ_Truck.blend scene onto Node3D in the Scene tab.
11. Press Ctrl + S to save the scene.
12. In the FileSystem tab, right-click the LeftyJ_Truck.blend scene and select Show in File Manager
from the drop-down list at the bottom.
13. In the window that appears, double-click on the LeftyJ_Truck blend file.
14. In Blender, which just popped up, click on the Texture Paint workspace to the right of the Blender
menu on the top bar:
Figure 6.2 – Texture Paint workspace
15. Using the mouse wheel, scroll in to see the model better.
16. Move the mouse cursor, which is now a big circle, over to the back cab of the truck and click the left
mouse button and paint the side of the back cab.
17. On the top bar, in the main menu, click File and select Save from the drop-down list, or press Ctrl + S
in Windows or Cmd + S on Mac.
18. Click anywhere in Godot:
Figure 6.3 – Blender 3 Path in Godot's Editor Settings
19. On the top bar, in the main menu, click File and select Quit from the drop-down list.
20. When Blender asks whether you want to save your changes before closing, select Save.
21. Restart Godot and click anywhere inside it.
How it works…
In this recipe, we went to the main menu in Godot, which can be found in the
top left of the Editor area. We clicked on Editor and then Editor Settings. In
Filter Settings, on the left-hand side of the pop-up window, then under
FileSystem, we clicked Import. Then, we clicked on the folder icon on the far
right of Blender 3 Path under Blender. Finally, we selected the correct path
that Blender 3 installed.
Next, we went to https://www.cadnav.com/ to download a blend file called
Lefty jack Truck 3D Model. We extracted the files in the ZIP folder to
wherever we wanted. I have a folder called 3D Assets in my Documents folder
where I extract 3D models – you can extract it to your desktop or anywhere you
like.
We double-clicked on the cadnav.com_model folder to open the folder. Then, we
clicked and dragged the Model_G0402A160 folder into the FileSystem tab in Godot.
We clicked on the arrow to the left of the Model_G0402A160 folder to show the
contents of the folder. Then, we clicked and dragged the LeftyJ_Truck.blend scene
onto Node3D in the Scene tab to see the model in the viewport. We saved the
scene by pressing Ctrl + S on our keyboard.
After, we right-clicked the LeftyJ_Truck.blend scene in the FileSystem area and
selected Show in File Manager from the drop-down list at the bottom. This
brought up the Models_ G0402A160 folder window in the Chapter 6 Godot project. In
the window that appeared, we double-clicked on the LeftyJ_Truck blend file to
open the file in Blender.
Once we were in Blender, we went to the Texture Paint workspace, which is to
the right of the Blender menu on the top bar. We used the mouse wheel to
zoom in to see the model better. We painted the back cab by moving the mouse
cursor, which became a big circle, over the back cab of the truck and then
pressed the left mouse button. We then saved the file and clicked on Godot.
When we clicked on Godot, we saw an importing assets window open briefly
because we changed that file in Blender.
Finally, we selected File and then Quit from the drop-down list in Blender.
Blender asked whether we wanted to save our changes before we exited. We
selected Save. When we restarted Godot, we clicked anywhere in Godot and
the model with the changes appeared.
Importing FBX files into Godot 4
In this recipe, we are going to download the FBX2glTF.exe file from GitHub and
connect it to FBX2glTF Path in Editor Settings. We will download and import
an FBX file into Godot.
Getting ready
For this recipe, click the + button to the right of the Blend scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on
Scene in the main menu next to Project, then select Save Scene As, and
name it FBX.
How to do it…
First, let’s download the FBX2glTF.exe file from GitHub and connect it to Godot:
1. Go to https://github.com/godotengine/FBX2glTF/releases/tag/v0.12.9-p2 and select FBX2glTF.exe.
2. Save the file somewhere you will remember it.
3. In the main menu, on the top left of Godot, select Editor | Editor Settings.
4. On the left of Filter Settings | FileSystem, click Import.
5. Click on the folder icon to the far right of FBX2glTF Path, as shown in Figure 6.1.
6. Select the FBX2glTF.exe file that you just downloaded and click the Close button.
7. Go to https://polyhaven.com/a/wooden_table_02 and, to the right of 4K, click on the down arrow to
open the drop-down list:
Figure 6.4 – FBX file type
8. Select ZIP and click on all the PNG files you wish to include in the download. Then, click Download.
9. Extract the ZIP file to your Godot Chapter 6 project folder or a new folder on your computer. Then,
drag the textures folder and the wooden_table_02_4k.fbx file into the FileSystem tab.
10. Press Ctrl + S (Cmd + S on Mac) to save the scene and reboot Godot.
11. In Godot, click and drag wooden_table_02_4k.fbx onto Node3D in the Scene tab.
How it works…
In this recipe, we went to GitHub to download the FBX2glTF.exe file. We went to
the main menu in Godot, in the top left of the Editor area. We clicked on
Editor and then Editor Settings. In Filter Settings, on the left-hand side of
the pop-up window, under FileSystem, we clicked Import. After, we clicked on
the folder icon on the far right of FBX2glTF Path under Blender. We selected
the path where the FBX2glTF.exe file was installed.
Next, we went to Poly Haven and downloaded wooden_table_02_4k.fbx, which is the
FBX version of Wooden Table 02. We clicked on all of the PNG texture files. If we
hadn't included these PNG files, it would not have worked. We extracted the
contents of the ZIP file into the Godot Chapter 6 folder. We could have also
created a new folder and extracted its contents in the new folder and then
dragged the textures folder, along with the wooden_table_02_4K.fbx file, into the
FileSystem tab in Godot.
When the files are imported, we will see some errors and a red x by the
wooden_table_02_4K.fbx file, but don’t worry – we saved the scene and then
rebooted Godot. The FBX file now doesn’t have a red x. Finally, we clicked and
dragged the wooden_table_02_4k.fbx file onto Node3D in the Scene tab.
Importing glTF files into Godot 4
In this recipe, we are going to download and import a glTF file into Godot. This
is the format that is supported by Godot by default.
Getting ready
For this recipe, click the + button to the right of the FBX scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on
Scene in the top-left corner next to Project, then select Save Scene As, and
name it glTF.
How to do it…
In this recipe, we will download the glTF format of Wooden Table 02 from the
previous recipe:
1. Go to https://polyhaven.com/a/wooden_table_02 and, to the right of 4K, click on the down arrow to
open the drop-down list:
Figure 6.5 – glTF file type
2. Select glTF, then click Download.
3. Extract the ZIP file to your Godot Chapter 6 project folder or a new folder on your computer. Then,
drag the textures folder and the wooden_table_02_4k.gltf file into the FileSystem tab.
4. In Godot, click and drag wooden_table_02_4k.gltf onto Node3D in the Scene tab.
How it works…
In this recipe, we went to Poly Haven and downloaded wooden_table_02_4k.gltf,
which is the glTF version of Wooden Table 02.
We extracted the contents of the ZIP file into the Godot Chapter 6 folder. We
could have also created a new folder and extracted its contents into the new
folder and then dragged the textures folder, along with the wooden_table_02_4K.gltf
file, into the FileSystem tab in Godot.
Finally, we clicked and dragged the wooden_table_02_4k.gltf file onto Node3D in
the Scene tab.
Using the Import dialog
In this recipe, we are going to duplicate the wooden table that we used in the
previous recipe and download an Old Wood Floor texture. Using the Import
dialog, we are going to extract the old_wood_floor.tres file from the
old_wood_floor_1K.gltf file we downloaded. Then, we will use that texture for the
texture of the wooden table.
Getting ready
For this recipe, click the + button to the right of the glTF scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on
Scene in the top-left corner next to Project, then select Save Scene As, and
name it Import.
How to do it…
First, we will download the Old Wood Floor texture from Poly Haven and then
extract the .tres file:
1. Go to https://polyhaven.com/a/old_wood_floor and, to the right of 1K, click on the down arrow to
open the drop-down list:
Figure 6.6 – The Old Wood Floor texture
2. Select glTF, then click Download.
3. Extract the ZIP file to your Godot Chapter 6 project folder or a new folder on your computer, then
drag the textures folder and the old_wood_floor_1k.gltf file into the FileSystem tab.
4. In Godot, right-click in the FileSystem tab and select New Folder from the drop-down list. Name this
new folder materials.
5. Go to https://polyhaven.com/a/wooden_crate_01 and, to the right of 1K, click on the down arrow to
open the drop-down list.
6. Select glTF, then click Download.
7. Extract the ZIP file to your Godot Chapter 6 project folder or a new folder on your computer, then
drag the textures folder and the wooden_crate_01_4k.gltf file into the FileSystem tab.
8. Click wooden_crate_01_4k.gltf and hold and drag it onto Node3D in the Scene tab.
9. Click on old_wood_floor_1k.gltf in the FileSystem tab.
10. Click on the Import tab to the right of the Scene tab.
11. Click on the Advanced button on the bottom right-hand side of the Import tab.
12. In the Advanced Import Settings pop-up window, click on the Materials tab.
13. In the Materials tab, click on old_wood_floor.
14. In the Advanced Import Settings pop-up window, click on Actions above the Scene, Meshes, and
Materials tabs. This can be found at the top left-hand side of the window.
15. After clicking Actions, click Set Mesh Save Paths.
16. Click on the materials folder and then click on the Select This Folder button. After, click on the Set
Paths button.
17. In the Advanced Import Settings pop-up window, click on Actions above the Scene, Meshes, and
Materials tabs. This can be found at the top left-hand side of the window:
Figure 6.7 – Extract Materials
18. After clicking Actions, click Extract Materials.
19. Click the materials folder and click on the Select This Folder button.
20. Click on the Extract button. Then, click on the Close button.
21. In the FileSystem tab, click on wooden_crate_01_4k.gltf.
22. In the Import tab, click the Advanced button.
23. In the Advanced Import Settings pop-up window, click on the Materials tab.
24. In the Materials tab, click on wooden_crate_01.
25. On the far right-hand side, check the On checkbox to the right of Enabled.
26. Click on the folder to the far right of Path under Enabled.
27. Double-click on the materials folder.
28. Click on old_wood_floor.tres and then click the Open button.
29. Click the Reimport button at the bottom of the Advanced Import Settings pop-up window.
30. If you don’t see a change, save the scene and reboot Godot.
How it works…
In this recipe, we went to Poly Haven and downloaded old_wood_floor_1k.gltf. We
extracted the contents of the ZIP file into the Godot Chapter 6 folder. We could
have also created a new folder and extracted its contents into the new folder or
an existing folder.
Then, we dragged the textures folder, along with the old_wood_floor_1k.gltf file,
into the FileSystem tab in Godot. We created a new folder called materials so
that we had a place to extract the .tres file we got from old_wood_floor_1k.gltf.
We went back to Poly Haven and downloaded wooden_crate_01_4k.gltf. We
extracted the contents of the ZIP file just like we did with old_wood_floor_1k.gltf.
We clicked and dragged wooden_crate_01_4k.gltf onto Node3D in the Scene tab.
At this point, we could see the crate with its default texture.
Next, we clicked on old_wood_floor_1k.gltf in the FileSystem tab and then clicked
on the Import tab, which is to the right of the Scene tab, and clicked the
Advanced button to bring up the Advanced Import Settings pop-up window.
In the Advanced Import Settings pop-up window, we clicked on the
Materials tab and clicked on old_wood_floor.
After that, we checked the On checkbox to the right of Enabled and clicked on
the folder to the far right of Path under Enabled. We double-clicked the
materials folder so that we could use it for the .tres file that we extracted from
old_wood_floor.
Then, we clicked Actions in the Advanced Import Settings pop-up window to
select Set Mesh Save Paths from the drop-down list. We clicked on the
materials folder and then clicked on the Select This Folder button. We did this
so that any mesh data that we extract will be saved to the materials folder. Then,
we clicked the Set Paths button.
Next, we clicked Actions in the Advanced Import Settings pop-up window to
select Extract Materials from the drop-down list. We clicked the materials
folder and clicked on the Select This Folder button. After, we clicked on the
Extract button to extract the old_wood_floor.tres file from old_wood_floor_1K.gltf.
Then, we clicked on wooden_crate_01_4k.gltf in the FileSystem tab. This is where
we added the texture that we extracted from old_wood_floor_1K.gltf and added it
to wooden_crate_01_4k.gltf. We clicked the Advanced button in the Import tab to
bring up the Advanced Import Settings pop-up window.
Finally, we clicked on wooden_crate_01, which is located under the Materials tab,
so that we could check the On checkbox to the right of Enabled. Under Path,
we selected the materials folder to find old_wood_floor.tres and clicked on the
Open button to select it. After, we clicked on the Reimport button at the
bottom of the Advanced Import Settings pop-up window to add the
old_wood_floor.tres texture that we extracted from old_wood_floor_1K.gltf. The Old
Wood Floor texture should now be applied to the wooden crate. If this didn’t
happen for you, save the scene and reboot Godot.
7
Adding Sound and Music to Your Game
Godot 4 fixed some audio issues, such as popping, resampling behavior, and
performing sound operations simultaneously.
In this chapter, we are going to use the AudioStreamPlayer node to play
constant music no matter where the player is located. We will also set up a
repeated gunshot SFX to show off Godot 4’s built-in polyphonic support.
We will use the AudioStreamPlayer2D node to see how to create directional
sound. When the player comes close to an object, they will be able to hear it. In
the last recipe, we will use the AudioStreamPlayer3D node to create
directional sound in a 3D environment.
In this chapter, we will cover the following recipes:
Working with AudioStreamPlayer
Exploring directional sound in 2D
Using directional sound in 3D
Technical requirements
For this chapter, you need the standard version of Godot 4.0 or later running
on one of the following:
Windows 64-bit or 32-bit
macOS
Linux 64-bit or 32-bit
Android
Web Editor
You can find the code and the project files for the projects in this chapter at
GitHub: https://github.com/PacktPublishing/Godot-4-Game-DevelopmentCookbook/tree/main/Chapter%207.
Working with AudioStreamPlayer
In this recipe, we will use the AudioStreamPlayer node to play constant rain
SFX or music, no matter where the player goes in the game. We will also use
another AudioStreamPlayer node to create SFX of a gunshot to show off the
new polyphonic support, which allows you to repeat the same sound multiple
times on top of itself, using one AudioStreamPlayer node without any
distorting sounds.
Getting ready
For this recipe, open Godot 4 and start a new project called Chapter 7. In the
Scene tab, click 2D to add a 2D scene. Click on Scene in the main menu next
to Project, then select Save Scene As, and name the scene AudioStreamPlayer.
How to do it…
Let’s download our gunshot SFX and music before we add the
AudioStreamPlayer node to the scene:
1. Go to https://pixabay.com/sound-effects/search/background and download the Soft Rain Ambient
file. If you have your own MP3, WAV, or OGG files or find a different file on this website that you like,
you can use that file instead.
2. Extract the file onto the FileSystem tab in Godot.
3. Go to https://www.videvo.net/sound-effect/gun-shot-single-shot-in-pe1097906/246309 and download
the Loud Gunshot WAV or MP3 file.
4. Extract the file into the FileSystem tab in Godot.
5. Left-click on + above Node2D in the Scene tab to bring up the Create New Node window. In the
Search box, type audio and select AudioStreamPlayer at the bottom of the list.
6. Left-click on the Node2D node and then + in the Scene tab. In the Create New Node window, type
mesh in the Search box and then select MeshInstance2D to create the node in the scene. Left-click
the Create button.
7. Right-click the MeshInstance2D node in the Scene tab and rename it Background.
8. In the Inspector window, click on <empty> to the right of Mesh and select New BoxMesh.
9. Left-click on the same place to open the properties of the Background mesh.
10. In the Inspector window, change the Size property of x to 100 and y to 100.
11. In the Inspector window, left-click on Transform to show the transform properties.
12. To the right of Position, change the x value to 600px and the y value to 340px.
13. To the right of Scale, left-click the link icon so that the link is gray and broken.
14. Change the value of x to 12 and the value of y to 7 in Scale.
15. Left-click on the Node2D node and then + in the Scene tab. In the Create New Node window, type
button in the Search box and then select Button.
16. Left-click the Create button.
17. Left-click and drag on the bottom-right dot to make the button bigger. Move the button inside the
viewable background area.
18. In the Inspector window, click on the empty box under Text and enter Gun Shot.
Figure 7.1 – The background and button placement
Left-click on AudioStreamPlayer in the Scene tab.
19. In the FileSystem tab, left-click, hold, and drag soft-rain-ambient-111154.mp3 (or .WAV) to
<empty> to the right of Stream in the Inspector window.
20. In the Inspector window, check the checkbox to the right of Autoplay.
21. Left-click on the Button in the Scene tab.
22. In the Inspector window at the bottom, left-click <empty> to the right of Script.
23. Left-click New Script from the drop-down list.
24. In Path, rename the script Gunshot.gd.
25. Left-click the Create button.
26. Left-click on the Button in the Scene tab.
27. Left-click the Node tab located to the right of the Inspector tab.
28. Toward the top left, click pressed().
29. At the bottom left, click the Connect button.
30. Left-click the Connect button in the window that pops up.
31. Left-click on + above Node2D in the Scene tab to bring up the Create New Node window.
32. In the Search box, type audio and select AudioStreamPlayer at the bottom of the list.
33. Left-click on AudioStreamPlayer2 in the Scene tab.
34. In the FileSystem tab, left-click, hold, and drag GunShotSnglShotIn PE1097906.wav to <empty> to
the right of Stream in the Inspector window.
35. Left-click 1, which is located to the right of Max Polyphony in the Inspector window, and change it
to 10.
36. Left-click Script, which is to the right of 3D in the top-middle area in Godot.
37. In the Gunshot script, copy the following code:
1 extends Button
2
3 @onready var audio = $"../AudioStreamPlayer2"
4
5 func _on_pressed():
6   audio.play()
38. In the AudioStreamPlayer scene, click the Run the current scene button in the upper-right corner
of the editor or hit the F6 key.
We click on the button and hear the gunshots and the rain at the same time,
and no matter how fast we click the button, we don’t get any distortion.
How it works…
We went to Pixaby and downloaded Soft Rain Ambient to show that the music or
ambient sound effect will play, no matter where a player is in the game. You
can download a different free file on the website, or you can use your own
WAV, MP3, or OGG Vorbis files. We extracted the file onto the FileSystem tab
in Godot.
We went to https://www.videvo.net/ and downloaded Loud Gunshot. We are going
to attach a AudioStreamPlayer node to a button, and when we click it, it will
play the gunshot sound effect. We extracted the file into the FileSystem tab in
Godot.
We added the AudioStreamPlayer node to the Scene tab. We added a
MeshInstance2D node as a child of the Node2D node and renamed it
Background. We added a BoxMesh to the Mesh property. We changed the Size
values of the x and y to 100.
We opened the Transform properties in the Inspector window to change the
Position x value to 600px and the y value to 340px, centering it so that the default
camera could see the background. We left-clicked the link icon so that we can
change both the x and y values to the values we want. We changed the scale of
the x value to 12 and y to 7 so that it covers the area that the default camera will
show.
We left-clicked on the Node2D node and then + in the Scene tab to add a
button as a child of Node2D. We left-clicked and dragged the bottom-right dot
that surrounds the button to make the button bigger. Then, we moved the
button into the viewable background area. We typed Gun Shot in the empty box
under the word Text in the Inspector window.
We left-clicked on AudioStreamPlayer in the Scene tab so that we could see
its Inspector properties. In the FileSystem tab, we left-clicked and dragged
the soft-rain-ambient-111154.mp3 file to <empty> to the right of Stream in the
Inspector window. If you downloaded a different file or file type, use that
instead. Then, we checked the checkbox to the right of Autoplay in the
Inspector window to turn it on. Now, when we run the current scene, the file
will play.
We left-clicked on the Button node in the Scene tab to see its properties in the
Inspector window. At the bottom, we left-clicked <empty> to the right of
Script and selected New Script. We named this script Gunshot.gd and leftclicked the Create button to create it.
We left-clicked Button in the Scene again so that we can add a signal to the
button. We left-clicked on the Node tab, which is to the right of the Inspector
tab. Toward the top of the list of signals, we left-clicked pressed() and then leftclicked the Connect button. A window appeared, and we left-clicked the
Connect button to hook up the signal to the script.
We added another AudioStreamPlayer node to use with the gunshot audio
that we downloaded. We left-clicked on AudioStreamPlayer2 to show the
properties in the Inspector window. We dragged GunShotSnglShotIn PE1097906.wav
to <empty> to the right of Stream in the Inspector window.
We changed the value of Max Polyphony to 10 in the Inspector window. This
is the number of sounds AudioStreamPlayer2 can play at the same time.
Clicking on the button really fast will play the full gunshot file each time,
without cutting out when the next gunshot is fired by clicking the button again.
We clicked the script in the Workspaces part of Godot to add code to the
Gunshot.gd script. In line 3, we entered @onready var audio = $"../AudioStreamPlayer2"
in case you got an error and then deleted $"../AudioStreamPlayer2" after =. Then, in
the Scene tab, we left-clicked and dragged the AudioStreamPlayer2 node to
the right of the = sign in the Gunshot.gd script.
When we connected the signal, line 5 was created. In line 6, delete the default
pass line and enter audio.play(). This will play the gunshot sound every time the
button is pushed. We ran the current scene (by pressing F6), and you can hear
the rain audio playing as the scene is running.
When we clicked on the button, we heard the gunshot at the same time as the
rain sounds. We can click the button fast to hear multiple gunshots, along with
the background rain sound that the first AudioStreamPlayer node is playing,
and it still sounds good.
Exploring directional sound in 2D
In this recipe, we will attach AudioStreamPlayer2D to a block and create a
player. When the player moves toward the block, the sound file will play and
get louder as the player gets closer.
Getting ready
For this recipe, open Godot 4 and start a new project called Chapter 7. In the
Scene tab, click 2D to add a 2D scene. Click on Scene in the main menu next
to Project, then select Save Scene As, and name the scene Audio2D.
How to do it…
We start by creating the background, the box with the AudioStreamPlayer2D
node, and the player:
1. Left-click on the Node2D node and then + in the Scene tab. In the Create New Node window, type
mesh in the Search box and then select MeshInstance2D to create the node in the Scene tab. Leftclick the Create button.
2. Right-click the MeshInstance2D node in the Scene tab and rename it Background.
3. In the Inspector window, click on <empty> to the right of Mesh and select New BoxMesh.
4. Left-click on the same place to open the properties of the Background mesh.
5. In the Inspector window, change the Size property of x to 100 and y to 100.
6. In the Inspector window, left-click on Transform to show the transform properties.
7. To the right of Position, change the x value to 600px and the y value to 340px.
8. To the right of Scale, left-click the link icon so that the link is gray and broken.
9. Change the value of x to 12 and the value of y to 7 in Scale.
10. Left-click on the Node2D node and then + in the Scene tab. In the Create New Node window, type
spr in the Search box and then select Sprite2D.
11. Left-click the Create button.
12. Drag icon.svg into <empty> to the right of Texture in the Inspector window.
13. Left-click Transform in the Inspector window.
14. To the right of Position, change the x value to 85 and the y value to 600.
15. To the right of Scale, change the x value to .5, and the y value will also change to .5 because we did
not click on the link icon to the right.
16. Left-click on the Node2D node and then + in the Scene tab. In the Create New Node window, type
mesh in the Search box, and then select MeshInstance2D to create the node in the scene.
17. In the Inspector window, click on <empty> to the right of Mesh and select New BoxMesh.
18. Left-click on the same place to open the properties of the MeshInstance2D mesh.
19. In the Inspector window, change the Size value of x to 50 and the value of y to 50.
20. Left-click on Visibility under CanvasItem in the Inspector window.
21. Left-click on the white field to the right of Modulate.
22. Enter ff0000 into the Hex # field or pick your own color.
23. Left-click on Transform in the Inspector window.
24. To the right of Position, change the x value to 1100 and the y value to 40.
Figure 7.2 – Audio2D – Transform and CanvasItem in the Inspector window
25. Left-click on the MeshInstance2D node and then + in the Scene tab. In the Create New Node
window, type aud in the Search box, then select the AudioStreamPlayer2D node, and then the
Create button.
26. Left-click on AudioStreamPlayer2D in the Scene tab.
27. In the FileSystem tab, left-click, hold, and drag soft-rain-ambient-111154.mp3 (or .WAV) to
<empty> to the right of Stream in the Inspector window.
28. In the Inspector window, check the checkbox to the right of Autoplay.
29. In the Inspector window to the right of Max Distance, left-click 2000 and change it to 1900.
30. Left-click on Transform in the Inspector window.
31. To the right of Position, change the x value to 1100 and the y value to 40.
32. Left-click on the Node2D node and then + in the Scene tab. In the Create New Node window, type
char in the Search box and then select CharacterBody2D.
33. Left-click on the Create button.
34. Left-click on the CharacterBody2D node and then + in the Scene tab. In the Create New Node
window, type coll in the Search box and then select CollisionShape2D.
35. Left-click on the Create button.
36. Left-click <empty> to the right of Shape in the Inspector window.
37. Select New RectangleShape2D from the drop-down list.
38. In the Scene tab, left-click and drag the Sprite2D node onto CharacterBody2D. Sprite2D should be
the first child under CharacterBody2D and CollisionShape2D should be the first child under
Sprite2D, as shown in Figure 7.4.
39. Left-click CollisionShape2D in the Scene tab, and in the top-left corner, you will see
CollisionShape2D.
40. Left-click and drag the dots of CollisionShape2D to fit the shape of Sprite2D in the bottom-left
corner.
Figure 7.3 – CollisionShape2D on Sprite2D
41. Left-click on the CharacterBody2D node and then + in the Scene tab. In the Create New Node
window, type aud in the Search box and then select AudioListener2D.
42. Left-click the Create button.
43. In the Inspector window of AudioListener2D, check the On checkbox to the right of Current.
44. Left-click on CharacterBody2D in the Scene tab.
45. In the Inspector window, left-click on <empty> to the right of Script.
46. Select New Script from the drop-down list.
47. In Template:, make sure it is empty. If not, click the button to the right of Template:.
48. In Path:, rename the script Player.gd.
49. Left-click the Create button.
50. In the Script workspace in the main menu, add the following lines to Player.gd:
1 extends CharacterBody2D
2
3 @export var speed = 300
4
5 func get_input():
6    var input_direction = Input.get_vector("ui_left", "ui_right", "ui_up",
"ui_down")
7    velocity = input_direction * speed
8
9 func _physics_process(_delta):
10   get_input()
11   move_and_slide()
51. In the Audio2D scene, click the Run the current scene button in the upper-right corner of the
editor or hit the F6 key.
Use the arrow keys to move toward the red box. As you move closer to the red
box, you should hear the volume get louder. If you continue going offscreen to
the right, the sound will pan to the left speaker.
How it works…
We added a MeshInstance2D node as a child of the Node2D node and
renamed it Background. We added a BoxMesh to the Mesh property. We changed
the Size values of x and y to 100. We opened the Transform properties in the
Inspector window to change the Position x value to 600px and the y value to
340px to center the background so that the default camera can see the
background.
We left-clicked the link icon so that we could change both the x and y values
independently to the values we want. We changed the scale of the x value to 12
and y to 7 so that it covered the area that the default camera will show.
We left-clicked on the Node2D node and then + in the Scene tab to add
Sprite2D as a child of Node2D. We added icon.svg to the texture of Sprite2D.
We moved the starting location of the player by changing the Transform
Position values of x to 85 and y to 600. We scaled the size down by changing the
Transform Scale values of x to .5. Because the link icon was not changed, the
y value also was changed to .5. We will come back to this later when we add it
to CharacterBody2D.
We added another MeshInstance2D node as a child of the Node2D node. We
added a BoxMesh to the Mesh property. We changed the Size values of x and y
to 50. We left-clicked Visibility in the Inspector window and left-clicked on the
white field to the right of Modulate to change the color of MeshInstance2D.
We opened the Transform properties in the Inspector window to change the
Position x value to 1100px and the y value to 40px.
We left-clicked on MeshInstance2D so that when we create a
AudioStreamPlayer2D node, it will be the child of MeshInstance2D. We
added the AudioStreamPlayer2D node to the Scene tab. From the
FileSystem tab, we dragged the soft-rain-ambient-111154.mp3 file we used in the
first recipe into the Stream property of the Inspector window. We checked
the checkbox of the Autoplay property in the Inspector window.
We changed the value of Max Distance to 1900 so that we can only hear it when
the player gets close to the AudioStreamPlayer2D node that is on
MeshInstance2D. The Attenuation property, under Max Distance in the
Inspector window, is how much the sound will drop off as the player moves
away from MeshInstance2D. You can experiment with that setting. In the
Transform properties in the Inspector window, we set the x value to 1100 and
the y value to 40 so that the AudioStreamPlayer2D node is positioned where
MeshInstance2D is positioned.
We created a CharacterBody2D node as a child of Node2D. Left-clicking on
the CharacterBody2D node, we added a CollisionShape2D node as a child of
the CharacterBody2D node. In the Inspector window for CollisionShape2D,
we selected New RectangleShape2D from the drop-down list. We left-clicked
and dragged the Sprite2D node in the Scene tab onto the CharacterBody2D
node.
The Sprite2D node is now a child of the CharacterBody2D node. We leftclicked on the CollisionShape2D node in the Scene tab and saw it highlighted
in the top-left corner of the white background. We left-clicked on that, resized it
as needed, and then dragged it onto Sprite2D at the bottom-left corner of the
white background.
We left-clicked CharacterBody2D in the Scene tab and added
AudioListener2D as a child node of the CharacterBody2D node. In the
Inspector window, we checked the On checkbox to the right of Current so
that AudioListener2D was active.
We added a script to the CharacterBody2D node. We left-clicked the
CharacterBody2D node, and in the Inspector window, we left-clicked on
<empty> to the right of Script. In the dropdown, we selected New Script. In
the popup, we made sure that the template was empty because we are not
going to use the default CharacterBody2D: Basic Movement script. We named the
script Player.gd.
We wrote a simple code that moves the player in all directions. In line 3, we
created a variable called speed and assigned it the value of 300. We used @export
so that we could change this value in the Inspector window. In line 5, we
created a get_input() function, where we look for the input direction and assign
the velocity value. In line 6, we looked to see whether the arrow key was
pressed.
In line 7, we assigned the velocity value equal to the direction x speed. In line
9, we used the _physics_process(delta) function. Since we are not using delta in
this function, we put an underscore before delta. Line 10 calls the get_input()
function, and line 11 calls the move_and_slide() function, which moves the player.
When we run the current scene, we move the player up toward the
MeshInstance2D square, and as we get closer, we hear our sound file. When
we move away from the square, the sound fades out.
Figure 7.4 – Moving the player to the red square
Using directional sound in 3D
In this recipe, we will attach an AudioStreamPlayer3D node to a cylinder and
create a player. When the player moves toward the cylinder, the sound file will
play and get louder as the player gets closer.
Getting ready
For this recipe, open Godot 4 and start a new project called Chapter 7. In the
Scene tab, click on 3D to add a 3D scene. Click on Scene in the main menu
next to Project, then select Save Scene As, and name the scene Audio3D.
How to do it…
Let’s first start by making a ground, a post, a player, and a camera. After that,
we will add the AudioStreamPlayer3D node to the post and AudioListener to
the player:
1. Left-click the three vertical dots to the left of the Transform view on the viewport toolbar.
2. Add Sun and Environment to the scene by left-clicking the Add Environment to Scene button at
the bottom while holding down the Shift key.
3. Left-click on the Node3D node and then + in the Scene tab. In the Create New Node window, type
mesh in the Search box and then select MeshInstance3D to create the node in the scene. Left-click
the Create button.
4. Right-click the MeshInstance3D node in the Scene tab and rename it Ground.
5. In the Inspector window, click on <empty> to the right of Mesh and select New PlaneMesh.
6. Left-click on the same place to open the properties of the Ground mesh.
7. In the Inspector window, change the Size property of x to 15 and y to 15.
8. Left-click on the Node3D node and then + in the Scene tab. In the Create New Node window, type
mesh in the Search box and then select MeshInstance3D to create the node in the Scene tab. Leftclick the Create button.
9. Right-click the MeshInstance3D node in the Scene tab and rename it Post.
10. In the Inspector window, click on <empty> to the right of Mesh and select New CylinderMesh.
11. In the Inspector window, left-click on Transform.
12. Under Position, change the values of x to 5, y to 1, and z to –5.
13. Left-click on the Node3D node and then + in the Scene tab. In the Create New Node window, type
char in the Search box and then select CharacterBody3D to create the node in the scene. Left-click
the Create button.
14. Left-click on the CharacterBody3D node and then + in the Scene tab. In the Create New Node
window, type coll in the Search box and then select CollisionShape3D to create the node in the
scene. Left-click the Create button.
15. In the Inspector window, click on <empty> to the right of Shape and select New
CapsuleShape3D.
16. Left-click on the CharacterBody3D node and then + in the Scene tab. In the Create New Node
window, type mesh in the Search box and then select MeshInstance3D to create the node in the
scene. Left-click the Create button.
17. Right-click the MeshInstance3D node in the Scene tab and rename it Player.
18. In the Inspector window, click on <empty> to the right of Mesh and select New CapsuleMesh.
19. Left-click on the CharacterBody3D node.
20. In the Inspector window, left-click on Transform.
21. Under Position, change the values of x to -6, y to 1, and z to 6.
22. In the Inspector window, left-click on <empty> to the right of Script.
23. Select New Script from the drop-down list.
24. In Template:, make sure it is not empty. If it is, then click on the button to the right of Template: to
see CharacterBody3D: Basic Movement.
25. In Path:, rename the script Player3D.gd.
26. Left-click on the Create button.
27. Change line 8 to var gravity = 0.
Figure 7.5 – Player3D.gd (the change to line 8)
28. Left-click the 3D workspace above the viewport.
29. Left-click on the CharacterBody3D node and then + in the Scene tab. In the Create New Node
window, type cam in the Search box and then select Camera3D to create the node in the Scene tab.
Left-click the Create button.
30. In the Inspector window, left-click on Transform.
31. Under Position, change the values of x to 5, y to 4, and z to 7.
32. Under Rotation, change the values of x to -8.
33. Left-click on the CharacterBody3D node and then + in the Scene tab. In the Create New Node
window, type aud in the Search box and then select AudioListener3D to create the node in the
scene. Left-click the Create button.
34. In the Inspector window of AudioListener3D, check the On checkbox to the right of Current.
35. Left-click on the Post node and then + in the Scene tab. In the Create New Node window, type aud
in the Search box and then select AudioStreamPlayer3D from the drop-down list to create the node
in the Scene tab. Left-click the Create button.
36. Left-click on the AudioStreamPlayer3D node in the Scene tab.
37. In the FileSystem tab, left-click, hold, and drag soft-rain-ambient-111154.mp3 (or .WAV) to
<empty> to the right of Stream in the Inspector window.
38. In the Inspector window, check the checkbox to the right of Autoplay.
39. In the Inspector window to the right of Unit Size, left-click on 10 and change it to 1.5.
40. In the Audio3D scene, click the Run the current scene button in the upper-right corner of the
editor or hit the F6 key.
Figure 7.6 – AudioStreamPlayer3D – the Unit Size radius
Use the arrow keys to move the player to the post, and as you get closer, the
volume increases. When you get to the post, move from the left of the post,
through the post, and then to the right of the post.
Figure 7.7 – Moving the player to the left of the post
How it works…
We added a MeshInstance3D node as a child of the Node3D node and
renamed it Ground. We added a PlaneMesh to the Mesh property. We changed
the Size values of x and y to 15.
We added a MeshInstance3D node as a child of the Node3D node and
renamed it Post. We added a CylinderMesh to the Mesh property. We leftclicked Transform in the Inspector window so that we can change the
Position values to move the post. We changed the Position values of x to 5, y
to 1, and z to –5. This moved the post to the far-right corner.
We created a CharacterBody3D node as a child of the Node3D node. We
added a CollisionShape3D node as a child of the CharacterBody3D node. We
used CapsuleShape3D so that it will fit the player’s CapsuleMesh. We added a
MeshInstance3D node, which we renamed Player. We used a CapsuleMesh for
the player.
We left-clicked on the CharacterBody3D node and then left-clicked
Transform in the Inspector window to change its position. We changed the
Position values of x to -6, y to 1, and z to 6. In the Inspector window, we
created a new script and used the CharacterBody3D: Basic Movement
template. We renamed the script Player3D.gd. We changed line 8 to var gravity = 0
so that the player would not fall through the ground.
We went back to the 3D workspace and left-clicked on the CharacterBody3D
node. We added a Camera3D node to the CharacterBody3D node. In the
Inspector properties of Camera3D, we changed the Position values of x to 5,
y to 4, and z to 7. We changed the rotation value of x to –8.
The camera will follow the player since we have Camera3D as a child of
CharacterBody3D. It’s positioned behind and to the right of the player. The
rotation faces slightly down, so we can see the ground while the player moves.
We added AudioListener3D to the CharacterBody3D node and checked the
On checkbox located to the right of Current. This activates AudioListener3D
on the player. We added the AudioStreamPlayer3D node to the Post node in
the Scene tab. We dragged our soft-rain-ambient-111154.mp3 file into <empty>,
located to the right of Stream.
If you downloaded another file or have your own MP3, WAV, or OGG file, use
that file instead. In the Inspector window, we checked the On checkbox
located to the right of Autoplay. We changed the Unit Size value to 1.5 in the
Inspector window. The unit size is how far the sound can be heard. The further
out the sound is, the softer it is, and the further in the sound is, the louder it is.
The Max dB property will adjust how loud the file is at the maximum volume.
Volume dB is the base sound level. Play around with different files and
settings. You can move the player off of the ground and not fall because we
turned off the gravity in the movement script. When we run the current scene,
as we move the player up toward the post, the sound gets louder. Experiment
with how loud and soft the sounds are in relation to how near and far the player
is to the post.
If you move through the post and in all directions around it, you will see that
the sounds come out of the correct speakers relative to where the player is
positioned.
8
Making 2D Games Easier with TileSet and TileMap
In this chapter, we will download a hex tileset and add a TileMap to Godot. We
will set up the tileset to paint on the TileMap. We will add two layers to the
TileMap: a ground layer for the background and an objects layer to place trees
on top of the ground layer. We will use TileMap tools such as Paint, Rect,
Line, Bucket fill, Picker, and Eraser, and place random tiles to paint our tiles
to the TileMap.
We will edit the color of a tile in the sprite sheet and see what other ways we
can use to edit a tile. We will create an alternative tile and add a collision layer
to the tile. We will set up a navigation layer on the tiles and use Custom Data
Layers to add an Int variable with a value of 10 to a tile.
We will create four terrain tilesets and manually paint them to the TileMap. We
will download a new tileset and add a new TileMap. We will set up the tiles as a
terrain and paint the terrain to the new TileMap, so they tile automatically (or
autotile). We will download an isometric tileset and set up the isometric tiles so
we can paint them on the new TileMap.
By the end of the chapter, we will be able to add layers to the TileMap to create
a game layout using only one TileMap and edit a tile to create custom tiles and
add collision layers to tiles. We will be able to add a navigation layer and add
custom data to a tile so that if a player lands on a tile, they can get a coin, for
example. We will be able to manually paint terrain and autotile terrain to a
TileMap. We will also know how to set up and paint isometric tilesets on a
TileMap.
In this chapter, we will cover the following recipes:
Using the new TileSet editor
Examining TileMap layers
Playing with the new TileMap tools
Playing with Tile Atlas editing
Exploring the TileSet physics
Exploring the TileSet navigation
Creating Custom Data Layers with the TileSet
Painting terrains in TileMap
Transitioning TileSet terrains
Organizing isometric tiles into fixed-sized grids using the TileSet resource
Technical requirements
For this chapter, you need the standard version of Godot 4.0 or later running
on any of the following:
Windows 64-bit or 32-bit
macOS
Linux 64-bit or 32-bit
Android
Web Editor
You can find the code and the project files for the projects in this chapter at
this GitHub link: https://github.com/PacktPublishing/Godot-4-GameDevelopment-Cookbook/tree/main/Chapter%208.
Using the new TileSet editor
In this recipe, we are going to download a hex tileset and bring it into Godot.
We will add a TileMap to the Scene tab and then add a TileSet to the TileMap
in the Inspector. In the TileSet editor, we will use the Setup tab with the hex
file we downloaded to set up the tileset so we can use it to paint with the
TileMap.
Getting ready
For this recipe, open Godot 4 and start a new project called Chapter 8. In the
Scene tab, click 2D to add a 2D scene. Click on the word Scene in the main
menu next to Project and then select Save Scene As and name it TileSet.
How to do it…
We will start by downloading our hex tileset and then adding a TileMap to the
Scene tab:
1. Go to https://opengameart.org/content/hex-tileset-pack and, at the bottom, click on
HexTilesetv3.png.
2. From your Downloads folder, move or copy/paste the file into the FileSystem tab or your Chapter 8
project folder.
3. Left-click on the Node2D node and then the + symbol in the Scene tab. In the Create New Node
window, type tile in the search box and then select TileMap to create the node in the scene. Leftclick on the Create button.
4. In the Inspector, click on <empty> to the right of Tile Set and select New TileSet from the dropdown list.
5. Left-click on the same place to open the properties of the TileSet.
6. In the Inspector, to the right of Tile Size, change the x value to 32 and the y value to 32.
7. In the FileSystem tab, left-click and drag the HexTilesetv3.png file to the blank box under the Tiles
and Patterns tabs in the TileSet editor to the right of the FileSystem tab.
Figure 8.1 – Dragging the HexTilesetv3.png file to the Tiles tab
8. Click Yes on the popup asking whether you would like to automatically create tiles in the atlas.
9. In the Inspector, left-click on Square, which is to the right of Tile Shape, and select Hexagon.
10. In the Inspector, to the right of Tile Offset, left-click on Horizontal Offset and select Vertical
Offset from the drop-down list.
Figure 8.2 – The TileSet and Inspector settings
How it works…
We downloaded HexTilesetv3.png at the bottom of the page. Make sure to
download this file and not the one above it. From the Downloads folder on your
computer, drag the HexTilesetv3.png file into the FileSystem tab of Godot or you
can copy the file in the Downloads folder and then paste it into your Chapter 8
project folder, which we created before we started this recipe. If Godot freezes,
reboot Godot and notice that the file is in the FileSystem tab.
We added a TileMap node by left-clicking the + sign in the Scene tab and
selecting TileMap in the Create New Node window. Then, in the Inspector
tab, we left-clicked on <empty> (located to the right of Tile Set) and selected
New TileSet from the drop-down list. We left-clicked on the TileSet located to
the right of Tile Set in the Inspector to see the new TileSet properties.
We know that the scale of HexTilesetv3.png is 32 x 32 because it was on the
preview page where we downloaded the file. In the Inspector, we changed the
Tile Size values of x and y to 32. We left-clicked and dragged the HexTilesetv3.png
file from the FileSytem tab in the blank box into the Tiles tab in the TileSet
editor. When the popup asked whether we would like to automatically create
tiles in the atlas, we clicked the Yes button.
In the Inspector, we select Tile Shape, and to the right of that is a field with
Square selected. We clicked on Square and, from the dropdown, we selected
Hexagon because the tileset we downloaded is hexagonal. In the Tile Offset
Axis property in the Inspector, we selected Vertical Offset because the tileset
we downloaded is vertically offset.
Examining TileMap layers
In this recipe, we are going to create two layers in the TileMap. One will be for
the ground and the other for objects that we can place on top of the ground. We
will use this in the next recipe, where we will paint a level using the TileMap
tools.
Getting ready
For this recipe, we are going to continue from where we left off in the last
recipe.
How to do it…
Let’s add the Ground and Objects layers so we can use the TileMap tools in
the recipe:
1. In the TileMap section of the Inspector, left-click on Layers.
2. To the right of Name, enter Ground.
3. At the bottom under Z Index, left-click on + Add Element.
4. In the new layer, to the right of Name, enter Objects.
5. To the right of Z Index in the new layer, left-click on 0 and enter 1.
Figure 8.3 – Layers properties in the Inspector
6. At the very bottom of the bottom panel and to the right of TileSet, click on the TileMap editor to see
the layers we entered.
Figure 8.4 – The Ground and Objects layers in the TileMap editor
How it works…
We looked in the Inspector, and at the bottom of the TileMap section and
above the Node2D section, we clicked on Layers to see the layers’ properties.
In the Name field, we entered Ground to name this layer. We left Z Index at 0
because we will always see this layer as this is the background of our level. At
the bottom, we clicked on the + Add Element button to add another layer.
We entered Objects in the Name field to name this layer. We changed the Z
Index value of this layer to 1 so that when we paint using this layer, we can see
the Ground and Objects layers at the same time.
We clicked on TileMap at the bottom of the bottom panel to see the TileMap
editor. In the upper-right corner of the TileMap editor, we saw the layers that
we just created, as shown in Figure 8.4.
Playing with the new TileMap tools
In this recipe, we will use the TileMap editor to paint our tiles. We will use
TileMap tools such as Paint, Rect, Line, Bucket fill, Picker, and Eraser, and
place random tiles.
Getting ready
For this recipe, we are going to continue from where we left off in the last
recipe.
How to do it…
In the first three steps, we are making sure we are in the TileMap editor and
the Ground layer is selected. We should be if you just finished the last recipe.
Follow these steps now:
1. In the Scene tab, left-click on the TileMap node.
2. At the very bottom of the bottom panel and to the right of TileSet, click on the TileMap editor.
3. Make sure the Ground layer is selected. It is to the right of the TileMap tools we are going to use in
this recipe. See Figure 8.5 to see the TileMap editor.
4. Select the Paint (D) icon located to the right of the Tile | Patterns | Terrains tabs, and the
Selection (S) icon at the top of the bottom panel. It is selected in Figure 8.5 and is blue with a blue
outline around it.
5. Left-click on the green hexagon in the Base Tiles sprite sheet and move the mouse to the hexagon
grid in the viewport.
6. Left-click on where you want to place the tile.
Figure 8.5 – The selected paint tool in the TileMap toolbar
7. Select the Line (L) icon located to the right of the Paint (D) icon.
8. Left-click on the brown hexagon in the Base Tiles sprite sheet and move the mouse to the hexagon
grid in the viewport.
9. Left-click and hold, then move the mouse where you want to place the line of tiles.
10. Select the Rect (R) icon located to the right of the Line (L) icon.
11. Left-click on the blue hexagon in the Base Tiles sprite sheet and move the mouse to the hexagon grid
in the viewport.
12. Left-click and hold, then move the mouse where you want to place the tiles in a rectangle pattern.
13. Select the Bucket (B) icon located to the right of the Rect (R) icon.
14. Left-click on the green hexagon in the Base Tiles sprite sheet and move the mouse to the hexagon
grid in the viewport.
15. Left-click, then move the mouse over the area we put the blue hexagons in and left-click to paint that
area green.
16. Let’s paint some more using the green, brown, blue, and white hexagons before we start painting on
the Object layer.
Figure 8.6 – Painting the Ground layer tiles
17. Left-click on Ground located to the right of the paint icons and select Objects from the drop-down
list.
18. Left-click on the Rect (R) icon.
19. Left-click on the Place Random Tile icon to the left of Objects.
20. Change the field to the right of Scattering to 5.
21. Left-click on the trees under the green hexagon in the sprite sheet and move the mouse into the
viewport. Left-click and hold and drag an area in the hexagons you painted.
22. Left-click on the Place Random Tile icon to turn it off.
23. Left-click on the Eraser (E) icon to the left of the Place Random Tile icon.
24. Click on a tree that was painted and left-click on the Eraser (E) icon to turn it off.
25. Left-click on the Picker (P) icon to the left of the Eraser (E) icon and click on a tree that was
painted.
26. Left-click on an empty tile.
How it works…
We made sure that we clicked on the TileMap node in the Scene tab so we
could select the TileMap editor in the bottom panel. We made sure the Ground
layer was showing so that when we paint, it is on the correct layer.
We found where the TileMap toolbar is located and selected the Paint icon. We
selected the green hexagon in the Base Tiles sprite sheet and moved the
mouse to the hexagon grid in the viewport and left-clicked where we wanted to
place the tile. While using the Paint tool, we can hold Shift + Ctrl and drag to
draw a rectangle, or Shift and drag to draw a line.
We selected the Line (L) icon located to the right of the Paint (D) icon. We
left-clicked on the brown hexagon tile and moved the mouse into the viewport.
We left-clicked and held, then moved the mouse to another hexagon in the
viewport. We created a line of brown hexagons from the spot we first selected
to the last spot at which we stopped dragging.
We selected the Rect (R) icon located to the right of the Line (L) icon. We leftclicked on the blue hexagon tile and moved the mouse into the viewport. We
left-clicked and held, then moved the mouse to another hexagon in the
viewport. We created a rectangle of blue hexagons from the spot we first
selected to the last spot at which we stopped dragging. Since we are using
hexagons, we won’t see perfect rectangles, but you can sort of see a rectangle
shape.
We selected the Bucket (B) icon located to the right of the Rect (R) icon. We
left-clicked the green hexagon tile and moved the mouse into the viewport. We
left-clicked, then moved the mouse over the blue hexagons we just added, and
left-clicked to paint them green.
If you paint borders above and below, you can use the Bucket (B) tool to fill in
the space between them. We used the paint tools we just learned about to paint
more tiles, so we have more tiles to use the Place Random Tile and the
Picker icons.
We changed the layer that we are going to work on by left-clicking on Ground
and selecting Objects from the dropdown. We left-clicked on the Rect (R) icon
so that when we paint the trees onto the layer using the Place Random Tiles
icon, we can cover a large area. We could also use the Bucket (B) icon if we
wanted to place the tree over everything we painted on the Ground layer.
We left-clicked on the Place Random Tiles icon so we can place random tiles
over a section that we selected. We changed the value in Scattering to 5 to
give us a good amount of space and trees. If we left the Scattering value at 0,
trees would be painted on all of the selected areas. We left-clicked on the tree’s
hexagon located under the green hexagon in the sprite sheet. Then, we painted
the trees on the Objects layer over the Ground layer.
We left-clicked the Place Random Tile icon to select it. We left-clicked on the
Eraser (E) icon and then left-clicked on a tree that we previously painted to
erase that tree. We left-clicked the Place Random Tile icon to unselect it. You
can right-click a tile to erase the tile as well.
We left-clicked on the Picker (P) icon and then left-clicked on a tree tile. We
left-clicked on an empty tile to paint a tree. The Picker (P) tool is used to
select a tile in the TileMap and paint that tile somewhere else.
Playing with Tile Atlas editing
In this recipe, we will edit the color of a tile in the sprite sheet and see the
other ways in which we can edit a tile. Then, we will paint the tile on the
TileMap with the new color.
Getting ready
For this recipe, we are going to continue from where we left off in the last
recipe.
How to do it…
We are going to change the color of the tile in the upper-right corner of the
sprite sheet:
1. Make sure the TileMap node in the Scene tab is selected.
2. In the bottom panel, left-click on TileSet.
3. In the section to the left of the sprite sheet, left-click on Select, which is between Setup and Paint.
4. Left-click on the tile in the upper-right corner of the sprite sheet.
5. Left-click on Rendering to show the rendering properties we can edit.
Figure 8.7 – Rendering properties location in Select
6. Left-click on the White field to the right of Modulate.
7. Change the values of R and G to 0.
8. Left-click on Modulate to exit the popup.
9. Left-click on TileMap on the bottom panel to the right of TileSet.
10. Make sure we are on the Objects layer.
11. Left-click on the tile we just changed and paint it on a tile.
How it works…
We checked to see whether we left-clicked the TileMap node in the Scene tab
so we could see TileSet and TileMap on the bottom panel. We left-clicked on
TileSet to see the TileSet editor and then we left-clicked on the tile in the
upper-right corner of the sprite sheet so we could edit this tile.
We looked at the section to the left of the sprite sheet located on the right side
of the bottom panel. We see Setup, Select, and Paint above a field that shows
the properties. The properties of Setup are used to edit the Atlas and create or
remove base tiles. The Select properties are used to edit the tiles. Paint
Properties are used to paint over the tiles. We left-clicked on Select to edit a
tile.
We left-clicked on Rendering to see its properties. We left-clicked on the white
field to the right of Modulate. In the color popup, we changed the values of R
and G to 0 so the color of the tile is now blue. We left-clicked Modulate to exit
the color popup.
We left-clicked on the TileMap in the bottom panel and made sure we were on
the Objects layer. Then, we painted the tile that we just changed onto the
TileMap.
Exploring the TileSet physics
In this recipe, we are going to create an alternative tile and add a collision
layer to the tile. We will paint the tiles on our TileMap.
Getting ready
For this recipe, we are going to continue from where we left off in the last
recipe.
How to do it…
First, we are going to create an alternative tile to add a collision layer to the
tile:
1. In the TileSet editor, go to the section to the left of the sprite sheet. Left-click on Select, which is
between Setup and Paint.
2. In the TileSet editor, right-click on the upper-right tile in the sprite sheet. It’s the one that we
changed the color of.
3. Left-click on Create an Alternative Tile from the drop-down list.
4. In the Inspector, left-click on Physics Layers in the TileMap properties located under Tile Size.
5. Left-click on + Add Element.
6. In the bottom panel, left-click on the tile we just created located under Alternative Tiles.
7. In the section to the left of the sprite sheet, left-click on Select.
8. Left-click on Physics and then Physics Layer 0.
9. At the bottom where you see the tile, left-click on the green Add Polygon tool.
10. Left-click on the inside of the green area of the tile in a circle and, at the end, click the first place you
clicked to close the circle. Adjust as needed by moving the points that you added around the green
circle.
Figure 8.8 – Physics Layers in the Inspector and TileSet
11. Left-click on Paint, which is to the right of Select.
12. Under Paint Properties, left-click on the Select a property editor and select Physics Layer 0 from
the drop-down list.
13. Confirm that the title has Physics Layer on the tile.
14. Left-click on TileMap on the bottom panel to the right of TileSet.
15. Make sure we are on the Objects layer.
16. Left-click on the tile we just changed and paint it on a tile.
How it works…
We left-clicked Select in the TileSet editor so we could edit the tile. We rightclicked on the upper-right tile in the sprite sheet and then left-clicked on
Create an Alternative Tile from the drop-down list. This created a copy of the
tile with its original color. The new tile is located under Alternative Tiles,
which is to the right of Base Tiles.
We left-clicked on Physics Layers in the Inspector. This adds a Physics layer
to the TileSet where we can add a collision shape to the tile.
We left-clicked on the alternative tile that we made and left-clicked on Select
located to the left of the sprite sheet in between Setup and Paint. We left-
clicked on Physics and then Physics Layer 0 to see the tile we were going to
add the collision shape to. Under Angular, we left-clicked the Add Polygon
tool and clicked areas inside of the green circle and clicked on the first dot that
we placed.
This is the collision shape of the tile. You can left-click on the dots and drag to
move the collision shape to exactly where you want it. If you want the whole tile
to have a collision shape, then left-click on the three vertical dots to the right of
the Delete Points tool. Select Reset to default tile shape from the dropdown list.
We left-clicked on Paint. In Paint Properties, we left-clicked on the Select a
property editor and selected Physics Layer 0 to check to see whether the
hexagon had the Physics layer that we edited in the tile. If it does not, then
left-click the three vertical dots and left-click the Add Polygon tool and click
areas inside of the green circle.
We left-clicked on the TileMap in the bottom panel and made sure we were on
the Objects layer. Then, we painted the tile that we just changed onto the
TileMap.
Exploring the TileSet navigation
In this recipe, we will create another alternative tile, and on that tile, we will
set up a navigation layer. We paint the tile with the navigation layer on to the
TileMap.
Getting ready
For this recipe, we are going to continue from where we left off in the last
recipe.
How to do it…
First, we are going to create an alternative tile to add a navigation layer to the
tile:
1. In the TileSet editor, go to the section to the left of the sprite sheet. Left-click on Select, which is in
between Setup and Paint.
2. In the TileSet editor, right-click on the upper-left tile in the sprite sheet. It’s a blank hexagon tile next
to the white hexagon tile.
3. Left-click on Create an Alternative Tile from the drop-down list.
4. In the Inspector left click on Navigation Layers in the TileMap properties located under Terrain
Sets.
5. Left click + Add Element.
6. In the bottom panel, left-click on the tile we just created located under Alternative Tiles.
7. In the section to the left of the sprite sheet, left-click on Select.
8. Left-click on Navigation and then Navigation Layer 0.
9. Below Navigation Layer 0, left-click on the three vertical dots.
10. Left-click on Reset to default tile shape from the drop-down list.
11. Left-click on Paint, which is to the right of Select.
12. Under Paint Properties, left-click on Select a property editor and select Navigation Layer 0.
13. Confirm that the tile is blue and has the navigation layer on the tile.
14. Left-click on TileMap on the bottom panel to the right of TileSet.
15. Make sure we are on the Objects layer.
16. Left-click on the tile we just changed and paint it on a tile.
Figure 8.9 – Navigation layers in the Inspector and TileSet
How it works…
We left-clicked Select in the TileSet editor so we could edit the tile. We rightclicked on the upper-left tile in the sprite sheet and then left-clicked on Create
an Alternative Tile from the drop-down list. This created a copy of the blank
hexagon tile. The new tile is located under Alternative Tiles, which is to the
right of Base Tiles. We left clicked on the Navigation Layers in the
Inspector. This adds a Navigation Layer to the TileSet.
We left-clicked on the alternative tile that we made and left-clicked on Select
located to the left of the sprite sheet in between Setup and Paint. We leftclicked on Navigation and then Navigation Layer 0 to see the tile we were
going to add the collision shape to. We left-clicked on the three vertical dots to
the right of the Delete Points tool and selected Reset to default tile shape
from the drop-down list. Now, the tile is filled in blue, which is the navigation
layer.
We left-clicked on Paint. In Paint Properties, we left-clicked on the Select a
property editor and selected Navigation Layer 0 to check whether the
hexagon tile has the navigation layer that we edited in the tile. If it does not,
then left-click on the three vertical dots and select Reset to default tile shape
from the drop-down list.
We left-clicked on the TileMap in the bottom panel and made sure we were on
the Objects layer. Then, we painted the tile that we just changed onto the
TileMap in a path to simulate where the player can walk on the map.
Creating Custom Data Layers with the TileSet
In this recipe, we are going to use a Custom Data Layer. We will name it Coins
to add an Int variable with a value of 10. In the two previous recipes, we edited
the tile and then confirmed the settings in the Paint properties. This time, we
are going to only set up the Paint properties before we paint the tile in the
TileMap.
Getting ready
For this recipe, we are going to continue from where we left off in the last
recipe.
How to do it…
First, we are going to create an alternative tile to add a navigation layer to the
tile:
1. In the TileSet editor, go to the section to the left of the sprite sheet. Left-click on Select, which is in
between Setup and Paint.
2. In the TileSet editor, right-click on the yellow $ in the sprite sheet. Its atlas coordinates are (2, 14).
Figure 8.10 – Atlas coordinates (2, 14)
3. Left-click on Create an Alternative Tile from the drop-down list.
4. In the Inspector, left-click on Custom Data Layers in the TileMap properties located under
Navigation Layers.
5. Left click + Add Element.
6. To the right of Name, type in Coins.
7. To the right of Type, left-click on Any and select Int.
8. In the bottom panel, left-click on the tile we just created located under Alternative Tiles.
9. In the middle of the TileSet editor, to the left of the sprite sheet, left-click on Paint.
10. Under Paint Properties, left-click on Select a property editor.
11. Left-click on Coins under Custom Data.
12. Under Painting and to the right of Coins, left-click on 0.
13. Type 10 to replace 0.
Figure 8.11 – Paint Properties (Custom Data Layers | Inspector and Paint Properties | TileSet)
14. Left-click on TileMap on the bottom panel to the right of TileSet.
15. Make sure we are on the Objects layer.
16. Left-click on the tile we just changed and paint it on a tile.
How it works…
We left-clicked Select in the TileSet editor so we could edit the tile. We rightclicked on the yellow $ located at (2, 14) in the atlas. Then, we left-clicked on
Create an Alternative Tile from the drop-down list. This created a copy of the
yellow $ hexagon tile. The new tile is located under Alternative Tiles, which is
to the right of Base Tiles.
We left-clicked on Custom Data Layers in the Inspector. This added a
Custom Data Layer. We entered Coins as the name of this data layer. For the
type of this data layer, we selected Int from the drop-down list. In the bottom
panel, we left-clicked on the tile we just created located under Alternative
Tiles just to make sure we were still on that tile.
We left-clicked on Paint. In Paint Properties, we left-clicked on Select a
property editor. We left-clicked Coins under Custom Data. Under Painting
and to the right of Custom Data 0, we left-clicked on 0 and typed 10 into the
field.
We left-clicked on the TileMap in the bottom panel and made sure we were on
the Objects layer. Then, we painted the tile that we just changed onto the
TileMap. In a real game, you would get the value returned when the player
walks on the tile by the game code.
Painting terrains in TileMap
In this recipe, we are going to create four terrain sets in the Inspector and
TileSet. Then, in the TileMap, we are going to paint the terrains.
Getting ready
For this recipe, we are going to continue from where we left off in the last
recipe.
How to do it…
First, we will set up the terrain sets in the Inspector and then in the TileSet:
1. In the Inspector, left-click on Terrain Sets located in between Physics Layers and Navigation
Layers.
2. Left-click on the + Add Element button below Terrain Sets and left-click on Terrains.
3. Under Terrains, left-click on the + Add Element button.
4. To the right of Name, change it to Dirt.
5. Left-click on the + Add Element button at the bottom of the Terrain Sets section in the Inspector.
6. To the right of Name, change it to Grass.
7. Left-click the field that shows the color to the right of Color. Change the color to Green (hex 80d840).
8. Left-click on the + Add Element button at the bottom of the Terrain Sets section in the Inspector.
9. To the right of Name, change it to Water.
10. Left-click on the field to the right of Color. Change the color to Blue (hex 2c53f0).
11. Left-click on the + Add Element button at the bottom of the Terrain Sets section in the Inspector.
12. To the right of Name, change it to Snow.
13. Left-click the field to the right of Color. Change the color to White (hex ffffff).
14. In the bottom panel, left-click on Paint.
15. In Paint Properties, left-click on Select a property editor and select Terrains.
16. Under Painting and to the right of Terrain Set, left-click on No terrains.
17. Left-click on Terrain Set 0.
18. To the right of Terrain, left-click on No terrain.
19. In the dropdown, select Dirt.
20. On the sprite sheet, left-click on the brown hexagon in the atlas coordinate (1, 1).
21. Left-click and drag all over the hexagon until it’s filled.
22. To the right of Terrain, left-click Dirt.
23. In the dropdown, select Grass.
24. On the sprite sheet, left-click on the green hexagon in the atlas coordinate (0, 1).
25. Left-click and drag all over the hexagon until it’s filled.
26. To the right of Terrain, left-click Grass.
27. In the dropdown, select Water.
28. On the sprite sheet, left-click on the blue hexagon in the atlas coordinate (2, 1).
29. Left-click and drag all over the hexagon until it’s filled.
30. To the right of Terrain, left-click Water.
31. In the dropdown, select Snow.
32. On the sprite sheet, left-click on the white hexagon in the atlas coordinate (1, 0).
33. Left-click and drag all over the hexagon until it’s filled.
34. In the bottom panel at the bottom right, left-click on TileMap.
35. At the top left of the bottom panel, there are Tiles, Patterns, and Terrains tabs. Left-click on the
Terrains tab.
36. Off to the side of the painted tiles that we did previously, pick a terrain tile and paint a terrain. You
will see the Terrains tab with a list of terrain tiles, as shown in the following figure:
Figure 8.12 – The Terrains tab with a list of terrain tiles
How it works…
We left-clicked on Terrain Sets located in between Physics Layers and
Navigation Layers in the Inspector. We left-clicked on the + Add Element
button below Terrain Sets. Under Terrain Sets, in the Inspector, we saw
Mode with Match Corners and Sides. We ignored that and left-clicked on the
+ Add Element button below it. We will learn about the Mode options in the
next recipe. We left-clicked Terrains in the Inspector.
Then, under Terrains, we left-clicked on the + Add Element button. We
changed the name of the terrain that appeared to Dirt. The color was brown by
default, so we didn’t change anything. If the color is not brown, then left-click
on the field to the right of Color and change the color to brown (hex 805840). We
left-clicked on + Add Element at the bottom of the Terrain Sets section in the
Inspector and changed the name of the next terrain to Grass. We changed the
color to green. We repeated that two more times to add a blue Water and white
Snow terrain.
We go to the bottom panel and select Paint to see Paint Properties for
Terrains. Under Painting, we change the Terrain Set field to Terrain Set 0.
This shows Terrain with a field to the right that says No terrain. We leftclicked on No terrain and the terrains that we created in the Inspector were
listed below No terrain in the drop-down list.
At the top of the sprite sheet, we saw the tiles that we were going to use for
these terrains. We selected Dirt in the drop-down list and left-clicked on the
brown hexagon that we used in a previous recipe. We left-clicked and dragged
all over the hexagon until it was filled. We did the same for Grass, Water, and
Snow in the drop-down list.
We went to the TileMap on the bottom panel and selected the Terrains tab to
see all of the terrain tiles that we just finished setting up. In the viewport, we
went to a clear spot and selected the terrain tiles and painted a terrain.
Transitioning TileSet terrains
In this recipe, we will use a new TileSet, which we are going to download. We
will add a new TileMap and set up the tiles so they will autotile when we paint
the terrain to the new TileMap.
Getting ready
For this recipe, we are going to continue from where we left off in the last
recipe.
How to do it…
First, let’s download a new TileSet to use with a square tile shape. We are
going to use it in the new TileMap that we will add in the Scene tab. You can
create a new scene and add the new TileMap if you want to keep the TileMaps
separate:
1. Go to https://opengameart.org/content/happyland-tileset and download tileset.png.
2. From your Downloads folder, move or copy/paste the file into the FileSystem tab or your Chapter 8
project folder.
3. Left-click on the Node2D node and then + in the Scene tab. In the Create New Node window, type
tile in the search box and then select TileMap to create the node in the Scene. Left-click the Create
button.
4. In the Inspector, click on <empty> to the right of TileSet and select New TileSet from the dropdown list.
5. Left-click on the same place to open the properties of the TileSet.
6. Left-click and drag tileset.png into the Tiles tab in the TileSet editor on the bottom panel and select
No in the pop-up window.
7. In the TileSet on the bottom panel, left-click Setup located to the right of the Tiles tab.
8. Left-click and drag over the tiles in the upper-left corner with the water and grass, as shown in Figure
8.13.
Figure 8.13 – Manually selecting tiles
9. In the Inspector, left-click on Terrain Sets located in between Physics Layers and Navigation
Layers.
10. Left-click on the + Add Element button below Terrain Sets.
11. Left-click on the field to the right of Mode.
12. Select Match Sides.
13. Left-click Terrains.
14. Under Terrains, left-click on the + Add Element button.
15. To the right of Name, change it to Water.
16. Left-click on the field to the right of Color.
17. Change the color to Blue (hex 0000ff).
18. Left-click on the + Add Element button below Color and Water.
19. To the right of Name, change it to Grass.
20. Left-click on the field to the right of Color.
21. Change the color to Green (hex 002e00).
22. Left-click on Paint located to the left of the sprite sheet on the right side of the bottom panel.
23. Under Paint Properties, left-click on Select a property editor.
24. Select Terrains in the drop-down list.
25. Left-click on No terrains, located to the right of Terrain Set under Painting.
26. Select Terrain Set 0 in the drop-down list.
27. Left-click on No terrain, located to the right of Terrain under Terrain Set.
28. Select Water from the drop-down list.
29. Left-click in the center of the nine water squares so a blue dot appears in the middle.
30. Left-click on each side that faces away from the grass tile in the center. Be sure to fill the blue square
on the bottom right, as shown in Figure 8.14.
31. To the right of Terrain, left-click on Water.
32. Select Grass in the drop-down list.
33. Left-click on the center of the five grass squares so a green dot appears in the middle.
34. Left-click on each side that faces in toward the grass tile on the edges. Be sure to fill the green square
in the center of the water tiles, as shown in Figure 8.14.
Figure 8.14 – Painting the Water and Grass terrain tiles
35. Left-click on TileMap in the bottom panel to the right of TileSet.
36. In the top left of the bottom panel, there are Tiles, Patterns, and Terrains tabs. Left-click on the
Terrains tab.
37. Left-click on Grass and, in a space off to the side of the other TileMap, paint some grass. Then, leftclick on Water to add some water, as shown in the following figure:
Figure 8.15 – Painting grass and water on TileMap2
How it works…
We downloaded tileset.png at the bottom of the page. From the Downloads folder
on your computer, drag the tileset.png file into the FileSystem tab of Godot or
you can copy the file in the Downloads folder and paste it into your Chapter 8
project folder, which we created before we started this recipe. If Godot freezes,
reboot it and notice that the file is in the FileSystem tab.
We added a TileMap node by left-clicking the + sign in the Scene tab and
selecting TileMap in the Create New Node window. Then, in the Inspector
tab, we left-clicked on <empty> located to the right of Tile Set and selected
New TileSet from the drop-down list. We left-clicked on the TileSet located to
the right of Tile Set in the Inspector to see the new TileSet properties of
TileMap2.
We left-clicked and dragged the tileset.png file into the Tiles tab of the TileSet
in the bottom panel. This time, we manually selected the tiles by selecting No
when the pop-up window asked whether we wanted to automatically create the
tiles. We left-clicked the Setup tab in the bottom panel to select the tiles we
wanted to use in this TileSet. We left-clicked and dragged on the tiles in the
upper-left corner with the water and grass to select these tiles and use only
these tiles in the tile sheet.
We left-clicked on Terrain Sets located in between Physics Layers and
Navigation Layers to see the properties. We left-clicked on the field to the
right of Mode and selected Match Sides. The Match Sides, Match Corners,
and Match Corners and Sides options are used for terrains to match each
other in the terrain set.
We left-clicked Terrains in the Inspector. Then, under Terrains, we leftclicked on the + Add Element button. We changed the name of the terrain
that appeared to Water. We changed the color to blue. We left-clicked on the +
Add Element button at the bottom of the Terrain Sets section in the Inspector
and changed the name of the next terrain to Grass. We changed that color to
green.
We left-clicked Paint located to the left of the sprite sheet on the right side of
the bottom panel and left-clicked on Select a property editor. We selected
Terrains in the drop-down list and left-clicked No terrains, located to the right
of Terrain Set. We selected Terrain Set 0 in the drop-down list. We leftclicked No terrain located to the right of Terrain. We saw Water and Grass in
the drop-down list and left-clicked on Water. We left-clicked in the middle of all
of the water squares.
We left-clicked on each side that faces away from the grass tile in the center,
and we made sure to fill the blue square with no grass in the tile. For the Grass
tiles, we left-clicked on each side that faces toward the grass tile in the center,
and we made sure to fill the green square in the center of the water tiles. By
left-clicking in the center of a tile, you have selected the tile to be used when
we paint the TileMap. When we left-clicked on the sides of a tile, we set it up so
that a tile would spawn in the direction we selected.
We went to the TileMap in the bottom panel and selected the Terrains tab to
see the Water and Grass terrain tiles that we just finished setting up. In the
viewport, we went to a clear spot and selected the terrain tiles and painted a
terrain. For this tileset, autotiles work most of the time. You can select a
specific tile and paint that as well as using autotiles.
Organizing isometric tiles into fixed-sized grids
using the TileSet resource
In this recipe, we are going to download an isometric tileset. We will add a new
TileMap, set up the tiles, and paint the tiles onto the new TileMap.
Getting ready
For this recipe, we are going to continue from where we left off in the last
recipe.
How to do it…
We are going to download an isometric tileset and add a new TileMap to the
Scene tab. You can create a new scene and add the new TileMap if you want to
keep the TileMaps separate:
1. Go to https://opengameart.org/content/towers-of-defense and download towers of defense.png.
2. From your Downloads folder, move or copy/paste the file into the FileSystem tab or your Chapter 8
project folder and left-click on No in the pop-up window.
3. Left-click on the Node2D node and then + in the Scene tab. In the Create New Node window, type
tile in the search box and then select TileMap to create the node in the scene. Left-click on the
Create button.
4. In the Inspector, click on <empty> to the right of Tile Set and select New TileSet from the dropdown list.
5. Left-click on the same place to open the properties of the TileSet.
6. In the Inspector, change the Tile Size values of x and y to 32.
7. Left-click and drag towers of defense.png into the Tiles tab in the TileSet editor in the bottom
panel and select No in the pop-up window.
8. In the TileSet on the bottom panel, left-click Setup located to the right of the Tiles tab, and then leftclick on the top two tiles.
9. In the Inspector, to the right of Tile Shape, left-click on Square and select isometric from the dropdown list.
10. To the right of Tile Offset Axis, left-click on Horizontal Offset and select Vertical Offset from the
drop-down list.
11. In the Inspector under CanvasItem, left-click on Ordering.
12. To the right of Y Sort Enabled, check the On checkbox.
13. In the Inspector above Node2D, left-click on Layers.
14. To the right of Y Sort Enabled, check the On checkbox.
15. In the TileMap, make sure the Tiles tab is selected.
16. Left-click on the grass tile and place two or four tiles on an empty part of the grid in the viewport.
17. In the Inspector, left-click and hold on the number 32 of the y value in the Tile Size property; then
move the mouse to the left to adjust the tiles so they fit together.
18. The value of y should be 16. Place more grass and concrete tiles down, as shown in the following
figure:
Figure 8.16 – Isometric tiles Inspector and TileSet settings
How it works…
We downloaded towers of defense.png at the bottom of the page. From the Downloads
folder on your computer, drag the towers of defense.png file into the FileSystem
tab of Godot or you can copy the file in the Downloads folder and then paste the
file into your Chapter 8 project folder, which we created before we started this
recipe. If Godot freezes, reboot it and notice that the file is in the FileSystem
tab.
We added a TileMap node by left-clicking on + in the Scene tab and selecting
TileMap in the Create New Node window. Then, in the Inspector tab, we
left-clicked on <empty> located to the right of Tile Set and selected New
TileSet from the drop-down list. We left-clicked on the TileSet located to the
right of Tile Set in the Inspector to see the new TileSet properties of
TileMap3. We changed the TileSize values of x and y to 32. We are going to
change the value of y later, but by changing these now, we will have the correct
x and y values of the tiles when we drag the tower of defence.png file into the
TIleSet.
We left-clicked and dragged the tower of defence.png file into the Tiles tab of the
TileSet on the bottom panel. We manually selected the tiles by selecting No
when the pop-up window asked whether we wanted to automatically create the
tiles. We left-clicked the Setup tab in the bottom panel to select the tiles we
wanted to use in this TileSet. We left-clicked on the top two tiles to use only
these tiles in the tilesheet.
We looked for Tile Shape in the Inspector and left-clicked Square to open the
drop-down list, and then we selected Isometric. We looked to the right of Tile
Offset Axis and left-clicked on Horizontal Offset and selected Vertical
Offset from the drop-down list. This set up the TileMap to work with the tiles
we downloaded.
We saw that on TileMap3, we have a warning about Y sort not being enabled
on all of its layers. To fix this, we looked for Ordering in the Inspector under
CanvasItem. We left-clicked on it and then, to the right of Y Sort Enabled, we
checked the On checkbox. We left-clicked on Layers located above Node2D in
the Inspector to see its properties. We looked to the right of Y Sort Enabled
and checked the On checkbox.
We left-clicked on the TileMap on the bottom panel and made sure that we
were on the Tile tab. Since we are going to just paint the tiles and did not set
up these tiles to use as terrain, we need to stay on the Tile tab. We left-clicked
on the grass tile and added two to four tiles in an empty space in the viewport
on the TileMap. The tiles are spread apart because the Tile Size value of y is
too big set at 32.
We left-clicked and held on to the number 32, then moved the mouse to the left
to lower the size to see how the tiles fit as we slid the mouse. We saw that 16 is
a good number for y and now the tiles look good. We can add more tiles if we
want.
9
Achieving Better Animations Using the New
Animation Editor
In this chapter, we are going to create a 3D cube, and in the animation player,
we will use the new 3D Position, 3D Rotation, and 3D Scale tracks on the cube.
We will create an animation with the improved Bezier curve to spin a cube one
way and then the other way at the end of the animation. In Godot 4, we can use
Euler, Quaternion, and Basis on rotation in animations. We are going to create
an animation that has a rotation animation on the x, y, and z axes.
We will change the rotation order of the Euler rotations to see the effect of the
MeshInstance3D node we rotated. With animations, Godot 4 removed the
dependency on bone rests. Now, skeletons only have a final pose for each bone.
One of the results of this change is that we can use animations across different
models with similar skeletons.
We will download a model with a walking animation and use that animation on
a model without animations that we downloaded as well. We look at the
Transition node in the AnimationTree node. First, we will create two very
basic 2D animations. Then, in the AnimationTree node, we add these two
animations to the Transition node and connect the Transition node to the
Output node to run the animation.
We could do this in Godot 3.x, but it is a little easier in Godot 4. We look at the
new Movie Maker mode, where we will create and animate a scene and record
it.
In this chapter, we will cover the following recipes:
Exploring changes with transform tracks
Investigating the new Bezier curve workflow
Playing with 3D rotation animations
Working with bone poses
Triggering a transition
Playing with the new Movie Maker mode
Technical requirements
For this chapter, you need the standard version of Godot 4.0 or later running
on one of the following platforms:
Windows 64-bit or 32-bit
macOS
Linux 64-bit or 32-bit
Android
Web Editor
You can find the code and the project files for the projects in this chapter on
GitHub at https://github.com/PacktPublishing/Godot-4-Game-DevelopmentCookbook/tree/main/Chapter%209.
Exploring changes with transform tracks
In this recipe, we are going to create a MeshInstance3D node. In the
Animation Player, we will animate the 3D mesh using the new 3D Position,
Rotation, and Scale tracks.
Getting ready
For this recipe, open Godot 4 and start a new project called Chapter 9. In the
Scene tab, click 3D to add a 3D scene. Click on the word Scene in the main
menu next to Project, then select Save Scene As, and name it Animation.
How to do it…
First, we will add a MeshInstance3D node and the AnimationPlayer node to
our scene:
1. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type mesh in the search box and then select MeshInstance3D to create the node in
the scene. Left-click the Create button.
2. In the Inspector tab, click on <empty> to the right of Mesh and select New BoxMesh.
3. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type anim in the search box and then select AnimationPlayer to create the node in
the scene. Left-click the Create button.
4. Left-click on Animation in the top part of the bottom panel:
Figure 9.1 – Animation Editor
5. Left-click New from the drop-down list.
6. When the Create New Animation window appears, left-click the OK button.
7. Left-click MeshInstance3D in the Scene tab.
8. Left-click on + Add Track, located in the top-left corner of the Animation Editor.
9. Left-click 3D Position Track.
10. In the Pick a node to animate window, left-click on MeshInstance3D and then left-click the OK
button.
11. Left-click on + Add Track, located in the top-left corner of the Animation Editor.
12. Left-click 3D Rotation Track.
13. In the Pick a node to animate window, left-click on MeshInstance3D then left-click the OK button.
14. Left-click on + Add Track, located in the top-left corner of the Animation Editor.
15. Left-click 3D Scale Track.
16. In the Pick a node to animate window, left-click on MeshInstance3D then left-click the OK button.
17. Left-click on the field to the left of the Animation Looping button just below the top-right corner of
the Animation Editor and change the 1 value to 5. See the highlighted section in Figure 9.2:
Figure 9.2 – Changing the animation length
18. Left-click in the seconds bar to the right of + Add Track, and a vertical blue line appears. Move the
line to 0.
19. Left-click on MeshInstance3D in the Scene tab.
20. In the animation player editor, on the 0 value in 3D Position Track, right-click, and then left-click on
the Insert Key button that appears.
21. In the animation player editor, on the 0 value in 3D Rotation Track, right-click, and then left-click on
the Insert Key button.
22. In the animation player editor, on the 0 value in 3D Scale Track, right-click, and then left-click on the
Insert Key button.
23. Move the blue line to 2.5 seconds.
24. Move the cube to the right.
25. In the animation player editor, on the blue line in 3D Position Track, right-click, and then left-click
on the Insert Key button.
26. Rotate the cube.
27. In the animation player editor, on the blue line in 3D Rotation Track, right-click, and then left-click
on the Insert Key button.
28. In the animation player editor, on the blue line in 3D Scale Track, right-click, and then left-click on
the Insert Key button.
29. Move the blue line to 5 seconds.
30. Move the cube back to where it started.
31. In the animation player editor, on the blue line in 3D Position Track, right-click, and then left-click
on the Insert Key button.
32. Rotate the cube so that it is now in its original position.
33. In the animation player editor, on the blue line in 3D Rotation Track, right-click, and then left-click
on the Insert Key button.
34. In the animation player editor, on the blue line in 3D Scale Track, right-click, and then left-click on
the Insert Key button.
35. Left-click the key we just inserted for Scale and, in the Inspector tab, change the x and y values to
1.5.
36. In the top-left corner of the Animation Editor, left-click on the Play selected animation from start
button by pressing Shift + D.
How it works…
We created a MeshInstance3D node with a BoxMesh. We added an
AnimationPlayer node to the scene.
We looked in the Animation Editor. At the top, we left-clicked on Animation
and then New in the drop-down list to create a new animation. We used the
default name new_animation when we clicked the OK button instead of changing
the name.
We left-clicked the MeshInstance3D node in the Scene tab so that when we
add an animation track, the track will be used with the MeshInstance3D node.
We left-clicked on + Add Track to add the new 3D Position Track, 3D
Rotation Track, and 3D Scale Track. When the Pick a node to animate
window appeared, we selected MeshInstance3D because the position,
rotation, and scale tracks we are using are not using the Transform property’s
location but the MeshInstance3D properties itself.
We changed the length of the animation (seconds) from 1 to 5. We left-clicked in
the seconds area between 0 and 5 to bring up the vertical blue line that
indicated where the animation is in the timeline. We moved the blue line to 0.
We left-clicked on MeshInstance3D in the Scene tab so that when we add the
keys to the animation, it tracks MeshInstance3D.
With the blue line at 0 in the timeline, we right-clicked on the line of 3D
Position Track and then left-clicked on the Insert Key button that appeared.
We did the same for 3D Rotation Track and 3D Scale Track. This created a
starting point for each track.
We moved the blue line to 2.5 seconds and moved the cube to the right. We
right-clicked on the line of 3D Position Track and then left-clicked on the
Insert Key button. We rotated the cube, then right-clicked on the line of 3D
Rotation Track, and then left-clicked on the Insert Key button. On the blue
line in 3D Scale Track, we right-clicked and then left-clicked on the Insert
Key button. Halfway through the animation, the cube moves to the right and
rotates.
We moved the blue line to 5 seconds and moved the cube back to its starting
position. We right-clicked on the line of 3D Position Track and then leftclicked on the Insert Key button. We rotated the cube back to its original
position, then right-clicked on the line of 3D Rotation Track, and then leftclicked Insert Key.
We right-clicked on the blue line in 3D Scale Track, and then left-clicked on
the Insert Key button. We left-clicked the key we had just inserted and, in the
Inspector tab, changed the x and y values to 1.5. At the end of the animation,
the cube rotates and moves back to where it started while it gets bigger.
We left-clicked on the Play selected animation from start button by pressing
Shift + D to see the animation.
Investigating the new Bezier curve workflow
Bezier curves create smooth curves between points set in an animation track or
vector graphics. In this recipe, we will create a cube, and using the Bezier
curve track, we will rotate the x axis to spin one way for half of the animation
and the opposite way for the last half.
Getting ready
For this recipe, click the + button to the right of the Animation scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on the
word Scene in the main menu next to Project, then select Save Scene As, and
name it Bezier.
How to do it…
First, we add a MeshInstance3D node and AnimationPlayer to the Scene
tab;
1. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type mesh in the search box and then select MeshInstance3D to create the node in
the scene. Left-click the Create button.
2. In the Inspector tab, click on <empty> to the right of Mesh and select New BoxMesh.
3. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type anim in the search box and then select AnimationPlayer to create the node in
the scene. Left-click the Create button.
4. Left-click on Animation in the top part of the bottom panel.
5. Left-click New from the drop-down list.
6. When the Create New Animation window appears, left-click the OK button.
7. Left-click on the field to the left of the Animation Looping button just below the top-right corner of
the Animation Editor and change the 1 value to 5:
Figure 9.3 – Animation looping button
8. Left-click MeshInstance3D in the Scene tab.
9. Left-click on + Add Track, located in the top-left corner of the Animation Editor.
10. Left-click Bezier Curve Track.
11. In the Pick a node to animate window, left-click on MeshInstance3D, then left-click the OK
button.
12. In the window that appears, under Node3D, left-click on Rotation and then left-click Open.
13. Right-click to the right of rotation:x and Insert Key.
14. Move the key to 0.
15. Right-click to the right of rotation:x and Insert Key.
16. Move the key to 5.
17. Left-click the Toggle between the bezier curve editor and track editor, button located on the
bottom—it’s the first icon on the left, as shown in Figure 9.4:
Figure 9.4 – Bezier curve Editor
18. Move the Bezier curve so that it arches to 100 in the middle. You may need to zoom in on the timeline.
19. In the top-left corner of the Animation Editor, left-click on the Play selected animation from start
button by pressing Shift + D.
How it works…
We created a MeshInstance3D node with a BoxMesh. We added an
AnimationPlayer node to the scene.
We looked in the Animation Editor. At the top, we left-clicked on Animation
and then New in the drop-down list to create a new animation. We used the
default name new_animation when we clicked the OK button instead of changing
the name.
We changed the seconds of the animation from 1 to 5. We left-clicked the
MeshInstance3D node in the Scene tab so that when we add an animation
track, the track will be used with the MeshInstance3D node.
We left-clicked on + Add Track, located in the top-left corner of the Animation
Editor, and selected Bezier Curve Track. When the pop-up window appeared,
we left-clicked on MeshInstance3D and then left-clicked the OK button to
animate the MeshInstance3D cube. In a window that appeared, we looked
under Node3D in the list. We left-clicked on Rotation and then left-clicked
Open. This gave us the animation tracks of rotation:x, rotation:y, and
rotation:z.
We right-clicked to the right of rotation:x and Insert Key twice. The first key
we moved to 0, and the second key we moved to 5. We have a starting and
ending animation point, so now we can show the Bezier curve.
We left-clicked the Toggle between the bezier curve editor and track
editor, button to switch to the Bezier Curve Editor. We moved the Bezier
curve so that it arches to 100 in the middle, as shown in Figure 9.4. This will
rotate the cube in one direction for 2 seconds, then slow down, and rotate the
cube in the opposite direction. We left-clicked on the Play selected animation
from start button by pressing Shift + D to play the animation.
Playing with 3D rotation animations
In this recipe, we create an animation that has a rotation animation on the x, y,
and z axes. We are going to use the Euler in the Rotation Edit mode and also
look at the other options you can use in the Rotation Edit mode. We change
the rotation order in the Euler Rotation Order properties.
Getting ready
For this recipe, click the + button to the right of the Bezier scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on the
word Scene in the main menu next to Project, then select Save Scene As, and
name it Euler.
How to do it…
Let’s add a MeshInstance3D node and the AnimationPlayer node to the
Scene tab:
1. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type mesh in the search box and then select MeshInstance3D to create the node in
the scene. Left-click the Create button.
2. In the Inspector tab, click on <empty> to the right of Mesh and select New BoxMesh.
3. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type anim in the search box and then select AnimationPlayer to create the node in
the scene. Left-click the Create button.
4. Left-click on Animation in the top part of the bottom panel.
5. Left-click New from the drop-down list.
6. When the Create New Animation window appears, left-click the OK button.
7. Left-click on the field to the left of the Animation Looping button just below the top-right corner of
the Animation Editor and change the 1 value to 5.
8. Left-click MeshInstance3D in the Scene tab.
9. Left-click on 5 seconds in the animation timeline.
10. Left-click on Transform in the Inspector tab.
11. In the Inspector tab, under Scale, left-click the white chain link icon to the far right of z 1.
12. In the Inspector tab, under Scale, change the value of x to 5.
13. In the Inspector tab, change the Rotation values of x to 500, y to 1000, and z to 250.
14. In the Inspector tab, to the far right of Rotation, left-click on the key icon ( ) to insert the key.
15. In the pop-up window, left-click on Create.
16. Left-click on 0 seconds in the animation timeline.
17. In the Animation Editor, right-click to the right of the rotation track under MeshInstance3D and leftclick Insert Key in the popup.
18. Left-click on the key you placed at 0, and in the Inspector tab, change the x, y, and z values to 0.
19. In the Inspector tab, to the far right of Rotation Order, left-click on the key icon.
20. In the pop-up window, left-click on Create.
21. Left-click on the rotation_order key to see the properties in the Inspector tab.
22. In the top-left corner of the Animation Editor, left-click on the Play selected animation from start
button by pressing Shift + D.
23. Left-click YXZ to the right of Value in the Inspector tab and select another value.
24. In the top-left corner of the Animation Editor, left-click on the Play selected animation from start
button by pressing Shift + D:
Figure 9.5 – Euler rotation animation
How it works…
We created a MeshInstance3D node with a BoxMesh. We added an
AnimationPlayer to the scene.
We looked in the Animation Editor. At the top, we left-clicked on Animation
and then New in the drop-down list to create a new animation. We used the
default name new_animation when we clicked the OK button instead of changing
the name.
We changed the seconds of the animation from 1 to 5. We left-clicked the
MeshInstance3D node in the Scene tab so that when we add an animation
track, the track will be used with the MeshInstance3D node. We also did this
to add the animation keys from the properties in the Inspector tab.
We left-clicked on Transform in the Inspector tab to see its properties. We
left-clicked on the chain link icon located to the right of Scale so that we can
change the x value in Scale and not change all of the values. We changed the
value to 5 so that we can tell where the cube is rotating.
We changed the x, y, and z values of Rotation to 500, 1000, and 250 so that we
can change the rotation order later. In Rotation properties in the Inspector
tab, we left-clicked on the key icon to add Rotation to the animation. In the
Animation Editor, a key was created with the values we set in the Inspector
tab at the 5-second mark.
In the animation timeline, we clicked on the 0-second mark. We left-clicked on
the key to show the x, y, and z values in the Inspector tab. We changed all of
the values to 0. We started the rotation animation at 0, 0, and 0 values and
ended at the 500, 1000, and 250 values.
In the animation timeline, we clicked on the 0-second mark so that when we add
the key for Rotation Order, it will start at 0 seconds. In the Inspector tab, we
left-clicked the key icon located to the far right of Rotation Order. The key
was automatically placed at the 0-second mark, so when we start the animation
it will rotate the x, y, and z values in the order we set in this key. We leftclicked the rotation_order key to see the properties in the Inspector tab when
we play the animation.
We played the animation using the default order; then we changed the
rotation_order value and played the animation again to see that the animation
changed. If you change the Rotation Order values in the Inspector tab, it will
not work as expected. You must change the values in the animation by clicking
on the animation key.
Working with bone poses
In this recipe, we will download a model with animations and a model without
any animations. We will extract the animations from the model with animations
and put them into the model without animations.
Getting ready
For this recipe, click the + button to the right of the Euler scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on the
word Scene in the main menu next to Project, then select Save Scene As, and
name it Bones.
How to do it…
First, we are going to download our two models from https://free3d.com/:
1. Go to https://free3d.com/user/renderpeople and download the FBX files of Nathan Animated 003
Walking and Eric Rigged 001 to your computer and unzip the files into folders named Nathan and
Eric.
2. Click and drag the two folders into the FileSystem tab in Godot.
3. Left-click on the arrow to the left of the Nathan folder to open the folder.
4. Double left-click on rp_nathan_animated_003_walking.fbx.
5. In the Scene tab of the Advanced Import Settings window, left-click on Skeleton3D.
6. Left-click on <empty>, located to the right of Bone Map under Retarget.
7. Left-click on New BoneMap from the drop-down list:
Figure 9.6 – Nathan model Skeleton3D and New BoneMap
8. Left-click on BoneMap, located to the right of Bone Map under Retarget.
9. Left-click on <empty>, located to the right of Profile under Bone Map.
10. Left-click on New SkeletonProfileHumanoid from the drop-down list:
Figure 9.7 – Nathan model Skeleton3D and New SkeletonProfileHumanoid
11. To the right of Group is Body. Notice the picture of the body has all green dots.
12. Left-click on Body to the right of Group and click Face. All of the dots should be green.
13. Left-click on Face to the right of Group and click LeftHand. All of the dots should be green.
14. Left-click on LeftHand to the left of Group and click RightHand. All of the dots should be green.
15. Left-click the Reimport button at the bottom of the Advanced Import Settings window.
16. Double left-click on rp_nathan_animated_003_walking.fbx.
17. In the Scene tab of the Advanced Import Settings window, left-click on Skeleton3D.
18. Left-click on the down arrow, located to the right of Bone Map | BoneMap under Retarget.
19. Select Save from the drop-down list.
20. Name the file Nathan_bonemap.tres.
21. Left-click the Close button at the bottom of the Advanced Import Settings window.
22. Left-click rp_nathan_animated_003_walking.fbx in the FileSystem tab.
23. Left-click the Import tab located next to the Scene tab above the FileSystem tab.
24. Left-click on Scene located under Import As:.
25. Select Animation Library:
Figure 9.8 – Changing the file of an animation library
26. Left-click on the Reimport button on the bottom left.
27. Left-click on the Save Scenes, Re-Import, and Restart button.
28. Left-click on the arrow to the left of the Eric folder to open the folder.
29. Double left-click on rp_eric_rigged_001_zup_t.fbx at the bottom.
30. In the Scene tab of the Advanced Import Settings window, left-click on Skeleton3D.
31. Left-click on the down arrow to the right of <empty>, which is located to the right of Bone Map
under Retarget.
32. Left-click on Load from the drop-down list.
33. In the Open a File window, select Nathan_bonemap.tres and left-click the Open button.
34. Left-click on Nathan_bonemap, located to the right of Bone Map under Retarget.
35. Notice that all dots on the body are red. Left-click on the red dot that is on the top, which is the head
part of the skeleton.
36. Below the body, it should now say Head with the name Nathan bonemap to the right of it. Left-click
the button to the right of that to attach the bonemap we loaded to this model’s bonemap.
37. Left-click on all of the down arrows by hip, spine_01, upperleg_l, and upperleg_r to attach the
skeleton to the body:
Figure 9.9 – Mapping the skeleton to the bonemap file we loaded
38. Left-click and match each dot to the corresponding skeleton in the Bone Picker window. Do this for
Body, Face, LeftHand, and RightHand. They should be all green when you are finished.
39. Left-click on the Reimport button on the bottom left.
40. Right-click on the rp_eric_rigged_001_zup_t.fbx file, at the bottom of the Eric folder, and select
New Inherited Scene.
41. Left-click on AnimationPlayer in the Scene tab.
42. In the Animation Editor in the bottom panel, left-click Animation and select Manage Animations in
the drop-down list:
Figure 9.10 – Animation Tools button in the Animation Editor
43. In the Edit Animation Libraries window that popped up, left-click Load Library.
44. Double-click on the Nathan folder and left-click on the rp_nathan_animated_003_walking.fbx file.
45. Left-click on the Open button at the bottom of the window.
46. Left-click on the OK button at the bottom of the Edit Animation Libraries window.
47. Left-click on Take 001 to the right of Animation and select rp_nathan_animated_003_walking/Take
001 from the drop-down list.
48. In the top-left corner of the Animation Editor, left-click on the Play selected animation from start
button by pressing Shift + D.
How it works…
We downloaded two models. We unzipped them into a new folder for each that
we named Nathan and Eric. We dragged the two folders into the FileSystem tab
in Godot.
We opened the Nathan folder and double left-clicked on
rp_nathan_animated_003_walking.fbx to bring up the Advanced Import Settings
window. We left-clicked on Skeleton3D in the Scene tab of the Advanced
Import Settings window. Then, we left-clicked on <empty>, located to the
right of Bone Map under Retarget, and selected New BoneMap from the
drop-down list.
We left-clicked on BoneMap located to the right of Bone Map under Retarget
to see the BoneMap properties. We left-clicked on <empty> located to the
right of Profile under Bone Map and selected New
SkeletonProfileHumanoid from the drop-down list.
To the right of Group is Body, which you can left-click on and change to see
Face, LeftHand, and RightHand. We looked at all of these to make sure all of
the dots were green. This is taking the model’s animation points and mapping
them to Godot’s internal skeleton. We clicked the Reimport button so that the
model is now mapped to Godot’s internal skeleton.
We double left-clicked on rp_nathan_animated_003_walking.fbx to bring up the
Advanced Import Settings window. We left-clicked on Skeleton3D in the
Scene tab of the Advanced Import Settings window. We left-clicked on the
down arrow located to the right of Bone Map | BoneMap under Retarget to
bring up the drop-down list.
We selected Save from that list and named the file Nathan_bonemap.tres. We leftclicked on the Close button of the Advanced Import Settings window. This
file is the bonemap of our model, which has the animation that we will add to
our other model that does not have an animation.
We left-clicked the rp_nathan_animated_003_walking.fbx file in the FileSystem tab to
make sure the file that we were working on was selected. We left-clicked on the
Import tab next to the Scene tab. We left-clicked on Scene, located under
Import As:, to change this file to an animation library instead of a scene. This
will take out the mesh and keep the bones so that it can run the animation on a
new model.
We clicked on the Reimport button to apply the changes. A Save Scenes, ReImport, and Restart button appeared, and we clicked it. Godot will save, reimport, and then reboot. If you look at the rp_nathan_animated_003_walking.fbx file,
you should see that the scene icon has been replaced with a new icon indicating
that it is now an animation library file.
We opened the Eric folder and double left-clicked on rp_eric_rigged_001_zup_t.fbx at
the bottom. In the Advanced Import Settings window, we left-clicked on
Skeleton3D. We left-clicked on the down arrow to the right of <empty>,
which was located to the right of Bone Map under Retarget.
This opened a drop-down list, and we selected Load from that list. In the Open
a File window, we selected Nathan_bonemap.tres and left-clicked the Open button.
The Nathan bonemap and animation that we saved are now on our Eric model,
which previously didn’t have animation.
We left-clicked on BoneMap located to the right of Bone Map under
Retarget. This brought up a picture of the body with black and red or blue dots
all over. When we did this with the Nathan model, they were all green dots. Since
we loaded the Nathan library to the Eric model, the two skeletons don’t match.
We left-clicked on the red dot where the head is, and under the picture of the
body, we saw Head, and to the right of that, we saw the skeleton name of the
Nathan model that we loaded to the Eric model.
We left-clicked on the icon to the right of that to bring up the Bone Picker
window with a listing of all of the Eric model’s skeleton parts. We left-clicked
the Head node in the Bone Picker window, and after that, it should have
turned green. If the dot was red after you connected a bone, that means you
connected the wrong bone.
Look at the filename when you click on a dot, and that should tell you exactly
which bone to select in the Bone Picker window. We connected all of the red
dots so that they are now green in the Body, Face, LeftHand, and RightHand
sections. We left-clicked on the Reimport button on the bottom left to import
the changes we made to the model.
We right-clicked on the rp_eric_rigged_001_zup_t.fbx file, at the bottom of the Eric
folder, and selected New Inherited Scene. We clicked on the
AnimationPlayer node in the Scene tab to see the Animation Editor in the
bottom panel. We left-clicked on the Animation Tools button so that we can
select Manage Animations from the drop-down list.
In the Edit Animation Libraries window that appeared, we left-clicked Load
Library to load the rp_nathan_animated_003_walking.fbx file. We left-clicked on Take
001 to the right of Animation and selected
rp_nathan_animated_003_walking/Take 001 from the drop-down list to add
the Nathan model animation to the Eric model. We ran the animation and saw the
Eric model walk.
A great resource to get free character and animation models is the following
website: https://www.mixamo.com/#/. You do need to sign up for a free Adobe
account, though. Putting Mixamo animations into a Mixamo character is
generally easier because the animation recognizes the bones, so you don’t have
to bone map as much or at all as we did in this recipe.
Triggering a transition
In this recipe, we will create two animations. The first will shrink and spin the
background. The second will expand and spin the background like a scene
transition. We added these animations to the AnimationTree node. We add a
Transition node to use as a bridge to run the animations when we hook them
up to the Transition node and out to the Output node.
Getting ready
For this recipe, click the + button to the right of the Bones scene we just
completed to add a new scene. In the Scene tab, click 2D Scene. Click on the
word Scene in the main menu next to Project, then select Save Scene As, and
name it Transition.
How to do it…
Let’s create our MeshInstance2D background. Then, we’ll create Shrink and
Expand animations in AnimationPlayer:
1. Left-click on the Node2D node and then left-click the + button in the Scene tab. In the Create New
Node window, type mesh in the search box and then select MeshInstance2D to create the node in
the scene. Left-click the Create button.
2. Right-click on the MeshInstance2D node in the Scene tab and select Rename from the drop-down
list.
3. Enter Background as the new name of the MeshInstance2D node.
4. In the Inspector tab, click on <empty> to the right of Mesh and select New BoxMesh.
5. Left-click on Transform in the Inspector tab.
6. To the right of Position, change the x value to 580 and the y value to 322.
7. To the far right of Scale, click on the white link icon.
8. To the right of Scale, change the x value to 1175 and the y value to 670.
9. Left-click on the Node2D node and then left-click the + button in the Scene tab. In the Create New
Node window, type anim in the search box and then select AnimationPlayer to create the node in
the scene. Left-click the Create button.
10. Left-click on Animation in the top part of the bottom panel.
11. Left-click New from the drop-down list.
12. When the Create New Animation window appears, enter Shrink as the name of the animation and
then click the OK button.
13. Left-click on + Add Track located in the top-left corner of the Animation Editor.
14. Left-click Property Track.
15. In the Pick a node to animate: window, select Background and left-click the OK button.
16. In the Select Property window, under Node2D, select Scale, and left-click on the Open button.
17. Left-click on + Add Track, located in the top-left corner of the Animation Editor.
18. Left-click Property Track.
19. In the Pick a node to animate: window, select Background and left-click the OK button.
20. In the Select Property window, under Node2D, select Rotation, and left-click on the Open button.
21. Left-click on Background in the Scene tab.
22. Make sure the blue line is on 0 in the Timeline section of the AnimationPlayer editor.
23. In the Inspector tab, left-click on the Key icon to the far right of Scale.
24. In the Inspector tab, left-click on the Key icon to the far right of Rotation.
25. Make sure the blue line is on 1 in the Timeline section of the AnimationPlayer editor.
26. Change the Scale x and y values to 0 in the Inspector tab.
27. In the Inspector tab, left-click on the Key icon to the far right of Scale.
28. Change the Rotation value to 360 in the Inspector tab.
29. In the Inspector tab, left-click on the Key icon to the far right of Rotation:
Figure 9.11 – Adding the animation keys to the Timeline
30. Left-click on Animation in the top part of the bottom panel.
31. Left-click New from the drop-down list.
32. When the Create New Animation window appears, enter Expand as the name of the animation and
then click the OK button.
33. Left-click on the field to the left of the Animation Looping button just below the top-right corner of
the Animation Editor and change the 1 value to 3.
34. Left-click on + Add Track, located in the top-left corner of the Animation Editor.
35. Left-click Property Track.
36. In the Pick a node to animate: window, select Background and left-click the OK button.
37. In the Select Property window, under Node2D select Scale, and left-click on the Open button.
38. Left-click on + Add Track, located in the top-left corner of the Animation Editor.
39. Left-click Property Track.
40. In the Pick a node to animate: window, select Background and left-click the OK button.
41. In the Select Property window, under Node2D select Rotation, and left-click on the Open button.
42. Left-click on Background in the Scene tab.
43. Make sure the blue line is on 0 in the Timeline section of the AnimationPlayer.
44. In the Inspector tab, left-click on the Key icon to the far right of Scale.
45. In the Inspector tab, left-click on the Key icon to the far right of Rotation.
46. Make sure the blue line is on 1 in the Timeline section of the AnimationPlayer.
47. To the far right of Scale, click on the white link icon.
48. Change the Scale x value to 1175 and the y value to 670 in the Inspector.
49. In the Inspector tab, left-click on the Key icon to the far right of Scale.
50. Change the Rotation value to 0 in the Inspector.
51. In the Inspector tab, left-click on the Key icon to the far right of Rotation.
52. Left-click on the Node2D node and then left-click the + button in the Scene tab. In the Create New
Node window, type anim in the search box and then select AnimationTree to create the node in the
scene. Left-click the Create button.
53. In the Inspector tab, to the right of Tree Root, left-click on <empty>.
54. In the drop-down list, left-click New AnimationNodeBlendTree.
55. In the Inspector tab, to the right of Anim Player, left-click on Assign.
56. Select AnimationPlayer in the Select a Node window and left-click the OK button.
57. In the Inspector tab, to the right of Active, check the On checkbox.
58. In the bottom panel, right-click to the left of the Output node.
59. In the drop-down list, select Transition.
60. In the Inspector tab, left-click on Inputs.
61. Left-click the + Add Element button.
62. To the right of Name, enter Shrink.
63. To the right of Auto Advance, under Name, check the On checkbox.
64. Left-click the + Add Element button.
65. To the right of Name, enter Expand.
66. To the right of Auto Advance, under Name, check the On checkbox.
67. In the bottom panel, right-click to the left of the Transition node.
68. In the drop-down list, select Animation.
69. Highlight Animation in the box under Animation and change the name to Shrink:
Figure 9.12 – Animation node in AnimationTree panel
70. Left-click to the right of the Film Reel icon and select Shrink from the drop-down list.
71. In the bottom panel, right-click to the right of the Transition node and under the Shrink Animation
node.
72. In the drop-down list, select Animation.
73. Highlight Animation in the box under Animation and change the name to Expand.
74. Left-click to the right of Film Reel and select Expand from the drop-down list.
75. Left-click and drag the white dot on the right side of the Shrink animation node to the white dot to
the left of Shrink in the Transition node.
76. Left-click and drag the white dot on the right side of the Expand animation node to the white dot to
the left of Expand in the Transition node.
77. Left-click and drag the white dot on the right side of the Transition node to the white dot to the left
of the Output node:
Figure 9.13 – AnimationTree bottom panel
How it works…
We created a MeshInstance2D node with a BoxMesh. We renamed the
MeshInstance2D node Background.
We left-clicked on Transform in the Inspector to see the properties. We
changed the Position values of x and y to center the background in the middle
of the viewable default camera. We clicked on the white link icon located to the
far right of Scale so that we could change the x and y values to different
values. We changed the Scale values of x and y to cover the viewable default
camera.
We added the AnimationPlayer node to the Scene tab. At the top of the
AnimationPlayer node, we left-clicked on Animation to create a new
animation that we named Shrink. We left-clicked on + Add Track, located in the
top-left corner of the Animation Editor, and selected Background from the
drop-down list to animate the Background node. We selected Property Track
from the next drop-down list so that we could add the Scale and Rotation
properties to animate the background.
We made sure the blue line in the Timeline section of the AnimationPlayer
node was at 0. We left-clicked on the Key icons located to the right of Scale
and Rotation, so we start the animation with the default values. We moved the
blue line to the 1-second mark and changed the x and y values of Scale to 0 and
the Rotation value to 360. This will spin and fade out the background when the
animation is run. You can press the Play selected animation from start
button by pressing Shift + D.
We added the AnimationPlayer node to the Scene tab. At the top of the
AnimationPlayer node, we left-clicked on Animation to create a new
animation, which we named Expand. We left-clicked on the field to the left of the
Animation Looping button just below the top-right corner of the Animation
Editor and changed the 1 value to 3 so that for the last 2 seconds of the
animation, we could see the full background.
We left-clicked on + Add Track, located in the top-left corner of the Animation
Editor, and selected Background from the drop-down list to animate the
Background node. We selected Property Track from the next drop-down list
so that we could add the Scale and Rotation properties to animate the
background. We made sure the blue line in the Timeline section of the
AnimationPlayer node was at 0.
We left-clicked on the Key icons located to the right of Scale and Rotation so
that we start the animation with the now default values from the end of Shrink.
The values of Scale x and y are 0 and Rotation is 360. We left-clicked on the
white link icon located to the far right of Scale so that we could change the x
and y Scale values to a different number for each.
We moved the blue line to the 1-second mark and changed the Scale value of x
to 1170, the y value to 670, and the Rotation value to 0. This will spin and fade in
the background when the animation is running. You can press the Play
selected animation from start button by pressing Shift + D to run the
animation.
We added an AnimationTree node to the Scene tab. In the Inspector, we
selected New AnimationNodeBlendTree for the Tree Root property. We
added the AnimationPlayer node in the Scene tab to the Anim Player
property in the Inspector tab. We checked the On checkbox located to the
right of Active. This will run anything in the AnimationTree node. In our case,
anything hooked up to Output in the grid on the bottom panel will run. Other
uses for the AnimationTree node are BlendSpace 2D or BlendSpace3D and
StateMachine.
We right-clicked to the right of the Output node in the bottom panel and
selected Transition from the drop-down list. With the Transition node
selected in the bottom panel, we left-clicked Inputs in the Inspector tab. We
left-clicked the + Add Element button and changed the name to Shrink.
We checked the On checkbox to the right of Auto Advance so that the Shrink
animation we will add later will advance to the Expand animation we will also
add later. We left-clicked the + Add Element button and changed the name to
Expand. We checked the On checkbox to the right of Auto Advance so that the
Expand animation we will add later will advance to the Shrink animation to loop
the animation.
We right-clicked to the right of the Transition node in the bottom panel and
selected Animation from the drop-down list. We changed the name of the
Animation node to Shrink. We left-clicked to the right of the Film Reel icon
and selected the Shrink animation we created earlier.
We added another Animation node to the left of Transition and under the
Shrink animation. We named this node Expand. We left-clicked to the right of
the Film Reel icon and selected the Expand animation we created earlier.
We connected the white dots of the Shrink and Expand animation nodes to Shrink
and Expand in the Transition node. We connected the white dots of the
Transition node and the Output node. We can see that both animations are
playing.
Playing with the new Movie Maker mode
In this recipe, we will create a scene with a ground and a pillar in the center.
We will animate the light to go from one side to the other while rotating so that
we can see the shadow. We will set up and use the new Movie Maker mode to
record the animation. The Movie Maker mode is a great tool to use to make
promotional videos.
Getting ready
For this recipe, click the + button to the right of the Transition scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on the
word Scene in the main menu next to Project, then select Save Scene As, and
name it Movie.
How to do it…
First, we are going to make the scene and add the lighting:
1. Left-click on the three vertical dots to the left of Transform View on the viewport toolbar to edit the
Sun and Environment settings.
2. Add the Sun and Environment nodes to the scene by left-clicking the Add Sun to Scene button at
the bottom while holding down the Shift key.
3. Click on DirectionalLight3D in the Scene tab.
4. In the Inspector, left-click Transform.
5. Change the values in Position to x 0, y 7, and z 11.
6. Change the values in Rotation to x -60, y -20, and z 0.
7. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type mesh in the search box and then select MeshInstance3D to create the node in
the scene. Left-click the Create button.
8. Right-click on the MeshInstance3D node in the Scene tab and select Rename from the drop-down
list.
9. Enter Ground as the new name of the MeshInstance2D node.
10. In the Inspector tab, click on <empty> to the right of Mesh and select New PlaneMesh.
11. Left-click on Transform in the Inspector tab.
12. Change the Scale value of x to 10. All of the Scale values should have changed to 10 because the
white link icon was not clicked.
13. At the top of the Inspector tab, left-click on the PlaneMesh node to the right of Mesh.
14. Left-click on <empty> to the right of Material.
15. From the drop-down list, select New StandardMaterial3D.
16. Left-click on StandardMaterial3D to the right of Material.
17. Left-click on Albedo and left-click on the white box to the right of Color.
18. Change the values of R to 0, G to 255, and B to 0.
19. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type mesh in the search box and then select MeshInstance3D to create the node in
the scene. Left-click the Create button.
20. In the Inspector tab, click on <empty> to the right of Mesh and select New BoxMesh.
21. Left-click on Transform in the Inspector tab.
22. Change the Position value of y to 2.
23. Left-click on the white Link icon to the far right of Scale.
24. Change the Scale value of y to 5.
25. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type cam in the search box and then select Camera3D to create the node in the scene.
Left-click the Create button.
26. Left-click on Transform in the Inspector tab.
27. Change the Position values of x to -11 and y to 3.
28. Change the Rotation value of y to -90.
29. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type anim in the search box and then select AnimationPlayer to create the node in
the scene. Left-click the Create button.
30. Left-click on Animation in the top part of the bottom panel.
31. Left-click New from the drop-down list.
32. When the Create New Animation window appears, enter Sun as the name of the animation and then
click the OK button.
33. Left-click on the field to the left of the Animation Looping button just below the top-right corner of
the Animation Editor and change the 1 value to 15.
34. Left-click on + Add Track located in the top-left corner of the Animation Editor.
35. Left-click 3D Position Track.
36. In the Pick a node to animate: window, select DirectionalLight3D and left-click the OK button.
37. Left-click in the animation timeline and move the blue line to 0.
38. Left-click on the DirectionalLight3D node in the Scene tab.
39. In the Inspector tab, under Transform, left-click on the Key icon to the far right of Position.
40. In the Please Confirm window, left-click on the Create button.
41. In the Inspector tab, under Transform, left-click on the Key icon to the far right of Rotation.
42. In the Please Confirm window, left-click on the Create button.
43. In the bottom animation panel, left-click at the 15-second mark. The blue line should now be at the 15-
second mark.
44. Make sure we are still clicked on the DirectionalLight3D node in the Scene tab.
45. In the Inspector tab, left-click Transform.
46. In the Inspector tab, under Transform, change the values in Position to x 0, y 7, and z -11.
47. In the Inspector tab, under Transform, change the values in Rotation to x -60, y 160, and z 0.
48. In the Inspector tab, under Transform, left-click on the Key icon to the far right of Position.
49. In the Please Confirm window, left-click on the Create button.
50. In the Inspector tab, under Transform, left-click on the Key icon to the far right of Rotation.
51. In the Please Confirm window, left-click on the Create button.
52. Left-click on Camera3D in the Scene tab.
53. Left-click <empty>, located to the right of Script at the bottom of the Inspector.
54. Select New Script from the drop-down list.
55. To the right of Path:, name the file runanimation.
56. Copy this code into runanimation:
1 extends Camera3d  
2  
3 @onready var anim = $"../AnimationPlayer"
4  
5 func _ready():  
6    anim.play("Sun")
57. Create a folder outside of the project folder where you want to save your movie AVI files.
58. Left-click on Projects in the top left-hand corner of Godot and select Project Settings in the dropdown list.
59. On the left side under Editor, left-click on Movie Writer:
Figure 9.14 – Movie Writer in Project Settings
60. Left-click on the folder icon to the far right of Movie File.
61. Change the path to the folder you created.
62. In the File field, type Sun_Demo for the name of the movie you are going to record:
Figure 9.15 – Path to the folder and name of the file
63. Left-click on the Save button.
64. Left-click on the Close button in the Project Settings window.
65. In the upper right-hand corner, to the left of Forward, left-click the Enable Movie Maker mode
button. It will highlight in blue when clicked on:
Figure 9.16 – Enable Movie Maker mode button
66. In the Movie scene, click the Run the current scene button in the upper-right corner of the editor
or hit the F6 key.
67. When the animation is done, then exit the scene and left-click the Enable Movie Maker mode
button. It will no longer be highlighted in blue.
68. Go to the folder where you saved the movie and play the movie.
How it works…
We added the DirectionalLight3D node and the World environment to the
Scene tab. We changed the Position and Rotation values of the
DirectionalLight3D node to position the light on the left side of the ground.
We changed the rotation of the light to face toward the center of the ground
mesh that we are going to place in the next steps.
We created a PlaneMesh node that we named Ground. We changed the Scale
value to 10x10x10 by only changing the x value because the white link icon was
not clicked. We added a StandardMaterial3D node to the Material property
in the Inspector tab so that we could change the color of the ground. This will
make it easier to see the shadow and the pillar we are going to add to the scene
next.
We created a BoxMesh node that changed the y Position to 2 so that it would
stand on the ground plane. We changed the y Scale value to 5 to create a
shadow. This time, we left-clicked on the white link icon so that it turned gray
and we could change only one value.
We added a Camera3D node to the Scene tab. We moved the camera by leftclicking on Transform in the Inspector tab and changing the Position values
of x to 11 and y to 3. We changed the Rotation value of y to 90 so that the
camera would face the pillar.
We added an AnimationPlayer node to the Scene tab. In the
AnimationPlayer editor, we created a new animation, which we named Sun.
We changed the length of the animation to 15 seconds. We left-clicked on +
Add Track and selected 3D Position Track from the drop-down list. In the
Pick a node to animate: window, we selected DirectionalLight3D.
The blue line that shows where the animation should be at 0 seconds. We leftclicked on the DirectionalLight3D node in the Scene tab so that we can
change the Position and Rotation values of the node. We left-clicked on the
Key icons to the right of Position and Rotation to set the starting point of the
animation. In the timeline section of the AnimationPlayer node, we leftclicked at 15 seconds, which is the end of the animation.
We make sure we were still clicked on the DirectionalLight3D node in the
Scene tab, and then we change the Position and Rotation values to where the
DirectionalLight3D node should be at the end of the animation. We made
sure the blue line was on the 15 second mark and left-clicked the Key icon to
the far right of Property and Rotation.
We left-clicked on the Camera3D node in the Scene tab. In the Inspector tab,
we left-clicked on <empty> to the right of Script and created a new script. We
named the script runanimation. On line 3 of the code, we used @onready to load the
AnimationPlayer node into the anim variable. You should drag the
AnimationPlayer node to the right of = if it doesn’t work just by typing it out.
In the ready function, we told the AnimationPlayer node to run our Sun
animation.
We created a new folder outside of the project folder that we were working on.
This is where we will save the movie files that we create. We opened Project
Settings, and under Editor, we left-clicked on Movie Writer. We left-clicked
on the folder on the far right of Movie File, and at the top of Path, we changed
the path to point to the folder we created to store our movie files.
In the field to the right of File, we typed Sun_Demo as the name of the file we were
going to record. You can change the audio mix rate. If we had audio playing in
the scene, when we recorded the scene, the audio would not play but it would
be on the movie. We can change the speaker layout to Stereo, 3.1, 5.1, or 7.1.
We can change the MJPEG quality. Higher values will look better but the movie
file size will be bigger. We can disable V-Sync, which can speed up the video
writing, but your hardware should be fast enough to render, encode, and save
the video at a higher frame rate than your monitor’s refresh rate. We can also
change the frames per second (FPS) of the movie.
We left-clicked the Enable Movie Maker mode button. It was highlighted in
blue after we clicked on it. We left-clicked on the Run the current scene
button to play the scene. After the animation finished, we exited the scene we
just ran and left-clicked on the Enable Movie Maker mode button.
If we didn’t, every time we ran the scene, it would save a movie. If you wanted
to make another movie of something else, you would have to go back to Project
Settings and change the filename so that it wouldn’t overwrite the old file. We
went to the folder in which we saved the movie file and ran the movie file.
10
Exploring New Multiplayer Features in Godot 4
In this chapter, we will set up a CharacterBody3D scene for the player with
the default movement script attached and a scene where the players will spawn
a character into a multiplayer game. We will create a menu with Host and Join
buttons so that we can run two debug scenes.
The first button is to simulate a game as the host server and the other one joins
a game as a client. We will use the new MultiplayerSpawner node to spawn
an instance of the player to the hosted scene. We will synchronize players with
the MultiplayerSynchronizer node. We will also make the player unique
when they spawn into a multiplayer game. We export the Spawner project and
use Windows Command Prompt (CMD) to create a headless server. We will
write a GDScript script to use the Universal Plug and Play (UPnP) class to
port-forward on a peer-to-peer (P2P) network.
In this chapter, we will cover the following recipes:
Using the new MultiplayerSpawner node
Using the new MultiplayerSynchronizer node
How to use the Headless mode
How to use UPnP with P2P networking
Technical requirements
For this chapter, you need the standard version of Godot 4.0 or later running
on one of the following platforms:
Windows 64-bit or 32-bit
macOS
Linux 64-bit or 32-bit
Android
Web Editor
You can find the code and the project files for the projects in this chapter on
GitHub at https://github.com/PacktPublishing/Godot-4-Game-Development-
Cookbook/tree/main/Chapter%2010.
Using the new MultiplayerSpawner node
In this recipe, we need to set up a CharacterBody3D scene to use as the
player. We will also create a scene to simulate the game. We will create buttons
where we can host or join and hook them up in a script. After that, we use the
new MultiplayerSpawner node to spawn a player to the scene on the server.
We can move the player we spawned into the scene independent of the player
we will load into the server scene as a default.
Getting ready
For this recipe, open Godot 4 and start a new project called Chapter 10. In the
Scene tab, click 3D to add a 3D scene. Click on the word Scene in the main
menu next to Project, then select Save Scene As, and name it Spawner.
How to do it…
We will start by creating the player scene. After that, we will work on the
Spawner scene to hook up the server and client to simulate a multiplayer
game:
1. Click the + button to the right of the Spawner scene we just completed to add a new scene. In the
Scene tab, click Other Node. In the Create New Node window, type char in the Search box and
then select CharacterBody3D to create the node in the scene. Left-click the Create button. Click on
the word Scene in the top-left corner next to Project, then select Save Scene As, and name it
Character.
2. Left-click on the CharacterBody3D node and then left-click the + button in the Scene tab. In the
Create New Node window, type mesh in the Search box and then select MeshInstance3D to create
the node in the scene. Left-click the Create button.
3. In the Inspector tab, click on <empty> to the right of Mesh and select New CapsuleMesh.
4. Left-click on the CharacterBody3D node and then left-click the + button in the Scene tab. In the
Create New Node window, type coll in the Search box and then select CollisionShape3D to create
the node in the scene. Left-click the Create button.
5. In the Inspector tab, click on <empty> to the right of Shape and select New CapsuleShape3D.
6. Left-click on the CharacterBody3D node and then left-click the + button in the Scene tab.
7. Left-click on Transform in the Inspector tab.
8. Under Position, change the value of y to 1.
9. In the Inspector tab, click on <empty> to the right of Script and select New Script.
10. In the Attach Node Script window, to the right of Template, make sure the CharacterBody3D:
Basic Movement checkbox is checked.
11. You can keep the default filename as Character and left-click on the Create button.
12. Left-click on the Spawner scene.
13. Left-click on the three vertical dots to the left of Transform View on the viewport toolbar to edit the
Sun and Environment settings.
14. Add the Sun and Environment nodes to the scene by left-clicking the Add Sun to Scene button at
the bottom while holding down the Shift key.
15. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type panel in the Search box and then select Panel to create the node in the scene.
Left-click the Create button.
16. Right-click on the Panel node and select Rename from the drop-down list. Rename the node Menu.
17. Left-click on the Menu node and then left-click the + button in the Scene tab. In the Create New
Node window, type vbox in the Search box and then select VBoxContainer to create the node in the
scene. Left-click the Create button.
18. Left-click on the VBoxContainer node and then left-click the + button in the Scene tab. In the
Create New Node window, type button in the Search box and then select Button to create the node
in the scene. Left-click the Create button.
19. Right-click on the Button node and select Rename from the drop-down list. Rename it HostButton.
20. In the Inspector tab, under Text, enter Host in the box.
21. Left-click on the VBoxContainer node and then left-click the + button in the Scene tab. In the
Create New Node window, type button in the Search box and then select Button to create the node
in the scene. Left-click the Create button.
22. Right-click on the Button node and select Rename from the drop-down list. Rename it JoinButton.
23. In the Inspector tab, under Text, enter Join in the box.
24. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type mesh in the Search box and then select MeshInstance3D to create the node in
the scene. Left-click the Create button.
25. In the Inspector tab, click on <empty> to the right of Mesh and select New PlaneMesh.
26. Right-click on the MeshInstance3D node and select Rename from the drop-down list. Rename it
Ground.
27. In the Inspector tab, click on PlaneMesh to the right of Mesh.
28. Change the x and y values to the right of Size to 10 and 10.
29. To the right of Transform View, left-click on Mesh and select Create Trimesh Static Body in the
drop-down list.
30. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type cam in the Search box and then select Camera3D to create the node in the
scene. Left-click the Create button.
31. In the Inspector tab, click on Transform.
32. Under Position, change the y value to 1 and the z value to 5.
33. Left-click on the Node3D node and then in the Inspector, click on <empty> to the right of Script.
Select New Script.
34. To the right of Path, change the name of the script to Server.gd.
35. Left-click on HostButton in the Scene tab.
36. Left-click on the Node tab to the right of the Inspector tab.
37. Left-click on pressed() under BaseButton and left-click the Connect… button on the bottom right of
the screen:
Figure 10.1 – Adding signals to the buttons
38. Left-click on the Node3D node in the Connect to Script section in the Connect a Signal to a
Method window.
39. Left-click on the Connect button in the Connect a Signal to a Method window.
40. Left-click on JoinButton in the Scene tab.
41. Left-click on pressed() under BaseButton and left-click the Connect… button on the bottom right of
the screen.
42. Left-click on the Node3D node in the Connect to Script section in the Connect a Signal to a
Method window.
43. Left-click on the Connect button in the Connect a Signal to a Method window. Add the following
code to Server.gd:
1 Extends Node3D
2
3 var character = preload("res://Character.tsc")
4 var Port = 5555
5 var multi_peerer = ENetMultiplayerPeer.nav()
6
7 func _on_host_button_pressed():
8      multi_peer.create_server(Port)
9      multiplayer.multiplayer_peer = multi_peer
10     multiplayer.peer_connected.connect(add_player)
11     add_player(multiplayer.get_unique_id())
12
13 func _on_join_button_pressed():
14     multi_peer.create_client("localhost", Port)
15     multiplayer.multiplayer_peer = multi_peer
16
17 func add_player(peer_id):
18     var player = character.instantiate()
19     player.name = str(peer_id)
20     add_child(player)
44. Click on the word Scene in the top-left corner next to Project and then select Save All Scenes:
Figure 10.2 – Server.gd
45. Left-click on Debug in the main menu between Project and Editor.
46. At the bottom of the drop-down list, mouse over Run Multiple Instances and select Run 2
Instances:
Figure 10.3 – Multiple debug instances
47. Left-click on the Node3D node and then left-click the + button in the Scene tab. In the Create New
Node window, type mul in the Search box and then select Multiplayer Spawner to create the node
in the scene. Left-click the Create button.
48. In the Inspector tab, to the right of Spawn Path, left-click on Assign.
49. Left-click on Node3D and then the OK button.
50. In the Inspector tab, left-click on Auto Spawn List.
51. Left-click on the + Add Element button.
52. Left-click on the folder icon to the right of Element 0.
53. In the Open a File window, select Character.tscn.
54. In the Spawner scene, click the Run the current scene button in the upper-right corner of the
editor or hit the F6 key.
55. A pop-up window asks whether we want to grant public and or private access. Check private and
uncheck public.
56. Separate the windows. In the first window, left-click Host and move the player with the arrow keys.
57. In the second window, left-click Join. Click back to the first window and move the players.
How it works…
We created a new scene for our player. In the Scene tab, we used Other Node
so that our base node would be CharacterBody3D. We added a
MeshInstance3D node as a child of the CharacterBody3D node. We used a
CapsuleMesh node on the MeshInstance3D node and also added a
CapsuleShape3D node. We moved the CharacterBody3D node’s y Position
value to 1 so that it is on the ground level. We added the CharacterBody3D:
Basic Movement script so that we could move the player around.
We added the DirectionalLight3D and the WorldEnvironment nodes so that
we could see the scene when we ran the scene at the end of the recipe.
We added a Panel node and renamed it Menu. We added a VBoxContainer node
as a child of the Menu node. We added two buttons as child nodes to the
VBoxContainer node. We renamed the first button HostButton, and in the
Text field, we entered Host. We renamed the second button JoinButton, and in
the Text field, we entered Join.
We created a MeshInstance3D node, and for the mesh, we used a
PlaneMesh. We renamed it Ground. We changed the Size value of x to 10 and y
to 10. This gave us more room to spawn players later. We left-clicked on Mesh
in the toolbar above the viewport to the right of Transform View and selected
Create Trimesh Static Body from the drop-down list. This is so that our
CharacterBody3D node won’t fall through the ground. We created a
Camera3D node, and in the Inspector tab, we left-clicked on Transform. We
changed the Position values of y to 1 to raise up the camera and z to 5 to move
the camera back.
We left-clicked on Node3D and added a new script to the node. We named the
script Server.gd. We left-clicked on the HostButton node in the Scene tab so
that we can add a signal to the button. We left-clicked on the Node tab to the
right of the Inspector tab and selected pressed(). We connected the pressed()
method to the Server.gd script on the Node3D node. We did the same thing with
the JoinButton node in the Scene tab.
We wrote code to set up a server where we can host or join. In line 3, we
preloaded the Character scene into the character variable. In line 4, we set the
Port variable to 5555. We used 5555 because it’s well over 1024. Port numbers 0
-1024 are reserved for privileged services and are well-known port numbers.
In line 5, we assigned a new instance of ENetMultiplayerPeer to the multi_peer
variable. In the _on_host_button_pressed() function, we created a server in lines 8
and 9. In lines 10 and 11, we added the Character scene to the Spawner
scene on the server. In the _on_join_button_pressed() function, we created a client.
In lines 14 and 15, we joined the local server on port 5555.
In the add_player(peer_id) function, we added the Character scene with a
network ID. In line 18, we instantiated a new instance of the character that we
preloaded and assigned it to the player variable. In line 19, we created a unique
ID for the player. In line 20, we added the player as a child to the scene where
it is called.
We left-clicked on Debug in the main menu in the top-left section of the Godot
editor. When the drop-down list appeared, we went to Run Multiple
Instances and selected Run 2 Instances. We did this so that after we add the
MultiplayerSpawner node and run it, two windows will appear. In one
window, we can run it as the host, and in the other window, we can run it to
join the server.
We added a MultiplayerSpawner node to the Spawner scene. In the
Inspector, to the right of Spawn Path, we left-clicked Assign and selected
Node3D from the drop-down list. We left-clicked on Auto Spawn List to see
its properties in the Inspector tab. We left-clicked on the + Add Element
button. We left-clicked on the folder icon to the right of Element 0 and
selected our Character.tscn file in the Open a File window. This will spawn our
player.
We ran the current scene and we separated the two debug windows from the
start on top of each other. If this is the first time we run this server, a pop-up
window will ask whether we want to grant public and/or private access. We
checked the private checkbox and unchecked the public checkbox.
We left-clicked on Host and the player spawned in the scene. We moved the
player around with the arrow keys. We left-clicked on the second window and
selected Join. The player bounced out of the window, but if you go back to the
first window, you will see both players and notice that both players use the
same movement as the host player. In the next recipe, we will fix this by adding
a MultiplayerSynchronizer node to the CharacterBody3D scene.
Using the new MultiplayerSynchronizer node
In this recipe, we are going to add the MultiplayerSynchronizer node to the
CharacterBody3D scene. We will also add some code to the Character.gd script
so that each player that spawns into a game is unique.
Getting ready
For this recipe, we are going to continue where we left off in the last recipe.
How to do it…
We are going to start in the Character scene and add the
MultiplayerSynchronizer node:
1. Left-click on the CharacterBody3D node and then left-click the + button in the Scene tab. In the
Create New Node window, type mult in the Search box and then select MultiplayerSynchronizer
to create the node in the scene. Left-click the Create button.
2. In the bottom Replication panel, left-click on the + Add property to sync... button:
Figure 10.4 – The bottom Replication panel of the MultiplayerSynchronizer node
3. In the Pick a node to synchronize window, select CharacterBody3D and left-click the OK button.
4. In the Select Property window, under Node3D, left-click on Position and then left-click on the
Open button.
5. In the top middle of the editor, left-click on Script.
6. Select the Character.gd script to edit this script.
7. On line 10, enter func _enter_tree():.
8. On line 11, enter set_multiplayer_authority(str(name).to_int()).
9. Create an empty line so that line 12 is blank and line 13 is the _physics_process(delta) function.
10. On line 14, enter if not is_multiplayer_authority(): return:
Figure 10.5 – Setting up the multiplayer authority
11. In the Spawner scene, click the Run the current scene button in the upper-right corner of the
editor or hit the F6 key.
12. A pop-up window asks whether we want to grant public and/or private access. Check private and
uncheck public.
13. Separate the windows. In the first window, left-click Host and move the player with the arrow keys.
14. In the second window, left-click Join. Click back to the first window and move the players.
How it works…
We started in the Character scene. We left-clicked on the CharacterBody3D
node in the Scene tab and then added a MultiplayerSynchronizer node. In
the bottom Replication panel, we left-clicked on the + Add property to
sync... button. We selected the CharacterBody3D node in the pop-up window.
We selected Position located toward the bottom of the Select Property
window. We only used one property, but in a real game project, you would
probably use more.
We edited the Character.gd script so that we could set the authority for each
player that spawned in the game. This will let each player control only
themselves. At the end of the last recipe, when we moved the host or the client
player, the other moved as well. In line 10, we created an _enter_tree() function
because the players can spawn in and out at any time. In line 11, we set the
multiplayer authority string, name, to an integer. In line 14, we checked at the
beginning of the _physics_process(delta) function to see whether the local system
is the multiplayer authority. If not, then exit the code.
We selected the Spawner scene. We ran the current scene and we separated
the two debug windows since they start on top of each other. If this is the first
time we run this server, a pop-up window will ask whether we want to grant
public and/or private access. We checked private and unchecked public. We
left-clicked on Host, and the player spawned in the scene.
We moved the player around with the arrow keys. We left-clicked on the second
window and selected Join. The player spawned on top of the host player. We
moved the player and noticed that the host player stays where they are while
the joined player moves around the scene. You can see in the host window that
the movement is happening in real time.
How to use the Headless mode
In this recipe, we will export the Spawner project that we have worked on so
far in this chapter. We use Command Prompt (CMD) to create a headless
server for our Spawner project. A headless server is used in multiplayer games
where you only need processing done because graphics and sound are not
included in a headless server.
Getting ready
For this recipe, we are going to use the Spawner project that we built in the
last two recipes to export as a Windows headless server. In the FileSystem
tab, right-click on res// and mouse over New. In the drop-down list that
appears, left-click on Folder. Name the folder Project.
Click on the Spawner tab and then left-click the Run Project (F5) button
located above and to the left of the Inspector tab. In the Please Confirm
window, left-click on the Select Current button.
How to do it…
We will start by exporting the Spawner project that we made in the last two
recipes:
1. In the main menu, left-click on Project, to the right of Scene, in the top-left corner of the Godot
editor.
2. Left-click on Export in the drop-down list.
3. Select Windows Desktop (Runnable).
4. If you have not installed Windows Desktop (Runnable), left-click on Add at the top of the window
and select Windows Desktop (Runnable). Left-click on Manage Export Template at the bottom of
the window and left-click on the Download and Install button. After it has been installed, left-click
on the Close button to close the window. Repeat steps 1-3 after you have installed Windows Desktop
(Runnable).
5. At the bottom of the Export window, left-click on the Export Project... button.
6. Double-click on the Project folder in the Save a File window and left-click on the Save button.
7. Left-click on the OK button in the Project Export window.
8. Click on the Close button in the Export window.
9. Right-click on the Project folder.
10. At the bottom of the drop-down list, left-click on Open in File Manager.
11. In the File Manager window, left-click in the address field and enter cmd, then press the Enter key:
Figure 10.6 – Searching for CMD in the folder address field
12. In the Command Prompt (CMD) window, type the first three letters of the first filename in the list
and hit the Tab key.
13. Use the left arrow key to move the cursor in Command Prompt (CMD) and Backspace to delete
console. An example is filename.console.exe.
14. Move the cursor back to the right of the last quotation mark. It should now look like filename.exe
with the cursor on the right-hand side of the last quotation mark.
15. Press the spacebar, then type --headless, and press Enter:
Figure 10.7 – The .exe file with the --headless command
16. In the File Manager window, double-click on the Chapter 10.exe file.
How it works…
We looked in the main menu section of the Godot editor and left-clicked on
Project. In the drop-down list, we left-clicked on Export and selected Window
Desktop (Runnable).
If we didn’t see it listed, then we left-clicked on Add located at the top toward
the middle of the window. We selected Windows Desktop (Runnable) and
left-clicked on Manage Export Template located near the bottom of the
window. We left-clicked on the Download and Install button in the pop-up
window. After we installed Windows Desktop (Runnable), we selected
Windows Desktop (Runnable).
We left-clicked on the Export Project... button at the bottom of the Export
window. We double-clicked on the Project folder we created in the Getting ready
section and left-clicked the Save button to save the export of the Chapter 10
project to the Project folder. We didn’t worry about the yellow warnings we got.
We right-clicked on the Project folder and selected Open in File Manager at
the bottom of the drop-down list. We left-clicked in the Address field and typed
cmd. When we pressed Enter, the Command Prompt (CMD) window opened.
We used the left arrow to move the cursor to the period in front of .exe and
backspaced to delete console. It should end in Chapter 10.exe". We pressed the
spacebar and then typed –headless. We pressed the Enter key to run the
headless file. We double-clicked on the Chapter 10.exe file to run the program.
How to use UPnP with P2P networking
In this recipe, we will use the UPnP class to port-forward, which is used in P2P
networking. We will create a new scene, then add a script to the Node2D node,
which searches for ports that can be forwarded, and then forward the port. The
script can be used in your multiplayer game to look for internal and external
ports and gateways (routers).
Getting ready
For this recipe, click the + button to the right of the Character scene we just
completed to add a new scene. In the Scene tab, click 3D Scene. Click on the
word Scene in the main menu next to Project, then select Save Scene As, and
name it UPNP.
How to do it…
First, we will add an empty script to the Node2D node in the Scene tab:
1. Left-click on the Node2D node in the Scene tab.
2. In the Inspector tab, click on <empty> to the right of Script.
3. Left-click on New Script from the drop-down list.
4. In the Attach Node Script window, uncheck the checkbox to the right of Template.
5. To the right of Path, name the script UPNP.gd and left-click on the Create button.
6. Starting on line 3, type the following code:
3 func _ready():        
4     var upnp = UPNP.new()      
5     var find_result = upnp.discover()     
6          
7     if find_result == UPNP.UPNP_RESULT_SUCCESS:  
8         if upnp.get_gateway() and upnp.get_gateway().is_valid_gateway():           
9             var map_result_udp = upnp.add_port_mapping(5555, 0, "game_udp:", "UDP,
0)
10            var map_result_tcp = upnp.add_port_mapping(5555, 0, "game_tcp", "TCP",
0)  
11          
12            if not map_result_udp == UPNP.UPNP_RESULT_SUCCESS:            
13                upnp.add_port_mapping(5555, 0, "", "UDP")  
14            if not map_result_tcp == UPNP.UPNP_RESULT_SUCCESS:            
15                upnp.add_port_mapping(5555, 0, "", "TCP")   
16          
17    var external_ip = upnp.query_external_address()
18    upnp.delete_port_mapping(5555, "UDP")    
19    upnp.delete_port_mapping(5555, "TCP")   
7. Save the UPNP.gd script:
Figure 10.8 – UPNP.gd
How it works…
We left-clicked on the Node2D node in the Scene tab and left-clicked on
<empty> to the right of Script in the Inspector tab to add a new script. We
unchecked the checkbox to the right of Template in the Attach Node Script
window so that our new script would be empty except for the first line. We
named the script UPNP.gd.
We entered the code in the script. In line 3, we created the _ready() function. In
line 4, we created a upnp object. In line 5, we assigned the find_result variable to
the discover method of upnp. In line 7, we checked to see whether it had found a
port. In line 8, we looked for a gateway and made sure that it was a valid
gateway.
In line 9, we created a variable called map_result_udp to call add_port_mapping. The
first argument is the external port, and the second is the internal port. The
default on the second argument is 0, which is the same as the first argument.
The third argument is a description shown in some routers. The fourth
argument determines the protocol to use, either UDP or TCP, to transmit the
data.
The fifth argument is the duration in seconds, and the default 0 that we used
means that there is no duration. In line 10, we did the same as in line 9, except
we used TCP. In lines 12-15, we did the same as in line 9 and line 10, but we
used no description. We did this because some routers want a description while
others don’t. In line 17, we created a variable called external_ip, which returns
an external IP address of the default gateway as a string.
This variable is not used in this code and would be used to hook it up in your
game. In lines 18-19, we called delete_port_mapping to shut down the server. The
first argument is the port number and the second is the protocol. We shut down
both UDP and TCP protocols. Finally, we saved the script.
Index
As this ebook edition doesn't have fixed pagination, the page numbers below
are hyperlinked for reference only, based on the printed edition of this book.
Symbols
2D
CharacterBody, setting up to move 70-77
directional sound, exploring 146-151
2D projects
NavigationServer2D, using 87-91
3D
CharacterBody, setting up to move 77-80
directional sound, exploring 151-156
NavigationServer, using 80-86
3D games
SoftBody, using 92-96
3D rotation animations
playing with 192-195
3D terrain
Heightmap, using 66-70
A
annotations
investigating 18-20
AudioStreamPlayer
working with 142-145
await keyword
using 24-27
B
Bezier curve
workflow, investigating 190-192
Billboard node
using 117-119
Blender blend files
importing, into Godot 4 130-133
bone poses
working with 195-201
C
callables
using, with signals 34-38
CharacterBody
setting up, to move in 2D 70-77
setting up, to move in 3D 77-80
Comment nodes
working with 111-114
coroutines
using 24-27
CurveTexture nodes
creating 115
using 115, 116
Custom Data Layers
creating, with TileSet 172-174
D
decals 57
Decals_World 58-60
lightning decal, creating 60, 61
using, in game 57, 58
working 62, 63
directional sound
exploring, in 2D 146-151
exploring, in 3D 151-156
E
Editor Settings dialog 13, 14
working 15
F
FBX files
importing, into Godot 4 133, 134
Fog Shader mode
working with 125-127
FogVolume node 47, 48
frames per second (FPS) 213
function
calling, with super keyword 27-29
G
getters
properties, using with 20-24
Global Uniforms
using 102-104
glTF files
importing, into Godot 4 135, 136
Godot
reference link 1
Godot 4
Blender blend files, importing 130-133
FBX files, importing 133, 134
glTF files, importing 135, 136
working, with particle nodes in 48-50
Godot 4 Editor
navigating 2-7
GPUParticles3D node 49
H
Headless mode
using, considerations 225-228
Heightmap
using, for 3D terrain 66-70
I
Import dialog
using 136-140
Instance Uniforms
using, with shaders 105, 106
working 106
Integer nodes
working with 111-114
isometric tiles, into fixed-sized grids
organizing, with TileSet resource 181-184
L
lambda functions
working with 31-34
M
MultiplayerSpawner node
using 216-222
MultiplayerSynchronizer node
using 223-225
N
NavigationServer
using, for 3D 80-86
NavigationServer2D
using, for 2D projects 87-91
new Movie Maker mode
playing with 208-214
nodes
creating, with Texture3D and CurveTexture 115, 116
P
P2P networking
UPnP, using with 228-230
particle nodes, Godot 4
Particles2D 53, 54
trails, using 51, 52
working with 48-56
Project Settings dialog
features, exploring 8-12
properties
using, with getters 20-24
using, with setters 20-24
S
Screen-Space Indirect Lighting (SSIL) 40
setters
properties, using with 20-24
shader language
Uniform Arrays, exploring 100-102
shaders
creating, with Shader Creation dialog 98-100
Instance Uniforms, using with 105, 106
signals
callables, using with 34-38
signed distance field global illumination (SDFGI) 39, 40
settings 41-45
Signed Distance Fields (SDFs) 40
Sky Shader mode
improving 121-125
SoftBody
using, for 3D games 92-96
super keyword
using, to call function 27-29
T
terrains
painting, in TileMap 174-177
Texture3D nodes
using 115
Tile Atlas editing
playing with 166-168
TileMap
layers, examining 161, 162
terrains, painting 174-177
terrains, transitioning 177-181
TileMap tools
playing with 162-166
TileSet
editor, using 158-160
navigation, exploring 170-172
physics, exploring 168, 169
resource, used for organizing isometric tiles into fixed-sized grids 181-184
used, for creating Custom Data Layers 172-174
transform tracks
used, for exploring changes 186-189
transition
triggering 201-208
typed arrays
working with 29-31
U
Uniform Arrays
exploring, in Godot 4 shader language 100, 101
working 102
UPnP
using, with P2P networking 228-230
UVFunc node
using 119-121
V
Visual Shaders Context menu
exploring 107-111
Volumetric Fog
used, for enhancing games 45, 46
www.packtpub.com
Subscribe to our online digital library for full access to over 7,000 books and
videos, as well as industry leading tools to help you plan your personal
development and advance your career. For more information, please visit our
website.
Why subscribe?
Spend less time learning and more time coding with practical eBooks and Videos from over 4,000
industry professionals
Improve your learning with Skill Plans built especially for you
Get a free eBook or video every month
Fully searchable for easy access to vital information
Copy and paste, print, and bookmark content
Did you know that Packt offers eBook versions of every book published, with
PDF and ePub files available? You can upgrade to the eBook version at
packtpub.com and as a print book customer, you are entitled to a discount on
the eBook copy. Get in touch with us at customercare@packtpub.com for more
details.
At www.packtpub.com, you can also read a collection of free technical articles,
sign up for a range of free newsletters, and receive exclusive discounts and
offers on Packt books and eBooks.
Other Books You May Enjoy
If you enjoyed this book, you may be interested in these other books by Packt:
Game Development with Blender and Godot
Kumsal Obuz
ISBN: 978-1-80181-602-1
Discover what low-poly modeling is and why it matters
Understand how to use materials, shaders, and textures in your models
Explore how to render and animate a scene in Blender
Focus on how to export Blender assets and import them into Godot
Use 3D low-poly models in Godot to create fun games
Design a dynamic and easy-to-navigate game world
Explore how to interact with the game via interfaces
Understand how to export your game for Windows
Godot Engine Game Development Projects
Chris Bradfield
ISBN: 978-1-78883-150-5
Get started with the Godot game engine and editor
Organize a game project
Import graphical and audio assets
Use Godot’s node and scene system to design robust, reusable game objects
Write code in GDScript to capture input and build complex behaviors
Implement user interfaces to display information
Create visual effects to spice up your game
Learn techniques that you can apply to your own game projects
Packt is searching for authors like you
If you’re interested in becoming an author for Packt, please visit
authors.packtpub.com and apply today. We have worked with t




Table of Contents
Preface xiii
Part 1: 3D Assets with Blender
1
Creating Low-Poly Models 3
Technical requirements 3
Understanding low-poly models 4
Parts of a 3D model 5
Low or hi, what’s the difference? 5
Advantages of low-poly models 6
Limitations of low-poly models 8
Creating a low-poly barrel 8
Starting with a primitive 10
Editing the model 12
Shaping the body 13
Separating the lid 15
Finishing the body 17
Placing metal rings 18
Finalizing the lid 21
Automating with modifiers 22
Summary 25
Further reading 25
2
Building Materials and Shaders 27
Technical requirements 28
Introducing materials 28
Creating materials 31
Assigning materials 32
Discovering shaders 34
Summary 38
Further reading 39
viii Table of Contents
3
Adding and Creating Textures 41
Technical requirements 42
Understanding UVs and texture
coordinates 42
Using the UV Editor 43
Importing and applying a texture 45
Creating textures procedurally 49
Noise Texture 52
Bump 52
Emission 53
ColorRamp 53
Principled BSDF 55
Mix Shader 56
Exporting your textures 56
Changing the rendering engine 57
Baking a texture File 57
Summary 58
Further reading 59
4
Adjusting Cameras and Lights 61
Technical requirements 61
Rendering a scene 62
Understanding light types 65
Types of light 65
Basic properties of light 67
Specific properties of each light type 68
Wrapping up 69
Introducing MatCap and Ambient
Occlusion 69
MatCap 70
Ambient Occlusion 72
Summary 74
Further reading 75
5
Setting Up Animation and Rigging 77
Technical requirements 78
Where to build animations 78
Animating in Godot Engine 79
Animating in Blender 79
Wrapping up 79
Understanding the readiness of models 80
Topology and rigging 80
Grabbing 82
Creating animations 83
Rigging 84
Animating 94
Getting animations ready for Godot 98
Summary 99
Further reading 100
Table of Contents ix
Part 2: Asset Management
6
Exporting Blender Assets 103
Technical requirements 104
Getting ready to export 104
Deciding what to do with n-gons 104
Setting origin points 106
Applying rotation and scale 109
Naming things properly 111
Wrapping up 111
Exploring glTF and other export
formats 111
Comparing gITF with other formats 112
Introducing glTF 113
Deciding what to export 115
Include 115
Transform 116
Geometry 116
Animation 117
Creating presets 117
Summary 117
Further reading 118
7
Importing Blender Assets into Godot 119
Technical requirements 120
Making a scene! 120
Going between Blender and Godot 123
Deciding what to do with materials 125
Labeling Blender materials by purpose 126
Labeling Blender materials by color 126
Importing your models into separate folders 127
Using a staging area in Godot 127
Wrapping up 128
Importing animations 128
MeshInstance and Skeleton 130
AnimationPlayer 130
Separating actions 131
Summary 133
Further reading 134
8
Adding Sound Assets 135
Technical requirements 136
Learning about different sound
formats 136
Introducing WAV 136
Introducing OGG 137
Introducing MP3 138
x Table of Contents
Wrapping up 138
Deciding on looping or not 139
Turning the looping on and off 140
Playing audio in Godot 142
Playing background music 143
Playing a sound effect on demand 143
Increasing gameplay experience 145
Summary 145
Further reading 145
Part 3: Clara’s Fortune – An Adventure Game
9
Designing the Level 149
Technical requirements 150
Creating the cave 151
Erecting the walls 157
Sinking the walls 159
Placing the rocks 159
Distributing props 160
Finishing the rest of the level 161
Constructing the missing materials 162
Fixing the leaves 163
Creating the water 165
Laying models on a grid 170
Taking advantage of MeshLibrary 172
Using a mesh library with a grid map 174
The necessity of using multiple grid maps 175
Wrapping up 176
Summary 176
Further reading 177
10
Making Things Look Better with Lights and Shadows 179
Technical requirements 180
Adding different types of light 180
Lighting candles 181
Introducing candles to the level 183
Mimicking the sunlight 185
Enabling and adjusting shadows 187
Creating post-processing effects 189
Background 191
ToneMap 192
Screen Space Reflections (SSR) 193
Ambient Occlusion (SSAO) 193
Glow 194
Adjustments 195
Wrapping up 196
Using global illumination 196
Turning on Light Baking 198
Adjusting Indirect Energy 198
Summary 200
Further reading 201
Table of Contents xi
11
Creating the User Interface 203
Technical requirements 204
Creating a simple button 204
Wrapping in a panel 206
Filling the panel with more control
nodes 208
Adding a MarginContainer 209
Styling the Label node 210
Positioning the Close button 212
Adding the close functionality 213
Wrapping up 214
Taking advantage of themes 215
Creating a new theme 216
Styling a CheckButton 217
Changing a CheckBox and discovering radio
buttons 218
Attaching a theme 221
Altering a vertical slider component 222
Wrapping up 223
Summary 224
Further reading 224
12
Interacting with the World through Camera and Character
Controllers 225
Technical requirements 226
Understanding the camera system 226
Tidying things up for interactivity 228
Deciding on a type of projection 229
Adjusting the camera settings for our game 231
Detecting user input 234
Knowing where the player interacts 234
Distinguishing useful mouse events 236
Moving the player around 239
Creating walkable areas with a Navigation node240
Introducing a basic player character 242
Preparing a clickable area for raycasting 244
Using Navigation node for pathfinding 246
Moving the player to their desired spot 247
Wrapping up 248
Triggering animations 249
Understanding how Clara looks around 251
Adding a looking behavior to moving
functionality 252
Playing the right action for Clara 253
Blending animations or actions 254
Summary 255
Further reading 256
13
Finishing with Sound and Animation 257
Technical requirements 258 Playing music and sound effects 258
xii Table of Contents
Setting background music 259
Conditionally playing a sound 260
Understanding the volume through decibels 262
Creating reaction spots 263
Placing trigger points in the world 264
Getting to know a better collision detection
method 266
Lighting the candles and sconces 267
Adding the trigger for the backpack 271
Interacting with the door 272
Building simple animations in Godot 274
Creating the door animation 275
Playing the door animation on a condition 277
Waiting for the door animation to trigger an
event 278
Let there be flickering lights 280
Wrapping up 282
Loading another level 282
Using an event bus 283
Listening to the EventBus signal 285
Discussing some of the choices we can all make 287
Summary 288
Further reading 289
14
Conclusion 291
Technical requirements 292
Exporting your game 292
Preparing your project for export 293
Creating a mechanism for turning the game off 294
Configuring Windows export settings 295
Offering different gameplay
experiences 297
Having an iterative creation process 297
Discovering different genres 298
Summary 299
Further reading 299
Index 301
Other Books You May Enjoy 310
Preface
Game Development with Godot and Blender is a comprehensive introduction for those who are new to
building 3D models and games, allowing you to leverage the abilities of these two technologies to create
dynamic, interactive, and engaging games.
This book will start by focusing on what low-poly modeling actually is, before diving into using Blender
to create, rig, and animate our models. We will also make sure that these assets are game-ready, making
it easy for you to import them into Godot and use your assets effectively and efficiently. Then, in Godot,
you will use the game engine to design scenes, work with light and shadows, and transform your 3D
models into interactive, controllable assets.
By the end of the book, you will have a seamless workflow between Blender and Godot that is specifically
geared towards game development and will have created a point-and-click adventure game following
our instructions and guidance. Beyond this point, you should be able to take these newly acquired skills
and create your own 3D games from conception to completion!
Who this book is for
This book is for game developers who are looking to make the transition from 2D to 3D games. You
should have a basic understanding of Godot, and be able to navigate the UI, understand the Inspector
panel, create scenes, add scripts to game objects, and so on. Previous experience with Blender is helpful
but not required.
What this book covers
Chapter 1, Creating Low-Poly Models, covers the creation of low-poly models in Blender. You’ll also
look at how to utilize modifiers to expedite the process.
Chapter 2, Building Materials and Shaders, shows you how to create and assign different materials to
your models, and understand where shaders come into play.
Chapter 3, Adding and Creating Textures, teaches you how to prepare your models for texturing.
Applying third-party textures and creating your own are also covered in this chapter.
xiv Preface
Chapter 4, Adjusting Cameras and Lights, presents different light types and how to capture a shot of
your scene. You’ll be revisiting some of these notions in the Godot context later in Chapter 10, Making
Things Look Better with Lights and Shadows.
Chapter 5, Setting up Animation and Rigging, discusses the notion of animation and whether doing
it in Godot or Blender is the right choice. Once we settle the matter in Blender’s favor, you’ll rig and
animate a simple model.
Chapter 6, Exporting Blender Assets, tackles a most crucial and often ignored topic: exporting your
models from Blender. You’ll be specifically shown a format that is the most suitable for Godot Engine.
Chapter 7, Importing Blender Assets into Godot, conveniently shows how to import your models into
Godot. The transition between different applications is not always smooth, so you’ll also be presented
with shortcomings and workarounds.
Chapter 8, Adding Sound Assets, investigates the use of sound in Godot Engine. You’ll partake in a
short exercise to play a sound file after discovering different types of audio files the engine supports.
Chapter 9, Designing the Level, will be the beginning of a series of exercises for building a point-andclick adventure game. To kick off the effort, you’ll be designing the level with the models that come
within the GitHub repository.
Chapter 10, Making Things Look Better with Lights and Shadows, presents different light types you
can deploy in your level to enhance the look and feel of the game. To complement the scene further,
you’ll also discover the use of global illumination and post-processing effects.
Chapter 11, Creating the User Interface, discusses the necessity of user interfaces. Then, you’ll utilize a
bunch of Godot UI components to compose a piece of note. Last but not least, you’ll investigate why
creating themes in Godot might be a time-saver.
Chapter 12, Interacting with the World through Camera and Character Controllers, presents different
camera types and settings on different gaming platforms. After attaining a basic view into the game
world, you’ll continue with detecting user input, which is essential for the type of game you are
building. To finish off, you’ll use this information to move a game character to their designated spot.
Chapter 13, Finishing with Sound and Animation, finishes the core mechanics of our little game. To
that end, you’ll be adding sound effects and animations to certain game objects. Also, you’ll create a
simple animation in Godot and create the necessary conditions for the player to meet in order to trigger
this animation. Once all the in-game requirements are finished, you’ll load a new level for the player.
Chapter 14, Conclusion, shows how to export your game to Windows, so you can share it with the
world. You’ll finish this chapter and the book off by getting to know what else Godot can offer to you.
To get the most out of this book xv
To get the most out of this book
You will need the Windows versions of Blender 2.93 and Godot 3.4.4 installed on your computer. All the
visual examples and code samples have been tested for these versions. If you have newer or older versions
installed, you might notice discrepancies.
Knowing how to use GitHub at a basic level might help. Alternatively, you can download the whole
repository and work with your local copy.
If you are using the digital version of this book, we advise you to type the code yourself or access
the code from the book’s GitHub repository (a link is available in the next section). Doing so will
help you avoid any potential errors related to the copying and pasting of code.
Download the example code files
You can download the example code files for this book from GitHub at https://github.com/
PacktPublishing/Game-Development-with-Blender-and-Godot. If there’s an update
to the code, it will be updated in the GitHub repository.
We also have other code bundles from our rich catalog of books and videos available at https://
github.com/PacktPublishing/. Check them out!
Download the color images
We also provide a PDF file that has color images of the screenshots and diagrams used in this book.
You can download it here: https://packt.link/0KyZi.
Conventions used
There are a number of text conventions used throughout this book.
Code in text: Indicates code words in text, database table names, folder names, filenames, file
extensions, pathnames, dummy URLs, user input, and Twitter handles. Here is an example: “If you
increase the radius to 10.0, something interesting will happen.”
xvi Preface
A block of code is set as follows:
extends AudioStreamPlayer
func _unhandled_key_input(event: InputEventKey) -> void:
 if event.is_pressed() and event.scancode == KEY_SPACE:
 stream_paused = false
 else:
 stream_paused = true
Bold: Indicates a new term, an important word, or words that you see onscreen. For instance, words in
menus or dialog boxes appear in bold. Here is an example: “When you applied the Solidify modifier,
you must have seen that there are so many other modifiers.”
Tips or important notes
Appear like this.
Get in touch
Feedback from our readers is always welcome.
General feedback: If you have questions about any aspect of this book, email us at customercare@
packtpub.com and mention the book title in the subject of your message.
Errata: Although we have taken every care to ensure the accuracy of our content, mistakes do happen.
If you have found a mistake in this book, we would be grateful if you would report this to us. Please
visit www.packtpub.com/support/errata and fill in the form.
Piracy: If you come across any illegal copies of our works in any form on the internet, we would
be grateful if you would provide us with the location address or website name. Please contact us at
copyright@packt.com with a link to the material.
If you are interested in becoming an author: If there is a topic that you have expertise in and you
are interested in either writing or contributing to a book, please visit authors.packtpub.com.
Part 1:
3D Assets
with Blender
This part of the book provides you a detailed look into how to create models, textures, and animation
in Blender. By the end of this part, you’ll be able to create game-ready assets.
In this part, we cover the following chapters:
• Chapter 1, Creating Low-Poly Models
• Chapter 2, Building Materials and Shaders
• Chapter 3, Adding and Creating Textures
• Chapter 4, Adjusting Cameras and Lights
• Chapter 5, Setting Up Animation and Rigging

1
Creating Low-Poly Models
Blender is a sophisticated program that has gone through a lot of iterations to get to the point where
it is now. More and more professionals in different industries are investigating it as an alternative to
other well-known 3D applications out there, such as Maya, 3ds Max, ZBrush, and Modo. Also, Blender
happens to be a good starting point for hobbyists and people who can’t afford the licensing fees of the
aforementioned software. Additionally, Blender has a helpful and large community that creates courses
and tutorials. Blender Conference (BCON) is an annual event where you can meet professionals.
An important decision you must make before you start creating 3D content with any type of software
is where you are going to use your assets – this directly affects the style and workflow you will follow
to accomplish the task. One type of workflow is called low-poly modeling, with which you create 3D
assets that have a minimum number of details.
In this chapter, we’ll discuss why low-poly modeling might be beneficial compared to other workflows.
Following the advantages, you’ll learn how to create low-poly assets using different techniques. We’ll
conclude this chapter by introducing a few modifiers that might prove indispensable.
In this chapter, we will cover the following main topics:
• Understanding low-poly models
• Advantages of low-poly models
• Creating a low-poly barrel
• Automating with modifiers
Technical requirements
To follow the instructions in the chapters that involve Blender, you must install the necessary software
on your computer. The Blender website – more specifically, their download page at https://www.
blender.org/download/ – contains instructions and links for your platform. In this book,
we are using Blender 2.93. Although version 3.0 will offer interesting and exciting options to new
4 Creating Low-Poly Models
and existing Blender users, the current version is more than capable of creating game assets for your
projects and the topics covered in this book.
This book uses GitHub to store the code that will be used in the Godot chapters. However, the same
repository (https://github.com/PacktPublishing/Game-Development-withBlender-and-Godot) also hosts the Blender files used throughout the relevant chapters. Where
it makes sense, the repository will be structured with Start and Finish folders inside each specific
chapter for you to start over or compare your work as you make progress.
Understanding low-poly models
Simply put, a 3D model is considered to be low-poly when it uses the minimum number of polygons
to make its most characteristic features, mainly its look and feel. However, let’s take a look at them
in a little more detail.
In real-time applications such as game engines, your computer’s central processing unit (CPU) and
graphics processing unit (GPU) are responsible for processing the visual information you see on the
screen. In the last two decades, the trend has been leaning heavily toward the GPU side since GPUs
are dedicated to one main task: processing graphics.
GPUs have an advantage over CPUs in that regard, and they don’t discriminate between 2D and 3D
graphics. However, whereas 2D images contain pixel information, 3D objects are represented by data
that holds the necessary coordinate information that defines the object.
Although a cube is still a bunch of pixels after it is rendered on your screen, the data that defines
the cube is essentially eight points, which are called vertices. For demonstration purposes, in the
following screenshot, Blender’s vertex size setting has been changed so that you can see where those
vertices are more easily:
Figure 1.1 – The eight vertices of a cube
Understanding low-poly models 5
Both cubes are the same object, but it’s possible to render the same eight vertices and their relationship
with each other in two different ways: one that looks like a solid object (on the left) and another that
looks transparent (on the right). So, keep in mind that vertices are data points that define the shape
of the object, not how it looks. Later in this chapter, you’ll learn how to make objects look different,
similar to what’s shown in the preceding screenshot.
Before we discuss what makes a model low-poly, we must understand a few other essential parts.
You’ve already seen that the vertex is the most crucial component, but there are two more concepts
you must be aware of:
• Edge
• Face
Let’s see how these two relate to a vertex. By doing so, we’ll be on our way to understanding what
makes a model low-poly.
Parts of a 3D model
An edge is what connects two vertices. It’s as simple as that. If you look at Figure 1.1 again, you’ll
see that not all the vertices are connected. However, when they are connected, it’s called an edge and
depicted by Blender with a straight line going from one vertex to the other.
A face, as you may have deduced, is a logical outcome when you arrange vertices – or edges – in a
certain pattern. For example, a cube or a six-sided die has six faces. Although Figure 1.1 makes it
look like you need four edges to make a face, there is a simpler way – that is, three edges are enough
to form a face. So, a triangle is the simplest face, also known as a polygon.
Low or hi, what’s the difference?
When you are designing a model, you are creating polygons. The density of the polygons in a model
is what determines whether a model can be considered low-poly. The following figure displays one
low-poly and one high-poly work sample, courtesy of Sketchfab users MohammadRezae and DJS_05:
Figure 1.2 – An example of a low-poly versus high-poly model
6 Creating Low-Poly Models
You can find a lot of examples of different polygon counts on websites such as Sketchfab.
In the industry, if you are asking for a model to be designed for you, you may want to mention that
you want it done in low-poly form. It’s often agreed that if you don’t mention this, people will assume
it’s going to have as many polygons as possible since you would want your models to be as detailed
as possible with plenty of polygons. So, the distinction is made when you are cutting those polygons
out, not when you are keeping them in.
Let’s focus on our default cube again. Is it low-poly or hi-poly? It might be both. Although we know
that only eight vertices are needed to create a cube, we could have had many more vertices along the
edges that connected the original corner vertices. However, it would not have made any difference
in the rendered result. That being said, it would have taken the computer a lot longer to render the
same visual result.
So, as mentioned previously, when your model has just enough polygons to make sense of the object
you’d like to design, you’ll have a low-poly model.
Although GPUs are fast and they do a fantastic job these days of rendering millions of polygons and
going low-poly may feel like you are cutting corners, there are good reasons why you may not want
to have that many polygons in your project.
Advantages of low-poly models
Here is a quick list of the benefits of following a low-poly modeling practice:
• Fewer polygons
• Small file size
• A certain artistic style
• Easy to prototype
• No or minimal texturing
Working with fewer polygons certainly means fewer things to change and worry about. Shortly, you’ll
learn how to create a barrel, and by the end of that exercise, your model will have close to a thousand
polygons. This number may seem high at first but imagine working with a hi-poly barrel model with
more than 10,000 polygons. So, if you are new to 3D modeling, low-poly modeling is a great place
to start.
Should you decide to alter your models, working with a higher number of polygons will force you
to be more careful. So, in essence, having fewer polygons is comforting since you will feel like you
have more control over your creation. Naturally, fewer polygons will result in a smaller file size too.
Advantages of low-poly models 7
The artistic style advantage is a non-technical item in the advantages list. Nevertheless, it might be an
important decision. Let’s focus on Figure 1.3, for example. You’ll see why lack of detail doesn’t always
mean lack of imagination:

Figure 1.3 – Low-poly model landscape
Here, you can see just enough details to figure out that there is a church. Perhaps this church is looking
onto a town square. The mountain tops have some snow. Is this a peaceful town that’s appealing to
tourists for winter sports? Perhaps the townspeople are currently hiding in the church from a villain?
Our imagination fills in the details. Whatever the case and the game genre is, the low-poly aspect of
the 3D models doesn’t induce a penalty for creativity. In fact, in the last few years, we’ve seen more
games with low-poly assets making headlines.
If you are working in a small game development team or if you are the only developer, you’ll sometimes
want to focus on game mechanics first to see if the idea is fun. In situations like these, you’ll want
to prototype objects quickly so that you can embed them into your code. When the model you are
working on has a generic shape of the object you would like to design and has enough details, then
you might be done. That’s why it’s a highly sought-after choice among indie developers since you
can move forward quickly to the next model, then to programming your game. In essence, low-poly
modeling is like prototyping but it’s a few steps more refined than placing a cone for a tree, a cylinder
for a barrel, or a cube for a crate.
8 Creating Low-Poly Models
Last on the list is texturing. This is a process where you give a certain look and feel to your model. A
sandy beach usually looks yellow. If it’s a rocky beach, then the rocks will most likely have different tones
of gray. Thus, it’s about mainly applying color information to the surfaces of your model. Sometimes,
this color information will be complemented by additional data such as reflectivity, metallicity, and
roughness. We’ll discover all this in the next chapter.
It’s often said that most things in the computer world are a trade-off. Speed versus quality versus price
is a common example where you can most likely have two out of three but not all three. Despite all
the benefits a low-poly workflow provides, there are some limitations, but recognizing them will help
you to find workarounds or plan ahead.
Limitations of low-poly models
If your models need to show damage such as missing parts along an edge or some chunks blown out
of a face, then you need to introduce more polygons in those areas. This still won’t make it a high-poly
model, but you’ve got to consider additional polygons if you fancy some dynamic details.
Also, if you decide to animate your low-poly models, you’ll need to introduce more geometry by
adding more polygons in the areas where there will be bending and twisting (depending on the model
you are animating).
Additionally, since there are fewer polygons, you may have to be creative with the lighting of your scene
to give the illusion of detail. Although the color of the water in Figure 1.3 is the same throughout the
composition, the designer used a couple of clever methods to make the scene look more interesting.
First, the water’s surface looks fractured. This gives the illusion that there is some slight movement
in this water’s body. Perhaps there is a gentle breeze. Second, some of those fractures have a reflective
material applied. This makes the surface reflect the objects further ahead on the horizon.
We’ll look at ways to overcome these limitations in the following chapters, but for now, let’s learn how
to create a few low-poly models of our own.
Creating a low-poly barrel
Every discipline comes with a few conventions for beginners. If you are learning a new programming
language, writing “Hello World” to the screen is a classic example. Learning how to use 3D modeling
software is no different. For example, a barrel, a potion bottle, or a donut can be started with basic
shapes you are familiar with, such as a cylinder, a cone, or a torus, respectively.
In this section, you’ll learn how to design a barrel but, first, here are a few useful shortcuts that will
help you navigate around and accomplish the tasks we’ll cover in this section:
• Rotate: Middle mouse button + drag mouse
• Zoom: Scroll mouse wheel forward/backward
• Move: Shift + Drag Mouse
Creating a low-poly barrel 9
Blender is rich with so many shortcuts and it’s possible to change them to your liking once you gain
more experience. Speaking of shortcuts, this book only lists Windows shortcuts. However, when you
see the Ctrl key mentioned, it’s the Command key in macOS.
When you launch Blender for the first time, you’ll be presented with some options. One important
option is to decide which mouse button to use to select objects. Historically, the right mouse button
was the default, but you may find this uncommon. If you dismissed that initial screen, and you are
not happy with the mouse button assignment for the select operation, you can still change it by going
to the Edit menu and selecting Blender Preferences. In the Keymap section, expand the Preferences
section, as shown in the following screenshot; you’ll be able to change a bunch of settings, including
Select with Mouse Button:
Figure 1.4 – The Preferences window of Blender
Speaking of the select button, whichever side you choose, the other side will be reserved for moving
the 3D cursor to a new position. A 3D cursor is a visual marker you place in the world. When you add
new elements to your scene at a particular location, or things need to align to a certain point, the 3D
cursor will be that point. We’ll most likely keep the 3D cursor where it is for most exercises, but keep
in mind that if the left click is for selection, then the right click is for the 3D cursor, and vice versa.
10 Creating Low-Poly Models
Official manual
Since this book is about game development, we’ll focus on a small and relevant portion of
Blender. However, sometimes, looking at the official manual might be a good idea, especially
for shortcuts. The Blender website has a decent user manual: https://docs.blender.
org/manual/en/2.93/.
Modeling is a multi-step process. It involves starting with the basics and adding more details as you
go. The following is what we’ll do to design a barrel:
• Start with a primitive
• Edit the model
• Shape the body
• Separate the lid
• Finish the body
• Place metal rings
• Finalize the lid
The list is merely an example workflow that highlights useful parts of Blender. When you gain more
experience and find a different order to accomplish what you have in mind, you can work in whatever
way works for you. However, you are likely to start with primitives.
Starting with a primitive
A new scene in Blender comes with a cube, a camera, and a light source. Since we are going to create
a barrel that is more like a cylinder, we should get rid of that cube:
1. Select the cube and press X on your keyboard to delete it.
2. Trigger the Add menu to the left of the Object menu.
3. Select Cylinder under the Mesh group.
The shortcut for adding new objects is Shift + A, which will bring up the same list of options. If you
feel like deleting the other default objects, feel free to do so since you can always add them later using
the Add menu. The following screenshot shows where you can find it:
Creating a low-poly barrel 11
Figure 1.5 – You can add many types of primitives to your scene
Once you add the cylinder to your scene, you’ll see that the cylinder comes with a lot of side faces; 32
to be exact. For a low-poly barrel, that’s a lot of faces that could be cut down by half and you would
still have a decent-looking barrel.
When you add a new object, a panel will appear at the bottom left of the screen. The title of this panel
will reflect what you are currently trying to accomplish. In this case, it should display Add Cylinder.
If it looks closed, click the title and it’ll expand to show the properties you can alter for your cylinder.
The default options are all fine except for the number of vertices. However, this is also a good chance
to play with the values and see the changes reflect instantly. While you are doing all this, that panel
may disappear if you click away from your cylinder. To bring it back, click Adjust Last Operation
under the Edit menu. When you feel like you’ve got the hang of editing a new object’s properties, you
can set the relevant values, as shown in the following screenshot:
Figure 1.6 – 16 faces will be enough for creating our barrel
12 Creating Low-Poly Models
Adding a primitive such as a cylinder has introduced a new object to your scene. You’ve changed its
basic properties, such as the number of vertices. That number defines how many points are used to
make up the top and bottom circles, as shown in the preceding screenshot. This was all done at the
object level; hence, you’ve been working in Object Mode. Now, it’s time to dive deeper and edit the
finer details of this cylinder.
Editing the model
It may seem like every time you change the value of something, you are editing the model. However,
from Blender’s perspective, not all edits are the same. When you start with primitives, there are higherlevel operations you can perform such as changing the number of vertices that define the general shape
of the primitive. This is what you have seen and done so far – you’ve been editing objects.
When you want to have more control over the vertices, faces, and edges that make up the object, you
should switch to another mode that allows you to work with these properties so that you can have
much more refined control over the shape of the model.
Mac shortcuts
You can always use menus, buttons, and other interface elements to do your work, but you’ll
eventually depend on shortcuts. If the shortcuts that have been mentioned so far don’t work
for you, then you may want to check out Blender’s manual to find the right combination for
your platform: https://docs.blender.org/manual/en/2.93/interface/
keymap/introduction.html.
Select the barrel and press Tab. This will turn on Edit Mode. If you keep pressing the Tab key, you'll
go back and forth between Object Mode and Edit Mode. You’ll also see that Blender’s UI is either
hiding some of the buttons and menus or revealing some new ones, depending on which mode is
active. This means some options are only available in a certain mode. If you are wondering where that
thing you just saw disappeared, make sure you are in the right mode.
Then, in Edit Mode, press Ctrl + R to trigger Loop Cut and Slide. This is a context-sensitive operation,
so if you see nothing happening, it’s because the mouse is not over a face for this tool to operate. Hover
your mouse over different parts of the cylinder. You’ll see a yellow line going all the way around; the
direction of the line depends on where your cursor is on that face. While still over one of the side
faces, trigger your mouse wheel up twice to increase the number of cuts to 3. This is a preview of the
loop cuts, but they are not part of the cylinder yet.
A loop cut will require two mouse clicks, regardless of how many loops you would like to have. With
the first click, you are telling Blender that you want to introduce some cuts; in this case, 3. The second
click will finalize the position of these cuts, but you can change it by moving your mouse up and down
along the side of the barrel. So, in between the first and the second click, you have some freedom to
position the cuts. The following screenshot shows what we are after:
Creating a low-poly barrel 13
Figure 1.7 – Adding more edges with precise values
If you accidentally moved your cursor in between two clicks, which would have moved the baseline
of the cuts, do not worry. Once the edges have been added, the operation’s details will be displayed
so that you can fine-tune where the cuts appear in your model. The important part is to set Factor to
0 so that you have the perfect cut in the middle. If you made a last moment change before you made
the cuts, you can also adjust the number of cuts.
The main reason why you switched to Edit Mode is to have more control over the shape of your
objects. While still in Edit Mode, you’ll now learn how to use those loop cuts to give your object the
shape of a barrel.
Shaping the body
A barrel is such a generic concept. However, we have not discussed what kind of barrel we will be
working on. Technically, we are not too far off from an oil barrel since they usually look cylindrical
and have two rounded-off ridges. Then, there are plastic barrels that you see in gardens for collecting
rain. These tend to have a plain side with the top and bottom slightly tapered in or with the middle
section slightly bulging out, depending on which way you look at it.
We’ll go for a more classic one: a wooden barrel. Since we have the basic shape, we can now start
adding more details to our barrel. Two things come to mind easily. Most barrels have a few metal rings
– in the middle, near the bottom, and at the top – for enduring the stress of what they are holding.
Also, the lid is rarely flush with the side but more likely inset, so maybe we should treat that top part
separately. Let’s start tackling all these one at a time.
Are your 3D objects looking flat?
It’d be nice to have some life in all that gray! If the default look for 3D objects feels too flat and
you’d rather see the edges emphasized like you see them in pictures, here is a trick. There is a
button with a down-looking icon at the top-right corner of the 3D Viewport. If you click that
button and expand the Viewport Shading panel, you can switch Lighting to MatCap, and
turn on both the Shadow and Cavity options in the panel. Selecting Both for the Cavity type
may also be a good option. Investigate different values as you see fit so that you have an easier
time working with your models.
14 Creating Low-Poly Models
Our barrel needs a belly. We need to make those loops we have just introduced wider to create a classic
shape for the barrel. With those three edges still selected, hit S, type 1.1, and press Enter to scale it
up by 10%. As usual, the last operation’s fine-tuning settings will be shown if you would like to adjust
your values after finishing the action. Now, we only need to make the middle ring slightly larger.
Although we have been in Edit Mode so far, we have not investigated what you can edit. In the top-left
corner of 3D Viewport next to the Edit Mode dropdown, you’ll see Vertex, Edge, and Face icons from
left to right. These buttons have 1, 2, and 3 as shortcuts, respectively.
Switch to Edge edit mode by pressing the middle icon or 2. To create the belly for the barrel, you need
to select and scale up all the edges that make up the middle ring, but you probably don’t want to do
that for each edge one by one. Thus, we need to look at how to select an edge loop.
There are two ways to select an edge loop. The first method uses a keyboard shortcut:
1. Hold the Alt key.
2. Click one of the edges.
This should select all the edges that are connected to the one you’ve just clicked, as shown in the
following screenshot:
Figure 1.8 – Selecting all the edges that make a loop is easy
The second way is as follows:
1. Select one edge.
2. Go to the Select menu.
3. Expand Select Loops and choose Edge Loops.
Creating a low-poly barrel 15
Whichever way you do this, after you select the middle edge loop, you must do the following:
1. Scale it by pressing S.
2. Type 1.05.
3. Hit Enter.
This should result in a classic barrel shape.
However, the top face still belongs to the cylinder. Although conceptually, a lid might be considered
an essential part of a barrel, from an editing perspective, it must be treated as a separate object. Let’s
learn how to separate parts to edit them individually.
Separating the lid
To create the lid, first, make sure you are still in Edit Mode. Switch to face select mode by clicking the
third icon next to the Edit Mode dropdown or by pressing 3. Then, do the following:
1. Select the top face.
2. Press P.
3. Choose Selection.
This will separate the top face and make it a separate object.
Alternatively, you can expand the Separate group under the Mesh menu. The following screenshot
shows where you can find this option if you are doing the separation with the menus:
Figure 1.9 – Separating things is sometimes necessary and, in fact, helpful
16 Creating Low-Poly Models
Shortcuts
At this point, you must have noticed that Blender uses a lot of shortcuts. It might be difficult to
learn and remember all these at the beginning. If you have a rough idea about what you’d like
to do with the meshes, vertices, edges, and such, you should check out the appropriate menus
near the top to see what operations are available. Pressing a shortcut key will show you just
the relevant part of those menus, but investigating those menus and looking at the shortcut
might be a good exercise.
For example, the P key is used to separate things, but there are three types of separation, so
you’ll still have to make a final decision on the type. However, using the shortcut still takes a
shorter time than expanding the menus.
Now might be a good time to introduce you to Outliner in the top-right corner. The following
screenshot shows all the objects that exist in your scene right now:
Figure 1.10 – The lid and the body should be two separate objects
You can ignore the Camera and Light objects if you kept them in your scene since we’ll discover what
those two do later in this book. Over time, when you create more objects, you’ll want to label your
objects so that you can easily find them in Outliner.
Let’s try it now. Double-click the label for Cylinder in Outliner and type Body. Do the same thing
for Cylinder.001 and mark it as Lid. You’ll also notice that clicking labels in Outliner will select the
objects in 3D Viewport and vice versa. Finally, hit that eye icon to hide the lid for now. We’ll finalize
the lid once we deal with the body.
Creating a low-poly barrel 17
Finishing the body
What would you say is wrong or missing from the body? It looks paper-thin, doesn’t it? If only there
was a way to stretch each face out or in, and fill in the gaps so it looks solid! So far, you’ve been selecting
edges and faces. You can follow a similar workflow to select some faces, duplicate them, and move them
around to give thickness to the body. This is tempting, but let’s find an easy way to solidify the body.
For this, you need to enable the Modifiers panel. A modifier is a tool that offers a non-destructive way
to change your objects. You’ll get to read about a few of them in the Automating with modifiers section.
There is a wrench icon on the right-hand side near 3D Viewport that is going to let you add modifiers.
Here are the steps you must take to give substance to the barrel’s body:
1. Switch to Object Mode.
2. Select the Body object.
3. Open the Modifiers panel.
4. Choose Solidify from the Add Modifier dropdown.
Modifiers change objects, so even if you are in Edit Mode, working with a modifier will look as if
you are in Object Mode for the object you are editing. You’ll discover some of the modifiers in that
dropdown list later in this chapter. For now, the following screenshot shows what the Solidify modifier
is doing. Most things in Blender come with a lot of values to tweak, but you only need to change the
Thickness value in the Solidify options for the time being:
Figure 1.11 – Our barrel is starting to look more solid
How much Thickness is enough? 0.03 m or 0.04 m might be a good value. You could pick an
industry-standard thickness or choose a value that looks visually appealing. Depending on the type
of game you are working on or whether you are creating assets for a client, you can pick what works
best for the asset.
18 Creating Low-Poly Models
A discussion about units
Most of the world is using the metric system these days. However, if either because it’s the
default option or a matter of preference, you may have Imperial units set up in your Blender
copy. Throughout this book, the Metric system will be utilized. You can find Units as a panel
inside the fifth tab from the top on the right-hand side. This tab contains an icon with a cone,
a sphere, and what looks like a dot.
Modifiers are very helpful, but you need to get your hands dirty sometimes. This means that there
is a limit to what modifiers can do for you. For example, we now need to put metal rings around the
body. There is no modifier to do this for you. Nevertheless, we can still take advantage of modifiers
as we go. But, first, let’s create some metal rings.
Placing metal rings
The barrel now has some substance, but it’s missing metal rings. Creating another cylinder and sizing
it up so that it looks like a ring is too much work and requires precision. There is a simpler method
that takes advantage of the barrel’s geometry. You’ll be using familiar methods you’ve already seen:
loop cuts, loop selection, and separation.
While in Edit Mode, create a loop cut between the bottom and the first edge loop of the body. For
the other loop cut, you’ll be creating the cut in between the top edges and the loop right below it. In
the end, you’ll be creating two loop cuts, as shown in the following screenshot
Figure 1.12 – Two separate cuts from both ends approaching the middle section
Creating a low-poly barrel 19
You’ve already seen how to select an edge loop: it involved holding the Alt key and clicking an edge.
You’ll do something very similar except it’ll be for selecting a face loop. For this, make sure the face
icon is clicked in Edit Mode. Alternatively, while in Edit Mode, you can press 3.
When you hold the Alt key and click an edge, you’ll be selecting the faces that are adjacent to that edge
you’ve just clicked. It’ll also keep selecting the other faces that are in a similar direction to complete
a loop. Try it a few times with horizontal and vertical edges to see how the loops’ direction changes
accordingly.
What you must do is select all the faces that make up the two rings that are close to the top and bottom
of the barrel. The following screenshot shows which faces should be selected so that you can separate
them to form the metal rings:
Figure 1.13 – You’ve got to have something selected so that you can separate it
Once you select the first loop, you can hold down Shift and repeat the previous operation to keep
adding more loops to your selection.
Now, you are ready to separate those faces. Hit P to bring up the Separate options and choose Selection.
Now, you can rename the newly created Ring object. If you go back to Object Mode, you’ll see that
you can select each object individually. Select the ring; you’ll see that the Solidify modifier still exists
for this new object too. Isn’t that handy?
20 Creating Low-Poly Models
The thickness value in the modifier is the same, but what would happen if we changed the sign of
that value? If you click the Thickness field, it will let you type in a value. Adjust it so it shows -0.04
m. As you can see, it’s still the same thickness, but in the other direction – it looks like we have those
metal rings around the body of our barrel finally!
Now, let’s learn how to add another ring for the middle section. You can follow similar steps to create
two more loops, one above and one below the center loop. However, you can do better.
Select the middle edges by conducting an edge loop operation and then triggering the Offset Edge
Slide option under the Edge menu or pressing Shift + Ctrl + R. This is very similar to Loop Cut and
Slide but it has two major differences. First, this operation will consider an edge as its baseline and
move the new edges off in opposite directions. Second, you need to click just once when you are happy
with where the new edges will sit. Choosing 0.1 for the Factor value in the operation’s properties might
be a good number if you’re having sensitivity issues with your mouse.
We’ll follow a similar procedure: select and separate. In face edit mode, you will use a combination
of Alt + Shift by clicking one of the vertical edges sandwiched between your new loops. After you
separate the middle faces, you’ll be left with an important decision: should you rename your new
object and invert the direction of thickness in its modifier just like you did for the upper and lower
rings? In essence, you want your new object to join its fellows. That’s exactly what you’ll do next but
with a clever trick without repeating yourself.
Which mode?
During the modeling process, there are times when you’ll need to edit parts of your model. In
this case, being in Edit Mode will be necessary. However, when you separate chunks from your
models, you’ll most likely want to go back to Object Mode to do something with this new object.
So, going back and forth between these two modes will be necessary and feel natural after a while.
In Object Mode, first, you must select the middle ring you have just created. You don’t need to rename
it; you’ll see why shortly. You must add one more object to your selection by holding Shift and clicking
the ring in 3D Viewport. Make sure your last click is on the ring object you created a while ago. The
order of clicks matters at this point. The last object you interact with will be considered as the active
object by Blender. It will be marked with a yellow outline compared to orange outlined objects, which
are part of the selection but not considered active objects.
Once you have your rings selected in the correct order, you must join them by pressing Ctrl + J. Did
you notice what just happened? Let’s break it down:
• You can no longer see Body.001 in the Outliner
• The Ring object has accepted Body.001 into the fellowship
• The Ring object’s Solidify modifier has been applied to Body.001
There are no longer separate pieces since all those separate parts are now considered as one object,
as shown in the following screenshot:
Creating a low-poly barrel 21
Figure 1.14 – One ring to join them all
As you get more confident in Blender, you’ll find that you can follow different methods to achieve the
same result. There is no right or wrong way, but rather time-saving habits, and you’ll develop your own
since every designer has their preferred way of doing things. Sometimes, there are other concerns,
technical or artistic, that will limit your workflow. However, as a beginner, you should observe how
other artists are creating similar objects. Luckily, there are plenty of examples out there, so learn,
experiment, and divert as you go.
Earlier, you had to separate the lid. After that, you made changes to the body and even added rings.
Now, it’s time to put a lid on your barrel.
Finalizing the lid
If you hid the lid once you separated it, you can click the eye icon in Outliner to turn it on. You need
to do a basic scale operation to put the lid in its place. To achieve this, first, select the lid, and then
do the following:
1. Press S.
2. Type in 0.96.
3. Press Enter.
22 Creating Low-Poly Models
Why such a precise value? Because we’ve been using 0.04 m in the Solidify modifier. So, we should
reduce the scale of the lid by 4%. This will save us from the trouble of lining up all the edges of the lid
so that they are flush with the inner side of the barrel. If you have been using a different value in your
modifier, you’ve got to compensate your scale value in this step so that both add up to 1 in the end.
You’ve done it! With the lid in the right place and looking just below the rim level, the barrel is complete.
Check out the following screenshot and compare it to your creation:
Figure 1.15 – A wooden – rather gray – barrel in its glory
If you decide to create this barrel from scratch again, perhaps you can place the upper ring close to
the lid, and the lower ring at the bottom. Placing five rings is also a possibility, but you may want to
adjust the height of each ring in case the composition looks busy.
So far, you have used one modifier, and it has served you well. Let’s dive into more modifiers and see
how powerful they can be.
Automating with modifiers
A modifier is a non-destructive way of applying an operation to change an object’s geometry. This is
often preferred when you don’t want to take repetitive steps or the operation is complex enough that
you don’t want to directly alter the object’s geometry.
Automating with modifiers 23
When you applied the Solidify modifier, you must have seen that there are so many other modifiers.
Could you imagine what you can do with each one? How about you use a few modifiers in a row?
Yes, you read that right. You can stack up many modifiers and create complex shapes with little effort.
However, there is an important detail you must pay attention to – their order matters! New modifiers
are always added at the bottom, and they work in conjunction with the previous modifiers in the stack.
Thus, the effect is compounding. If you logically stack your modifiers, you could create something
as complex as what’s shown in the following screenshot with only a few primitive objects in no time:
Figure 1.16 – Modifiers help you create something this complex easily
This object is using primitives such as cylinders and cubes, but the result looks interesting. This is
thanks to a hefty list of modifiers and the order that they’ve been used. Some of the modifiers have
been applied multiple times with different values, but here is a list:
• Subdivision
• Decimate
• Boolean
• Bevel
• Mirror
• Weighted Normal
24 Creating Low-Poly Models
At the time of writing, Blender has over 50 modifiers. Describing each would fill a book. Most likely,
you’ll stick with the modifiers that are in the Generate category. Here is a set of modifiers you’ll use
most of the time:
• Boolean: This is one of those modifiers that is used a lot and it comes in three sub-modes:
 Difference: Subtracts the value of one object from another
 Union: Will combine both objects
 Intersect: Will only keep what’s common in both meshes
• Bevel: Sometimes, you want to have more detail, especially along sharp edges so that they
don’t look too harsh – the more surface there is for the light sources to reflect on, the more
realistic it’ll look to the eye. This modifier will also work on vertices if you want to soften those
sharp corners.
• Array: This makes copies of the object it’s assigned to in different axes, with or without some
offset if you wish. You could have a fixed number of copies or fill a particular length with as
many copies as you can fit in that distance.
• Mirror: This is like the Array modifier except it creates one copy along the axis you select. You
can pick multiple axes. Thus, it’s possible to start with only a quarter of the object and mirror it
on the X and Y axis so that you have one whole object. This allows you to keep your changes to
a minimum in the original quarter so that you can mirror your changes to the rest of the mesh.
When you add your modifiers, it’s sometimes not obvious which order you should stack them in.
Luckily, it’s possible to change their order or temporarily disable them by using the buttons that are
part of the modifier’s header.
While creating rings for the barrel, you could have used a different technique to achieve the same
result: extrusion. This would require you to select what needs to be extruded – in this case, all the
faces that make up the ring – and extrude along each face’s outward-facing direction. Extrusion, in
essence, is a technical term for moving vertices, faces, or edges.
Modifiers have a big advantage compared to classic methods such as pushing and pulling vertices
and faces around. Wouldn’t it be convenient to come back later and fine-tune your changes further?
If you happen to select the lid now and come back to the Body object, the modifier will still be there.
You won’t have this kind of flexibility with permanent mesh modifying techniques such as extrusion.
Summary 25
Summary
In this chapter, you learned about the benefits of low-poly modeling. Then, you created a wooden
barrel from a primitive cylinder and incorporated modifiers. Although textures may give a more
realistic look to your models, you also know you can do without them.
As an exercise, feel free to create a potion bottle. You can start with a cylinder, just like you did for
the barrel. The loop cuts and the scaling down values will be different to give it a conical shape. This
is your chance to practice modifiers. A finished potion bottle is waiting for you in this book’s GitHub
repository if you want to see a finished example and compare yours.
Several shortcuts are commonly used by many professionals during the modeling process. Here is a
list you’ve used so far:
• Shift + A: Add an object
• Tab: Switch between Edit Mode and Object Mode
• Ctrl + R: Introduce loop cuts
• Ctrl + J: Join
• S: Scale
• P: Separate
In the next chapter, you’ll learn how to apply materials to your models so that parts of your model
can still have a different look and feel without textures.
Further reading
The section’s title suggests reading sources, but sometimes seeing is even better. Just as a picture is
worth a thousand words, a video might be worth a thousand pictures. So, here is a list of URLs for
video content that might be useful for all levels of Blender practitioners:
• https://www.youtube.com/c/JoshGambrell
• https://www.youtube.com/c/CurtisHolt
• https://www.youtube.com/c/GrantAbbitt
• https://www.youtube.com/c/SouthernShotty

2
Building Materials and Shaders
According to Wikipedia, a material is a substance, or a mixture of substances, that constitutes an object.
This definition for real-life objects also stands true for the models you create electronically with some
extra technical details. Let’s look at the definition of a material in our context.
In Blender, materials are essentially containers that hold a bunch of numbers, colors, and textures,
besides other useful stuff, and most importantly the shader itself. A shader is a piece of code that
tells the rendering engine, either Blender’s or Godot Engine’s, what to do with a material’s properties.
In essence, a material is like a box full of little items, and it comes with a user manual (the shader) so
that the software you work with knows what to do with those little items.
You now know the raw definition of what materials and shaders are, but what are they used for?
The barrel you created in the previous chapter had metal rings and wooden slats that gave it its form.
However, everything in that model looked rather gray. Adding materials to your models will enhance
their form by showing colors and other properties you are familiar with from real life.
In this chapter, you’ll learn how to make your models look more real by applying materials. To that
end, we will cover the following topics:
• Introducing materials
• Creating materials
• Assigning materials
• Discovering shaders
By the end of this chapter, you’ll know how to create and assign different materials, and understand
where shaders come into play during this process.
28 Building Materials and Shaders
Technical requirements
Although this chapter is about materials, you’ll need at least one 3D model. This can be your finished
work from Chapter 1, Creating Low-Poly Models. Alternatively, you can use the barrel model that
comes in the Start folder of the Chapter 2 folder in this book’s GitHub repository: https://
github.com/PacktPublishing/Game-Development-with-Blender-and-Godot.
Introducing materials
As we mentioned in the introduction, materials are assigned to objects. However, you can’t assign
materials to all objects. When you start up a new Blender file, it comes with a cube, a camera, and a
light object. Only one of these objects has substance from Blender’s perspective, and that’s the cube.
Let’s break this down a bit more to understand why it matters. Although a camera and a light source
have physical properties and they occupy space in real life, this isn’t the case in Blender. They are
conceptual objects.
A camera is a tool through which you see the world. So, you don’t get to see the visual properties of
the camera itself. It doesn’t matter if the camera is painted red or blue. Similarly, a light source shines
a bright or dim light, sometimes with a certain color, but it doesn’t take up space in a Blender scene.
Therefore, if there is no substance, we can’t apply a material to these two objects.
If only there was an easier way to know which objects can receive materials…
If you select each of the default objects one after another, you’ll see that some icons are popping in and
out of the view on the right-hand side of the screen. Different sets of options, represented by icons, are
stacked in the Properties panel. This panel will display the relevant properties of the selected objects.
When you select the cube, you’ll notice that the Properties panel introduces a lot of icons, different
than the ones for a camera or a light object. Either hover over the icons to see their title or simply click
the icons to take a quick look at what’s at your disposal. While doing that, you’ll eventually discover
the second-last icon, which should turn on the Materials panel (if you need to remember it later, it’s
the icon that looks like a sphere with a checkerboard pattern).
You haven’t created a material yet. However, Blender starts with a default cube, which comes with a
default material. Let’s learn how to change its color. After selecting the cube, follow these steps:
1. Open the Materials tab in the Properties panel.
2. Click the colored rectangle on the right-hand side of Base Color.
3. Pick a different color from the color wheel.
The following screenshot will help you find all this. Once you have chosen a color, the change will not
apply to the cube at first; you’ll find out why soon:
Introducing materials 29
Figure 2.1 – Color is one of many things you can change for a material
While selecting a color, the color wheel will help you out. However, if you want to be more precise with
the color you are selecting, the three buttons (RGB, HSV, and Hex) under the color wheel can help
you. In the preceding screenshot, a value of E77EB6 was used in Hex mode. All these color modes
act like units, but the result will always be the same color when you switch between different modes.
Panels and settings
Working in Blender doesn’t always mean you have to directly modify the geometry (vertices,
edges, and faces) of your models; you will often find yourself looking for settings and altering
them in many panels. Later in this book, when you work with objects such as camera and light,
you’ll use the appropriate panels so that you can tweak the settings for these objects.
Let’s figure out why the last change you made didn’t reflect on the screen. By default, Blender shows
models as solid objects. Sometimes, just like an X-ray may help a doctor understand what’s going on, you
will need to see your model differently. The following are four different ways you can see your objects:
• Solid: The default option; you’ve been using this all along. It simply shows your model as a
solid object.
30 Building Materials and Shaders
• Material Preview: You will mainly see the color you applied to the object, but you will also see
some of the other properties you have applied.
• Wireframe: The object will look like a metal wire has been bent and welded to create a frame that
defines the model. Since this mode only renders edges and vertices, it is useful when you want
to visualize polygons and detect overloaded areas so that you can easily optimize the models.
• Rendered: This is a more accurate view than Material Preview because it uses the rendering
engine of Blender to create the most accurate representation. It does this by considering the
lights and shadows in your scene. Naturally, it uses more GPU, so you’ll most likely work with
other view options most of the time.
The previous list shows all the options you have for Viewport Shading. The default view, Solid, is
fast but not accurate when you want to work with materials. Now that you’ve changed the properties
of your material, you must be in Material Preview to see it in effect. To switch to it, press Z and then
2. Alternatively, after you press Z, you can select the appropriate option with your mouse, as shown
in the following screenshot:
Figure 2.2 – Different Viewport Shading options presented in a radial menu
Creating materials 31
Now that you have a basic understanding of what materials are, we’ll go back to the barrel from
Chapter 1, Creating Low-Poly Models, and create materials for it.
Creating materials
So far, you’ve been editing the default Blender material, but creating new ones is easy enough. We’ll need
at least one object that has some substance. You can either continue with the barrel you’ve designed
or open the file in the Start folder in the Chapter 2 folder of this book’s GitHub repository. If
you go with your own file, you’ll most likely have the default material, labeled as Material, still in the
Material panel. Using the minus (-) button, you can remove that and start fresh. The aforementioned
file in this book’s GitHub repository has already removed this default material for you.
It might be tempting to click the plus (+) button right above that minus (-) button you may have just
clicked. Go ahead and do it. You’ll end up with an empty line appearing in the material list. Those two
buttons simply add and remove material slots to/from the objects, but not the materials themselves.
Once you have a slot ready, you can designate a material for that slot. We’ll investigate slots and different
materials as we move forward, but let’s create our first material by following these steps:
1. Select the body of the barrel.
2. Press the New button in the Material panel.
3. Change Base Color to a brown color.
4. Rename your new material Wood after double-clicking its title.
The following screenshot should help you compare your results with what’s expected to happen. While
selecting a color, you can hit the Hex button (shown in Figure 2.1) and type in AD8654 so that your
barrel is the same color as the one shown here:
32 Building Materials and Shaders
Figure 2.3 – The body of the barrel looks more wooden
Now, let’s create another material – this time, a metallic one. But where did that New button go? In
this situation, when the New button is missing, you can do the following:
1. Click the button with the plus (+) sign.
2. Press the New button.
3. Rename your new material Steel.
4. Pick an appropriate color for it, such as 555E64.
So, this time, you have introduced a new slot and filled it with a new material. It would seem the Body
object now has two materials and only one of them is in effect. Furthermore, we don’t need that steel
material for the body part of our model anyway. So, we should remove it. While the Steel material is
selected, press the button with the minus (-) sign to remove it from the body.
Although you have created a new material and removed it, this doesn’t mean it was all a waste. The
material is still part of your Blender file but has been left unassigned. We’ll make use of it soon. This
means that you have used the Material panel like a workbench. Now, let’s learn how to assign existing
materials to objects.
Assigning materials
If you have your materials at the ready, then you can assign them to different objects easily. This saves
you from creating the same materials repeatedly. We’ll see how this is done in this section.
The Ring object has not been assigned any material, but you can assign the Steel material to it. Start
by selecting the Ring object, then expand the drop-down menu next to the New button, as shown in
Assigning materials 33
the following screenshot. Select the Steel material from the list. This will assign the selected material
to the object:
Figure 2.4 – Existing materials are listed in this drop-down menu
It’s a good idea to name your materials according to their function, such as Wood and Steel, as it will
be easier to find them later. You will also see that the color of the material is shown as a small icon
next to the material’s name; this helps to a certain extent, but it’s limiting if you have many materials
with similar colors.
The lid might use the same wood material but, maybe, we can change things up a bit. After selecting
the Lid object, do the following:
1. Assign the Wood material.
2. Click the New Material button (it looks like two sheets of paper).
3. Rename Wood.001 to Dark Wood.
4. Choose a darker color, such as 7E623D.
You have just created a copy of the original Wood material for the Lid object. If you expand the
materials list, you’ll see all the available materials. Feel free to add, remove, duplicate, and/or assign
as many materials as you wish for practice.
Additionally, you can assign materials not only to the whole object but also parts of that object. If
you select some faces in Edit mode, then you can also apply a material to those selected faces only.
In essence, the Material panel lists the materials associated with your model, regardless of whether
it’s applied to the whole model or parts of it.
34 Building Materials and Shaders
Things must look a bit more colorful at this point. However, despite all your efforts, you can only go
so far by just changing colors. The metal rings still don’t look metallic enough. They should look more
reflective, so we are missing something here. We need to discover new ways to give extra qualities to
the base color. That’s what shaders are for and that’s what we’ll tackle next.
Discovering shaders
Shaders were defined as two things at the beginning of this chapter: a piece of code and a user manual.
Have you felt like you’ve been writing code so far? Most likely, no.
Nevertheless, behind that Material user interface, there is a code layer, which is the shader. For
example, the default shader you’ve been using so far has hundreds of lines of code. The following is
only a portion of the code that makes that shader:
metallic = saturate(metallic);
transmission = saturate(transmission);
float diffuse_weight = (1.0 - transmission) * (1.0 -
 metallic);
transmission *= (1.0 - metallic);
float specular_weight = (1.0 - transmission);
clearcoat = max(clearcoat, 0.0);
transmission_roughness = 1.0 - (1.0 - roughness) * (1.0 -
 transmission_roughness);
specular = max(0.0, specular);
Luckily for you, you don’t have to write a single line of code. More importantly, Blender interprets the
shader code so that it can offer UI elements such as color pickers to select colors, sliders to define a
range of values, and drop-down menus that come with more advanced options so that you can utilize
the shader easily.
The “user manual” aspect of shaders regards which properties of the material will be exposed to
the user. For example, color is an obvious setting we should be able to change. The shader code will
expose color and some of the other properties of a material to the outside world so that you can use
the material easily. This is very similar to the way you use any device. You usually interact with a
device via an interface by clicking buttons and turning some dials. A combination of these actions
triggers certain events internally, which are not revealed to you, but you get to experience the result
of these operations.
Going back to the original definition, you work with materials via a shader. These two go hand in hand.
Moreover, just as Blender introduces a default material, it also comes with a default shader assigned
to this material. It’s called Principled BSDF. You can see this name next to the Surface section of the
material’s details. If you click Principled BSDF (Principled from now on, for simplicity’s sake) in the
Discovering shaders 35
interface, you’ll see a list of other shaders. Selecting a different shader from that list will associate a
different shader with your material. Some of the other shaders in that list are as follows:
• Diffuse BSDF: A basic shader that is responsible for displaying color on a surface. When
objects are supposed to have a simple color – in other words, diffuse a certain color – this is
the right shader to use.
• Emission: If you are designing an object and you want it to act like a light source, such as a
fluorescent light, you can use this shader so that it looks like it’s glowing.
• Glass BSDF: A shader with which you can simulate a glass surface. It comes with an Index of
Refraction (IOR) setting so that you can decide how transmissive the glass is since there are
different types of glass out there.
• Glossy BSDF: This is used to add reflection, which is great for simulating metals or mirrors.
• Toon BSDF: When you need the surfaces and edges to have a cartoony effect.
When you want your objects to show different qualities, then you will want some of the simple shaders
to work together. For example, in a lot of science-fiction movies that show advanced machines and
such, it is common to see glowing force fields that are also transparent. If you use Glass BSDF only,
you’ll see through but without a glow. If you use Emission, there will be no see-through visibility.
So, the Principled shader is the best combination of commonly used shaders. It acts like an uber
shader that employs properties of different shaders under one roof. For that reason, at this point, it’s
best to stick with the default shader.
BSDF
You’ll notice that some shaders come with this abbreviation. BSDF is a technical term and stands
for bidirectional scattering distribution function. It is composed of BRDF and BTDF, which
are responsible for reflecting and transmitting the light, respectively. Altogether, this system
is responsible for how realistic the light will interact with your object. In layman’s terms, it
calculates how much of the light is soaked by the material, and how much of it will be reflected
by considering intensity, angle, and so on.
Now, let’s learn how to make modifications to the Steel material for our barrel. Unfortunately, there
isn’t just one setting you can turn on to give a surface a metallic look. It turns out that not all metals
are created equal. Some metal surfaces look more reflective or shiny, while some look rougher, and
so on. We’ll use a mixture of the following properties with different values to get the result we want:
• Metallic
• Specular
• Roughness
36 Building Materials and Shaders
The dictionary definitions of these words might be good enough. That being said, in the context of
Blender, those three properties work in tandem to create different metal surfaces. Therefore, you
need to balance the intensity for each, similar to working with a recipe sometimes. When you are
changing these values, to see the effect, you need to be in Rendered mode. You can switch to it by
pressing Z and then 8.
Shader values
The numerical values you change for a shader don’t have units but act more like a percentage
or intensity. 0 means you want none of it. 1 means full scale. So, 0.5 means 50%.
Let’s analyze the results shown in the following screenshot. A default Blender material comes with
0, 0.5, and 0.5 as values for Metallic, Specular, and Roughness, respectively. So, the sphere in the
top-left corner has values very close to a default Blender material. This means that, by default, your
models will have some shine and roughness:
Figure 2.5 – The same spheres with the same color but with
different metallic, specular, and roughness values
Discovering shaders 37
In the top-right corner, you can see that only the metallic value has been increased. Even though the
specular value is the same, we get to see more light being reflected. This makes sense because metal
surfaces reflect more light. So, a surface that has more metallic qualities should reflect more light.
This is exactly the case for the bottom-left model.
Finally, the sphere at the bottom right is what happens when we have a fully metal surface with an
amplified roughness value. Notice how the shine is distributed more evenly on the sphere’s surface
because it’s rougher. When light hits a rough surface, all the nooks and crannies of the surface will reflect
much of the light in many different directions. When the surface is less rough or more polished, the
light will directly bounce back into your eyes – in this case, Blender’s camera. Hence, it will look shiny.
By the way, in all these cases, the base color is still the same, but the final look sure does feel different.
The user manual page for the Principled shader contains a few charts that depict how some of this
shader’s settings interact with each other. It’s similar to what’s shown in the preceding screenshot but
it comes with a lot more cases: https://docs.blender.org/manual/en/latest/
render/shader_nodes/shader/principled.html.
The following screenshot shows the difference between two materials that both use the same base color:
Figure 2.6 – As expected, the metal rings are reflecting some of the light
The barrel on the left uses the default metallic, specular, and roughness values Blender provides. The
barrel on the right has a material with 1.0, 0.5, and 0.2 set for its Metallic, Specular, and Roughness
values, respectively. In summary, chances are you’ll have to play with all three properties to get the
metal look you want.
38 Building Materials and Shaders
Non-metallic objects
Playing around with these three properties is also true for non-metallic cases, such as bricks,
liquids, grass, and more. Let’s compare a brick and a liquid, for example. Both can have the
same base color – that is, blood red or some other tone. A brick is not a reflective object, so
it should have very low – perhaps 0 – metallic and specular values. Most likely, its roughness
value will be high. On the other hand, the liquid will need to be less rough and have a higher
specular value.
Playing with the properties of a shader can be fun but it can also feel like you don’t know what you
are doing half the time. There is nothing wrong with experimenting to achieve the look you want.
If you want to feel more confident about what you’re doing, you can start observing objects around
you. This may give you a better insight into choosing the properties that will give the result you’ve
imagined. The property names are helpful in that sense, but they rarely work alone, so mix-and-match
is necessary, even for professionals.
We’ll investigate materials and shaders again when we cover Godot Engine, but here, you’ve seen how
they work in Blender. Let’s summarize what we have learned so far.
Summary
Throughout this chapter, you learned how materials can be used to give objects a different look. To
create materials, you used the Material panel as a workbench to prepare many materials at once, and
later assign these materials to different objects.
Shaders are almost inseparable from materials, and you got a glimpse of how many options they come
with. You also saw that you can pick different shaders for your materials. However, most of the time,
Blender’s default shader, Principled BSDF, will be enough.
Using the default shader, you created a few materials that have different qualities, such as wood and
steel. Furthermore, you discovered ways to create different-looking metal surfaces by utilizing metallic,
specular, and roughness properties with varying intensities.
There is another topic that is usually covered alongside materials and shaders: textures. It was
intentionally omitted, but it’ll be covered in the next chapter with an explanation of why. For now, all
that matters is that textures are graphic files that may enhance a material’s visual impact. When you
are ready, turn to the next chapter so that you can get to know them better.
Further reading 39
Further reading
Blender’s official documentation provides a detailed enough explanation of how different shaders and
their properties work. The following URL lists many shaders you can investigate: https://docs.
blender.org/manual/en/latest/render/shader_nodes/shader/.
Sometimes, seeing more examples may help you in your creation process. BlenderKit is a useful
Blender add-on that you can use to access a whole bunch of materials and a lot more, such as models
and scenes. Visit https://www.blenderkit.com/ to read the installation instructions.
Since this book is about game development, we are only covering the basics of Blender in the context
of helping us build a game with low-poly models. This means we are also limiting the level of detail
that’s employed while creating materials for the game. However, many professionals use Blender for
different reasons, such as to create marketing material, product visualization, animation, and more.
So, should you want to dig deeper into creating materials in a different workflow, here are some of
the many great online courses out there:
• https://cgcookie.com/course/fundamentals-of-blender-materialsand-shading
• https://www.udemy.com/course/become-a-material-guru-inblender-cycles/
• https://studio.blender.org/training/procedural-shading/

3
Adding and Creating Textures
In a typical 3D workflow, one of the most common properties you would add to a material is texture.
A texture is an image file that is responsible for the textured look of a model so surfaces don’t show
just flat colors. Although objects you come across in real life have a perceived color, they also have a
characteristic look that is defined by this property in 3D applications. For example, both a flower and
a sandy surface may have a yellow color, but you know a flower’s petal would look smoother, whereas
grains of sand would look gritty.
Most day-to-day objects have wear and tear. Look around and you’ll see that most surfaces will either
have chipped paint, a slight deformation, or some scratches. Imagine the barrel you designed in the
first two chapters has been in use for some time. It’d naturally have a few scratches on the metal rings.
You can only go so far by applying colors to your materials and altering the roughness values. If you
want to achieve a more realistic look, you’ve got to apply textures to your models.
Some 3D professionals only focus and gain expertise on certain domains. Texturing is one of these
domains besides modeling, lighting, and animation. Typically, a texturing specialist will employ the
help of classic image editing applications such as Adobe Photoshop, GIMP, and so on to create textures.
Then, the artist will bring these textures into Blender so that they can be applied to surfaces. If you
are not skilled in creating textures from scratch, you will learn in this chapter how you can still rely
on existing textures out there created by other artists.
Preparing and using textures with the aforementioned workflow often sounds static because you need
access to the source file of these textures. Luckily, there is a dynamic way to create your own textures
within Blender, so you don’t have to go back and forth between Blender and other software.
This is not a “one is better than the other” situation because each method has its own place and merits.
You’ll get to know new parts of Blender to facilitate both methods so you can make an informed decision
about which texturing method to use. To that end, we are going to cover the following list of topics:
• Understanding UVs and texture coordinates
• Using the UV Editor
42 Adding and Creating Textures
• Importing and applying a texture
• Creating textures procedurally
• Exporting your textures
By the end of this chapter, you’ll have learned how to prepare your models for texturing, apply available
textures, and create your own textures dynamically. The practice you’ll gain in this chapter will give
you insight into choosing the right method of texturing for your projects.
Technical requirements
This book’s GitHub repo (https://github.com/PacktPublishing/Game-Developmentwith-Blender-and-Godot) will have a Chapter 3 folder with Start and Finish folders
in it for you to compare your work with as you go. These folders also contain other dependencies such
as the texture files necessary to follow and complete the exercises.
Although you worked on a barrel in the previous chapters, we’ll only use the standard Blender objects,
such as a cube and a plane, to keep things simple so you can focus on the texturing workflow.
Understanding UVs and texture coordinates
While you are modeling, you are altering the coordinates of the vertices of a model. Thus, you are
working with spatial coordinates. To apply a texture over your model, you need to work in a different
kind of coordinate system that is called texture coordinates or UVs. Let’s see how these two terms
relate to each other.
The spatial coordinate system is often described with the XYZ acronym since we often use X, Y, and
Z axes to define the position of 3D objects. Similarly, UV is another acronym but it is used in the
texturing workflow; the letters U and V were picked to describe the texture coordinate system. So,
UV doesn’t really stand for ultraviolet.
The process that maps UV coordinates to XYZ coordinates is called UV unwrapping. Via this
method, you tell Blender how a graphic file is mapped to XYZ coordinates. If unwrapping sounds
counterintuitive, you could try to reverse the process in your mind. What kind of texture would you
need so that if you wrapped it around your 3D model, it would fit perfectly? Let’s analyze the following
figure where a graphic file that is painted with a checkerboard texture is applied to a standard cube:
Using the UV Editor 43
Figure 3.1 – A 2D checkerboard texture wrapping a 3D object
In Figure 3.1, you see a cube with a checkerboard texture on the left. In the middle part, you see the
cube as if gift wrap is being peeled off. Finally, the cube is fully unwrapped on the right side; its texture
is laid flat. The texture file is actually all of the checkerboard parts, and it exists as a 2D graphic file.
The reason we are using words such as unwrapping and 2D graphic files is because we are simulating
a real-life 3D object on a flat screen. In reality, that cube would occupy a space, have a volume, and it
would be full of the material it was made of. For example, a cube that might be a child’s toy made of
wood. Or, it might be a six-sided die, most likely made of acrylic. If you cut into it, you’d see the material.
To change the nature of the problem from a 3D volume problem to a 2D graphics problem, you
need a new tool. You’ve been working with Blender’s default interface, which is conveniently set up
to edit XYZ coordinates. For editing UVs, you need the UV Editor, which you will discover in the
following section.
Using the UV Editor
Blender comes with preset workspaces so you can focus on a particular workflow. So far, you’ve been
in the Layout workspace. You can see it as the active tab just under the header of the application, next
to the Help menu. You should create a new file and switch to the UV Editing workspace by clicking
the appropriate tab. Figure 3.2 is what you’ll see when you are in the UV Editing workspace.
44 Adding and Creating Textures
Figure 3.2 – UV Editing is one of many default workspaces in Blender
In the UV Editing workspace, the application will mainly be divided into two sections: the left side,
which is called UV Editor, shows a bunch of squares laid out on a flat surface, and the right side
shows the default cube. The black dots you see in UV Editor are actually the vertices of the cube in
3D Viewport. You might notice that if you counted the dots in UV Editor, they don’t add up to the
number of vertices the cube has. There are more points in UV Editor because some of those points
will eventually merge once those squares in UV Editor are folded around the edges and wrapped
around your 3D object.
At this point, all of the vertices of the cube should be selected for you by Blender. However, if you
happen to select a vertex of the cube, you’ll see that the squares in UV Editor will disappear. That’s
because we haven’t turned on the sync mode yet. At the top-left corner of UV Editor, you’ll see a
button with an icon that looks like two diagonal arrows going in opposite directions. If you have that
button pressed, you’ll notice that selecting the vertices in either view will synchronize.
When you add a new cube, Blender unwraps that cube by default. The general layout of the vertices in
UV Editor resembles a T shape, like what you saw in Figure 3.1. Similar to 3D Viewport, the vertices
in UV Editor will form edges and faces, but it’s all 2D in UV Editor. As mentioned earlier, we have
converted the 3D-ness of the model to a 2D representation so we can work with graphics files.
Importing and applying a texture 45
UV Editor is where you can see how the points in the editor map or correlate to a texture file. To do
that, we need to bring a texture file as follows:
1. Open the Chapter 3 folder.
2. Open the Start folder.
3. Drag and drop pips.png into the UV Editor area.
If you open that PNG file in your computer’s default image viewing application, you’ll notice that it
has transparent parts. Its dimensions of 1024x1024 are not fully painted. It just happens that the file’s
non-transparent areas come right under the faces in UV Editor, therefore the faces in 3D Viewport.
Powers of two
Sooner or later, you’ll notice that most texture files come in certain standard dimensions such
as 512, 1024, 2048, and so on. Although these files don’t have to be square, which means you
could actually have 256x512 as dimensions, it’d still pay off to keep either dimension in powers
of two. This is due to algorithms that are employed by GPUs so that they run more efficiently.
So far, we have taken advantage of Blender’s default UV layout for a cube and have seen how UV
faces can overlap with the texture file we have been previewing in UV Editor. However, if you enable
Material Preview in 3D Viewport, you won’t see the die texture applied to the cube. That’s because
we haven’t yet told Blender to use the die texture in the material assigned to the cube. Let’s do that
in the following section.
Importing and applying a texture
When you've dragged the texture file into UV Editor, you have effectively imported it, but, in reality,
the material for the cube doesn’t know how to use that texture yet. That being said, the material has
all of the information it needs to map 3D vertices to 2D texture coordinates thanks to UV Editor. It
just needs to be told which texture to apply to the cube.
To accomplish this, we’ll switch to a new workspace so we can connect textures with materials. Also,
we’ll import another texture using a different method and assign it to the cube’s material to showcase
how you can use the same UV information with different texture files.
Just like when you switched to the UV Editing workspace, it’s now time to switch to a different workspace
for convenience. The sixth workspace, labeled as Shading, is the one you are looking for. We’ll do our
work in the lower half of the new workspace, which looks like a grid; it’s called the Shader Editor.
The upper part is still the same old 3D Viewport, but Material Preview is automatically turned on
so you can see your changes reflect immediately. So, the Shading workspace should look similar to
what you see in Figure 3.3.
46 Adding and Creating Textures
Figure 3.3 – Shading is one of many convenient workspaces set up for you
As you discovered in Chapter 2, Building Materials and Shaders, Blender files come with a default
material. We’ll modify that default material to understand the texture workflow. The Shader Editor
area is already populated with two entities that make up the material as follows:
• Principled BSDF (Principled in short form)
• Material Output
These are called nodes. The node on the left, Principled, holds the properties you already saw in the
previous chapter. A lot of these properties have little circles on the left side. These circles, which are
called sockets, can connect to other nodes’ sockets. We don’t have enough nodes to create meaningful
connections yet but we will soon.
Speaking of connectivity, Principled has an output that is connected to the Material Output node. If
you hold your mouse down on the Surface input of Material Output and drag the connection away,
you’ll eventually break the connection between those two nodes. Then, the cube will look black since
there is no surface information. Try to reconnect those nodes by dragging the BSDF output to the
Surface input. The default gray color will be reestablished.
Importing and applying a texture 47
Nodes vs code
In the previous chapter, you were told that shaders are lines of code that instruct the GPU
what to display. When you use nodes in Shader Editor, you are actually writing code, but
you are coding visually. As the order of lines is important in conventional programming, the
nodes and the connections coming in and out of the nodes are also important. However, visual
programming is easier to conceptualize.
When we were modeling the barrel in Chapter 1, Creating Low-Poly Models, we needed to add 3D
objects to the scene. We did that by pressing Shift + A. We’ll do something similar. In this case, we’ll add
new nodes to Shader Editor. Blender is context-sensitive, which means the same shortcuts will yield
similar results if your mouse is over different workspaces, areas, and interfaces. If you press Shift + A
over Shader Editor, you’ll see a list come up and show entities that are relevant to Shader Editor.
When this pop-up menu opens, it’s positioned exactly so that the mouse cursor is right over the Search
button. To add a texture node, perform the following steps:
1. Click Search in the Add menu.
2. Type Image with your keyboard.
3. Select Image Texture in the filtered results.
4. Click anywhere near the other nodes.
This will introduce an Image Texture node to Shader Editor, just as you see in the following figure:
Figure 3.4 – An Image Texture node in Shader Editor
48 Adding and Creating Textures
You have already imported the pips.png file when you were working with UV Editor, so there is
no need to import that file again. We’ll just recall it. As usual, the button to the left of the New button
in the Image Texture node will bring up a list; select pips.png from that list. Then, attach the Color
output of Image Texture to the Base Color input of Principled. This will apply the texture to the
cube’s faces. Voilà, the default cube now looks like a six-sided die as seen in Figure 3.5:
Figure 3.5 – The texture file is applied to the model via its material
A six-sided die has pips, usually marked with a variable number of circles on each side. What if you
wanted to have a different looking six-sided die, with the numbers represented by Roman numerals?
To import and apply a new texture, perform the following steps:
1. Create a new Image Texture node with the help of Shift+A.
2. Click the Open button.
3. Select roman.png in this chapter’s Start folder.
4. Connect this Image Texture node's Color to the Principled node’s Base Color.
Since the texture coordinates are already mapped in UV Editor, you can easily swap textures that
have similar shapes with different designs.
When you work with more complex models, you’ve got more work to do in adjusting the UVs; as long
as the UV coordinates are aligned with the right parts of the texture, you’re good. However, imagine a
different scenario. How would you go about modeling surfaces that look like they are showing a repeating
pattern with slight deviations? In the following section, we’ll look into a different texture workflow.
Creating textures procedurally 49
Creating textures procedurally
The word “procedural” has been used a lot in recent years, especially in the video game industry,
to describe different things. Although one might say everything we have done so far is following a
certain procedure, the word means something else in our context. When we imported the texture file
in the preceding section, it was already designed for us. In other terms, it was a static file. The word
“procedural,” on the other hand, is a fancy word that means dynamic.
In a dynamic or procedural texturing workflow, the goal is to expose certain parameters of the texture
so that the texture can be changed on the fly, instead of going back to a graphic editing application.
Since it’s all dynamic, you won’t have to import graphic files, and you’ll be able to change aspects of
the final texture. For example, if the six-sided die was using a procedural texture, it’d be like changing
the color and/or the size of the pips.
Procedural textures have another benefit besides their dynamism. Static texture files would need you to
do the prior UV work so that the vertices would be aligned with the parts of the texture. In a procedural
workflow, the pattern in the texture might be seamless, so you don’t need to worry about the UVs.
Seamless, in our context, means that the pattern repeats in a perfect way to wrap around the model.
We’ll create a procedural lava texture as you see in Figure 3.6 in Blender so you can change its parameters
to have a different looking texture.
Figure 3.6 – Hot lava flowing through solidified crust
50 Adding and Creating Textures
In a new Blender scene, after deleting the default cube, perform the following steps:
1. Add a Plane.
2. Switch to the Shading workspace.
3. Bring up the default Material or create a new one.
4. Rename the material if you desire.
Nothing new or exciting so far, but we’ll utilize the following five new nodes very soon:
 Noise Texture: Perlin noise is a mix of black and white values that are mixed together in
a gradual way, so the result looks like a soup of grayscale values. Blender’s noise texture is
similar to Perlin, but the values are not grayscale; they come with random colors.
 Bump: It is used to simulate height fluctuations so surfaces could look bumpy.
 Color Ramp: Another name for this node would have been color mapper, but since it’s using
a gradient, the word “ramp” implies that the transition is smooth.
 Emission: Under normal light, hot objects have a glowing effect. This shader would help
you simulate a hot piece of steel coming out of an oven or a bright lightbulb.
 Mix Shader: It’s a shader that mixes two shaders to create a combined shader.
Before we move on to how to mix and match the preceding list of nodes, which kind of look
like a recipe’s ingredients, here is a little bit of explanation as to why they were chosen. When
you want to create your own procedural textures, a similar process might help you pick the
nodes that are helpful instead of making wild guesses about which nodes to select. Also, after
the explanation, try to imagine which one will connect to which. So, here we go.
Noise Texture is quite literally a texture that comes with some noise; the color variation in this
noise texture is used in the Bump node to simulate different heights. So, Noise Texture is like
the data and the Bump node is its visual representation in a sense. Then comes Color Ramp,
shown as ColorRamp, which assigns color information to different height values. If you've
ever seen a miniature landscape, it’s like painting hilltops white because of snow and the lower
areas with different shades of green depending on the elevation.
Hence, the first three nodes are taking care of most of the work for simulating elevation. Let’s
assume this lava texture is portraying a recent formation, so we are not after just displaying
cooled-down lava. We would like to see steaming hot, glowing lava in between the blackened
and dried-out lava. So, we’ll need an Emission shader for that. Finally, since the elevation is
its own thing and we are adding the emission part, we’ll need Mix Shader to combine both.
While working with nodes, you can drag and drop the nodes to arrange a cleaner layout for
yourself to make sense of what’s going on. Without further ado, let’s continue.
5. Add the aforementioned five nodes.
Creating textures procedurally 51
6. Connect as follows:
 Noise Texture’s Color to Bump’s Height
 Noise Texture’s Fac to ColorRamp’s Fac
 Bump’s Normal to Principled BSDF’s Normal
 ColorRamp’s Color to Mix Shader’s Fac
 Principled BSDF’s BSDF to Mix Shader’s first input Shader
 Emission Shader’s Emission to Mix Shader’s second input Shader
 Mix Shader’s Shader output to Material Output’s Surface
There is no left or right direction when it comes to connecting nodes. Some people consider a group
of nodes as a unit and arrange them close to each other. So, sometimes, the last output node from that
group connects almost vertically to another group of nodes. That being said, having a general flow of
left to right would fit the preceding instructions. Whichever way you arrange your nodes, the layout
might resemble what you see in Figure 3.7.
Figure 3.7 – Lava texture’s node arrangement
Let’s look at the values these nodes will have by following the original order of the node list as much
as possible.
52 Adding and Creating Textures
Noise Texture
For Noise Texture, the following values were used:
• Type defines the dimensions that are used in the creation of the noise, which involves complex
operations. It’s used in more advanced cases, so we’ll leave the default 3D value.
• The Scale property works more like a zoom factor. Too low, and you are closer to the noisy
surface. Too high, and you are seeing a larger portion of the noisy landscape as if you are
climbing up in an airplane. In this case, we set Scale to 3.0.
• The Detail property is self-explanatory. Although having a lower value will certainly result in
a muddy look, having a higher number beyond a certain value won’t add much to the quality.
It will simply increase the calculation time. A value of 8.0 is chosen in our case.
• Roughness is not the same concept you saw in Chapter 2, Building Materials and Shaders. That
one affected the reflective properties of a surface. This one is about how rough the edges are,
in a sense. In other words, how roughly the noise values are blending into each other, and a
value of 0.5 is enough.
• The Distortion property creates swirls and wavy patterns. Perhaps a little might be necessary
for a flowing lava look. You could experiment with it, but beyond a certain value when there is
too much distortion, things will look too fragmented. So, 0.2 is good enough.
Bump
This node will use the data provided by Noise Texture so it can represent different color values as
different height values. This is why the Height input was connected to the Color output since there
can’t be just one height value for the whole surface, so we had to feed it a set of colors.
Leaving the Invert setting unchecked, the following are the other values used:
• The Strength value determines the effect of the mapping between color values and the final
bumps. It works like a percentage since the values can be anywhere between 0.0 and 1.0. We’ll
leave it at 1.0.
• The Distance property is a multiplier of some sort. It works in conjunction with the Strength
property. Setting either one of them to 0 will result in a totally flat surface. Perhaps the best
way to describe this property is that it keeps the details set in Noise Texture. Any value closer
to 1.0 will show a washed-out surface, whereas higher values will fill in more details. Thus, a
value of 3.0 will yield a detailed enough result.
Creating textures procedurally 53
Emission
This is a very simple node and it’s responsible for making surfaces look glowing. We’ll discover lights
in Chapter 4, Adjusting Cameras and Lights, but if you want your objects to act like they are emitting
or radiating light, then you can use this node. Examples might be a piece of hot iron or fluorescent
lightbulbs; in our case, lava.
Since this is such a simple node, we have only the following two properties:
• The self-explanatory Color property is for picking which color the surface will emit. For hot
lava, you can switch to the Hex values on the interface and choose FF8400.
• The Strength value, which is 100.0 in our case, defines the intensity of the emission. This is a
unit measured in Watts so you can be scientific about it, but picking arbitrary values for visual
fidelity works most of the time too.
ColorRamp
The ColorRamp node is used for mapping input values to colors with the help of a gradient that
works like a threshold. The description is deceptively simple, but there is a lot going on under the
hood. So, let’s unpack it.
Most of the time, you’ll be connecting both the input and output sockets of a node to other nodes.
However, there are times when it is totally acceptable to use only one type of socket. For example, in
the Emission shader, you didn’t have to use the input sockets to define the Color and Strength values.
Instead, you handpicked their values. So, the node acts like a source of information.
Then, there are some nodes where it makes much more sense to connect the input socket to another
node’s output socket. ColorRamp is one of those nodes, and it works like a modifier by factoring in
incoming values. Noise Texture’s data will be a factor (Fac for short) in creating a lava surface, so we
connect the two Fac sockets.
Once the data is factored in, we need a system to process it. This is done via the gradient in the
ColorRamp node. The concept of a gradient might sound weird at first. If you were to connect the
Color of Noise Texture directly to Material Output, you’d see that there are smaller and larger zones
of colors. If you do that, remember to undo it so that the nodes are connected correctly once again.
We need a way to turn these flat but colored zones to elevation.
The gradient is going to help us define which zones are higher or lower so we can assign the appropriate
color to different elevations later. In essence, the gradient is a tool to define and blend in those zones
with the help of color stops. By default, there are two color stops, but you can use the plus and minus
buttons above the gradient to add and remove more color stops. These stops have a square shape
with a little triangle right above them. It is possible to drag these stops, which will change the zone
transitions we mentioned earlier.
54 Adding and Creating Textures
When you have a lot of stops, it’s sometimes difficult to click and drag them, so use active color stop
to step between them. When you add a fresh ColorRamp node, the active stop is marked as 0 and it
is to the left of the label that says Pos, which indicates the position of the active stop. Both the active
stop and the position fields show necessary UI elements for you to change the values once you hover;
also, you can click and enter a value. So, by using the active color stop and Pos, you can mark exactly
where the color stops are going to be if you don’t want to drag them around.
Last but not least, there is a color picker right above the Fac socket. You can use that to set the color
for the active stop.
Since this is not a straightforward node, we could benefit from some visual aid. Figure 3.8 is a zoomed-in
look at the ColorRamp node.
Figure 3.8 – A close-up look at the ColorRamp node
The preceding figure should help you see what we have talked about so far. Also, just like you are able
to zoom in and out with your mouse’s scroll functionality in the 3D view, you can do so in Shader
Editor. It will help you see some of the properties’ names and values more clearly.
Now, it’s time to use all of this information and mark our transitions; you’ll be interacting with all of
the elements just presented. To that end, perform the following steps:
1. Use the plus/minus buttons to have four color stops.
2. Set active color stop to 0, then do as follows:
I. Set Pos to 0.45.
II. Set color in the Hex mode to 000000.
Creating textures procedurally 55
3. Set active color stop to 1, then do as follows:
I. Set Pos to 0.53.
II. Set color in the Hex mode to FFFFFF.
4. Set active color stop to 2, then do as follows:
I. Set Pos to 0.94.
II. Set color in the Hex mode to FFFFFF.
5. Set active color stop to 3, then do as follows:
I. Set Pos to 1.00.
II. Set color in the Hex mode to 636363.
Notice that we are only picking grayscale values. In a real landscape, higher areas will be cooler lava,
and the lower areas will be hot pools of lava. So, to represent that idea, we are picking dark and white
colors. Usually, the whiter something is, the hotter it is. The proximity of the stops to each other
determines how smooth or sharp the transitions are.
Although we have been working with the ColorRamp node, the colors for our lava texture will be
defined in the Principled BSDF and Emission shaders and will be combined in Mix Shader. For the
time being, we have utilized the data from Noise Texture and transformed that data with the help
of a gradient and its carefully chosen values. We’ll revisit the factor concept again in the Mix Shader
section, but before that, let’s visit our trusty friend Principled BSDF.
Principled BSDF
We actually saw this node in Chapter 2, Building Materials and Shaders, but it was displayed as part
of the Material Properties interface. When you create a new material, it uses this shader by default.
It combines a great deal of other shaders in its body. For example, it has an emission socket, but
since we can’t do both the hot and cool part of the lava formation in one go, we are using a separate
Emission shader.
We’ll leave most options unchanged, but the following are the non-default values chosen for this exercise:
• Base Color is for picking the perceived color, such as green for grass and brown for dirt. You
can set 4A4A4A as the value in the Hex section of the color interface.
• The Specular property defines the reflectivity of the surfaces. Since dried lava is not a reflective
surface, we’ll pick a small value such as 0.2.
• Roughness is for specifying how rough the surface will be. Although it sounds like a simple
property, it’s functioning in conjunction with Base Color and Specular values. So, picking an
intuitive value is not always easy. You’d expect the dry lava to be rough, hence having a high
roughness value, but we’ll pick 0.2 in this exercise.
56 Adding and Creating Textures
You can refer to Figure 2.5 in Chapter 2, Building Materials and Shaders, and read the explanation
in the Discovering Shaders section for a refresher in understanding how multiple properties work
together and affect the final look.
Mix Shader
It blends one shader into another determined by the value in Factor. For the Factor socket’s value, if
you pick 0.0, the first shader will be used entirely. If you choose 1.0, it means that the second shader
will be utilized.
The range of decimal values is between 0 and 1 but it’s hard to know what to choose since we can’t
just arbitrarily determine how much of which shader to use. This is why we connected the Color
output from ColorRamp as a factor so that the fluctuation in Noise Texture would trickle down and
affect this node. The effect is cascading. In other words, every single pixel that’s going to be painted
either dark (for dried lava) or orange (for hot lava) should be decided based on where ColorRamp
thinks it belongs in Noise Texture. Thus, the color stops act like thresholds and this is all factored
in, in Mix Shader.
Once all of the nodes have been set and attached, feel free to play with the values in all of them,
especially ColorRamp. You’ll notice that the hot lava parts are sort of cooler at the shore, and denser
and brighter in the middle. Try to approach the color stops close to each other and see how these hot
zones in the lava pools change.
Creating this kind of texture using conventional image editing applications such as Adobe Photoshop
might have been possible, but those applications are layer-based and it’s not always easy to keep things
non-destructive. The power you have with a node-based approach is quick iterations. One thing for
sure is you don’t have to reimport your texture to see the changes. It’s all happening live in front of
your eyes.
However, at the end of the day, since you are developing a game, you’ll have to export your texture
so the game engine of your choice can use it. In the following and final section, we’ll see how we can
export our lava texture to the file system.
Exporting your textures
In later chapters, when we get close to working with Godot Engine, we’ll look into asset and project
management in more detail. However, after all the hard work we have done with the lava material,
it’s now time to learn how to export the texture.
We’ll do a few interesting but necessary things in this section to export our texture. First, we’ll change
Blender’s rendering engine. Then, we’ll add an Image Texture node in the middle of our material
without connecting it to anything. Weird, right? Blender works mysteriously sometimes.
Exporting your textures 57
Changing the rendering engine
We have been using the default Eevee rendering engine so far. Eevee is a real-time rendering engine
that gives you really fast results. Most game engines have their own internal real-time rendering
engines that are responsible for calculating lights and shadows. So, Eevee is a good way to simulate in
Blender what you’ll most likely experience when you export your assets to a game engine. However,
the speed and convenience come with a few penalties.
Blender has another engine that is called Cycles. Cycles is a very accurate but slow rendering engine
compared to Eevee. Cycles’ accuracy is due to the fact that it tackles advanced lighting calculations,
which leads to quality results such as showing reflective and transparent surfaces much better, displaying
more accurate shadows, and even creating volumetric effects such as haze and fog. The following is a
link to an article that demonstrates both engines’ capabilities and differences with use cases: https://
cgcookie.com/articles/blender-cycles-vs-eevee-15-limitations-ofreal-time-rendering.
In this book, we are not covering advanced enough topics that would require us to make a hard
decision between Eevee and Cycles. So, Eevee has been fine for our purposes. However, when you
work with procedural textures, there is no way, at least with the version of Blender we’re using, for
Eevee to export the lava texture. We’ll have to switch to the Cycles engine. Luckily, it’s done just with
the click of a button.
In the Properties panel on the right, the second tab from the top, which looks like the preview display
of a DSLR camera, is going to open Render Properties. The drop-down list at the top will show Eevee;
let’s change that to Cycles. Also, if you have a decent graphics card, you might want to change the
third dropdown, Device, value to GPU compute so that your graphic card can do the heavy lifting
instead of your good old CPU.
Looking down in that long list of properties, you’ll see a panel with the header Bake. If you expand
the header, you’ll see a Bake button. We’ll click that button soon, but we need to prepare what we’ll
bake first.
Baking a texture File
When we worked with the cube and die textures, we used an Image Texture node to bind an existing
image from the file system. Our situation is different when the texture is procedural since this has
been happening live in the memory. We need to figure out a way to bake this information into a file.
Since there is no such file, we need to pretend that we have one, as follows:
1. Add an Image Texture node.
2. Click the New button.
3. Type lava in the name section.
4. Click the OK button.
58 Adding and Creating Textures
We won’t be connecting Image Texture to anything. If you remember the definition of what a material
is from the early sentences in Chapter 2, Building Materials and Shaders, this new image we have just
labeled as lava will be packaged with the material. Blender will make an educated guess and will
bake the procedural texture parts into this image.
Now is the time to hit that Bake button in Render Properties. A progress bar at the bottom will
indicate that Blender is doing its thing. Once the process is finished, the bottom-left corner of the
Shading workspace will fill with the lava texture. That little section that displays the baked texture is
called Image Editor.
If you look at the baked image, you’ll notice that some details are lost. The pool of hot lava has warmer
and cooler spots in 3D Viewport, but the baked image has lost all of those details. This is because
the Emission strength is so high that it saturates the baked image. It’s like how digital cameras show
poor-quality images when the scene is over-exposed with light. To alleviate this problem, you can
bake again after setting the Emission node’s Strength to 1.0.
In the Image Editor interface, there is a button that has three stacked horizontal lines in it. If you click
that button, you’ll see a menu with two items: View and Image. If you expand the Image option, you
can click Save As to save lava.png in your file system. This file can now be imported into a new
Blender file and used in an Image Texture node. Then, you can apply this image in a material to a
Plane object just like you applied the pips.png to a cube.
Mission accomplished. If you chose the same values as those written in this chapter, you should have
the procedural lava texture you see in Figure 3.6. Additionally, you have created a static version of it.
Let’s summarize what else has been accomplished in this chapter.
Summary
This chapter started off with a brief discussion about what textures are and why they might be needed.
To recap, if you are fine with models that have just the color info on their surface, you are done as soon
as the modeling and material application process is finished. If you think you need to show distinctive
qualities on your models’ surfaces, you need to utilize textures.
To that end, you discovered how a new coordinate system—one that involves mapping spatial
coordinates to texture coordinates via a method called UV unwrapping—might be necessary. Once
the UV unwrapping is done, you can apply and swap different textures to your 3D models since the
mapping from 2D to 3D is established.
Although creating textures with image editing applications is quite possible, you also know how to
create textures procedurally in Blender. This is a powerful method, especially when it comes to surfaces
that are hard to UV unwrap, such as landscapes.
Last but not least, you learned how to change the rendering engine to be able to export your procedural
texture to your file system. Although this file is static and can no longer be updated automatically
(unless you overwrite it with a new export, of course), you have the benefit of sharing the file easily.
Further reading 59
You’ve been using Blender’s interface and your mouse to move around the scene and rotate the view
to have a better look at your models, materials, and so on. In the following chapter, you’ll learn how
to work with Camera and Light objects to create a composition where you can arrange objects in your
scene under the best light conditions possible.
Further reading
To read more about what each shader node does, you can refer to the official documentation at the
following link: https://docs.blender.org/manual/en/2.93/render/shader_nodes/.
For further practice, imagine where else the method for the lava texture could be used. Perhaps,
with carefully planned values and more color variations, the hot lava might be rust, and the cool lava
might be paint?
If you are curious and would like to investigate different software out there capable of producing
procedural textures, you can give Adobe Substance Designer a try. It’s a powerful program dedicated
solely to creating textures. Not all of the nodes are labeled the same, but there are a lot of similar nodes
to Blender’s. In fact, if you practice your skills there and look at other people’s creations, you might
gain insight into creating such textures in Blender.

4
Adjusting Cameras and Lights
When you start a new scene, there are default camera and light objects in the Outliner. Although
they are part of the scene, when you are modeling a new object, rotating around it, and looking at a
material preview of it, you are still using Blender’s internal camera and lighting system. This default
behavior is good for working fast but doesn’t produce artistic and accurate results.
In this chapter, you’ll learn what a camera does and how to employ lights to get the look you want.
The premise is simple: you can’t see anything without a light, and you can’t record or capture anything
if you have no apparatus to do so.
Although it sounds like we are covering two distinct topics, we’ll talk about both cameras and lights
in this chapter. Between the two, we’ll prioritize lights over cameras; you’ll be provided with an
explanation of why.
Thus, just like in real life, a camera and light conditions work together, and they go a long way to get
the best shot you want. To that end, we will cover the following topics:
• Rendering a scene
• Understanding light types
• Introducing MatCap and Ambient Occlusion
After reading this chapter, you’ll know how to pick the correct light type and capture a shot of your
scene. You’ll also know why you may want to postpone setting up cameras and lights. However, we’ll
offer you a way to attain some semblance of visual fidelity.
Technical requirements
We’ll be entering new territory in this chapter, so it will be safer for you to rely on the files in this book’s
GitHub repository: https://github.com/PacktPublishing/Game-Developmentwith-Blender-and-Godot.
62 Adjusting Cameras and Lights
The appropriate filename will be mentioned when it’s relevant. These files have already been set up
for you so that you can focus on the material in this chapter.
Rendering a scene
In the computing world, the word render is similar to its other meanings in a dictionary. The rendering
process in Blender will take a raw scene and produce a refined result. In more advanced cases, where
your scene may have a physics or a particle object, this process will be responsible for calculating
the state of these dynamic objects too. However, for brevity, we’ll only look at what role the camera
and light objects play in renders.
Let’s create our first render by doing the following:
1. Start a new Blender scene.
2. Press F12.
Alternatively, you can use the Render menu near the application’s title at the top. This should give
you the following output:
Figure 4.1 – Your first render of a default cube with Blender’s default camera and light options
Rendering a scene 63
This is nothing exciting perhaps since this is pretty much the look you are used to seeing while working
within Blender. The render is displayed in a separate window that covers the Blender window you
were just working on. Therefore, you can close this window by pressing the operating system’s close
button or by pressing Esc to return to Blender.
If you take more renders and go back and forth, you’ll notice that the grid underneath the cube and
other objects, such as the camera and light, are no longer part of the render. This is expected. These
objects, called gizmos, will facilitate things for you but won’t be with you at the end of the journey.
They work like scaffolding during the construction of a building. Although they are helpful while
doing the work, they are taken away after the job is finished.
Let’s repeat the previous exercise by changing one thing. What would happen if there were no cameras
in the scene? Time to experiment:
1. Right-click Camera in the Outliner.
2. Delete this Camera object.
3. Press F12.
Did you expect to see a pitch-black render? Instead, you got an error stating that no camera was found
in the scene. No camera means there isn’t any instrument to render your scene, so Blender displays
an error message.
Let’s run a similar experiment by removing the Light object. After starting a new Blender scene,
follow these steps:
1. Right-click Light in the Outliner.
2. Delete this Light object.
3. Press F12.
Let’s speculate about what we expect to see. We have a camera to render the scene but no lights. Even
though the cube object is part of the scene, we should not be able to see it. And yet, if you look at the
following render, you will see a silhouette of the cube:
64 Adjusting Cameras and Lights
Figure 4.2 – An unexpected render when there are no lights in the scene
Most software applications come with default settings for the sake of helping out the user. In this case,
Blender comes with a background color that contributes, unfortunately, to the result in the previous
render. If you were to change the color of this setting to black, for example, then you’d have a completely
black render. To achieve that, follow these steps:
1. Switch to the Shading workspace, as you did in Chapter 3, Adding and Creating Textures.
2. Switch from Object to World mode in the Shader Editor by using the dropdown near where
the four views meet.
3. Change the Background node’s Color property so that its Hex value is 000000.
The following screenshot shows the setup for changing the background color:
Figure 4.3 – We can also use the Shader Editor to change the scene’s background color
Understanding light types 65
If you take another render now, you’ll notice that it’s all black. There is neither direct nor indirect light
or color contributing to the result. So, although things are looking rather dark, this is the result we
expect to see. When would this be useful? If you would like zero surprises, which means you’d rather
control every single light source and how much they contribute, then picking a black color for the
background might be a good idea.
However, most Blender users are artists, not scientists. So, they often have multiple light sources and
adjust these objects’ settings to achieve visual fidelity, not scientific accuracy. Therefore, leaving the
background color alone might be something you’ll do as well.
Speaking of light sources and their settings, this is the right moment to segue into learning about the
different types of light Blender employs. We’ll light things up in the next section.
Understanding light types
So far, we have seen a render where the light object plays a role and another render when the light
object was missing. We haven’t discovered what this light object is. In this section, we’ll get to know
different types of lights. By the end of this section, you’ll have a good level of knowledge of each type
and why they matter.
We’ll do this discovery in the context of the Eevee render engine because it simulates what game
engines will do with your scene well. Since it’s enabled by default, you don’t need to make any changes
at this point. Hence, you first need good knowledge of lighting your scene with the basic types of light.
That’s what we are going to do next.
Types of light
Let’s look at the different types of light that are available:
• Point: This is the default light type you get when you start a new Blender scene. It’s also
called an omni light sometimes, short for omnidirectional, since it casts light in all directions.
Lightbulbs are a decent real-life example of this light. Of course, in reality, lightbulbs don’t cast
light through their base but it’s a good approximation.
• Sun: This type is used when you need a constant intensity of light. In other words, the light is
so powerful that it doesn’t lose any of its intensity along the way. Unlike the other light types,
Sun, just like the Sun, also sends light rays in one direction only. Thus, the light rays are coming
from an infinitely far away distance without losing their potency.
• Spot: When you need a flashlight-like light source, this is the light type you should use. It will
emit a cone-shaped beam of light in the direction you point it. Most shopping centers and
stores have lights of this type, usually hidden in the ceiling.
66 Adjusting Cameras and Lights
• Area: If you want to have a light source that has a large surface such as a window, TV screen,
or office lights such as conventional fluorescent tubes, then Area lights are the way to go. You
can also define the shape of the area. Since it is a considerably larger source of light in contrast
to Point lights, the result, including the shadows, feels softer.
To get a much better feeling about what each light type does, you will open a file that’s prepared for
you so that you can quickly switch between different types of light. Follow these steps:
1. Open the Start folder inside the Chapter 4 folder. This can be found in this book’s GitHub
repository, which was mentioned in the Technical requirements section.
2. Open the Lights.blend file.
3. Hold Z and then press 8 to switch the visuals to Rendered mode.
The scene contains a cube and a large plane as a base to hold this cube. The four different basic light
types are all in the same position, all with their default settings. Only the Spot light is enabled in the
Outliner and you can see its effect in the following screenshot. By clicking the eye icon next to each
light type in the Outliner back and forth accordingly, you can see what each light does. Notice the
overall feeling each light creates by illuminating a certain spot or changing how the shadows appear:
Figure 4.4 – A light object’s, specifically Spot light’s properties
Now that we have seen what each light does, let’s learn about some of their properties.
Understanding light types 67
Basic properties of light
The sample file was set up so that when you open it, the Properties panel should already be switched
to the appropriate Light tab; this will display the five common properties that all the basic lights share:
• Color: This is the tint of the emitted light. If you are designing a fireplace, you may want to
pick an orange or red tint, for example.
• Power/Strength: This defines how powerful your light source is in Watts. Thus, the higher
the value is, the more powerful the light will be. In the Sun light’s case, the Power property
is labeled as Strength, but the concept is still the same. If you are designing a scene where
accuracy is paramount, and you would like your lights to be as realistic as possible, then you
are in luck. The Power of Lights section at the following URL lists values for some known light
sources: https://docs.blender.org/manual/en/2.93/render/lights/
light_object.html.
• Diffuse: In Chapter 2, Building Materials and Shaders, you worked with materials and set the
color for the materials you applied to the barrel parts. The Diffuse property of lights works
like a multiplier. So, keeping it as 1.0, which is the default value, won’t change the perceived
color of a material. Decreasing it will diminish the color’s effect on a material. In essence, this
value determines the impact a light source has on a material’s color.
• Specular: This is similar to the Diffuse property, except it affects the Specular quality.
• Volume: This is a bit of an advanced topic that involves more sophisticated settings when you
set up materials. We won’t cover advanced material settings in this book. However, like the
Diffuse and Specular properties of lights, which work as multipliers, this property determines
the light’s contribution over a volume.
Out of these five properties, you’ll most likely never touch Diffuse, Specular, and Volume. This is
because, most of the time, it makes sense to change diffuse and specular values in a material. Also,
volumetric light is an advanced case that can be handled via other means, similar to adjusting it via
a material’s properties.
More esoteric lights
If you are the curious type and read up on lighting, generally within the context of 3D applications,
you will hear of terms such as ambient light, global illumination, and others. Even though
those terms are relevant and important when producing a render, we won’t cover them in
this book for two reasons. First, basic light types are often enough because this will give you
a more direct result and feeling for your scene. Second, the advanced lighting systems rely on
and affect basic lights by making tweaks. So, understanding the basic types would be a better
investment as a beginner.
68 Adjusting Cameras and Lights
Specific properties of each light type
Although you now have basic knowledge of what each light does, we haven’t investigated what kind
of setting contributes to the uniqueness of these lights. Now, let’s look at each light’s settings, which
give the light its characteristic look and feel.
Point
Radius is a setting that’s also used for Spot lights, but we’ll cover it under this section since there is
nothing else going on with Point lights. We’ve already considered a lightbulb as an analogy to Point
lights. In reality, lightbulbs come in different sizes. So, you can imagine the radius value, measured in
meters, as a mechanism to determine how big the lightbulb is.
The effect this value has is in the way the shadows are calculated. The default value, 0.1, will produce
a rather sharp shadow. Try to increase this value to 1.0. You’ll notice that there will be multiple
shadows overlapping each other, following a direction away from the light source.
If you increase the radius to 10.0, something interesting will happen. The bulb is large enough that
it will encompass the cube. It’s so large that it intersects with the plane too. The shadows for the cube
are no longer following a direction strictly away from the light source. The light source is so large it’s
as if there are multiple tiny point lights scattered inside a sphere with that radius value.
Sun
In some 3D modeling software and game engines, the Sun light is often labeled as directional light.
There is a good reason for that. In real life, the Sun is so far away but so powerful that it’s as if all light
rays are parallel to each other. So, the Angle property defines the direction of the rays.
What about the position of a Sun light? You could try to move its location, but the overall effect on
the scene won’t change because the light rays are assumed to have constant energy, regardless of where
they are coming from. So, the angle is the only meaningful factor for this light type.
Spot
A Spot light has the same Radius property as a Point light does. So, initially, they start as the same
thing, then a Spot light sheds its light while following a conic shape.
There is a collapsed section labeled as Spot Shape in the Properties panel for this light type. This
section houses two properties:
• Size: Measured in degrees, this value is the angle of the cone’s origin. The higher the value is,
the wider or larger the area will be once the light hits a surface. Similarly, lower values will
focus the light on a smaller area.
• Blend: Once you have defined the area of light via the Size property, you’ll have shaded areas
outside the illuminated zone. The Blend value, which will be between 0.0 and 1.0, works
like a percentage to adjust how smoothly these two contrasting zones blend into each other.
Lower values will have a sharper transition. So, having it as 0 means a very sharp separation.
Introducing MatCap and Ambient Occlusion 69
Area
For this light type to be more effective, deciding on its Shape setting is important. Four shapes exist:
• Rectangle
• Square
• Disc
• Ellipse
For all of these, you can customize the size of the shape. For example, the Rectangle shape will accept
two values, but the Square shape will only need one dimension. You won’t see much difference in the
test scene if you play with different values. However, rest assured that they make a real difference in
a much more complex scene where you distribute Area lights with different shapes.
Wrapping up
Adjusting light settings is only the beginning. Most 3D professionals dedicate themselves to certain
disciplines. Lighting is one of these disciplines where you work on topics such as global illumination,
bloom, volumetric effects, and many other advanced topics we won’t be covering in this book. With
that being said, using cameras and lights in Blender may still be useful to get a basic feeling about the
artistic direction you are taking. For example, if you are designing a car, the headlights will most likely
house a Spot light. If the model were a torch, a Point light might be appropriate.
Now, you may be thinking that we didn’t cover a lot about lighting, but we also covered even less
about the camera. This is because this book is about game development. In Part 3, Clara’s Fortune – An
Adventure Game, we mentioned that most of our work will be done in Godot, so you’ll see that there
will be many things we’ll set up and fine-tune in Godot. Some of that effort will be for the camera and
different light objects. Since we’ve been building individual models or constructing materials for our
models, which will all be imported into the game engine in the end, there is no need to do a meticulous
amount of work within Blender regarding cameras and lights. In other words, it’s practical to set up
cameras and lights in Godot because the settings in Blender won’t transfer.
Now that you know why you should generally ignore Blender’s cameras and lights, let’s look at two
helpful methods that will make your time more pleasant while still working in Blender.
Introducing MatCap and Ambient Occlusion
Since making more investment in a high-fidelity lighting setup in Blender no longer makes sense, we
should perhaps investigate different ways to make our scenes look better. What we’ll do next still means
what you see won’t be exported. However, it means you can look at models that no longer have the
default and boring gray look. Why not? Working with things that look nice sometimes feels nicer and
increases productivity. We’ll look at two techniques that will help you distinguish your models’ details.
70 Adjusting Cameras and Lights
MatCap
MatCap stands for material capture. We won’t get into the technicalities of how a MatCap is
constructed but, suffice it to say, it’s a type of shader Blender uses internally to give a different look
to the models. Normally, you’d need to switch to Material Preview mode to see how your materials
would look on your models.
However, during the modeling process, you usually work in Solid mode because it’s more performant
for Blender to show you the changes you are making to your models. Thus, while still working in Solid
mode, if you want to have a better visual as if you are in Material Preview, you can instruct Viewport
Shading to use MatCap. So, it’s the best of both worlds.
To make sure you are using Solid mode, do the following:
1. Press Z.
2. Then press 6.
This will switch Viewport Shading to Solid mode. It’s also represented as a disc in the second icon at
the top-right corner of the 3D Viewport. We’ll make some changes to Viewport Shading so that your
models can have more pronounced details. If you click the down-looking arrow on the right-hand
side of those icons, you’ll expand a panel. This panel is shown in the following screenshot:
Figure 4.5 – The default Viewport Shading options
Introducing MatCap and Ambient Occlusion 71
The settings in that panel let you change the way the models are displayed while you are editing them.
You can already see a preview of the current settings as a sphere in the upper section. Let’s click the
second button, MatCap, under the Lighting title. This should already change the look of the preview
in that panel, as well as the model’s look in the scene.
We won’t be discovering the Color part but try out the Random option for the barrel from Chapter 1,
Creating Low-Poly Models. You’ll see that different parts of the barrel take random colors. This helps to
distinguish separate parts in your scene. Similarly, we will leave the Background setting set to Theme.
Let’s investigate the Options section and focus on the parts that will give us a decent result:
1. Enable the Shadow option.
2. Set its value to 0.5.
You won’t normally see the effects of the light sources in Solid mode, but the last operation will create
a shadow effect. It’s a cheap effect that efficiently creates depth.
Sometimes, your models will have parts that are away from the center of mass. These outer parts may
also create areas that would look deeper from your point of view. Hence, you’ll have cavities. To mark
these areas more clearly, do the following:
1. Enable Cavity.
2. Set its Type value to Both.
3. Set World Space like so:
I. Ridge to 0.5
II. Valley to 1.0
4. Set Screen Space like so:
I. Ridge to 0.75
II. Valley to 1.0
This should create a big change in the way your models look. The Cavity option, with Type set to
Both, will seek parts of your models that are at different elevation levels and accentuate them. In a
way, if your model was laid out like a landscape, the ridges and valleys would be emphasized so that
they would be more noticeable. The values we picked are a bit arbitrary, so feel free to alter them
according to your taste or the complexity of the models.
Last but not least, in the settings for MatCap, if you wish, you can pick a different material. After all,
we are still looking at a gray cube, even though we have improved its perception. For example, you
can do the following:
1. Click the sphere preview under the MatCap button in Viewport Shading.
2. Select the third sphere in the second row.
72 Adjusting Cameras and Lights
If your version of Blender has the selection interface organized differently, we are looking for a sphere
that looks like brown clay. This will change the look of your cube to, well, muddy clay. The following
screenshot shows what we have done so far:
Figure 4.6 – Viewport Shading offers many ways to create a different look for your models
If the muddy color is too dark, then the second sphere in the first row is a nice alternative. However,
keep in mind that this is only for you to feel at ease while working with your models in Solid mode.
None of these changes will have any impact on the result when you render or export your models to
other software. These are, in a sense, throw-away materials that will make your experience in Blender
more pleasant.
So far, we have treated the Solid view as if it was Material Preview. This is useful when you want
a bit more visual clarity without previewing the model’s assigned materials since that makes extra
calculations by taking into account the lights too. Next, we’ll look into a way of doing something
similar in Rendered mode.
Ambient Occlusion
In this section, we’ll discover another handy visual tool that can help you have a bit more visual fidelity.
This tool is called Ambient Occlusion (AO), and it’s also a method that’s used in most games to create
a more realistic look. Let’s explore how and why this works.
Introducing MatCap and Ambient Occlusion 73
Let’s get the definition out of the way first. We have two names: ambient and occlusion. In the context of
Blender, as you may have guessed, ambient is a term that’s used to describe the overall light conditions.
We switched the background color to black to modify the ambient light near the end of this chapter’s
Rendering a scene section. So, we are already familiar with this concept.
Occlusion means to obstruct or block something. In our context, it means to obstruct light. So, we
want some light to be obstructed or occluded. But where exactly would we want this?
Take a look around wherever you are. You’ll notice that some areas, by having a flatter surface, will be
exposed to the natural or artificial lights coming off the ceiling or windows. Light – more specifically,
the photons that make up the light – will be bouncing off these surfaces. Wherever these flat surfaces
meet and make some sharper and some more moderate angles, they will be forcing the photons to
scatter in a zigzag manner. As a result, it’ll be harder for light to reach certain spots, so the geometry
of your models is going to occlude some of the light.
To see the effect of AO, open any of the following files from this chapter’s Start folder:
• Lights.Area.AO.blend
• Lights.Point.AO.blend
• Lights.Spot.AO.blend
• Lights.Sun.AO.blend
Also, remember to switch to Rendered mode by pressing Z followed by 8. Otherwise, the effect won’t
be visible. Do you notice the darker part where the cube meets the plane? That’s AO, as shown here:
Figure 4.7 – Ambient Occlusion visible where the cube touches the plane
74 Adjusting Cameras and Lights
The example files have been prepared so that the Ambient Occlusion option should already be visible
on the right-hand side in the Properties panel. By switching it on and off, you can observe the behavior.
AO affects the edges as if there is an extra volume of shadow, where shadows naturally would occur.
This makes it look more realistic. We’ll look at how to take advantage of AO as a separate effort inside
Godot Engine later in this book.
Additionally, in the AO settings, if you pick a higher Distance value, it will sample a larger area from
the object’s contact zone. This may help you have smoother or sharper AO.
We’ve covered a great variety of topics in this chapter. Now, it’s time to summarize what we’ve learned.
Summary
We started this chapter by rendering a scene with and without a camera and lights. During this effort,
we utilized Shader Editor, which was introduced in the previous chapter to change the background
color, also known as ambient color.
Then, we looked at different light types and how each type can be used to simulate real-life cases.
We did this using the Eevee rendering engine. Should you switch to the Cycles render engine, the
lights will have additional and more advanced properties, but the concepts you learned about in this
chapter will hold.
We also discussed the fact that your rendering concerns will be left for later when we tackle things
in Godot. However, it’d be a much more pleasant experience if we could work with better-looking
things. To that end, you were introduced to two different methods.
The first method is MatCap, which you can use to change the way models look, despite not turning
on material previewing. The second method, Ambient Occlusion, involves getting a feeling of where
objects meet and how they behave under existing light conditions. You can use both methods at the
same time if you wish.
In the next chapter, we’ll move things a bit. You’ll be studying and preparing a model for animation.
For this effort, you’ll utilize a process called rigging and simulate a skeleton-like structure inside your
model so that you can animate it.
Further reading 75
Further reading
Although this chapter covered cameras and lights, such topics are usually covered under the Rendering
title in many publications. That’s because there are different rendering engines, and each one treats
lights and cameras differently. Also, post-processing and color management might be your concern
if you want to take on more advanced renders. So, cameras and lights are only a small portion of
the rendering process. To learn more, Blender’s official documentation page might be a good start:
https://docs.blender.org/manual/en/2.93/render/index.html.
Also, here are a few online resources that might help you dive deeper:
• https://cgcookie.com/courses/fundamentals-of-digital-lightingin-blender.
• https://cgcookie.com/courses/production-design-with-blender-2-
8-and-eevee.
• https://cgcookie.com/courses/fundamentals-of-rendering.

5
Setting Up Animation
and Rigging
In Chapter 4, Adjusting Cameras and Lights, you saw why you should ignore certain concepts in
Blender, specifically cameras and lights, because they don’t transfer easily to Godot. This chapter is
sort of an opposite case. You might be wondering whether a game engine can’t move objects around
for us, right? After all, we use a game engine to facilitate things such as displaying models, creating
environments with visually rich effects, and so on. It’s normal to expect a game engine to take care of
animating our models as well.
Although animating simple objects is perfectly possible in Godot, doing it for complex models such as
a human character (or any bipeds, such as a robot) or a lion (or any quadrupeds, such as a cow) will
take a lot of effort. Therefore, it makes much more sense to do most animations in Blender because
it offers a much more streamlined workflow. We’ll explain in detail why that is so you can apply a
similar reasoning process in your own projects.
Sometimes, you will have a model that looks nice and complete, but it won’t be suitable or ready to
be animated. In Chapter 1, Creating Low-Poly Models, we discussed vertices, faces, and edges. We will
revisit some of those concepts in the context of getting our models ready for animation.
Then, when we believe the model is ready, we’ll look at Blender’s animation capabilities. We’ll do this
by discovering two new things. First, we’ll utilize a new method called rigging and construct a rig that’s
ubiquitous in animating models. Second, we’ll switch to a new workspace dedicated to animations.
During this effort, you’ll get to know a whole different side of Blender.
After you see how rigging is done and how models can be animated, we’ll look into ways to prepare
and store more animations in Blender so that they can easily be used later in Godot. So, once you know
beforehand what will be required down the line, this knowledge might help you in setting things up
accordingly in Blender before it’s too cumbersome to change later.
78 Setting Up Animation and Rigging
Despite the following section titles looking deceptively short, we have a lot to cover in this chapter:
• Where to build animations
• Understanding the readiness of models
• Creating animations
• Getting animations ready for Godot
In the end, you’ll know whether Blender or Godot is the right environment to tackle animations and
how to get models ready for animations so that you can rig them.
Technical requirements
There will be a lot of moving parts, figuratively and literally, in this chapter. Animation and rigging are
challenging topics for most people who start practicing 3D. Although we’ll take things step by step,
to give you extra help along the way, you might want to use some of the files that are in the interim
stages instead of doing it all at once.
As usual, the book’s repository will have the necessary files for this chapter at the following link:
https://github.com/PacktPublishing/Game-Development-with-Blenderand-Godot.
Where to build animations
Both Blender and Godot Engine have animating capabilities. Therefore, you might be wondering which
software is better for creating animations. To answer this crucial question, we should be discussing
what we are animating. When it comes to animations, especially in game development, we will be
tackling the following two main concepts:
• Whole-body objects: Objects such as a bouncing ball, a boat, or a projectile thrown from a
source are all examples of objects that act like a solid system with no individually moving parts.
The system can move as a whole without depending on its individual parts.
• Connected systems: Some systems depend on individual parts to be in motion. These systems
have parts that are connected to each other and the individual parts work together to move the
system they are part of. For example, cats use their feet, birds use their wings, and a human body
moves in a certain direction using two appendages that are either in contact with a surface or
interact with the medium they are in.
Sometimes, some tools and gadgets in real life can do a similar job, and it’s possible to use one over
another for a quick solution. However, every so often, we would like to pick the best tool for the job.
We’ll discuss both Blender and Godot in the context of the concepts we have just pointed out to see
which option might be a better choice.
Where to build animations 79
Animating in Godot Engine
Godot has a component, AnimationPlayer, that helps you build animations. We’ll look at it more
closely in later chapters when we import our models to create a point-and-click adventure game.
Similar to other applications’ animation components, it depends on setting keyframes to mark the
changing points of an animated object. For example, to create a bouncing ball animation, you’d mark
the ball sitting still on a plane in the earlier frames of the animation and mark a higher position in
the world in the later frames.
This is quite easy to do with Godot. You just have to mark the important events as keyframes, and this
operation is called keying or inserting a key. Thus, the engine figures out how the object should move
in between the two keyframes. However, when the system is much more complicated than a simple ball,
and it has moving parts, you’d be expected to select these separate parts to key them. This is not easy
to do in Godot since the workflow is not constructed in a way to facilitate such complex operations
in an easy manner. Consequently, it’s best to use Godot Engine when the system is relatively simple.
Animating in Blender
As was just mentioned, when you are animating an object with parts that are responsible for creating
the overall motion, such as animating a human body by moving individual parts such as feet and
hands, then doing this kind of work in Blender will be the right choice thanks to a method called
rigging. Later, in the Creating animations section, we’ll explain what rigging is and discover how to
construct a rig for our models.
For now, it should be enough to know that individually moving parts for an animated body will require
rigging to expedite the animation process. This is where Blender shines because it offers tools and
custom interfaces to help you along the way.
Besides the ease of creating an animation, let’s point out another reason why Blender is a better choice
for animating complex systems. If you construct your animations in Godot, you can only use them
in Godot. On the contrary, a Blender animation will act as a source of truth so you can share it with
other applications.
Wrapping up
We’ll say one more thing about why Blender might be a better choice regardless of the complexity of
creating animations. If you ever want to create a trailer for your game and you’ve gone through the
trouble of creating accurate enough camera and light conditions similar to the ones you are going to
employ in your game, then you can take a render of your scene, composed of many frames, which
will utilize Blender’s animation system.
So, for simple objects that can be moved, utilize Godot Engine’s animation system. For systems that
have individually moving parts, it’s better to do it in Blender. After all, Blender has dedicated tools
to facilitate the creation of advanced animations. Now, let’s discuss when your models are ready to
be animated.
80 Setting Up Animation and Rigging
Understanding the readiness of models
In Chapter 1, Creating Low-Poly Models, we started with primitive objects and altered their vertices,
faces, and edges. During that process, we were concerned with how the model would look. As corny
as it may sound, looks might be misleading sometimes. To be animated correctly, a model has to
respect certain conventions other than how it looks. In other words, you’ve got to be sure whether
your model is ready.
Topology and rigging
The readiness level of a model could be defined by the term topology, which sounds a bit technical.
In layman’s terms, it’s the distribution and arrangement of the vertices, edges, and faces of a model
that altogether mark how optimized the model is for animation.
Not all topologies are created equal. There are bad and good topologies. Let’s look at Figure 5.1 to
get a better idea about what we mean by topology or distribution, particularly as being bad or good.
Figure 5.1 – The same model with two different distributions of vertices
The preceding figure shows a model with the same shape, but the topologies are different. Simply put,
the left case is ready for animation, and the right one could use some work to straighten up those
vertices to form a good flow. Then, you’d have to fix some of the irregularities by evenly distributing
many of the faces that congregate. So, not only is the right case an eyesore, but it’s also detrimental
during the animation process.
Let’s briefly touch on the role of rigging to understand the importance of good topology. If you were
to model a human hand, you’d be designing fingers, knuckles, and the wrist. The model, or more
correctly, its volume, would be hollow. In other words, you’d only be creating the vertices that would
give the shape of a hand. However, in our minds, we know that this hand should have bones inside.
When you wiggle your fingers around or bend your fingers at the knuckles and joints, different parts
Understanding the readiness of models 81
of the skeleton start moving so that the outer structure that’s connected to the bone system can
move accordingly.
To simulate this, you take advantage of a practice called rigging, which involves introducing a skeleton
system and a series of constraints that manage how the skeleton system behaves. We’ll work on a
rigging example later in the chapter. For now, we are still concerned about our models being ready
for the rigging to take place. To emphasize the relationship between topology and rigging better, let’s
turn our attention to Figure 5.2.
Figure 5.2 – Different topologies for a hand model
Observe how the faces are aligned more naturally in the middle case, which certainly looks like an
improvement over the left one. Then, still for the middle case, look where the big thumb meets the
main part of the hand; that area could use a bit more detail so that when the thumb stretches out like
in the right case, there would be enough geometry to accommodate the skeleton’s behavior. Compare
the first and the third hands to see which one looks more natural to your eye when it comes to flesh
and skin in between fingers.
When a model is bending or stretching at certain points, it will be creating some creased and protruded
areas, similar to where the fingers meet the hand in the preceding figure. If vertices, hence faces, don’t
have a smooth flow, the model will look ripped or crushed in these weak spots. Having the correct
topology is a topic that’s hard to master and it throws off a lot of beginners when they want to get into
animation and rigging. You can find a few links that can help you understand the difference between
a good and bad topology in the Further reading section.
To satisfy a good topology, since it’s necessary to line up edges and faces correctly where the action
will occur, we need a mechanism to move problematic edges and faces around so that they will be in
the right place. For this, we are going to discover a new method, or rather, a shortcut.
82 Setting Up Animation and Rigging
Grabbing
In Chapter 1, Creating Low-Poly Models, you got to know two methods that are very commonly used
among Blender fans. They were Rotate (R as a shortcut) and Scale (S as a shortcut). There is a third
common method that we intentionally omitted during that exercise. We depended on modifiers that
helped us move vertices around, so we got away without it; however, it’s now time to employ it.
If you are able to rotate and scale things, then why can’t you move things around? In fact, you can,
and this new method will help you move vertices, edges, and faces anywhere you want. There is only
one caveat. Although most people refer to this operation as Move, its shortcut is a bit bizarre; it’s G.
So, an easier way to think of this shortcut in the context of moving might perhaps be grabbing. You
grab a vertex and leave it somewhere, in a sense.
In most Blender tutorials, you may find people use grab and move interchangeably. They're one and
the same. So, throughout this book, when you see the word move, we mean the grab operation and
the G shortcut.
Let’s practice this new piece of knowledge with a series of simple steps. After you start a new file,
perform the following steps:
1. Press Tab to enter Edit Mode.
2. Select only one vertex of the default cube.
3. Press G and move your mouse around.
The vertex you selected is now being pulled around while you are moving your mouse. To terminate
the grabbing, you can click anywhere and this should rest the selected vertex at its last position.
Figure 5.3 is an example of what we want to achieve.
Figure 5.3 – A vertex grabbed out of its original place and moved somewhere else
You might have surmised that the vertex was moving freely in all three axes, and that would be correct.
If you want to limit the movement to a certain axis, and if you wish to move the vertex a precise
amount, you can do that too. While still in Edit Mode, perform the following steps:
1. Select another vertex.
2. Press G, then X.
3. Type 0.5.
Creating animations 83
You can pick any one of the other two axes if you want. Regardless, the value you type for any given
axis defines the movement amount. So, a negative value will still move the selected part in the axis
you choose, just in the opposite direction.
Additionally, sometimes you might want to move the selection in any but a certain direction. When
you initiate a grab shortcut, if you press Shift before you pick the axis, it’ll move the selection to the
other two remaining axes. So, Shift+X would move things anywhere but on the X axis.
Practice the grabbing operation a bit more by selecting edges or faces if you would like. Soon, we’ll
explore the building blocks of animation. During that effort, you’ll most likely utilize the grab operation.
So, when you are ready, let’s see how we can animate things.
Creating animations
As we mentioned in the Where to build animations section, the type of animation we’ll do in Blender
involves having individual parts of a system that move independently from each other or collaboratively
move together sometimes. We also said that we would need a method called rigging, so let’s give an
example to understand why rigging is useful.
When you talk, whether you are sitting or walking, the muscles and bones that are responsible for
the talking are generally not affected by or affecting the other parts of your body. However, when you
are walking, your legs rotate around the hip bones, and the rest of the system triggers other natural
actions, such as swinging your arms, moving your shoulders slightly forward and backward, and so on.
In both cases where you have a local or system-wide dependency, we eventually move some of the
vertices that make up a model. Since moving so many vertices is a lot of work, we use a structure
we place inside the model to tell the necessary vertices where to move. The process to create such a
structure is called rigging. In a way, rigging mimics what bones and muscles do in real life.
In this section, we’ll work on a simple rigging process and rig a low-poly snake. Through this process, you’ll
prepare the model for animation, but first, we'll get to know some of the essential components, as follows:
• Armature: An armature, in simple terms, is a set of bones, but a better definition might be
a framework serving as a control structure – what materials are to textures, armatures are to
bones. So, the same armature could have multiple bones. Furthermore, the rigging process
could involve many armatures if the system that’s animated requires so.
• Bone: This is the most essential part of a rigging system. Without bones, there would not be
armatures, therefore nothing to animate. In real life, when your bones move outside of their
zone of freedom, you feel pain, so your body keeps things intact. There are similar ways to
restrict a bone’s freedom digitally, so to speak, so it works in tandem with other bones.
We’ll first look at how to rig a model. For this effort, we’ll utilize one armature and many bones. After
adding constraints to some of the bones, the rigging process will be complete. So, in the end, we will
use our rig to animate the snake.
84 Setting Up Animation and Rigging
Rigging
Now that the theoretical stuff is out of the way, we can focus on the practical aspects, mainly how to
set up armatures and bones. To focus on the rigging process, we’ll use a low-poly snake model. The
Snake.blend file in Chapter 5’s Start folder is a good starting point, and by the end of this
Rigging section, you’ll have reached what you see in the Snake.Rigged.blend file.
Besides these two files, we’ll mention other complementary files that show the interim phase. As
always, you can find all of these files at the URL mentioned in the Technical requirements section.
After you open the Snake.blend file, let’s add an armature by performing the following steps:
1. Press 3 on your numpad to switch to the Right Orthographic view.
2. Press Shift+A.
3. Select Armature.
You can also find the result of the preceding operations in the Snake.First Bone.blend file. If
your keyboard doesn’t have a numpad, then you can click on the X axis in the gizmo in the top-right
corner of 3D Viewport until you read Right Orthographic in the top-left corner. The following figure
should help you see what we have done so far:
Figure 5.4 – Beware the snake! On second thought, it doesn’t seem to have a mean bone in its body
We now have a new object type in our scene: an armature. You can see it in Outliner too with two
green stick figures next to its title. Right now, we have one bone in the armature. So, bone and armature
Creating animations 85
kind of mean the same thing at this point. Our goal, in rigging, will be to create and distribute a bunch
of bones inside the snake’s mesh. So, let’s add more.
We seem to have a problem, though. That bone we added earlier looks like it’s occluded by the snake’s
tail. So, if we keep adding more bones and laying them out so that they align with the snake’s body,
we won’t be able to see what we are doing. Luckily, the solution is a couple of clicks away. While the
armature is still selected, you can expand Viewport Display in the Armature settings in the Properties
panel and turn on the In Front option. This will make sure the armature is always visible.
Missing out on a numpad
Numpad shortcuts are helpful and they will make your life easier, especially during modeling
and rigging when you need to view your work from certain angles often on. The following
website offers eight different ways to mimic a numpad: https://essentialpicks.
com/using-blender-with-no-numpad/.
Meshes are composed of vertices, faces, and edges. Similarly, bones are made of three components: root,
body, and tip. The tip can be the root of another bone and vice versa. Just as we can go into Edit Mode
for a mesh to change its inner parts, we can do so with an armature. So, select the armature and press Tab.
You should be able to click on and select the root and tip separately. When you select the structure
in between the joints, it’ll automatically select the root and the tip since it’s all connected. Figure 5.5
shows only the tip selected.
Figure 5.5 – The tip of the bone is selected in Edit Mode
86 Setting Up Animation and Rigging
Credit where credit is due
The snake model we are rigging in this section is an asset created by an artist known as Quaternius.
You can follow his work at https://quaternius.com. We’ll be using his other assets in
later chapters as well. So, thank you for your generosity.
Now, we are ready to add more bones to the armature. We’ll do that by first positioning that initial bone,
then we’ll add new bones coming off the tip. While still in Edit Mode, perform the following steps:
1. Select the root joint.
2. Press G and move the mouse so that the joint is somewhere in the middle of the snake’s chest.
3. Click to finish grabbing.
4. Select the tip joint.
5. Press G and move the mouse so that the joint is somewhere near the Y axis but inside the tail.
6. Click to finish grabbing again.
A figure might be extremely helpful since all of this moving and positioning sounds a bit arbitrary.
Figure 5.6 is an example of what we have achieved in the last few steps.
Figure 5.6 – A well-placed bone for our snake
Creating animations 87
Since up, down, or right concepts lose their meanings in the 3D space, it’s important to have a simple
yet effective way to represent the natural flow of bones. If you compare Figure 5.5 and Figure 5.6,
which correspond to the Snake.First Bone.Editing.blend and Snake.First Bone.
Position.blend files, respectively, you’ll notice that the structure between the joints is going in
different directions. The broader part of the bone is closer to the root, and the narrower end of the
bone is approaching its tip. For example, imagine your kneecap as the root and your ankle as the tip
of one bone. Moreover, hip bone to kneecap, elbow to wrist, and so on.
We have to add a few more bones to our system. We’ll do that by extruding the original bone. While
still having the tip of the bone selected, perform the following steps:
1. Press E to start extrusion.
2. Move the mouse in the right and bottom direction so it follows the tail’s form.
3. Click to finish extrusion.
4. Repeat Steps 1 to 3 until you have four bones of roughly the same length.
The result is shown in Figure 5.7, and you can also open the Snake.Tail Bones.blend file to
compare your result.
Figure 5.7 – Four bones that make up the tail
88 Setting Up Animation and Rigging
Importance of clicks
Similar to finishing a grabbing operation, extrusion needs a final click to solidify the position
of an extruded object. Hence, throughout the rest of this chapter, when you follow a step where
you see the word extrude, you are expected to click and finalize the extrusion when you are
happy with the object’s position. If you prematurely terminate the extrusion, you can always
hit G and grab this new object to move elsewhere and continue extruding if you wish. Thus,
click to finalize both grabbing and extrusion, and use these two handy methods as often as you
need. Also, if you change your mind while extruding, right-clicking will cancel this operation.
Extrusion helped us do a few things at once. We have created a new bone, positioned it correctly so
its root aligned with the previous bone’s tip, parented this new bone to the previous bone, and finally,
moved its tip to where we’d start the next bone.
We’re halfway through adding bones to the snake. That being said, now is a good time for a bit of
housekeeping. We’ll be referencing some of these bones later, so it would be prudent of us to rename
them now. If you have been paying attention to the new bones’ names after the extrusion, you must
have seen that they are labeled in a format that goes like Bone.00X where X is the succeeding bone’s
number. To rename all of the bones you have added so far, perform the following steps:
1. Select the original bone.
2. Press F2 and rename it to Tail.1.
3. Repeat the preceding two steps for the rest of the bones so that their names look like Tail.X.
Let’s move on to adding bones for the torso. For this, we are going to utilize the original bone, which
is now renamed Tail.1. Some of the decisions that you’ll make while rigging your models will depend
on the situation you are going to use the rig for. It would have been perfectly possible to start the
bones from the head and go all the way to the end of the tail. However, we know that this snake will
have an inclination point, mainly where the torso and tail bones meet. Therefore, you need to perform
the following steps:
1. Select the root of Tail.1.
2. Press E to extrude a new bone in the right and top direction, following the torso.
3. Repeat Step 2 twice more so that you have three bones in the end.
4. Select each new bone and rename them to look like Torso.X where X is a consecutive number
starting at 1.
Creating animations 89
The result is what you see in Figure 5.8 and in the Snake.Torso Bones.blend file.
Figure 5.8 – New bones have been added following the torso to the head
We can now plan the remaining bones. We’ll be concerned with only two bones for brevity’s sake: the
head and mouth bones. If you have been following all along, the tip of Torso.3 should still be selected.
If not, select it, then perform the following steps:
1. Press E to extrude a new bone to the end of the snake’s nose.
2. Select Torso.3’s tip again.
3. Press E to extrude a new bone to the end of the snake’s mouth.
90 Setting Up Animation and Rigging
In the end, the fully constructed skeleton, which you can find in the Snake.Full Skeleton.
blend file, will look like what you see in Figure 5.9.
Figure 5.9 – The skeleton of our snake is complete
We are done with the skeleton. To complete the rigging, we need to add two more bones, which are
usually called control bones. The following is an explanation of why a simple skeleton, although
necessary, is still considered less than ideal. It has to do with the following two conflicting concepts:
• Forward Kinematics (FK): When you have a series of bones and you want to move the extremity
bones, for example, a thumb in a human’s hand, the motion would have to be calculated while
considering all of the position and orientation values for all of the interim bones starting from
the shoulder joint. Thus, the motion starts off at the root and goes forward.
• Inverse Kinematics (IK): This is a much more efficient method where, following the preceding
example, by moving a thumb, all of the connected bones determine their state in reverse order
one at a time, instead of calculating the overall system’s behavior. Thus, the moving bone dictates
how the bone behind should behave, and that bone behind does the same all the way to the root.
Creating animations 91
We prefer IK in our exercise since it’s much more convenient to use, and it is widely accepted in the
industry. If you would like to get more in-depth information, especially on the math aspect of FK and
IK, refer to the following two pages:
• https://www.sciencedirect.com/topics/engineering/forwardkinematics
• https://www.sciencedirect.com/topics/engineering/inversekinematics
To introduce IK to some of our bones, we need to create control bones that will propagate the motion
to the rest of the bones. Although these control bones will look like they are part of the skeleton
visually, they will be decoupled from the skeleton. Right now, all of the bones that have been extruded
have been automatically parented. So, we’ll need to unparent our two control bones once we extrude
them off the end bones.
It would seem one of these bones could be coming off the Head bone, and the other control bone, by
symmetry, could be coming off the Tail.4 bone. Assuming you are still in the Right Orthographic
view, in order to create these bones, you need to perform the following steps:
1. Extrude a bone in the left direction off the tip of the Head bone.
2. Rename this new bone as Head.IK.
3. Extrude a bone in the right direction off the tip of the Tail.4 bone.
4. Rename this new bone as Tail.IK.
We have created two new bones, but they are still attached to the skeleton. So, we need to separate
them. ALT+P is a shortcut you can use to clear the parent relationship, but we’ll do the decoupling
somewhere else since we’ll have to turn off another setting too. So, let’s do both at the same time, as
follows:
1. Select the Head.IK bone.
2. Turn on the Bone Properties tab (the green bone icon) in the Properties panel.
3. Expand the Relations section in that tab.
4. Clear the parent by clicking on X in the name field.
5. Turn off the Deform option.
6. Repeat Steps 3 to 5 for the Tail.IK bone.
The Snake.Full Skeleton.IK.blend file contains all of the progress you have made so far, but
let’s explain what we have done in the last several steps. We used to see the Armature properties, so we
asked the Properties panel to show another view to display bone properties. We broke the connection
of our control bones with their parent. Since there is no parent, the Connected checkbox automatically
switched itself off. Lastly, we turned off a setting that’s the crux of all this whole operation: Deform.
92 Setting Up Animation and Rigging
If you recall what topology is and why we use a rigging system to animate systems that bend and
stretch, then you’ll know that deformation is the key. We want the skeleton of the snake to deform
the mesh it’s in. However, we wouldn’t want that for the control bones since we’ll use these to dictate
the overall motion. So, they should not be deforming anything.
That being said, they will be responsible for IK, which is the last missing piece to the rigging. To
complete the rigging, we need to add the IK ingredient, and we’ll do that in Pose Mode.
In Chapter 1, Creating Low-Poly Models, we went back and forth between Object Mode and Edit
Mode. In this chapter, we’ve been in Edit Mode all this time to move the parts of a bone and extrude
new ones. Bones can be in another mode, Pose Mode, with which you can define the relationship of
the bones with each other by introducing constraints. Consider this new mode as editing the behavior
of the armature, hence how the model will pose.
Assuming you are in Edit Mode already, press CTRL+Tab then press 2 to switch. Or, if you are in
Object Mode, then CTRL+Tab will take you directly to Pose Mode. Keep in mind that this works if
you have a bone or the armature selected. Alternatively, the dropdown in the top-left corner can help
you to be in the right mode. We’re now ready to add IK constraints as follows:
1. Select the Tail.4 bone.
2. Turn on the Bone Constraints Properties tab (the blue bone icon with a strap around it) in
the Properties panel.
3. Choose the Inverse Kinematics option in the Add Bone Constraint dropdown.
4. Repeat Step 3 for the Head bone.
We have added the missing IK component to two bones. Maybe you noticed that the constraint was
not added to the control bones but to the bones just before them. We’ll now map some of the IK
constraints' values to use the control bones. To do that, while the Head bone is selected, perform the
following steps:
1. Click on the square icon in the Target field of the IK constraint.
2. Select Armature in the options.
3. Click on the bone icon in the Bone field of the IK constraint.
4. Select Head.IK in the options.
This will designate Head.IK as the control bone for the Head bone. So, from now on, whenever you
interact with Head.IK, it will control the Head bone that is connected to the other bones all the way
to the root. That’s why you see a dotted yellow line going from the tip to the joint in between the
Torso.1 and Tail.1 bones.
Let’s associate Tail.4 and Tail.IK by following the preceding recipe so that interacting with Tail.IK
can dictate the tail bones’ behavior. Select Tail.4 then perform the following steps:
Creating animations 93
1. Select Armature in the options after clicking on the square icon in the Target field.
2. Select Tail.IK in the options after clicking on the bone icon in the Bone field.
3. Change the Chain Length value to 3.
The first two steps in the preceding set of instructions are pretty much exactly the same except that
we picked the appropriate bone. The last step introduced a new concept that tells the control bone
how far down the chain of bones the root bone is. The dotted line moved accordingly. The final result
is what you see in Figure 5.10.
Figure 5.10 – A fully rigged snake
We’ve been doing all of this work so that the armature would be part of the snake. However, if you
look at Outliner, you can still see that these two objects are separate. It’s time to really connect the
skeleton to the snake’s mesh as follows:
1. Switch to Object Mode.
2. First select the Snake mesh, then Armature by holding down the Shift key.
3. Press CTRL+P to bring up the Set Parent To menu.
4. Choose With Automatic Weights.
94 Setting Up Animation and Rigging
When you parent the armature to the mesh, two things will happen. First, Snake in Outliner will be
moved as a child under the Armature item. Second, Snake will be assigned an Armature modifier
that will build the connection between these two objects.
In the end, the armature will designate its bones to nearby vertices so that when a bone moves, it
mobilizes the associated vertices. It’s as if some vertices that are closer to a particular bone weigh more
in terms of priority. Thus, you won’t see a tail bone move far away vertices that much.
Phew, the rigging is finally complete. As you may have noticed, all of this creating and separating
bones, adding constraints, adjusting settings, and so on could sometimes become a tricky business.
You get visual clues as to which bone is doing what and how they are connected, but the scene could
quickly get cluttered with gizmos. Like anything else, though, you get used to doing it with practice.
On that note, you’ll find links to more advanced rigging material in the Further reading section.
We have provided the Snake.Rigged.blend file both in the Start and Finish folders for you
to compare your results. You can also use this file as a starting point in the following section. Since
we deemed that rigging was necessary for animation and that our rig is done, we can now turn to a
new section where we’ll get to know the Animation workspace of Blender.
Animating
We’re about to animate our snake. We’ve prepared a skeleton and introduced two control bones to
construct a rig. In this section, we’ll use this setup to create an attack animation. Using the methods
presented in this section, you can create different animations for your models and store these animations
with the model in the same file.
Let’s switch to the Animation workspace to take advantage of a more suitable set of interfaces. The
layout will change to mainly two side-by-side 3D Viewport panels and what looks like a timeline
underneath. There are actually two panels at the bottom, as follows:
• Dope Sheet: We’ll work with keyframes soon to mark the defining points when parts of your
model move over time. For example, a frog can have one keyframe for its resting position, then
another keyframe defined as its highest jump level later in time.
• Timeline: This is a simpler version of Dope Sheet. It is represented with a clock icon and lets
you see things at a higher level. We won’t utilize this interface that much, but it’s useful to set
the Start and End keyframes of your animations.
Besides these two editors, there is also the Graph Editor, which you can access by clicking the icon
in the drop-down menu in the top-left corner of any panel. Actually, let’s do that by changing the left
3D Viewport into a Graph Editor. When you are done, you should see something like the following:
Creating animations 95
Figure 5.11 – We have further customized the Animation workspace
We have everything we need to animate the snake. We’ll start with an attack animation. For this,
we’ll move the head forward and raise the tail to depict a menacing pose. Start by switching the 3D
perspective to Right Orthographic by pressing 3 on the numpad and performing the following steps:
1. Go into Pose Mode.
2. Select the Head.IK bone.
3. Press I to insert a keyframe and select Location in the options.
This operation will add a key to the first frame in Dope Sheet as well as populating some elements
both in Dope Sheet and Graph Editor. So far, so good. Take a look at what’s added to the animation
editors and expand the Head.IK title in both editors to see what exactly is happening under the hood.
We are marking the location of the Head.IK bone.
For the next event in the snake’s attack animation, we need to move the snake’s head forward and key
(mark) its new location. For this, we need to select a new frame in the timeline as follows:
1. Change the frame value from 1 to 10 (just to the left of the Start section in Timeline).
2. Press G and move the head slightly to the left and up.
3. Press I to insert a keyframe and choose Location again.
96 Setting Up Animation and Rigging
This should add more elements – more specifically, curved lines – to Graph Editor. This is good
because you can use those curves to fine-tune how the action will start and end—more abruptly or
smoothly, which can be used for more dramatic effects. We leave it to your artistic interpretation. What
we can do, for now, is finish the head’s motion so that it goes back to its original position, as follows:
1. Change the frame value from 10 to 25.
2. Press Alt+G to reset its position to the original values.
3. Press I to insert a keyframe and choose Location again.
Figure 5.12 shows our progress so far.
Figure 5.12 – We have animated the head bone via a control bone
In the end, we have moved the torso bones by animating the Head.IK bone. That’s why we have
implemented a control bone instead of moving the individual torso bones. Additionally, we haven’t
done anything special to the Mouth bone, but that’s also moving to keep up with the head.
Let’s do something similar with the tail, as follows:
1. Set the frame to 1.
2. Select the Tail.IK bone.
3. Press I to insert a keyframe and choose Location.
4. Set the frame to 10.
5. Press G and move the tail slightly to the top and left.
Creating animations 97
6. Press I to insert a keyframe and choose Location again.
7. Set the frame to 25.
8. Press Alt+G to reset the position.
9. Press I to insert a keyframe and choose Location again.
In this pose, the tail naturally looks angry, which accentuates the head’s motion. By the way, where
is your head? If you look in Dope Sheet, the keyframes for the head animation are gone. Blender
only displays the keyframes for the selected object to keep the interface clean and simple. You can
display everything by toggling off the Only Show Selected button, which looks like a select icon in
the header of Dope Sheet. There is a similar button in Graph Editor; if you disable both, you should
have something similar to what you see in Figure 5.13.
Figure 5.13 – Both the head and tail keyframes are visible in the editors
You can also refer to the Snake.Animated.blend file in the Finish folder.
We’ve completed our first animation. If you would like to create another animation, where would you
do it? It seems that we could keep adding more keyframes to the timeline. However, how would we
know which keyframes are responsible for a particular animation?
We can answer this question both in Blender and Godot contexts. Actually, once we understand
how to create separate animations in Blender for the same model, we’ll have practically prepared our
animations to be shipped to Godot. To do this, we’ll discover Action Editor in the following section.
98 Setting Up Animation and Rigging
Getting animations ready for Godot
Creating separate Blender files for different animations would be extremely unwieldy. If only we had
a way to store multiple animations in the same file. Luckily, there is. We need to use a new interface
called Action Editor for that. Let’s see how we can use it to create another action for the snake.
There is a dropdown in the top-left corner of the Dope Sheet panel. Although that whole panel could
be considered as the Dope Sheet panel, we have been using its default view. This is similar to how
3D Viewport works. When we were switching between Object Mode and Edit Mode, we were still
working in the same 3D Viewport panel but in one of its specialized views. In other words, these
dropdowns customize the panel you are in. To switch the Dope Sheet panel to its Action Editor view,
perform the following steps:
1. Expand the dropdown that shows Dope Sheet.
2. Select Action Editor in the options.
This will reveal the title of our first animation, ArmatureAction, in the middle portion of the Action
Editor header. This is a lackluster action name. The snake deserves better. Let’s change it by clicking
its text and typing Attack. Now, you have just changed the default name to something you can easily
keep track of. Moreover, when we import this model into Godot and we want to trigger the correct
animation sequence, we’ll use this action name. Let’s create more actions as follows:
1. Click on the second icon next to the action title (the icon with stacked papers).
2. Change this new action’s title to Idle.
This will actually create a copy of the first animation. Except for its title, everything is the same, but
we can now change the features of the animation that match the title we just gave. In most games, the
idle state of characters usually looks calm, but they have a slight bobbing up and down motion that
indicates the character is alive but otherwise in a neutral state. Our idle action involves performing
the following steps:
1. Set the frame to 10.
2. Select the Head.IK bone and reset its position by pressing Alt+G.
3. Press G and move the bone ever so slightly downward.
4. Press I and choose Location.
5. Repeat Steps 2 to 5, but move the Tail.IK bone slightly upward.
Let’s do one more thing and test our new action. Change the End value in Timeline to 25 and click
the play button. This will let you see the action in a looped manner so that you get a sense of whether
the locations in the animation are good enough. Make more corrections to the location of the head
and tail control bones if you would like, but remember to set their values by pressing I.
Summary 99
Our snake is idling, up and down, perhaps waiting for a target to attack. By using the dropdown to
the left of the action’s title, you can switch between different actions.
Congratulations! You have officially created two animations. If, at times, it was difficult to follow the
instructions, you can find a fully finished example in the Finish folder in the Snake.blend file
for further studying.
We have done a lot in this chapter. It’s time to summarize our efforts.
Summary
This chapter started off with a discussion about which software (Blender versus Godot) would be
suitable for animations. We exemplified different cases of animation and determined that Blender is
the right choice for animating systems that have individually moving parts.
We then discussed the importance of good geometry, better known as topology, since not everything
that looks good is good enough from an animation perspective. Once the system is in motion, the
vertices, faces, and edges will act like a wrapper around a skeleton. If you know you’ll be animating
your model, you might be careful in how you create the geometry better ahead of time.
Nevertheless, if such an early option is not always possible, to prevent tearing and creasing that might
occur in certain areas of a model, we introduced the grab option. It can help you resolve problematic
parts by moving them to a different location.
As soon as the distribution of vertices is in a favorable place, then the rigging can start. This is, in fact,
one of the most advanced topics for most artists who are learning any 3D modeling software. It helps
sometimes to think of rigging as a bunch of strings that control a puppet. Like a puppet master, you
need to know which string controls which parts. To that end, we introduced IK, which has advantages
over a more direct, also known as FK, approach.
After we created a rig for a snake, we discovered the animation workspace. Since the rigging depended
on control bones via IK, our animation was done effortlessly. Along the way, we learned how to move
parts of a rig and keyframe their properties. In our simple case, it was only location, and we kept the
motion on one axis.
Lastly, we got to know how we could store two animations, rather actions, for the same model. Once
you have properly labeled actions, not only will it be easier for you to find them in Blender in the
future, but you will also see the benefit of this practice later in Godot chapters.
You have completed five chapters that took you from creating models to adding animations to your
models. Along the way, you’ve also learned how to construct and apply materials and textures. In the
following chapter, we’ll investigate how to export our work from Blender.
100 Setting Up Animation and Rigging
Further reading
We mentioned the importance of topology, and it could be challenging to know what constitutes
good or bad topology. So, to see more examples and benefit from other people’s expertise, refer to
the following links:
• https://blender.stackexchange.com/questions/140963/do-i-havebad-topology
• https://www.reddit.com/r/blenderhelp/comments/speyjs/is_this_
bad_topology/
• https://www.pluralsight.com/blog/film-games/ngons-triangles-bad
Some 3D practitioners specialize only in animation. Although it’s possible to animate some Blender
objects without rigging them, for example, cameras and lights to move them around the scene, most
online courses usually cover rigging and animation topics together. The following is a list of online
courses and material for you to further your knowledge in both of these domains:
• CG Cookie: https://cgcookie.com/courses?sort_category=140,179
• Udemy:
 https://www.udemy.com/course/rigging-fundamentals-blender/
 https://www.udemy.com/course/rigging-and-animating-low-polyfps-arms-in-blender/
 https://www.udemy.com/course/learn-3d-modelling-rigging/
 https://www.udemy.com/course/blendercharacters/
Additionally, while you are browsing for more training content, you might come across a topic called
Weight Painting, which is helpful in determining how the rigging will prioritize the nearby vertices.
We left it out for brevity’s sake, but it’s a topic you’ll most likely want to cover if you want to be
more thorough.
In the following chapter, we’ll be slowly transitioning from Blender to Godot. So, this chapter was really
the last hands-on Blender chapter. If you want to know more about what Blender can do, there are
some really useful resources out there, in both written and video formats, offered by Packt Publishing,
such as the following resources:
• Blender 3D By Example by Oscar Baechler and Xury Greer
• Blender 3D Modeling and Animation: Build 20+ 3D Projects in Blender by Raja Biswas
• The Secrets to Photorealism: The PBR/Blender 2.8 Workflow by Daniel Krafft
Part 2:
Asset Management
In this transitional part, you'll learn how to move from Blender to Godot. An essential part of this
workflow will be knowing which settings matter. By getting to know potential pitfalls and how to
apply workarounds, you can prepare yourself for scenarios where you have to use third-party assets.
In this part, we cover the following chapters:
• Chapter 6, Exporting Blender Assets
• Chapter 7, Importing Blender Assets into Godot
• Chapter 8, Adding Sound Assets

6
Exporting Blender Assets
Your journey in Blender has taken you to this point, where you want to take your creations in Blender
and deploy them in Godot Engine. We’ll cover importing these assets into Godot in the next chapter,
but first, we must make sure everything we have in Blender is up to Godot’s standard. So, we’ve got
to iron out a few kinks before exporting.
First, we are going to make sure the geometry of our models is fine. We have already talked about
polygons; we’ll dive deeper to understand them better to achieve models with better geometry. Origin
points are an important concept in both Blender and Godot. We’ll discuss why they are important
and learn how to alter the origin points.
We have not discussed the dimensions of our models so far. However, more important than the
dimensions of your models, we’ll investigate a concept called scale or scale factor, which is crucial
when you send your assets to not only Godot Engine but also to other game engines. The final part
of getting your models ready is an organizational practice: naming your assets.
After we finish making our preparations, we’ll need to convert our assets into a format Godot
understands. To that end, we’ll explore glTF and compare this format to a few others. Once Godot
imports this file type, it will understand how to make sense of vertices, materials, and animations
stored in a Blender file. We’ll look into importing in the next chapter, though.
Lastly, just because we can transfer assets out of a Blender file doesn’t mean we should be all-inclusive.
We’ll discuss which objects in a Blender scene are useful from a game development perspective. During
this exercise, we’ll also learn how to store our preferences for selecting the objects we want to export
under presets so that we don’t have to remember the export conditions every single time.
In this chapter, we will cover the following topics:
• Getting ready to export
• Exploring glTF and other export formats
• Deciding what to export
104 Exporting Blender Assets
By the end of this chapter, you’ll know what to do to get your models ready for export, choose an
appropriate export format and configure it, and learn how to export only the stuff you want.
Technical requirements
This is a chapter about understanding some concepts rather than practicing, so you’ll do a minimum
amount of work, such as looking at the value of certain things and occasionally rotating some objects.
You’ll likely revisit this chapter later to remember how to export your work samples. So, it’s OK to do
a preliminary reading first and come back again for another read.
Wherever it’s relevant in this chapter, the appropriate filenames in the Start and Finish folders
will be mentioned. The files that contain the necessary assets have been provided for you in this book’s
GitHub repository: https://github.com/PacktPublishing/Game-Developmentwith-Blender-and-Godot.
Getting ready to export
There are plans to make the transition between Blender and Godot Engine more seamless in future
versions. For example, you’ll be able to deploy your Blender file directly in a Godot project and start
accessing the elements from your Blender scene directly in Godot. However, we are not there yet, so
we need to do a bit of housekeeping before we send our stuff to Godot.
The following is not a complete list, but it covers the most common problems many artists face when
they go between Blender and Godot:
• Deciding what to do with n-gons
• Setting origin points
• Applying rotation and scale
• Naming things properly
Now, let’s discuss these topics (problems) and their solutions. We’ll start with more labor-intensive
topics and finish off with easier things to take care of before you hit the export button.
Deciding what to do with n-gons
Let’s give a formal definition of an n-gon and move on to its relevance in our work. Mathematically, a
closed plane with n edges is an n-gon, but we use friendlier names for some of these n-gons. For example,
a triangle is another name for a 3-gon. Moreover, for any number of edges equal to or more than five,
we generally use Greek prefixes to describe them – this includes pentagons, hexagons, heptagons,
and others. Lastly, a question for you to ponder on: what do you call a 4-gon, a square or a rectangle?
Getting ready to export 105
Although nothing is stopping you from creating 3D objects with faces that can make up any type of
n-gon, you should avoid it in some circumstances. It’s not a hard rule but it’s something to keep in
mind. So, why is this important for us?
We briefly discussed the role of a Graphics Processing Unit (GPU) in Chapter 1, Creating Low-Poly
Models. Just as a reminder, a GPU takes a polygon and dissects it into the tiniest n-gon, namely a
triangle. So, when you throw a bunch of complex polygons such as a pentagon or worse at the GPU,
it processes these complex shapes to the best of its capability into triangles. This process is called
triangulation. The following figure shows a few examples of triangulation:
Figure 6.1 – The triangulation result could be different for the same polygon
Thus, when you leave the triangulation task to the GPU, it makes assumptions about which vertices
should connect. Keep in mind that we don’t want all the vertices to be connected, just the minimum
number without creating any overlapping edges. So, for a pentagon, we can have five different
triangulation cases. That’s a lot of guesswork for a GPU to know which one you’d prefer.
In Chapter 5, Setting Up Animation and Rigging, we discussed the role of topology, which mainly
involves distributing edges and faces. If you studied the content in more detail by following the URLs
provided in that chapter, you must have come across the notion of edge flow. If you have a rig that’s
supposed to bend the model, you’ll want the edges to follow a line as straight as possible into the bent
part. Consequently, it pays off to do your own triangulation to create a smooth edge flow or simply
avoid any n-gons altogether.
N-gons usually occur when you do loop cuts, but you can also create them accidentally while editing
other parts of your model without noticing it. A quick way to get rid of them, if you can’t avoid
creating them, is to connect some of the vertices manually. You’ll find an object with five vertices,
hence five edges sharing one face, inside the Ngons.blend file in the Start folder. That’s a 5-gon
or a pentagon right there. Let’s see how we can fix it:
1. Select the vertex at the top and one of the bottom vertices by holding Shift.
2. Press J to trigger the Connect Vertex Path operation.
106 Exporting Blender Assets
This may not look much different, but you have added one more face by connecting those two vertices.
You must have two faces now. Let’s do something similar but pay attention to the number of faces
shown on the right-hand side of the status bar. It should show Faces: 0/3 after you do the following:
1. Select the vertex at the top and then the other bottom vertex by holding Shift.
2. Press J to connect these two vertices.
After your previous edits, your pentagon will look like the third case in Figure 6.1. If you fancy it, you
can undo your steps and connect another set of vertices. Which vertices you should connect depends
on your situation, so there is no hard rule.
Despite the number of vertices staying the same, you now have two more faces and two more edges
compared to the initial state. Speaking of the initial conditions, take a look at Tris in the status bar,
and reopen Ngons.blend without saving; you’ll see that Tris in the status bar will still show 3.
That’s because the GPU was implicitly triangulating the pentagon. You have now explicitly defined
which vertices should connect, hence where the edges and faces should be.
Now that we have covered why and when it is important to fix the n-gons, here is a situation where
you may not need to be concerned about n-gons at all. If you have a model that you know, for sure,
you won’t be animating (hence there is no rigging that would require a clean topology), then you can
do without fixing your n-gons. Professionals insist on fixing n-gons because chances are the models
will be animated, so they do it just in case. However, you now know you also have a choice.
Setting origin points
An origin point is a point where all your transformations start. This often sounds a bit technical,
so sometimes, it’s easier to think of it as the center of gravity. However, that might be a misleading
definition because you can change the origin point for your models, whereas the center of gravity
doesn’t normally change in real life.
We must open Origins.blend in the Start folder to get to the bottom of origin points. For now,
let’s just look at the following screenshot:
Figure 6.2 – These two barrels look very similar, but are they?
Getting ready to export 107
The Origins.blend file will contain two barrels, one painted in red and another painted in yellow.
If you select the red and yellow barrels back and forth, you’ll notice that an orange dot inside the
outlined shape is in a different spot for each barrel. To get a better view of what’s going on, you can
switch to the Right Orthographic view by pressing 3 and observing that orange dot after you select
either barrel. That dot is the origin point.
Follow these steps to understand the role of the origin point:
1. Select the red barrel.
2. Press R to rotate and then X to constrain the rotation axis. Then, type -45.
3. Select the yellow barrel.
4. Press R to rotate and then X to constrain the rotation axis. Then, type 45.
The values for the rotation were carefully selected to make these barrels tilt toward each other so
that you can compare their final conditions. Although both barrels rotated the same amount, the
yellow barrel seems to have leaned closer to the ground. To compare your results, you can refer to
Origins-1.blend in the Finish folder, or take a look at the following screenshot:
Figure 6.3 – Barrels rotated toward each other by the same amount around their origin point
Did you realize that both barrels were rotating around their origin point? We could take this a step
further and place the origin point at the bottom of one of the planks of the barrel’s body.
To make the barrel look like it’s leaning around a more accurate pivot point, follow these steps:
1. Select the yellow barrel and press Alt + R to reset the rotation.
2. Go to Edit Mode and select the left-most vertex. Alternatively, hold down the middle mouse
button to get a better view of the vertex that goes along the green Y axis.
108 Exporting Blender Assets
We still need to complete a few more steps to set the new origin, but the following screenshot should
help you find this mysterious vertex:
Figure 6.4 – This vertex will be the new origin point soon
In Chapter 1, Creating Low-Poly Models, we briefly mentioned 3D cursors. You might be used to working
with other types of cursors, such as the ones you often see in a word processor or code editor. They
usually blink regularly and place the character right there when you type on the keyboard.
Well, this is a 3D cursor, and it doesn’t blink, but its role is similar. You can see it sitting where the X
and Y axes meet in the preceding screenshot. To move that 3D cursor to the selected vertex and set
a new origin, do the following:
1. Press Shift + S. A radial menu will appear and offer many choices for snapping.
2. Select Cursor to Selected or press 2.
The choice we selected snapped the 3D cursor to the vertex you have selected. We are not quite done
with moving the origin yet since we haven’t told the barrel object where the new origin is. For that,
we need to do the following:
1. Go back to Object Mode.
2. Right-click and choose Origin to 3D Cursor under Set Origin.
This will move the origin point of the barrel to the 3D cursor. That’s why we had to move the 3D cursor
to a specific vertex so that we could designate it as a new origin. The following screenshot shows the
context menu and where to find the origin options:
Getting ready to export 109
Figure 6.5 – Setting the origin is a common operation, so it’s part of the context menu
You can open Origins-2.blend in the Finish folder to see the yellow barrel applied with the
same rotation from before, but, this time, the rotation is happening around a different origin point.
In the end, in most situations, setting a new origin point involves going into Edit Mode to select
where you’ll move the origin, then shifting the 3D cursor to this point temporarily so that you can
set the origin in Object Mode. You could, of course, designate a completely arbitrary point outside
the volume of your objects as their origin too.
An origin point will be used in Godot later, similar to Blender. If you set the origin point for a door
at one of the hinges in Blender, rotating that door in Godot around the Y axis will use the hinge to
revolve the door so that everything will look correctly calculated and adjusted.
Applying rotation and scale
This is, by far, one of the most important topics to take care of before you export your Blender asset.
It has been mentioned several times in this book that looks can be deceiving. Applying rotation and
scale falls under the false looks category. Let’s understand this issue better by opening Scale.blend
in the Start folder.
You should see two cubes, as shown in the following screenshot, that are on either side of the X axis.
Also, the Transform panel is already expanded for you to look at the transform these cubes have, and
you can use the N shortcut to toggle it on and off in the future. An object’s transform is defined by its
location, rotation, scale, and dimensions, but we’re only interested in rotation and scale.
Those two cubes sure look the same, except one is green and the other is red, but they also are different
in another way. Start by selecting the red cube, then the green cube. Do this a bunch of times while
paying attention to what’s changing in the Transform panel.
110 Exporting Blender Assets
The following screenshot also shows you where you can find this panel:
Figure 6.6 – The Transform panel is in the top-right corner of the 3D Viewport area
Both cubes’ dimensions are 4 x 4 x 4 meters. Their location, individually, indicates where they are
supposed to be. So far, so good. The scale and rotation values tell us a different story, though. So, how
did this happen? Simply, the author of this file did what even the most advanced users sometimes
do: they started modifying the properties of the red cube in Object Mode, whereas the green cube
received its changes in Edit Mode.
Making such a simple mistake is quite common, and in fact, it may not even be considered a mistake
because sometimes, you just want to select things and start editing without worrying too much about
which mode the object is in. However, once you are done, you need to reset the rotation and scale
back to 1 for game engines to do their job. This is one of the most common things people fix before
they deploy their models to any game engine, so the situation is export format-agnostic. So, if you
want to export your files as FBX so that you can import them into Unity, you’ll still need to do this.
Luckily, the fix is simple. You can select the object that has a transform you want to fix, then press
Ctrl + A. A popup menu will ask you what properties you would like to apply, which will reset the
object’s transform for the selected property. The fifth option, Rotation & Scale, is what we are looking
for. When you trigger that option, you’ll see that the red cube’s rotation and scale values will reset to
their default values.
After you import your models into Godot Engine, or another game engine for that matter, when your
models behave in a weird way, such as some faces are missing or the animations are acting up, often,
the rotation and scale are the culprits. So, make sure they are zeroed in before you export.
Exploring glTF and other export formats 111
Naming things properly
Phil Karlton, who worked at Netscape, now a disbanded company that paved the way for browsing
the internet with their web browser Netscape Navigator, famously uttered the following words:
“There are only two hard things in computer science: cache invalidation and
naming things.”
This quote is often passed around as a joke but, like most jokes, there is a hint of truth. If not in cache
invalidation, there certainly is for naming things. Seeing meaningful names will make it easier for the
future you or for a colleague to remember and understand what was done before.
When you start with primitive objects, Blender will label them for what they are: cube, plane, light,
and so on. Your models will eventually get more complex at some point, and they will most likely
have parts that will no longer look like a cube. So, keeping the original names will make your life
harder at some point, both while working in Blender and Godot and even in another application if
you use your exported assets.
So, give your objects names!
Wrapping up
You’ll likely do some of these fixes more regularly than others. It’s easy to forget to apply transformations,
for instance, but it’s an easy fix. Changing the origin point is a useful method during the modeling
process for you to scale and rotate things smartly. In the end, you’ll most likely leave it at its last
position, so it’s OK to come back to Blender to set it to its permanent position for your game to apply
correct transformations later. Peruse the list of topics presented in this section as often as you need,
and you’ll develop a habit over time.
If you would like to practice the notions presented so far, we have prepared a Fix-Me.blend file
in the Start folder. We wanted to design a simple heavyweight very fast, so that effort left the object
with its default name. Also, its rotation and scale values look premature. While you are at it, you can
also fix the n-gon and move the origin point to a different corner.
At some point, you’ll eventually want to transfer your files to Godot. To that end, we often use exchange
formats when both applications don’t share a common file format. That’ll be the case for us since we can’t
directly open and process Blender files in Godot. Therefore, we will discover a file format, glTF, that’s
been gaining popularity in recent years. It will help us transfer our work in Blender to Godot Engine.
Exploring glTF and other export formats
Compatibility between different software has always been a delicate matter. Actually, with most
physical things, it is still a common problem even in modern life. Electric plugs and sockets, for
example, come in different shapes and sizes in many countries. At the time of writing, 15 plug types
112 Exporting Blender Assets
are used worldwide according to https://www.worldstandards.eu/electricity/
plugs-and-sockets/. You may want to make sure your devices are compatible before you leave
home for a long distance.
It seems there is no consensus on what type of plug is best. Similarly, when it comes to exchanging
data between different pieces of software, there are a plethora of options you could choose from. So,
in the next few sections, we will discuss different types of export formats to see why we should choose
glTF over other formats and how gITF is the better choice. Then, we will discuss gITF in detail.
Comparing gITF with other formats
Out of the dozen file formats Blender employs in its arsenal of export options, we’ll focus on glTF
because it works well with Godot Engine. That being said, let’s present a few popularly used formats
such as Collada, FBX, and OBJ first before we get to the good stuff:
• Collada: This format, which has DAE as its file extension, was conceived to be a data exchange
format between 3D applications. This sounds promising at first, but although a game engine
could be considered a 3D application, it’s not – at least regarding the way this format was
intended to be used. Collada was designed more for exchanging information between more
classic 3D authoring programs such as Blender, Studio Max, Maya, and others, but not so
much for game engines.
It’s based on XML, so you can open a Collada file with a text editor. This format fell out
of favor over time since the specifications were ambiguous and have been incorrectly
interpreted and implemented. For earlier versions of Godot, especially before glTF was out,
Collada used to be the preferred file type. Now, we have glTF as a much better option.
• FBX: This is a proprietary file format offered by Autodesk. Since there are no official format
specifications available to the public, and FBX’s license doesn’t let open source projects use FBX,
even if the specifications are privately acquired, there have been attempts to reverse-engineer
this format to write exporters for it. That’s how Blender implemented the FBX exporter to the
best of their guesses.
Additionally, Godot engineers did their best to implement an FBX importer. Nevertheless,
all this has been a bit of guesswork since the specifications are not open. To prevent hidden
surprises and for a more seamless transition over to Godot, we won’t use this format.
• OBJ: This is a simple plain text data format created by Wavefront Technologies. So, yes, this
too can be opened with a text editor. Plain text data formats offer ease of editing, but since they
are not compressed files, it’s often slow to parse and import them. OBJ suffers from a different
problem, though. It can’t store animations and light sources, but it’s a simple and good format
to primarily hold mesh information.
This also means it doesn’t store material and texture information. To achieve that, you need
to create an MTL file alongside the OBJ file you are creating. OBJ is an old and reliable
format and is considered an industry standard, but it’s not cut out for modern game engines.
Exploring glTF and other export formats 113
Now that we have seen which formats we won’t use, let’s focus on what makes glTF a better choice for
us. We’ll do this by providing a brief history of glTF, followed by presenting which settings we must
choose in Blender’s export settings for our efforts.
Introducing glTF
Short for Graphics Language Transmission Format, glTF was first released in 2015 by Khronos
Group, a member-driven non-profit consortium founded and empowered by many big corporations.
Not every member corporation is in the digital content creation business, but they have a stake in
the consortium because Khronos maintains other standards such as OpenGL and WebGL, two wellknown graphics APIs that serve many industries.
The discussion about the reliability of a file format might be important at this point, especially if
you are planning to reduce long-term maintenance problems and costs. For example, how many of
us remember the early internet days’ video file formats? Just to name a few, there was RealMedia,
QuickTime, DivX, and many others, for which we’d have to install codecs, plugins, and more just to
watch a few cat videos. Our desire to watch our furry companions never changed, thankfully.
Nevertheless, things coalesce eventually, and it gives way to better and more maintainable file formats.
Hence, guidance from a standards group such as Khronos is a good thing since they ensure that the
file format receives proper attention and stays up to date with the ever-changing needs of the industry.
glTF is one of these healthy cases, and the fact that it’s open source and many corporations would like
to support it is a good sign. It would be a terrible day if you had a bunch of assets sitting in your game
engine one day and you learned that you can no longer export in that file type. What would you do
with the existing assets – throw them out and convert them into a new format?
Now that we’ve had a brief history lesson, let’s get to know the relevant parts for us. We’ll utilize
Blender’s glTF implementation, which supports the following features:
• Meshes
• Materials (Principled BSDF) and Shadeless (Unlit)
• Textures
• Cameras
• Punctual lights (point, spot, and directional)
• Extensions
• Custom properties
• Animation (keyframe, shape key, and skinning)
We won’t use even half of this feature set. We discussed why we won’t fuss over cameras and lights in
Chapter 4, Adjusting Cameras and Lights, for we’ll set them up when we are building our game in Godot.
114 Exporting Blender Assets
A quick note on what Blender’s glTF exporter does with meshes: n-gons will automatically be
triangulated. So, it won’t be left to the GPU’s mercy. The Deciding what to do with n-gons section of this
chapter covered how to split faces into triangles if you need a reminder on how to triangulate manually.
Let’s finish this section off by presenting three different flavors of glTF you can use. To access the list
of variations, you’ve got to choose the glTF 2.0 (.glb/.gltf) option after expanding the Export menu
item in the File menu. In the pop-up screen that appears, you’ll see a Format dropdown on the righthand side, which will show the variations that you can see in the following screenshot:
Figure 6.7 – Three possible variations you can use for a glTF export
These format variations will work the same, regardless of what settings you choose. We’ll cover these
in the next section, so first, let’s get to know what each variation does:
• glTF Binary: This is the default option that will create a file with the .glb file extension. We’ll
use this variation throughout this book, and you’ll most likely use it in your workflow as well
since it stores everything you need in one file, and it’s compressed. This makes it easy to share
with other people and transfer over the internet.
• glTF Embedded: This is similar to the binary option, except it converts all the data into a JSON
text format, similar to some of the other file formats we discussed earlier in this chapter. This
will result in a file with the .gltf file extension and will make the file size larger but open to
easy modifications with text editors if you wish. There is no practical reason why we should
choose this variation over the binary option.
• glTF Separate: This last option will create many files: one file with the .gltf file extension,
similar to the one you get if you choose the Embedded option, then a .bin file that holds
the data, and optionally all the textures you’ve used with either .jpg or .png extensions. So,
it likes to keep things separate. Since the data is stored in the .bin file, it keeps the .gltf
portion smaller, unlike the Embedded variation. Nevertheless, there is still no practical reason
Deciding what to export 115
for us to prefer this format. Also, if you had to send your model away, you’d have to remember
to send all the separate parts too.
Regardless of the variation, the importing software will follow the glTF instructions set by the Khronos
standards group to create your models, materials, animation, and others. So, choosing a variety may
only be needed when it’s necessary and for more advanced cases. For our work in this book, the binary
variation will satisfy our needs.
Now that we know which variation is best for us, we must reflect on our own needs so that we can tick
the right options in the exporter’s interface. That’s what we’ll cover in the next section.
Deciding what to export
Not everything in your scene should be exported. For example, as mentioned previously, we will
create the camera and light conditions for the game world inside Godot Engine. So, once that’s done,
there is no need to keep a camera and light object in your Blender scene. However, they might be
useful for you to take test renders to get a better feeling for your scene without constantly exporting
your models to Godot. In this section, we’ll determine the better export candidates and how to use
the export settings to facilitate that.
The export options are categorized, and we’ll go through some of the options where appropriate. We’ll
do this by discussing how these options relate to the objects you have in your scene. Note that the
export window is separate, so you don’t need to close it before you select your objects in the scene.
You can go back and forth between these two windows during this effort.
Include
Although the category’s title is straightforward, the implications of what to include might be very
important. By default, none of the options in this category are selected. So, it’s up to your workflow.
There are two groups you will see when you expand this section:
• Limit to: This is where you select what you want to include specifically as a mesh. We’ll discuss
this in more detail in the upcoming paragraphs.
• Data: Anything that is not a mesh could be considered data. For example, cameras and lights
are not physical objects with mesh information but complementary tools that help you render
a scene. We’ll leave everything under here unchecked.
By default, all the options for both groups come unchecked. We’ve already said to leave the data
untouched, but out of the four choices you can select under the Limit to section, the most important
one is Selected Objects.
If you leave this unchecked, then Blender will include everything in your scene. This means that at the
end of our exercise in the Setting origin points section, when we had two barrels, Blender would try
to export both of those barrels. That’s not something you’d most likely want. Chances are you’d want
116 Exporting Blender Assets
to design a barrel and export only that to Godot. So, we’ve got to have the Selected Objects export
option checked first. Then, we need to go into our scene and select the object(s) we want to export.
There might be some inconvenience in doing this so easily, though.
We have been designing relatively small models with a few different parts. The greatest number of
separate parts we designed was with the three distinct parts of a barrel. In the future, during your
work, if you happen to have a dozen or more parts in your Blender scene, it will quickly get tedious
to select all these parts again and again before you hit the export button. If only we had an option
that would not export the camera and light but what we deem as important so that we can have the
best of both worlds…
That option is Visible Objects. Start by deselecting Selected Objects and keep the Visible Objects
option on. For this option to work for us, we need to hide the camera and light objects so that they
are no longer considered candidate objects to the exporter. You can do that by clicking the eye icon
in the Outliner area for any object you don’t want to export.
In the end, you have a mixed bag of solutions when it comes to what to include in your export. There
are no right or wrong answers here, but you must choose what’s efficient for you.
Transform
We’ll cover this category for the sake of completeness. You’ll rarely touch this category since it has one
and only one option, which is on by default. Let’s explain why, though, and learn what +Y Up means.
In Blender, the three axes or the coordinate system, XYZ, is set up, so the Z axis defines how tall or
elevated an object is. In some other applications, such as Godot Engine, the Y axis is used as the going
up axis. So, the higher the Y position of an object is in Godot Engine, the higher it sits in the game
world. Therefore, this Blender export option converts Blender’s Z axis into Godot’s Y axis. It’s a handy
thing, so you don’t have to arbitrarily rotate your models so that they match the correct direction.
Geometry
We’ll leave most of the options under this category as-is and only discuss what matters to us. These
options are as follows:
• Apply Modifiers: We first discovered modifiers in Chapter 1, Creating Low-Poly Models. We used
a few that helped us model a barrel in no time. The fact that you can stack modifiers and change
the order of operation is great. However, they are temporary additions to the core objects. So,
unless you turn this option on in the export settings, the base object will be exported without
any modifiers applied. This will make your objects look quite awkward and primitive in Godot.
• Materials: The default status of this option is to export all your materials. This might be a good
thing for a beginner or quick results. When we discuss materials again when we cover Godot,
and should you decide to make your own materials in Godot, you may want to pick the No
Export choice so that they are no longer included in the resulting file.
Summary 117
In more advanced export scenarios, you may want to enable the Loose Edges and Loose Points
options as well, so you can keep the loose geometry as a part of the exported file.
Animation
We won’t change any of the default options in this category. We discussed how to create multiple
animations in the Getting animations ready for Godot section of Chapter 5, Setting Up Animation and
Rigging. The default settings will take care of converting the animations – more specifically, actions.
Creating presets
If you find yourself turning some of the options on and off under certain scenarios and memorizing
the correct combination is becoming hard or monotonous, you can create a preset of export options.
The top part of the export options has a dropdown with two buttons next to it. Using that area, you
can create your own presets – perhaps one for a selected objects case and another one for a visible
objects case.
Choosing the correct export options depends on the different conditions your project requires. So,
you must experiment and find what works best for you. At some point, you’ll import the result into
Godot Engine to visualize the glTF file. However, that might be a lot of work to go in between two
applications if you want to get a quick feeling about your creation. The following are two options you
can use to preview glTF files:
• glTF Viewer at https://gltf-viewer.donmccurdy.com/
• Microsoft 3D Viewer
This concludes the investigation of the export options that are relevant to our case. Let’s see what other
discoveries you have made so far.
Summary
This chapter was mainly about making your work compatible with Godot Engine. To that end, we
needed to go over a few different topics.
Firstly, we wanted to make sure our models had received the correct final touches. This involved
getting rid of n-gons and converting these polygons into more manageable and ideal triangular faces.
After that, you learned how to set origin points for your models, which may also be helpful during the
modeling phase. Making transformations permanent is essential, so that’s something to remember if
your models, especially during animations, behave awkwardly. Then, we looked at the idea of naming
things meaningfully. This is something you’ll eventually find yourself needing more and more down
the line when you have more experience.
118 Exporting Blender Assets
Then, out of the many formats Blender offers for exporting assets, we evaluated a few, such as
Collada, FBX, and OBJ. During that effort, we presented that glTF has become the de facto format
for communicating between Blender and Godot. Lastly, we discovered some options for the glTF
exporter and presented a few likely scenarios you may wish to employ. Finally, you learned how to
store the export options that work best for you.
Now, we’re ready to start importing our Blender assets into Godot. That’s exactly what we’ll do in the
next chapter. In a real-life scenario, chances are you’ll be conducting the operations presented in this
and the next chapter quite often in almost every phase of your game development journey. Let’s give
you a few more useful resources before we move on.
Further reading
Khronos Group is a maintainer of many other standards we use day-to-day. This is thanks to their
impressive list of members, which you can view at https://www.khronos.org/members/list.
We primarily used their glTF standard. The following links provide more technical information about it:
• https://docs.fileformat.com/3d/gltf/
• https://docs.fileformat.com/3d/glb/
• https://www.marxentlabs.com/gltf-files/
• https://www.marxentlabs.com/glb-files/
Thanks to its nifty specifications, the glTF exchange format has been gaining popularity not only in
the gaming industry but in other industries as well. Here is NASA’s famous Voyager spacecraft in all
its glory: https://solarsystem.nasa.gov/resources/2340/voyager-3d-model/.
You may have come across websites where Collada is still used for Godot projects. Perhaps you already
have access to a large repository of Collada files. If you would like to give it a try, but with a bit more
finesse, here is a GitHub repository that can help you: https://github.com/godotengine/
collada-exporter.
Last but not least, cleaning up your models and keeping them export-ready will be an ongoing task.
Blender’s user manual has a page on many tools and methods you can use to help you in your efforts:
https://docs.blender.org/manual/en/2.93/modeling/meshes/editing/
mesh/cleanup.html.
7
Importing Blender Assets
into Godot
You’ve come a long way. Your models are ready. Their scale and rotation values are fixed. What’s left
to do? Import them into Godot, of course! Hopefully, you’ll find the importing process much more
straightforward. This is a transitional chapter that covers mostly Godot topics with a minimal amount
of Blender involvement.
We’ll start this chapter by showing you how to create game objects using your imported models with
the click of a button. This process will convert the glTF files into game objects – more specifically,
scenes in Godot terminology.
If you must fix something with your models or add detail, where can you do this? Since you are now
in Godot, it’s tempting to fix the models in Godot, but this is counterproductive. In this chapter, we’ll
show you how you can update your Blender file and reflect the changes in Godot.
In Chapter 2, Building Materials and Shaders, we learned how to work with materials in Blender.
We’ll revisit this topic in the context of Godot so that we can understand how materials work in both
applications. We’ll present the pros and cons of handling materials in either application so that you
can decide which one works best for you. Whether you are working alone or in a team, there are a few
decisions that can either save a lot of time or be frustrating down the line when you realize you’ve got
to make a fundamental change. A decent material pipeline is one of these topics.
In Chapter 5, Setting Up Animation and Rigging, we stored two actions in our snake model. We’ll
import that model to see how Godot handles the animations stored in a glTF file. This chapter will
only cover how to import animations; how to use imported animations will be covered later in this
book when we build our point-and-click adventure game.
Thus, you’ll be presented with some of the crucial building blocks and practices that will serve you
in later chapters and your game projects.
120 Importing Blender Assets into Godot
In this chapter, we will cover the following topics:
• Making a scene!
• Going between Blender and Godot
• Deciding what to do with materials
• Importing animations
By the end of this chapter, you’ll be able to take your glTF files and convert them into usable Godot
assets, decide what to do with materials from a project pipeline perspective, and make sure you can
access the animations that come with a model file.
Technical requirements
As mentioned in the Preface section, we assume you already know your way around Godot for basic
things such as creating and composing scenes, adding scripts to nodes, using the Inspector panel to
change the conditions of your game objects, and more.
However, if you are a novice in Godot Engine, then you may want to start with the official learning
material at this address first: https://docs.godotengine.org/en/3.4/getting_
started/introduction/.
Throughout this book, we’ll be using Godot 3.4.4. There may always be something new or missing even
between minor versions. Should you be using a different version when you are reading this book, you
can either switch to the version this book is using or read the detailed changelog for different releases
for the appropriate version listed at https://godotengine.org/news.
This is still a transitional chapter; as is the previous and the next chapter. We’ll create a new Godot
project in Chapter 9, Designing the Level, and work within that Godot project in later chapters to make
a point-and-click adventure game. Until then, we can make do with temporary Godot projects. This
means that in this chapter and the next, we won’t be concerned at all with the structure of our files
and folders. However, the sections in this chapter have been laid out in a way that we assume you are
still working on the same Godot project.
As usual, this book’s GitHub repository at https://github.com/PacktPublishing/GameDevelopment-with-Blender-and-Godot contains some files that are relevant to this chapter.
Making a scene!
In a typical 2D game built in Godot, using a sprite node is essential. You would then assign a texture
to your sprite nodes in Godot’s Inspector panel. The 3D version is essentially the same, but it involves
using a MeshInstance node and then assigning a mesh to it. So, what textures are to sprite nodes is
what meshes are to mesh instance nodes. Although creating a Godot scene that just has a sprite node
and instancing this scene in a bigger scene is possible, it’s overkill since you could easily attach the
sprite node itself to the big scene.
Making a scene! 121
This is where it makes sense to treat mesh instances differently and store them in their own scenes,
unlike sprites, since 3D models have a lot more going on than getting assigned just one texture.
Additionally, since a 3D model has a lot more moving parts, assigning individual meshes to mesh
instances could be tiresome too, so let’s do better. The goal of this section will be to create a scene out
of a 3D model and to automate how to assign meshes to mesh instances.
Adobe Animate
Godot’s scene concept incorporates a lot of notions you might be familiar with if you have
worked with Adobe Flash in the past, or Adobe Animate these days, which uses movie clips,
similar to what Godot does with its scenes. Creating nested movie clips and binding scripts
is very handy, which is pretty much how a Godot project goes. Despite this similarity, there
comes a moment in Godot when it makes sense to consider a 3D model its own scene, which
is what this section will cover.
We suggest that you start a fresh Godot project for this section. Once you’ve done that, you need to
find the Sconce.glb file in the Start folder for this chapter. You have two options at this point.
First, you can copy and then paste this file, using your operating system’s filesystem, into where your
Godot project folder is. Alternatively, you can drag the sconce file to the FileSystem panel of Godot.
When you make a glTF file as part of your project, you’ll have something similar to the following:
Figure 7.1 – The Sconce model is now part of your Godot project
122 Importing Blender Assets into Godot
Did you have a red cross as an icon for your Sconce.glb entry too? This doesn’t happen all the time,
but that icon indicates there is a configuration problem; luckily, the fix is easy. Restarting Godot fixes
the issue most of the time. If that doesn’t work, then we’ll have to press a button to reimport the file
for Godot to configure it for us. The preceding screenshot also shows the Import panel in focus. You
can click the Reimport button at the bottom of that panel to make the file compatible with Godot.
Something else happened while we were discussing the icon issue. There are two material files in
our project:
• DarkMetal.material
• Fire.material
These materials came within the glTF file that was exported from Blender since we opted to keep the
materials. If you need a refresher on this, you can read the Deciding what to export section in Chapter 6,
Exporting Blender Assets. By default, Godot will place the materials next to the model file. You may
want to place your models and materials in separate folders for organizational reasons. We’ll discuss
something related to this in the Deciding what to do with materials section later in this chapter.
We’re now ready to make a scene using the sconce model. This effort will create all the necessary
bindings to display a Blender model in Godot. To achieve this, you must do the following:
1. Double-click the Sconce.glb entry in the FileSystem panel.
2. Click the New Inherited button on the pop-up screen.
The pop-up screen will display another button beside the one you’ve just clicked. There is also a
piece of information about what each button does but it might be confusing, so let’s explain it. In
layman’s terms, the Open Anyway button will let you see the contents of a glTF file, but this will be
read-only. Since you may want to make alterations, such as attaching scripts, you’ll often click the
New Inherited button.
If you bring up the Scene panel, you’ll see that your last effort has created two MeshInstance nodes
under one Spatial node. When you click either the Sconce or Flame mesh instance node, you’ll see
their mesh bindings in the Inspector panel. We didn’t have to create all this structure and bindings
manually; creating a scene out of a glTF file did it all for us.
When you have finished examining what’s changed so far, you can save your file as Sconce.tscn
since it is still a temporary construct as far as Godot is concerned. The following screenshot shows
our progress:
Going between Blender and Godot 123
Figure 7.2 – You have created a scene with a click of a button
You can now utilize Sconce.tscn in other scenes by creating more instances of it. For example,
in most 2D platformer games where there are enemies, you would have to create instances of scenes
that stored the enemy character sprites. This is similar. Hence, every time you need a sconce, you can
use the Sconce scene instead of the model file. We’ll create many more instances of this scene when
we work on our game later in this book.
Creating a scene out of a model file was easy, but how easy is it to change it? Either the sconce or the
flame could use a bit of touch. We’ll tackle how to update our models in our scenes next.
Going between Blender and Godot
In later versions of Godot, specifically starting with Godot 4.x, you’ll be able to directly import Blender
files into Godot and interact with them. Saving things in Blender will automatically update the situation
in Godot. We are not there yet. At the time of writing, we must resolve to an already tried and tested
method: re-exporting our assets. Let’s see how we can accomplish this easily.
While you are developing your game, you’ll likely want to make changes to your models. Perhaps
you’ve been working with a prototype that your 3D artist friend or contractor provided a while ago.
Now, they are ready to give you a more refined piece. So, let’s simulate a similar scenario by making
modifications to the sconce model we’ve been using. If you want to skip the Blender parts, you can
find the finished changes in the Sconce.blend file in the Finish folder. If you want to exercise
124 Importing Blender Assets into Godot
some Blender muscles, then we suggest that you make two changes in the Sconce.blend file in
the Start folder. These changes are as follows:
• Move the tip of the flame so that it doesn’t look too pointy. (Hint: go into Edit Mode.)
• Replace the flame material with something that is bright yellow. You can pick a name such as
HotFire for it. (Hint: Remove the old material and add a new one.)
We’re applying two important changes to our model. First, we are changing the geometry of our model,
however minor it might be. Second, we are introducing a new material instead of changing the color of an
existing material. All there is left to do is re-export our model and overwrite the existing Sconce.glb
file in our Godot project. Chances are, if you were following along, the Sconce scene in Godot is still
open, and despite overwriting Sconce.glb in the project, it looks like nothing has changed.
If you restart Godot, switch to a different scene tab, or do any other thing that would refresh the
view, then you’ll see your updates. Otherwise, you may still have the same old look. There is a general
refreshing problem, it’d seem. Hopefully, little things like this will be fixed in future versions of Godot.
The following screenshot shows the updates you will see:
Figure 7.3 – The flame is hotter and straighter with our newest changes
While we successfully updated the Sconce scene, we also introduced a new material to the project. The
import process was smart enough to know there was a new material coming in, but it was judicious
enough to keep the old materials, just in case they might be needed and used sometime later in
your project.
Deciding what to do with materials 125
This could lead to having lots of unused files over time. That is not the worst of your problems, though.
There is a much more insidious thing waiting for you when you import more and more models and
eventually lose track of what’s happening due to the sheer number of files as your project grows.
In the next section, we’ll present a scenario where importing glTF files straightforwardly as we have
done so far may cause some problems.
Deciding what to do with materials
An important decision awaits you. When you were exporting your Blender assets in Chapter 6, Exporting
Blender Assets, we briefly discussed what the export options in the exporter’s UI meant. However, we
never really talked about the implications of keeping the materials or not. In this section, we’ll present
the pros and cons of handling materials in Blender versus Godot.
Let’s assume you are now ready to import another model. For example, the Vessel.glb file in the
Start folder is something you want to add to your game. If you take a look inside the associated
Vessel.blend file, you’ll notice that we are using a material labeled as DarkMetal. Ironically,
perhaps accidentally, someone has decided to pick a light color, but the name, regardless of what the
intentions are, is the same material name we used in the sconce model file.
So, what will happen when we import this file into Godot? To find out, follow these steps:
1. Add Vessel.glb to your Godot project.
2. Turn this vessel model into a scene. For familiarity’s sake, save it as Vessel.tscn.
The following screenshot shows the new scene, as well as the status of the FileSystem panel:
Figure 7.4 – Everything is kind of looking OK, but shouldn’t this vessel have a lighter color?
126 Importing Blender Assets into Godot
Despite the mislabeling in Blender, we knew what we wanted for the vessel’s color. It was supposed
to be a lighter color but that’s not what we are seeing in Godot. While importing the vessel model,
since there was already a material with the same name in the project, Godot chose not to duplicate the
resources. This is efficient, perhaps, but not accurate. This kind of thing could easily happen, especially
if you are utilizing someone else’s files. Luckily, only the new stuff doesn’t look correct. In other words,
the incoming resources are not overwriting and messing up the existing resources.
So, what do we do to make the vessel show the color we want? We can offer a few suggestions that
are more organizational solutions. Thus, this is not a technical but a workflow or a pipeline type of
solution as it is often labeled in the industry. Therefore, the solution lies in how you want to treat
your files in your project, and whether you are working solo or in a group. These suggestions are to
do the following:
• Label Blender materials by purpose
• Label Blender materials by color
• Import your models into separate folders
• Use a staging area in Godot
None of these suggestions is a magic pill. You have to try and decide if they’re beneficial for you.
Also, sometimes, projects of different sizes make some of these solutions easy or difficult to apply.
The decision is yours after you learn what each one entails.
Labeling Blender materials by purpose
Naming materials in Blender by their shade, such as DarkMetal, can only go so far. How dark are
we talking about? Sooner or later, we will find ourselves playing a game of adjectives: dark, darker,
darkest, and likewise. It will get worse when we want to pick a lighter version of the dark tone we
have already picked.
Typically, a sconce’s base is wrought iron. Since it’s a metal, it makes sense to use the word metal in its
name, but it could easily get confusing. Instead, you could use the object’s name for its material title.
So, you’ll have Sconce.material once you import it into Godot.
Labeling Blender materials by color
If you want to go with color-like labels, then you can make this obvious and in a unique way without
leaving any room for Godot to interpret it in its own way. The Hex value in Blender for the DarkMetal
material is 393646. You could use that as a label. Hence, once imported, you’ll have this material as
393646.material.
Deciding what to do with materials 127
Keep in mind that you’ll often get busy and distracted while you are authoring your models and find
yourself fine-tuning a lot of things in your models, whether it’s geometry, materials, animations,
and much more. So, if you have already chosen a hex color as a name, and later alter the color of the
material, then you will have to remember to update the name.
Importing your models into separate folders
Some people organize their Godot projects so that they have separate folders for bigger concepts. This
includes materials, models, scenes, and scripts. If you want to make sure your materials are unique
to the model you are importing, a safer and easier way to do this is to create custom folders inside
a specific folder. For example, if you have a Models folder at the root of your project, instead of
dumping all the glTF files into this folder, you can create subfolders named after the model you are
importing. In our case, this is the structure you’d see:
• Models > Sconce > Sconce.glb
• Models > Vessel > Vessel.glb
Then, all the relevant materials for each glTF file will be contained in their own folder. This might
seem counter-productive at first since the same material file will be duplicated in different folders,
especially if the material’s names are color-coded. However, you’ll at least know what you are importing
is what you want in the first place.
This method might be advantageous in some scenarios. Maybe you are designing more than one
sconce style for your game. In this new style, despite the wrought iron part having a different shape,
it’ll most likely use the same material. Then, you can easily rename the folder as Sconces to store
multiple sconce files. This way, you’re intentionally agreeing with the fact that Godot will not create
duplicate materials but use the first imported model’s material.
Last but not least, let’s cover a caveat about this technique. If you are importing your files by dropping
them over the FileSystem panel, you’ve got to be careful since that panel is context-sensitive. This
means that you need to have the appropriate folder selected in the entry list. Otherwise, whichever
entry is selected will be the recipient. To be sure of where you are sending your files, you can do all this
by using your operating system’s filesystem. When you switch to Godot, your files will be processed
and, depending on the speed of your system, you might see a progress bar showing the progress of
the import.
Using a staging area in Godot
Last in our list of possible solutions to making sure models and materials are imported properly is
to use a staging area. This means, similar to using unique folders for models, you can designate a
folder to monitor what’s going on with a model. Perhaps this is a folder labeled as Staging inside
the Models folder.
128 Importing Blender Assets into Godot
Using the search functionality in the FileSystem panel, you can even check if there are duplicate materials
in other folders. This is a safe way to compare materials because you can observe their properties
in the Inspector panel. If there are no obvious differences, and you deem it safe, you can just move
the relevant glTF file to its final place while ignoring the duplicate material file in this staging area.
This requires a bit of work, but it might be a necessary practice in larger teams so that you can decide
and even notify the artist if there are obvious labeling mistakes. For example, if there is a typo for the
same material that multiple similar models should use, you won’t end up with two separate materials.
Wrapping up
Out of all these options, and perhaps a few more you may find online, you must decide which one
works best for you. It’s a common thing that you’ll start one way and switch to an alternative method
as your project’s needs change. Although your choice might have technical ramifications, it’s rather a
business decision; so, weigh up the pros and cons while making it.
There is one more thing you can do regarding your materials and models, but since this chapter is
about importing, we’re intentionally leaving it for later. It’s when you decide to create your materials in
Godot and bind them to the meshes of a model manually because, sometimes, you find models with
just their meshes but with no material information. We’ll show you how to create materials in Godot
in Chapter 9, Designing the Level, in the Constructing the missing materials section.
Now that we seem to be done with material things, in the next section, we’ll learn how to import the
animations we created for our snake in Chapter 5, Setting Up Animation and Rigging.
Importing animations
The last thing we’ll cover about importing Blender assets is animation. Thus far, we have taken care
of importing the mesh and materials of a model. We even discussed workflow problems concerning
the default import workflow for materials. Hopefully, there won’t be a hidden surprise in importing
animations, but how do we do it? You’ll find out in this section.
You can start by moving the Snake.glb file in the Start folder of this chapter to your project.
Then, as shown in the Making a scene! section, you can create and save a scene out of this model. The
snake model will bring a lot of its materials, and your FileSystem panel will look a bit crowded, but
this is what we have so far:
Importing animations 129
Figure 7.5 – The snake has followed you to Godot Engine
This is a good time to introduce some of the 3D nodes Godot uses. We’ll utilize the snake scene for
this effort because it has a good sample of different nodes you’ll most likely use in your projects.
The root node is of the spatial type. Godot’s chosen color for all 3D nodes is red. If you’ve been using
Godot’s Node2D nodes, which have a blue circle icon, Spatial nodes are the equivalent of that, only in
3D, and they are red. Whereas a Node2D node will have coordinates only in the XY plane, a Spatial
node will have them in the XYZ plane. You usually employ this kind of node as a root container for
other nodes. For example, the Armature and AnimationPlayer nodes are the direct children of the
root Spatial node, which is labeled as Snake.
Node types versus labels
In the snake scene, the MeshInstance node has been renamed Snake, which is useful so that
you can differentiate if you have a lot of mesh instances. There is no built-in Snake node type
in Godot, but it’s okay to just say Snake node, even though it’s of the MeshInstance type.
The Inspector panel will figure out the type and only list the relevant properties. Therefore,
throughout the rest of this book, we’ll refer to the scene’s nodes either with their custom labeled
names or node types.
We’ll soon analyze the role of AnimationPlayer, but let’s finish looking at the MeshInstance and
Skeleton child nodes first.
130 Importing Blender Assets into Godot
MeshInstance and Skeleton
We made an analogy between the MeshInstance and Sprite nodes in the Making a scene! section,
stating that they are responsible for holding visual elements in 3D and 2D spaces, respectively. So,
that leaves us with the Skeleton node.
In Chapter 5, Setting Up Animation and Rigging, we used bones and attached them so that we could
animate the snake. When the Snake.glb file was imported, the bones were imported as a single
unit. In other words, Godot grouped all your bones into a node of the Skeleton type. However, you
can still access each bone if you wish:
1. Select the Skeleton node.
2. Expand the Bones section in the Inspector panel.
3. Expand some of the entries, especially 9 and 10.
Do you recognize the names? These are the names you picked for the bones in Blender. Look at how
much preparation we require to construct a skeleton. The rigging process to create all this, however
complicated it may have looked initially, is still far too easy to do in Blender compared to Godot.
Now, let’s turn our attention to the last node type in the scene to further appreciate why doing the
animation in Blender was also a superior and preferred move. Enter AnimationPlayer.
AnimationPlayer
The last node in the Snake.tscn scene is AnimationPlayer. The color of this node is neither blue nor
red. This means you can use it in both 2D and 3D contexts. You may already be familiar with this
node if you have been building 2D games. If that’s the case, then you know that you need to place
keyframes in the player’s timeline to mark the changing points, just like we did in Blender. Regardless
of whether you have experience with AnimationPlayer or if this is the first time you are tackling it,
you’ll notice that creating so many keyframes, as shown in the following screenshot, is a lot of work:
Figure 7.6: You worked smart, not hard, to create all those keyframes in AnimationPlayer
Importing animations 131
Each orange diamond in the preceding screenshot is a keyframe and marks an important turning point
in the animation’s life cycle. This is the timeline for the Attack action we created in Blender. You can
see it in a dropdown in the top section. This is the main reason why we opted for Blender to create
all this for us – we were only concerned with the major events, not with what exactly happened in
between major events. Godot and Blender worked together to fill in the details. Also, updating your
animation in Blender is still a much better idea than fiddling with those diamonds.
As you can see, animations and actions are automatically imported, recognized, and organized in
AnimationPlayer for us. Despite how easy this was, there is currently a bug in Godot regarding the
animation imports. So, we need to do something about it that may not be necessary in the future.
We’ll discuss what the problem is and present a solution here. However, to follow the discussion
and updates on the problem, you can go to https://github.com/godotengine/godot/
issues/34394.
On the right-hand side of the Animation panel, there is an icon that looks like a recycling symbol.
At the time of writing, that loop button, which is supposed to play an action indefinitely, only works
while you are editing a scene. So, even though you can toggle the loop button on, the action will play
only once when you launch the game. Hopefully, soon, newer Godot versions will fix this looping
issue. Still, it makes sense to present a workaround for the time being.
Separating actions
Luckily, there is a solution to the problem we’ve just presented. We’ll instruct Godot to separate the
actions into separate files, similar to the way materials for a model are kept in the filesystem.
The default behavior for keeping animations for a model is to store them inside its file. In this case,
the Snake.glb entity is holding all its animations. To extract these animations, follow these steps:
1. Select Snake.glb in the FileSystem panel.
2. Switch on the Import panel and scroll down to the Animation section.
3. Choose Files (.anim) in the Storage drop-down options.
4. Click the Reimport button.
132 Importing Blender Assets into Godot
The following screenshot shows the steps we have taken so far:
Figure 7.7 – The import settings for the Snake.glb file
This will extract the actions into the filesystem. In the end, you’ll have two more files in your project:
• Attack.anim
• Idle.anim
These are the actions you defined in Blender a while ago. Also, similarly named actions are listed in
Godot’s AnimationPlayer dropdown. For example, Figure 7.6 shows the Attack action selected. There
is one more step left for us to fix the looping issue – it’s to reintroduce these actions we’ve just separated
back to AnimationPlayer, even though it’s already listing them. To achieve this, follow these steps:
1. Switch the Scene panel on.
2. Select the AnimationPlayer node in the scene structure.
3. Click the Animation button in the Animation panel (the button to the left of the
Action dropdown).
4. Choose Load and select Attack.anim from the Open a File pop-up menu.
5. Repeat Step 4 to load Idle.anim.
This will replace the existing actions with the actions coming from your filesystem. The following
screenshot shows where you can find all these names since there have been a lot of similar words.
Here, the Animation button has already been pressed and is displaying the available commands:
Summary 133
Figure 7.8 – The Animation panel’s menu for loading, saving, and doing many other things
In the future, hopefully, you won’t have to separate and reimport your actions with newer versions of
Godot. For the time being, this will work, but we won’t see the effects of this until we get to the later
chapters of this book, where we will trigger these actions.
Summary
Since we took care of exporting Blender assets in the previous chapter, it was time to learn how to
import these into Godot. This is what we covered in this chapter.
First, we learned that once a glTF file is part of a Godot project, Godot automatically takes care of things
such as separating materials. That being said, since we’d most likely keep creating more instances of 3D
assets, we looked into creating dedicated scenes out of glTF files. Moreover, we learned how to make
modifications to our models in Blender and get the scenes using these models updated back in Godot.
Then, we covered materials, which is an enmeshed topic within the model workflow, and discussed
different ways of labeling the materials, and even keeping the models in separate folders to prevent
any material file from overlapping. You decided what works best for you since this kind of thing might
be team-size or project specific.
Finally, we tackled how easily animations can be imported. Creating a scene out of a model took care
of all the scaffolding. Even though we’ll learn how to trigger animations in later chapters, especially
for looped animations, we presented a problem that may occur. A workaround was presented, and
we hope you won’t need this in the future.
This was your first chapter on Godot and you’re now officially using Godot Engine. Importing 3D
assets into Godot is an essential operation, and we hope you have a seamless back-and-forth between
Blender and Godot for your games.
134 Importing Blender Assets into Godot
In the next chapter, we’ll still work on a standalone topic, Adding Sound Assets, to keep things simple.
By the end of the next chapter, we’ll have covered the basics of setting up a project structure, which
means we can focus on building the game after that.
Further reading
You’ve already interacted with the Import panel of Godot. That area has a lot of settings that would
require us to write a chapter to investigate all possible combinations. The default settings work most
of the time but there is a Preset button in the top-right corner that lists the most used combinations.
Since the needs of a project, and thus the import requirements of a model, won’t be clear ahead of time,
we leave the task of discovering what those options entail to you. That being said, here is the official
resource that can guide you if you want to get more information: https://docs.godotengine.
org/en/3.4/tutorials/assets_pipeline/importing_scenes.html.
Similarly, you may want to import images instead of 3D assets. This is necessary when you are building
UI elements for a game. We’re mostly covering the 3D workflow throughout this book, so we won’t
emphasize the import settings for 2D assets. Nevertheless, if you want to be informed before we
tackle the UI topics, here is the official URL: https://docs.godotengine.org/en/3.4/
tutorials/assets_pipeline/importing_images.html.
8
Adding Sound Assets
Sound is often the most neglected part of game projects. While creating visual assets may seem hard
to do, a lot of us still tackle it because we get quick and reliable feedback, however, most people don’t
even know where to start when it comes to producing sound assets. Luckily, there are royalty-free
assets out there that you can use.
This chapter will not cover how to make sound assets but how to import them into your game. We
will focus on some of the technical aspects of sound management in Godot. This involves learning
about the different sound formats the engine supports. Picking the appropriate sound format is no
different than ironing out a topology for a 3D model for animation. Choose wisely and, even better,
know the benefits and limitations of each format.
Next, you will learn when and how some sound assets should be looped. We’ll investigate the import
options for different sound types and mention format-specific differences. We’ll also discuss scenarios
where it makes sense to have your sound assets looped.
Lastly, we’ll get to know different types of Godot nodes that are responsible for playing sound assets
in your scenes. This way, you can pick the appropriate audio player node for your project. To finish
off, we’ll play some sample sound assets to show the differences between these different nodes.
Needless to say, to make the best of this chapter, you may want to be in a quiet place where you can
practice some of the topics, especially in the later sections of this chapter.
In this chapter, we will cover the following topics:
• Learning about different sound formats
• Deciding on looping or not
• Playing audio in Godot
By the end of this chapter, you’ll know how to import sound assets, choose which file type is correct,
configure their settings, and play them in your project automatically or when it’s needed.
136 Adding Sound Assets
Technical requirements
Unlike the other chapters, instead of a Finish folder with individual assets, we’ll give you the finished
Godot project with all the scenes and scripts set up. Nevertheless, we would like you to practice but
focus solely on the topics presented in this chapter. Thus, we suggest you start with a clean slate, import
the sound files from the Start folder, and follow along. Following tradition, the necessary resources
can be found in this book’s GitHub repository: https://github.com/PacktPublishing/
Game-Development-with-Blender-and-Godot.
Learning about different sound formats
Sound files come in different formats, just like graphics files can come in different formats including
JPG, GIF, PNG, and others. The industry, and sometimes the consumers, define the fate of these
formats. Let’s place the consumers in the right context here. Occasionally, the specifications laid
out by the creator of a file format are not welcome by the people who are using this very format to
produce the work. Then, the work is created but not accepted by the platforms that would disperse
such content due to technical reasons. It’s almost like a tug of war where the inconvenience or the cost
of maintaining a file type outweighs the benefits and the ease of use. At these times, we tend to hear
about newer formats, hence there being a multitude of file formats out there.
Most of the time, this kind of technical layer is not visible to an end user, especially if they are only
perusing the content, such as listening to music on Spotify or YouTube. However, since we are building
a game, even though we are not too concerned about the production of such assets, we should still be
knowledgeable on this topic since we’d like to pick the most appropriate file format for a certain scenario.
Distinguishing what sound means
This is a note on what we mean by sound. We’ll be using the word sound or audio, in this chapter
and the rest of this book, to cover all possible scenarios, such as the feedback you get when you
interact with UI elements, when a player character is notified by an in-game event, or ambient music.
The version of Godot, 3.4.4, that this book is covering currently supports three different audio file
formats. Each has different advantages and limitations. Although converting these files into each other
is possible, after we present their formal definitions, perhaps you’ll decide not to.
Introducing WAV
Pronounced wave, WAV files have been around since the early 90s. It’s the short form of Wavefront
Audio File Format, a file specification created by IBM and Microsoft. This is a popular format among
music and audio professionals, despite being uncompressed since it retains the quality of a sound
recording. Thanks to the improvements in file storage capacity and internet speed, the high file size
doesn’t seem to be a big issue anymore.
Learning about different sound formats 137
On the limitation side, as far as technical aspects go, a WAV file can’t exceed 4 GB. However, this
should not be a concern because that number is equivalent to almost 7 hours of audio. It is extremely
unlikely there will be one audio file in any video game of that size.
So, why should you choose this format? Since it’s an uncompressed file type, the CPU that is also
responsible for processing a sound file will have an easier time playing it. A likely scenario for using
this file type is for sound effects. Usually, these effects are short-lived, such as the creaking of a door,
the swing of a sword, and so on. The file size won’t matter that much because the duration will be short.
Conversely, this is not the best format for background music. Sure, there won’t be any need to decompress
the file to be able to play it, but the file size will be significantly larger.
In summary, if you want a quick reaction and would rather have a sound file play as quickly as
possible, such as effects, then this is the right format for you. After all, you wouldn’t want the CPU
to be dealing with the decompression of an effect file while your game characters are busy with the
next chain of events.
If you are willing to sacrifice a few hundred milliseconds to wait for a decompression, such as when
not having the background music play instantly is a big deal, then you can opt for compressed file
types. These come in two different flavors.
Introducing OGG
We should start by clarifying this format since the name could be confusing if you come across some
resources on the internet. Technically, OGG is a container file format that can hold file types such as
audio, video, text, and metadata. Its developer and maintainer, Xiph, is also responsible for another
audio file format known as Free Lossless Audio Codec (FLAC). So, according to OGG specifications,
a FLAC could be part of an OGG file. Historically speaking, most OGG files out there have contained
a different audio file format known as Vorbis. So, you may find some websites with Vorbis content
that are essentially complying with the OGG format’s specifications.
Here is an example to simplify all these names and how they relate to each other. Consider OGG as a
ZIP file that knows what to do with its content. An OGG file carrying a video and a subtitle file will
trigger the necessary settings in a video player so that the player knows where to find the subtitles
since they will be embedded in one file. Similarly, another OGG file with an audio and metadata file
will command an audio player to display the album and track, record, and play the audio.
Since the format is not just one thing, but rather a set of files, it is often confusing to associate a specific
need with one file extension. For example, the .ogg extension was used before 2007 as a multimedia
holder as that was its original intention. Since then, Xiph suggests we use the .ogg extension for
Vorbis audio files. Additionally, the company has created a new set of file extensions to simplify things:
• .oga for audio-only files
• .ogv for video
• .ogx for multiplexed cases
138 Adding Sound Assets
Despite the naming conundrum, what you need to know is that the OGG audio format is compressed,
so it’s a lossy file format. Lossy in our context means that we could attain almost the same sound
quality by requiring less hard disk space. So, this is a good thing because this file format is a perfect
fit for playing background music. Keep in mind that since the CPU has to decompress this file type,
this is not the preferred format for playing quick sound effects.
Speaking of a lossy file format, our next candidate is another lossy file format that gained some
notoriety in the early 2000s.
Introducing MP3
When internet speed and disk storage were at a premium in the late 90s, MP3 filled an important
gap in transferring audio content just when a big audience needed it at the turn of the millennium.
Consumers flocked to websites to download copies of the tracks from their favorite bands. Sadly, so
many of these websites did not bother to have a legal license to distribute such content, so this led to
copyright infringements and, in the case of Napster, a lawsuit.
From a technical standpoint, MP3 files are somewhere in between WAV and OGG, compression-wise.
So, you’ll get smaller file sizes in OGG for the same quality of sound. That being said, decompressing
an MP3 file is faster than decompressing an OGG. Hence, this makes the MP3 format still useful,
especially where CPUs are challenged to the maximum, such as in mobile devices.
Despite disk space getting cheaper and cheaper, from a business point of view, it still makes sense to
prioritize WAV over MP3. For example, some websites that offer royalty-free sound files provide the
MP3 version but put the WAV version of a sound behind a paywall. Since an MP3 file has already
lost some of the original data due to its compression algorithm, editing with this file over and over
will yield more lossy results. So, having access to the original WAV file is always better if you want to
make modifications to it. However, if you don’t need to, then you might be fine with an MP3 version.
Wrapping up
In summary, WAV files are better for short sound effects whereas longer sound effects, especially
theme music, would be handled better with MP3 files. At the time of writing, most sound libraries
still don’t offer OGG commonly, despite being a good candidate. Nevertheless, if you have access to a
lot of WAV files and you want to be efficient in file size, then you can convert them into OGG using
online converters. Two examples are as follows:
• https://audio.online-convert.com/convert-to-ogg
• https://online-audio-converter.com/
Deciding on looping or not 139
In the case of music files, which are normally a few minutes long, if your original is in WAV format,
then uploading and processing these files online may take a long time since the file sizes will easily
be over 50 MB. Also, some of these online converters have file size limitations. To get around these
limitations, here is a link to a website that compares some offline converters that you can employ
in your efforts: https://www.lifewire.com/free-audio-converter-softwareprograms-2622863.
Regardless of what file type you choose and whether it’s for a sound effect or music, there comes a
point in your game development journey when you will have to decide if your sound asset should loop
or not. In the next section, we’ll discuss the reasons why having the loop feature on or off is useful.
Deciding on looping or not
A loop, in literal terms, is a continuous motion or structure in which if you pick a random spot, you
could come back to it by traveling all the way through. In aural terms, this is similar, but we don’t start
anywhere; we usually start playing a sound file, but the player restarts the track once it reaches the end.
This definition is classic, and not that insightful, so let’s do a better job by discussing it in various
contexts inside Godot or any game projects. So, you can make informed decisions in your projects
since it’s situation-specific. We’ll do this by presenting different use cases:
• Background music: This is the most typical case where a music piece plays in the background
while the game is running. The composer creates this kind of piece with the intention that once
played back to back, there will be no abrupt end. The sound at the end of the file will seamlessly
match the beginning. Sure, if you pay attention to the ups and downs in the rhythm, you will
know where you are in the file, but so long as the loop setting is on, everything will sound
smooth and blend in so that you can focus on your game experience.
• Machine gun: Imagine that either the player or an enemy character is interacting with a machine
gun in your game. Although short bursts are possible, due to the nature of machine guns, the
gun might be fired continuously. So, instead of detecting if the sound file has reached the end
and instructing the player to restart the file, you may want to play the file once if the said file’s
loop feature is on. This way, the machine gun effect will play until a stop command is given.
• Doors: This one is a bit of an edge case. Let’s assume we have visuals and other sound effects
in our game that indicate that we’re in an outdoor scene on a windy day. Perhaps the door is
in poor condition with rusted hinges, and one of the hinges is even leaning out a bit. The artist
may have decided to have this door animated to match the wind’s effect on the door so that it
oscillates between a closed and an open state. Here, it would make sense to have a looped sound
file that contains most likely squeaks and creaks that are synchronized with the door’s animation.
However, if a door will be responding to a player character’s action such as it being opened or
closed, then it doesn’t make sense to have the sound file in a loop. This is going to be a one-off event.
140 Adding Sound Assets
• User interface: The sound you hear when you interact with a user interface falls under this
category. These are usually not looped since they are event-based, similar to the one-off-door
action from the previous use case. However, let’s present a case that may seem like looping is
a good idea. Nevertheless, we’ll rule it out for a good reason.
Imagine that there is a UI component that’s helping the player set an amount. The interface has
two buttons that will increment and decrement the amount the player is seeing. Placing a UI
sound effect on either button is fine, and the sound will play only once, so long as the player
keeps clicking. What if we would like to give the player a chance to press and hold the button
down? After all, clicking a button ad nauseam to get to really high or low numbers may get
tedious quickly. So, how should we treat the looping condition in this case?
Human perception is sensitive during events like this. Players are usually busy during gameplay,
so they won’t perceive the delay while the CPU is busily decompressing a music file. However,
we are usually very perceptive in detecting the discrepancies at the end of a holding event for a
UI button. So, instead of treating repetitive UI events such as a machine gun, even though they
might feel similar, designers opt to trigger the sound effect individually instead of looping it.
In this section, we presented different use cases where the use of looping, or lack thereof, is common.
However, what you haven’t seen is how to turn the loop functionality on and off. We’ll show this by
revisiting our old friend, the Import panel.
Turning the looping on and off
So far, we have discussed what looping is and under which scenarios it may make sense to have it on
or off, but we haven’t seen how we can flip its status. In this section, we’ll put sound files of each type
in our project and study their settings in the Import panel.
We are going to use the Loop_Someday_03.wav file from the Freesound website, which was
created by a user called LittleRobotSoundFactory. The sound was originally in WAV format, but we
have converted it into OGG and MP3 versions as well. You can find all the versions in the Start
folder and compare their file sizes.
Once you’ve added the files to your project, let’s learn how Godot recognizes these files. So, switch
on the Import panel, and select either the OGG or MP3 version. Then, select the WAV version. The
interface differences are shown in the following screenshot:
Deciding on looping or not 141
Figure 8.1 – The MP3 and OGG versions have fewer import settings than the WAV version
As you can see, by default, the MP3 and OGG versions come with the loop setting on. Also, these
versions don’t seem to have that many settings. On the other hand, the WAV version’s loop is off by
default. Why is that?
If you remember what we introduced for different sound formats earlier in the Learning about
different sound formats section, Godot took the liberty of looping the compressed versions since these
will most likely be used for background music. On the contrary, if our example file was for a sound
effect, we’d most likely use a WAV file with no loop, since it’d be a quick one-off thing with minimal
CPU requirements.
Other WAV settings
Since we are currently working with the Import interface, let’s also point out that you can
reduce the file size of your WAV files by turning on some of the options in the Force section.
Figure 8.1 shows this and some other settings, such as trimming and normalizing your files.
The former of these will trim the silent part at the beginning and the end of files, which is
sometimes automatically added when exporting WAV files. This is especially important if you
want your sound effects to start right away without a delay.
142 Adding Sound Assets
So, turning the loop feature for any given sound file on and off is as easy as a click and you know how
to do it. Perhaps it’s more important to decide whether a file should be looped or not. This is something
you’ll have to answer along the way.
Regardless, you still need a Godot node to play your sounds at some point. In the next section, we’ll
get to know the different audio players Godot uses, and attach our sound files to the appropriate player.
Playing audio in Godot
Since Godot uses nodes for almost everything, it is no different for playing sounds. To play an audio
file, there are nodes you can attach to your scene, and you can configure them according to whether
it’s for a 2D or 3D game. We’ll focus on different audio players Godot uses in this section.
No matter what audio file type you choose, you will be able to play it with the nodes we’ll present in
this section. The experience you’ll feel will be different, of course, based on the node type, but this is
something you have to decide, depending on the type of game you are making. So, let’s look at the audio
streamer nodes Godot uses so that you can pick the appropriate one. Your three choices are as follows:
• AudioStreamPlayer: This node’s official definition is somewhat dry; it plays audio non-positionally.
What this means is that you are not concerned with which direction the audio is coming from.
For an FPS game, it’s essential to know in which direction the enemy is firing at you. This involves
positional data. You don’t have any kind of positional information in this audio node. However,
this is the right candidate for playing background music. Find more about it at https://
docs.godotengine.org/en/3.4/classes/class_audiostreamplayer.html.
• AudioStreamPlayer2D: You guessed it – this node includes position information. So, the
farther away the camera is from this node, the quieter the sound will be. This node is useful
for 2D platformer games, for example. So, as soon as a game object enters the view, the stream
will be picked up by the camera. Also, objects that are on the right-hand side of the camera will
prioritize the right speakers and vice versa. More details are available at https://docs.
godotengine.org/en/3.4/classes/class_audiostreamplayer2d.html.
• AudioStreamPlayer3D: Last but not least is the 3D version of an audio streamer. This conveys
3D positional information to a listener. Therefore, this is the kind of audio streamer node
you’ll be using in 3D setups. Naturally, this type of streamer employs more advanced features,
such as attenuation, which controls how the sound will dampen over a distance, and Doppler
effects. Thus, it might be a good idea to examine its properties by visiting https://docs.
godotengine.org/en/3.4/classes/class_audiostreamplayer3d.html.
We could go over every property for each type of stream player, but we leave that task to you since
picking the right streamer and configuring its settings is a form of art. We’ll use the proper streamer
when we build our game later in this book and focus on the important settings in that context. In the
meantime, you can read what each one is capable of by going to the aforementioned URLs from the
official documentation.
Playing audio in Godot 143
That being said, we won’t leave this chapter just yet. Let’s play a few sounds to simulate some of the
examples we’ve enumerated so far.
Playing background music
Let’s practice some of the things we’ve covered in this chapter. We’ll start by playing a sound that’s
a good candidate for background music. We’ll use the MP3 version of the loop-someday-03
file we imported in the Deciding on looping or not section. To play this sound as background music,
follow these steps:
1. Create a new scene and save it as Background-Music.tscn.
2. Add an AudioStreamPlayer node to your scene and turn on its Autoplay property in the
Inspector panel.
3. Drag and drop loop-someday-03.mp3 from the FileSystem panel into the Stream property
in the Inspector panel.
4. Press F6.
This will launch your current scene and automatically play the MP3 file. Since the file’s loop setting is
set to true, the 9-second-long music will play endlessly. You can now add this scene to other scenes
where you want to have background music.
Playing a sound effect on demand
For this effort, we’ll return to the machine gun example from the Deciding on looping or not section.
The sound for the machine gun is also set to loop, but we wouldn’t want this to autoplay when a
scene is launched. It’s most likely that your player character will enter or approach an area where
enemy forces are pummeling you with machine gun fire. Let’s write some code to simulate this sort
of triggering behavior:
1. Create a new scene and save it as Machine-Gun.tscn.
2. Add an AudioStreamPlayer node to your scene and attach a script to it with the following
lines of code in it:
extends AudioStreamPlayer
func _unhandled_key_input(event: InputEventKey) -> void:
 if event.is_pressed() and event.scancode ==
 KEY_SPACE:
 play()
 else:
 stop()
144 Adding Sound Assets
3. Drag and drop machine-gun.ogg from the FileSystem panel into the Stream property
in the Inspector panel.
4. Press F6.
Since we want the stream to play on demand, we are wiring it to a condition to be true – that is,
pressing the spacebar. Go ahead and press it once or twice; even hold it down for a brief period.
You’ll hear the machine gun sound going on or off, thanks to the play and stop commands of the
AudioStreamPlayer node.
The script we’ve implemented looks good enough, but it’s also a bit problematic. Maybe you’ve already
noticed it. Try to hold down the spacebar for long enough, such as 3 or 4 seconds, and you’ll hear a
jamming sound. This is because the script is firing too many play commands. So, after a while, the
CPU will be instructed to play the same asset too many times. We can do better by replacing the
script’s content with the following:
extends AudioStreamPlayer
func _unhandled_key_input(event: InputEventKey) -> void:
 if event.is_pressed() and event.scancode == KEY_SPACE:
 stream_paused = false
 else:
 stream_paused = true
Here, we have replaced the lines that had the play and stop commands with a different kind of command.
The new version will control whether the stream should be paused or not. For this script to work, we
need to turn on two things in the Inspector panel:
• Autoplay
• Stream Paused
This new setup will play the stream automatically, similar to what happened in the Playing background
music section, but then pause it right away. This seems counter-intuitive at first, but let’s analyze what
the new script is doing. When the spacebar is pressed, we resume the stream, and since the stream
was already playing, thanks to Autoplay being on, you get to hear the ta-ta-ta-ta sound! Also, when
you release the spacebar, hence the else case, the stream will be paused again. So, the new script
will not send consecutive play and stop commands, and thus will not clog the CPU.
We’ll conclude by discussing two more flavors of the machine gun firing in light of what we have
presented throughout this chapter.
Summary 145
Increasing gameplay experience
Did you notice that we used the same type of audio stream node for both the background music and
machine gun? In a way, we treated the machine gun as if it was background music. In other words,
we were not too concerned about where the sound was coming from.
To deliver a more enjoyable gameplay experience, you could use the AudioStreamPlayer2D and
AudioStreamPlayer3D nodes in 2D and 3D games, respectively. By tweaking the attenuation values
of these nodes, which define how sound travels over distances, your players can hear the sound of
the machine gun louder and louder as their characters get closer to the source. This would elevate the
sense of danger, and it’s a cheap and nice way to deliver immersion.
Summary
We started this chapter by presenting different types of files that Godot uses for playing sound. Knowing
the differences among these formats, when you work with composers, you can emphasize in which
format you want your sound files to be delivered. Chances are they might ask you about this, and they
might even deliver in all three possible formats.
Next, we discussed a few cases where looping a sound file might be a good idea. To facilitate this, we
investigated the options presented in the Import panel. However, the decision to loop or not is still
something you’ll have to decide.
Finally, to put our theoretical knowledge to use, we created two scenes that could play the sample files.
In the first case, we attached a sound file to an audio streamer and let it play automatically. For the
second case, we wrote a very simple script that let you start and stop the sound to mimic an enemy
character’s behavior, hence the sound effect it may make.
So far, we have been discovering some of the ingredients that are necessary for building games, such
as importing assets – whether it’s models from the previous chapter or sound assets in this one. In the
next chapter, we’ll dive right into building our point-and-click adventure game by designing our level.
Further reading
If you are into creating music and sound effects, here is a short list of software you can start with:
• LMMS: https://lmms.io
• Waveform Free: https://www.tracktion.com/products/waveform-free
• Cakewalk: https://www.bandlab.com/products/cakewalk
The aforementioned links will only cover the using a tool side of music production, so you may also
need to learn the artistic side of it, for which there are courses on multiple online training platforms,
such as Udemy.
146 Adding Sound Assets
By the way, if you see a sound file out there and it looks like it is free to download, it doesn’t mean
you have the license to utilize the piece in your work. You may want to read the fine print if you don’t
want to get a surprise call from a lawyer someday. Nevertheless, the following are a few websites that
offer paid and free sound content:
• https://gamesounds.xyz
• https://freesound.org
• https://www.zapsplat.com
• https://opengameart.org
Part 3:
Clara’s Fortune – An
Adventure Game
In this final part of the book, you'll be creating a point-and-click adventure game. Since it would be
too time-consuming to prepare all the game assets, you'll be provided with the necessary files.
In this part, we cover the following chapters:
• Chapter 9, Designing the Level
• Chapter 10, Making Things Look Better with Lights and Shadows
• Chapter 11, Creating the User Interface
• Chapter 12, Interacting with the World through Camera and Character Controllers
• Chapter 13, Finishing with Sound and Animation
• Chapter 14, Conclusion

9
Designing the Level
From this chapter on to the end of this book, you’ll be actively working on creating a point-andclick adventure game. We’ll show you the necessary steps to create a game in which you’ll place and
command a character whose name is Clara. Players will be controlling her actions inside a cave that
will be initially dark, but you’ll be able to give controls to the player to change the conditions of the
lights. Once you figure out how to move her around in the world, you’ll also place trigger points in
this cave so that the world reacts to Clara’s actions to make things interesting but also challenging.
This part of this book will cover enough basic building blocks for you to start practicing building
small-scale adventure games.
Through all these efforts, you’ll learn how to utilize different parts of Godot Engine, especially the
ones that are pertinent to 3D workflow. Whenever it’s necessary, we’ll remind you of the previous
chapters, where you can revisit some of the basic principles. This is because this part of this book will
heavily rely on practical applications of what we have presented so far.
With that said, as every game has a narrative; this is ours:
“It was no more than a fortnight ago when Clara’s uncle had sent for her. Clara was sailing her boat to the
coordinates her uncle gave her when she noticed a glimmer in the distance. After she carefully approached
the spot where she noticed the flash, she saw that this was the entrance to a cave under the cliffs of a rock
formation jutting out of the sea. She cautiously maneuvered the sails on her boat and entered the cave
without a hitch. Luckily, there was enough sunlight for her to see a pier and she anchored the boat. She’s
excited to visit her uncle.”
Although there is a lot to do, from adjusting the lights in a cave environment to triggering sound and
animations, we should start building the world first. That’s what this chapter is about.
We’ll start by composing a scene by placing models from the project folder. This kind of scene structure,
where the players experience a particular part of the game world, is often called a level and often
signifies different levels of difficulty or a distinctive environment.
150 Designing the Level
While we are arranging assets to build a level, we’ll look into creating and fixing materials in Godot
since, sometimes, some things are not perfectly transferred between applications. Chapter 6, Exporting
Blender Assets, and Chapter 7, Importing Blender Assets into Godot, covered the intricacies of how
exchanging information between Godot and Blender works if you need a refresher.
Although manually laying things out to create a level is alright, we could always benefit from using
tools that will make this kind of job easier on us. Godot’s GridMap is the right tool for placing objects
on a grid structure. For GridMap to work, it needs another Godot mechanism called a MeshLibrary.
We’ll show you how to construct one and use it as an alternative way of building levels.
In this chapter, we will cover the following topics:
• Creating the cave
• Constructing the missing materials
• Laying models on a grid
• Taking advantage of MeshLibrary
In the end, we’ll craft a level by arranging scenes/models, completing missing materials, and taking
advantage of GridMap and MeshLibrary for a faster workflow. By doing this, you’ll have the right
tools under your belt to design levels.
Technical requirements
Starting with this chapter, and continuing in the remaining chapters, you’ll be creating a point-andclick adventure game. Since it’d be too time-consuming for you to prepare all the game assets, we are
providing them. We have already exported the glTF files from Blender. Should you need to access the
originals for any modifications, or when a specific file is mentioned, these files can be found in the
Blender Models.zip file in this book’s GitHub repository.
Unlike the previous chapters, which usually had Start and Finish folders with simple assets, we’ll
switch things up a bit. This chapter will have the usual folders too, but they will contain the content of
a Godot project. The Godot project in the Start folder will contain the barebone assets for you to
start building the level for the game. By the end of this chapter, your game will have reached a stage
where you can use the content from the Finish folder to compare what you have created.
Additionally, starting with the next chapter, you’ll only have the Finish folder since you can use the
finished stage in each chapter as the starting condition for the following chapter, and so on.
We suggest that you head to this book’s GitHub repository at https://github.com/
PacktPublishing/Game-Development-with-Blender-and-Godot to check out the
content we have prepared for you and help Clara out in her adventures.
Creating the cave 151
Creating the cave
For the first level in Clara’s adventures, we thought of a small place so that you don’t get overwhelmed
with building a large layout. Figure 9.1 should help you visualize what we are building. This is a Blender
render we’ll try to recreate in Godot:
Figure 9.1 – We’ll be building this small level for Clara to discover
Our world will consist of a dock inside a cave that has access to the sea. When Clara anchors her
boat, she sees inside the cave. There isn’t much light to begin with, but as little as she can see, the
dock leads to a pier with laid stone. She can also see that there are a bunch of boxes, barrels, and pots
distributed here and there. Though the sconces on the walls will start unlit when the game runs, as
shown in Figure 9.1, you can see that all the sconces on the walls are lit. This is because we want to
show you a later stage in the game so that you can see what we are aiming for. Otherwise, it would
have been a dark figure.
In Chapter 10, Making Things Look Better with Lights and Shadows, we’ll investigate how we can create
a more dramatic-looking level by utilizing appropriate light types and enabling shadows. We covered
some of this in the context of Blender in Chapter 4, Adjusting Cameras and Lights, but we’ll do it in
the context of Godot as well.
152 Designing the Level
Level design versus game design versus visual design
If you are new to game development, then some of the names you come across might be
confusing. The word design is one such example since it usually implies what people see.
However, in actuality, it means a fashion, or a formula to do or conceive something. Let’s
discuss it in the right context.
We could have designed the level differently so that access to the door at the end of the pier
would be challenging. Perhaps the light conditions are so poor that Clara needs some help to
see an important clue. To make progress in the game, game design rules will define how the
player will interact with the world. Perhaps it’s enough for the player to click game objects in
the world, while other times, it’d be better to have an inventory and a crafting system.
Lastly, the visual design has nothing to do with the previous two design concepts. The cave
walls could still be cave walls but instead of having a low-poly and stylized look, they might
have looked ultra-realistic, where you could feel the stones were damp and covered with moss.
Would this have added anything to the game and been fun? So, all these design principles are
equally important and yet distinct.
The level, Level-01.blend, is available inside the Blender Models.zip file at the root of
this book’s GitHub repository. You’ll most likely need it open so that you can use it as a reference
when you are building the level in Godot.
We will start building the level by laying out different sections of it. Speaking of which, we must follow
these steps to structure our first level:
1. Create a new scene and save it as Level-01.tscn inside the Scenes folder.
2. Place a Spatial node as root and rename it Level-01.
3. Create more Spatial nodes inside the root node with the following node names:
 Floor
 Columns
 Walls
 Rails
 SunkWalls
 Props
 Rocks
 Sconces
 Dock
Creating the cave 153
We’ll be using these child Spatial nodes to store different parts of the level since we’ll end up having a
lot of parts in this level, despite it being very small. The following screenshot shows the node structure
after our last effort:
Figure 9.2 – Different structures for the level are grouped under many Spatial nodes
Inside these Spatial nodes, we’ll place the relevant parts of the level. For example, the floor pieces will
go inside the Floor node. We can put down our first asset easily by doing the following:
1. Highlight the Floor node in the Scene tree.
2. Press the chain icon at the top to instance another scene inside your highlighted node.
Alternatively, you can press Ctrl + Shift + A.
3. Type Floor_Standard in the Search section of the pop-up screen.
4. Select Floor_Standard.glb from the Matches section, as shown in the following screenshot.
154 Designing the Level
This will create an instance of Floor_Standard.glb inside the Floor node:
Figure 9.3 – You’ll want to use the search area to filter out the unwanted matches
You may have noticed that although we wanted to inherit a scene that should normally have a
.tscn file extension, instead, we instanced a glTF file. In Chapter 7, Importing Blender Assets into
Godot, we learned how to create scenes out of glTF files. So, we could have done that and created a
Floor_Standard.tscn scene, then instanced that scene inside the Floor node as well. We took
a shortcut instead. Creating scenes is useful when you are going to add additional elements besides
the model structure itself. We don’t need additional elements for the floor, so it’s alright to instance
just its glTF version.
On the other hand, there will come a moment when we create our level when directly instancing glTF
files won’t cut it. For example, when we tackle lights and shadows in the next chapter, it will make
much more sense to create a scene out of the sconce model and add a light object to the same scene.
Hence, the sconce scene will take care of displaying a glTF model as well as holding a light object so
that it can programmatically be turned on or off later. If you simply want to display models, but don’t
need anything more than that, instancing a glTF file is usually enough.
After you add the first piece, it will be automatically selected. If it’s not, you can click the floor piece
in the 3D view or highlight its node in the Scene tree. Once it’s been selected, you’ll see a gizmo at
the center of the model that will let you move and rotate the piece around. The directions of your
gizmo may look different if you have rotated your view. The following screenshot shows an example
of what we expect to see:
Creating the cave 155
Figure 9.4 – The gizmo for moving and rotating an object
The floor plan we are trying to lay out consists of more standard floor pieces. So, an easy way to get
extra pieces is to duplicate the existing pieces and move them aside, as follows:
1. Select the Floor_Standard node in the Scene tree.
2. Duplicate it by pressing Ctrl + D.
3. Move the new floor piece by dragging either the blue or the red axis in the gizmo.
This will add a new floor piece to the scene and move it around. We are intentionally ignoring the
green (Y) axis since we don’t want the floor to have any elevation at this point. However, for your
games, you can design levels with different height zones and connect them with stairs.
156 Designing the Level
Since our floor plan looks like a grid, it would be nice to have the floor pieces snap to each other. We
can do this by moving the pieces in either direction on the XZ plane while limiting their movements
to precise increments. To simulate this, delete the most recent floor piece you created, and then do
the following:
1. Duplicate a new Floor_Standard node.
2. Hold down Ctrl and use either the X or Z gizmo arrow to move the piece two units.
Why did we move it by two units? Because the model is designed to fit in a grid that’s 2 x 2 meters in
size. You can open the relevant Blender file to observe the dimensions. We are not measuring things
in Godot but it’s still respecting the scale and unit aspects set in Blender. That’s why we made sure the
scale for the model was set to 1. If you need a reminder on this, we suggest that you read the Applying
rotation and scale section in Chapter 6, Exporting Blender Assets.
After implementing the latest instructions for moving pieces with the snap feature on, you’ll get the
following output:
Figure 9.5 – The new floor piece is right next to the old one
All there is left to do at this point is duplicate enough floor pieces and move them around by using the
snap feature. Also, you’ll need to instance and place two new models inside the Floor node:
• Floor_Standard_Curved_1.glb
• Floor_Standard_Curved_4.glb
These curved floor tiles will accommodate curved walls, which means we can keep the architecture
consistent. By duplicating enough floor tiles and adding the new curved pieces, and after moving the
pieces around, we’ll achieve the following output:
Creating the cave 157
Figure 9.6 – With the two newly added types, the floor is ready
All the floor pieces are now under the Floor node in the scene, and this effort completes our task of
constructing the floor. We’ll follow a similar approach to lay the other parts of the cave under separate
Spatial nodes.
Erecting the walls
The next order of business in constructing the level is putting up the wall sections. You can do so
by instancing wall pieces under the Walls node, similar to the way you did for the floor pieces. As a
substitute for providing you with very similar instructions, we’ll use this section to highlight a few
special cases you may come across.
For example, you’ll eventually want to place wall pieces that will connect at a corner. So, you need to
rotate one of the pieces around its Y axis by 90 degrees. You can do this either by using the gizmo or
by typing the exact value in the Inspector panel under Rotation Degrees in the Transform section.
Another situation is with the wall that has a hole in it, which lets a bunch of twigs creep into the dock
area. This is a detail you can see on the right-hand side of Figure 9.1. We suggest using Wall_Hole.
glb for that particular section of the level. Similarly, Curve.glb should be placed over the curved
floor pieces we have already established.
158 Designing the Level
Although a door is technically not a wall, we could assume the arch and the door can get along with
the other wall pieces. After all, they conceptually belong to the same structure. So, for that section,
you can utilize the following pieces:
• Wall_ArchRound_Overgrown.glb
• Arch_Round.glb
• Doors_RoundArch.glb
Lastly, when you lay out all your wall pieces, you can duplicate them and pull them up two units on
the Y axis. This will make the walls the same height as the arch and the door. Once you’ve done this,
your floor should resemble what you can see in the following screenshot:
Figure 9.7 – The level is starting to look more like our reference picture
As you may have noticed there is a gap on the floor by the curved wall piece near the door. We’ll fill
that gap by cleverly placing two green plants soon. Otherwise, you’d have to prepare a floor piece
for edge cases like that. Either way is fine and going back and forth between Blender and Godot to
complete missing pieces is also part of the process.
Since we’ve been handling the walls, we can extend this effort by using additional wall pieces to simulate
the section of the level that meets the seawater in the cave.
Creating the cave 159
Sinking the walls
It seems the architect of this place went to great lengths to have stone bricks laid out to prevent mother
nature from tarnishing what’s under the floor. Smart!
To accomplish what the architect had in mind, you can utilize the standard wall pieces to create a curtainlike structure right where the floor is connecting with the water. In the end, when you place these pieces
inside SunkWalls in your Scene tree, you’ll be looking at what’s shown in the following screenshot:
Figure 9.8 – The same wall pieces are used to prevent water from leaking under
The ebb and flow of the sea will now be kept at bay. Notice that we didn’t want the sunken wall parts to
go all the way around the floor. This is because you can always limit the camera angles to not show the
back parts of the structure. It’s a cheap way to keep the asset count low. However, if you want to give
full freedom to the player so that they can rotate around the whole structure, you may want to change
your level design to accommodate that. We’ll be investigating camera settings in Chapter 12, Interacting
with the World Through Camera and Character Controllers. For now, we still need to finish our level.
Placing the rocks
Since we are currently concerned about the parts near the water, let’s add some rocks to the scene.
In the Blender file for this level (Level-01.blend), you’ll see individual rocks. They have been
organized to give the illusion of a rock formation. It’s perfectly fine to follow a similar approach and
place specific rocks into your scene in Godot too, more specifically under the Rocks node.
160 Designing the Level
However, there is an easier way. What if you exported the left and right rock formations as a single
object from Blender? This is entirely possible, and that’s why we have prepared two files for you:
• RocksLeft.glb
• RocksRight.glb
You can instance these two files and move the instances freely using the gizmo. This means you don’t
have to use the snap feature. Adjust the position of the rocks wherever you think is best.
Speaking of moving assets without using the snap feature, perhaps we can practice it a bit more. Since
the floor looks empty, it’s time we discuss complementary design elements such as props.
Distributing props
A prop is an object that serves as a support element. Props are also often called necessary clutter since
they complete a décor. Otherwise, when things look too sterile, it’s less pleasant to the eye and we start
paying attention to repeating patterns or unnecessary details.
Instead, we want the person who’s experiencing the scene to feel at ease. This is also a great way for
designers to hide important elements in plain sight. To that end, we will use the following list of props
and distribute these assets around the scene:
• Barrel.glb
• Backpack.glb
• Bush_Round.glb
• Candles_1.glb and Candles_2.glb
• Cart.glb
• Crate.glb
• DeadTree_3.glb
• Flag_Wall.glb
• Pot1.glb, Pot2.glb, Pot3.glb, and their broken versions
• Statue_Stag.glb
Creating the cave 161
Once you’ve finished moving the props, your scene will look as follows:
Figure 9.9 – The props have been distributed all over the dock
While you are at it, you may as well instance Column_Round.glb, make two more copies, and place
them under the Columns node. Also, Rail_Corner.glb and Rail_Straight.glb could be
placed along the edge and near the stag statue. You don’t have to be pixel-perfect with these objects,
but if you want to be precise, you can use Level-01.blend for reference.
Finishing the rest of the level
To finish off the level, we need to place the sconces and construct a pier. These assets are no different
than the other ones you have instanced and moved around the level.
However, placing the dock pieces may throw you off a bit as far as positioning goes. You may find that
the stairs piece looks slightly off dimension-wise. Sometimes, assets are designed to be generic, while
other times, assets will be designed so that they can fit or connect with the other models seamlessly.
Regardless, since it’s possible to adjust the final position in Godot, we can recover from these minor issues.
To simulate how we dealt with this issue, we’ll give you the Translation values we used for the positions
of both pieces:
• Dock_Long: 4, -1, 5.5
• Dock_Stairs: 4, -1.5, 8.9
162 Designing the Level
Your values will most likely be different since you were undoubtedly moving your level pieces in
directions that felt natural to you. If your numbers don’t match our example, don’t worry. We would
like to point out the relative difference between the two structures. You’ll also most likely have one
number that’s the same in one of the axes, either X or Z. Also, an educated guess on our end, your
Y for the stairs will be 0.5 lower. This should result in a pier structure that looks like it was designed
as one piece. If you want to have a taller pier, then you can create a copy of the stairs and move it
accordingly. That’s the benefit of having separate pieces.
We suggest that you add the boat model under the Docks node in the Scene tree at this point since it
could be considered as part of the docks area. This concludes the construction of our level. It should
look as follows:
Figure 9.10 – The level has been reconstructed in Godot
Despite our claim that the level’s construction is finished, you may have noticed that there are a few
odd looking things. We have a dock area with no water – and what are those ugly round things doing
by the door? We’ll find out how we can remedy all this in the next section.
Constructing the missing materials
When we were placing the props, we covered the gap near the door by placing a bush prop (this can
be seen in Figure 9.10). However, there is something awkward about those bushes. Similarly, the arch
Constructing the missing materials 163
over the door has some weird-looking dangling things over the stone bricks. They should be showing
greenery and leaves but all we have is a bland, gray surface. We’ll fix these issues in this section.
In addition, while it made sense to export individual models from Blender and place them in a Godot
scene, it didn’t make sense to export the water body. Even in Blender, that object was a plane that has
been applied a shader that mimicked water. We’ll recreate that effect in Godot.
Fixing the leaves
First, let’s describe what the problem is with the gray leaves. All the other models seem to have
their materials displayed properly. Despite all intentions and efforts, certain things are never fully
transferred between applications. This is the case with the leaves. We need to get a bit technical for a
more thorough answer though.
How would you go about designing a leaf in 3D? Since a leaf has so many details around its edges, it’s
hard to display that much detail without using enough vertices. To be conservative, you can use an
object with the least number of vertices and apply a transparent leaf texture to this basic object. The
following screenshot shows an application of this method:
Figure 9.11 – A transparent file is used as a texture for a rectangle shape
The preceding screenshot shows a very simple shader. The alpha value of the texture is attached to
the Alpha socket of the shader. Also, Blend Mode under Settings for the material is set to Alpha
Clip. This means that the alpha parts of the texture will be clipped out of the result. We need to do
the equivalent of this in Godot.
164 Designing the Level
Unfortunately, Godot doesn’t automatically understand and turn on transparency for imported
materials. We’ll have to do some manual work to display the leaves correctly. Luckily, this is also going
to get you familiarized with the materials and their settings in the Inspector panel.
Let’s start by finding the material for the bushes. The Models folder is structured in a way to keep
distinct models inside individual folders. Hence, expand the Bush folder in FileSystem panel and
double-click the Texture_Leaves.material item. This will populate the Inspector panel with
this material’s properties. There is a lot to look at, but we only need to tweak a few things:
1. Expand the Flags section.
2. Turn the Transparent setting on.
3. Expand the Albedo section.
4. Drag and drop Leaf_Texture.png from the Textures folder into the Texture field. As
an alternative, you can click the Texture field and Load the necessary file.
As you may have noticed, the texture for the material was missing, so there was no chance for the bushes
to display anything. Second of all, by turning the transparency on in the flags, we are asking Godot
to respect the transparent parts of the texture file. You can switch it on and off to see the difference if
you like. In the end, our scene will look as follows:
Figure 9.12 – Our bushes are starting to look healthier again
Constructing the missing materials 165
You can do the same thing for the arch model, which can be found in the Architecture folder inside
the Models folder. This may look like you are repeating yourself, and you are right about this. Since
we are keeping separate models that use the same Blender material inside their relevant folders, the
materials are duplicated as well. A detailed discussion about this was provided in the Deciding what to do
with materials section of Chapter 7, Importing Blender Assets into Godot. Since this is an organizational
issue, we leave the decision to you, but you now know how to enable transparency in materials.
Another missing piece in our material puzzle is the water object. We intentionally omitted the export
for that area. To most game developers out there, writing shader code is entering dangerous waters.
Nevertheless, that’s exactly what we’ll do. Hopefully, you’ll see that there is nothing to fear.
Creating the water
How do you model a body of water? The answer is not simple, and it even is a bit philosophical. The
following is a homage to Bruce Lee’s famous philosophical quote on martial arts, which uses water
as an analogy:
“… Be formless, shapeless, like water.
You put water into a cup, it becomes the cup.
You put water into a bottle, it becomes the bottle. …”
It’s hard to imagine what vertices we should create and organize for water in Blender or Godot. Instead,
we give qualities of water such as reflection, refraction, undulation, and murkiness to simple objects,
such as a plane or a cube.
Thus, for this effort, we usually rely on shaders instead of a 3D model. In this section, we are going
to write a very simple water shader. In the end, you can either use the shader from our example or
find another example on the internet. After all, there are a lot of examples out there, since creating
a decent water shader usually depends on your use case, and one solution sometimes doesn’t fit all.
Let’s start by creating a water object:
1. Place a MeshInstance node under the Dock node and rename it Water.
2. For this new object, assign a PlaneMesh to its Mesh property in the Inspector panel.
3. Click this PlaneMesh to expand its properties, and fill in the following values:
I. 20 for both x and y in Size.
II. 20 for both Subdivide Width and Subdivide Height.
166 Designing the Level
We’ll explain what these numbers mean soon, but here is what your Inspector panel should look like:
Figure 9.13 – A rather gray-looking body of water so far
The preceding screenshot shows the properties of a PlaneMesh in the Inspector panel. We have chosen
a size that made sense as far as the level’s dimensions are concerned. Using the gizmo, as you did for
moving other objects, position the water object where it makes sense concerning the dock area and
the overall scene. Once we have written our shader to make this gray object look like water, you may
also want to adjust its Y position too.
Additionally, perhaps coincidentally, we chose 20 as the subdivision value. You can divide the plane
into finer pieces if you want, but a value such as 20 will introduce enough vertices. So, yes, you have
effectively created vertices in Godot as opposed to doing so in Blender.
We are now ready to change the look of this gray plane. For this, we’ll create a material for it:
1. Right-click the res:// item in FileSystem and choose New Folder.
2. Type Materials and confirm.
3. Right-click the Materials folder in FileSystem and choose New Resource.
4. Search for ShaderMaterial and confirm.
5. Save it as Water.tres in the upcoming Save Resource As screen.
Normally, a newly created item will be displayed in the Inspector panel, but if it doesn’t or if you
brought another object’s properties to the Inspector panel, find Water.tres in FileSystem and
double-click it. You’ll see a barebones material with a white sphere as a preview in the Inspector panel.
It needs a shader to get more water-like visual qualities. This is how you can create it:
Constructing the missing materials 167
1. Right-click the Materials folder in FileSystem and choose New Resource.
2. Search for Shader and confirm.
3. Save it as cave-water.tres in the upcoming Save Resource As screen.
In Chapter 2, Building Materials and Shaders, we discussed the relationship between shaders and
materials, and how they go hand in hand. That was done in Blender, but the concept is universal.
Hence, we’ve created a material and a shader in Godot. Now, we must associate the two:
1. Bring up the Water.tres file’s properties to the Inspector panel.
2. Drag and drop cave-water.tres into the Shader property in the Inspector panel.
The water material has now been assigned an empty shader. We’ll explain the shader code after you
complete the following steps:
1. Double-click cave-water.tres in FileSystem.
2. Type the following code in the newly expanded Shader panel:
shader_type spatial;
uniform sampler2D wave_pattern;
uniform vec4 color:hint_color = vec4(0.19, 0.71, 0.82,
0.44);
uniform float height_factor:hint_range(0,1.0) = 0.1;
void vertex(){
 vec4 wave = texture(wave_pattern, UV);
 float displacement = sin(VERTEX.x * wave.x * TIME)
 + cos(VERTEX.z * wave.z * TIME);
 VERTEX.y += displacement * height_factor;
}
void fragment(){
 ALBEDO = color.rgb;
 ALPHA = color.a;
}
168 Designing the Level
The shader code we have written exposes a few options to the Inspector panel, starting with the lines
that start with the uniform statement. This is so that you can modify the material’s properties, just
like you were able to change the settings of the leaf material earlier in the Fixing the leaves section.
That one was a very elaborate shader with lots of options. Ours is a very simple shader with only
three parameters:
• A wave pattern for creating randomness
• A color for the water (by default, this is a light blue color)
• A height factor to control the motion of the waves (by default, this is 0.1)
Two of the properties have their default values. We’ll show you what you can pick for the wave pattern
later in this section, but first, let’s explain the general idea behind all this since this might be the first
time you are writing shader code.
Built-in Godot shader functions
The two functions, vertex and fragment, are built-in shader functions. The former controls
what each vertex will do, while the latter takes care of how the overall object will look. Godot has
more default functions; we’ve provided a link in the Further reading section for you to discover.
Since the fragment function looks simple enough, we’ll cover that one first. One of the properties
we exposed, color, will be used in this function so that we can paint the object with the color we
want. Consequently, we are taking the red, green, and blue channels of the input color and applying
them to the ALBEDO property of the shader. Albedo is a scientific term for color. In some applications,
it’s also referred to as Diffuse or Base Color, such as in Blender.
Naturally, we would like to have some translucent qualities for our water object. For that, we are using
the input color’s alpha channel and binding it to the ALPHA property of the shader. It’s a simple but
effective way to create transparency. Speaking of which, if you comment out the vertex function, you
should still be able to see the transparency because each function is responsible for one major aspect.
However, they complement each other when used together. So, it’s now the vertex function’s turn.
It would be nice to have the body of water move up and down a bit. That’s the reason why we have
introduced more vertices to the plane mesh by subdividing it. The vertex function will take each
vertex and change its y value to create an up and down motion. The last line in the function is
responsible for that. How much should each vertex change though? Well, that depends on your use
case. However, we came up with a displacement value that seemed appropriate and yet exciting
enough to simulate a somewhat calm water feature in this cave.
While calculating displacement, we are using a texture and sampling some of its values. It’ll bring
randomness to the way the vertices will move. To that end, we are combining the x and z values of
each vertex with the x and z values of the incoming texture (wave). You could alter a combination of
some of those properties and still get a similar result. Perhaps what’s more important is the use of the
Constructing the missing materials 169
built-in TIME property, which is telling the GPU to change the result with each millisecond passed.
Remove TIME from the equation and everything will be displaced once and sit still.
Finally, we regulate the intensity of the displacement with a height factor that can be adjusted in the
material settings. This concludes our water shader. The shader and material have already been connected,
but we have yet to tell the Water node which material it should use. To do so, follow these steps:
1. Select the Water node in the Scene tree.
2. Expand the Material section in the Inspector panel. You’ll see a slot with a label of 0.
3. Drag Water.tres from FileSystem to the 0 slot.
Voila! The dock should now have a water object that’s modulating over time. Move and zoom your
viewport camera in to get closer to the sunk walls to notice the alpha effect too. This is looking nice
already, but we can take this a step further by applying the shader a noise texture, which will add more
variation to the way the vertices fluctuate:
1. Expand the Shader Param section in the material’s settings in the Inspector panel.
2. Attach a New NoiseTexture for the Wave Pattern property.
3. Expand this new texture and attach a New OpenSimplexNoise to its Noise property.
This will add more randomness to the way the vertices are displaced. When you are done with all the
code bits and tweakings, your Inspector panel should look as follows:
Figure 9.14 – Notice how the water is transparent and wavy along the sunk walls
170 Designing the Level
It’s possible to fuss with the values of the noise to create more drastic effects, but we leave that to you.
By controlling the height factor and color, you can simulate calmer or stormier water conditions as
well. With that, you have created an important missing feature.
About keeping the shader separate
While creating the water material, you could have used an in-memory shader for the material
using the dropdown in the Inspector panel. Most Godot features usually start and stay this
way, but we followed a different approach by creating a resource first and then assigning it later.
Thanks to this method, you can create different water shaders and swap them as you need them.
With that, we have taken care of placing all the necessary elements and even completing missing parts,
such as fixing and/or creating new materials. However, while creating the layout, did it feel like you
were duplicating and moving so many of the same assets, especially with the wall and floor pieces?
We bet it did! So, let’s present a very helpful Godot tool with which you can lay things out easily if
your layout is grid-based.
Laying models on a grid
The main difference between placing objects such as candles, pots, and barrels, short props, and floor
and wall pieces is that you can distribute the former objects willy-nilly. They don’t have to follow
a pattern, whereas the floor and wall pieces must snap to each other. This kind of structure is also
referred to as a grid.
To speed things up, we even chose to duplicate an existing piece instead of instancing a fresh one
because when you create a new instance, it’d start at the scene origin, and you’d have to move this new
piece near your current area. You can even select multiple tiles in a row, duplicate them, and snap
these next to the old batch. Despite all these shortcuts, since all this sounds formulaic, perhaps there
should be a better tool. GridMap to the rescue!
If you have used Godot for 2D, you may already be familiar with the TileMap node. GridMap is the
same except it works in 3D. Thus, whereas TileMap will let you add sprites to your scene, GridMap
will use meshes. For those of you who have never used a TileMap node, both of these mechanisms
in Godot are responsible for using a set of tiles or meshes.
Benefits over manual placement
The GridMap solution we are offering is not just for you to expedite the creation of your levels.
Since the pieces are repeating, the GPU will optimize the rendering of said pieces and you’ll get
higher frame rates. This is usually a very sought-after result among game developers, particularly
when your levels grow and the number of objects you use in a scene starts to matter.
Laying models on a grid 171
In this section, we’ll present the general settings of a GridMap node. Although this node depends on
MeshLibrary to do its job, it makes sense to understand the individual settings at this point than mixing
both. We’ll learn how to create and utilize MeshLibrary in the Taking advantage of MeshLibrary section.
To conserve and compare what we have done so far, we’ll take things a bit slowly:
1. Save Level-01.tscn as Level-01-Gridmap.tscn. The root node could still stay as
Level-01.
2. Add a GridMap node and rename it FloorGridMap. You can drag this new node and make it
the first child right above the Floor node if you wish.
3. Turn off the Floor node by pressing the eye icon.
The last set of actions will introduce a GridMap node to the scene. It’s empty for now but we’ll fill it
with the floor pieces when we get to know mesh libraries. Your scene will look as follows:
Figure 9.15 – The missing floor pieces will soon be introduced with GridMap
Although we’re missing a mesh library, we have a GridMap node for which we can look at properties in
the Inspector panel. We suggest that you select FloorGridMap now and read along. The information
we’ll present here will lay the foundation for you to choose the settings of the future grids you’ll use.
GridMap works with a cell concept. A cell is a volume in which one of the meshes will fit. If you
expand the Cell section in the Inspector panel for the FloorGridMap node, you’ll see that we have a
value of 2 across the board for a cell. Fortunately, our floor pieces are 2 x 2 x 2 meters as well. So, we
don’t need to change those values in our case. In your future projects, you may have to match these
values to your models’ dimensions.
We’ll ignore the Octant Size setting in our efforts since it’s for more advanced cases where you can
further increase optimization. What’s much more important perhaps is the three on/off switches for
centering the meshes inside a cell on either axis. We’ll make use of this very soon, but the following
screenshot should help you see what we have been discussing so far:
172 Designing the Level
Figure 9.16 – Each GridMap can have settings to define the dimension of the pieces it’ll use
The preceding screenshot also shows an expanded menu and its options when you click the Grid
Map button at the top of the viewport. Out of those options, Cursor Rotate Y with the S shortcut will
probably be the one you’ll use the most. The floor pieces we laid out earlier in the Creating the cave
section all follow the same direction. We tried to cover the floor with props to break the sameness but
rotating a floor piece 180 degrees around the Y axis would be another solution.
Now that the theoretical knowledge has been established, let’s move on to practical applications of
using GridMap. In the next section, we’ll create a mesh library that we’ll use in tandem with our
FloorGridMap to fill in the missing floor pieces.
Taking advantage of MeshLibrary
When you clicked FloorGridMap to investigate its properties, the Godot interface changed slightly,
and it informed you that you should assign a MeshLibrary since, without one, a GridMap is ineffective.
In this section, we’ll show you what goes into creating a MeshLibrary. We’ll also talk about possible
challenges you might face, not technically, but workflow-wise.
There are two ways to create a MeshLibrary. We’ll show you the most common way since the other
method involves keeping meshes separately in the filesystem, and our project has not been set up to
accommodate that scenario. Without further ado, this is how you create a mesh library:
1. Start a new scene and save it as Floor-MeshLibrary.tscn in Miscellaneous.
2. Choose a Spatial node as its root.
3. Instance Floor_Standard under the Spatial node in the Scene panel.
Taking advantage of MeshLibrary 173
4. Click the Scene button in Godot’s top menu.
5. Expand Convert To and choose MeshLibrary.
6. Save your mesh library as Floor-MeshLibrary.tres in Miscellaneous.
If you drag and drop the floor piece directly into the viewport, it will be placed somewhere in the
scene while considering the perspective of where your mouse cursor was. The floor may, for example,
look tiny because it will be far away from you. Zeroing the position should put the object in the center
of the world and bring it closer. If you dropped the piece into the Scene tree instead, you won’t have
this problem.
The following screenshot shows the state right before Godot converts your scene into a mesh library:
Figure 9.17 – We are converting a scene into a mesh library
Now that we have a floor piece in the library, we can add one more model to it. The goal here is to
pile up items that have similar dimensions. This may sound confusing, but let’s add the curved wall.
Why? Because although a wall is normally thinner and taller, if you think of the volume the curved
wall occupies, it’s no different than a floor piece. Its base is of similar dimensions.
So, assuming Floor-MeshLibrary.tscn is still open, here is how you can introduce another
model to the same library:
1. Find the Curve.glb wall piece in FileSystem.
2. Drag and drop it over Spatial.
3. Convert your scene into a MeshLibrary again and overwrite the existing file in Miscellaneous.
This operation will add the newly introduced piece alongside the old floor piece and update the mesh
library. Thus, an easy way to create a mesh library is to start a new scene, add as many models as you
want, and turn this scene full of models into a mesh library.
174 Designing the Level
We haven’t concerned ourselves with where the pieces will go yet. We’ve just been selecting separate
pieces as candidates to decorate a grid. Now, let’s associate the mesh library with FloorGridMap and
start laying some models.
Using a mesh library with a grid map
So far, we have been preparing a mesh library to be used by FloorGridMap. We have two pieces
inside this library. We’ll use the floor piece first, and then see if it makes sense to use the curved piece.
For a GridMap to work, you need to fill its Mesh Library property in the Inspector panel. Let’s take
care of this first:
1. Select FloorGridMap in the Scene tree.
2. Drag and drop Floor-MeshLibrary.tres from Miscellaneous into the relevant
field in the Inspector panel.
This will display all the available models as thumbnails in the reserved GridMap interface, as shown here:
Figure 9.18 – The mesh library can now be used by FloorGridMap
All there is left to do is click one of those thumbnails – for example, Floor_Standard – and move your
mouse over the viewport. You should see a preview of the selected model under your cursor. If you
click where you can see the preview, you’ll make it permanent. Try this a few times.
Isn’t this a lot easier than laying out all the floor tiles by yourself? But wait a minute – you’ll most
likely notice that something looks slightly odd. It’s as if the floor pieces are not quite where they are
supposed to be. They snap to each other, but they don’t seem to quite respect the old coordinates.
They are either elevated, penetrating wall pieces, or situated off the walls.
This is something you’ll regularly come across when you work with grid maps. The solution is easy,
but keep in mind that this is not exactly a problem either. It depends on the origin points you set for
your models. So, yes, the origin points are something you may have to deal with even after you have
exported your models. As a result, you can either fix your origin points by going back inside Blender
and re-exporting your models or use some of the options available to you in the Inspector panel.
Taking advantage of MeshLibrary 175
For now, let’s try to turn the following Cell settings on and off:
• Center X
• Center Y
• Center Z
There is no set formula for whether these properties should be on or off. It depends on the models
that are used in a mesh library. For example, the Curve piece in the mesh library has its origin point
in one of the corners, whereas the floor piece has it, geometrically speaking, in the middle. Since there
is only one Cell setting for the whole grid map, you must have a standard way of dealing with all the
models of a mesh library. So, it’s not just about piling up a whole bunch of models haphazardly – it’s
about storing them in a way that respects cells, hence a grid structure.
To visualize what we are talking about, you can try to place a Curve piece from the mesh library onto
the scene. You’ll notice that you’ll have to reset the center settings but that this will also reset the floor
pieces back to their controversial positions. Therefore, this is something you’ve got to plan for and
make sure your objects share similar origin points, as well as similar dimensions.
Clearing a cell
You already know that clicking with the left button of your mouse will place the previewed
item from the mesh library. If you need to remove an existing cell from your scene, you can
right-click it and move your mouse around. If you happen to have the same model in preview
mode, removing the cell from the scene but not moving your cursor anywhere else may give
the impression that you didn’t remove anything. So, remember to wiggle your mouse after
you clear a cell.
The necessity of using multiple grid maps
Either for the reason that the dimensions of your models will be different, or the origin points won’t
necessarily align, you’ll eventually notice that you’re going to need to use different grid maps in your
scene. Since each grid map can have separate Cell settings, it’s entirely possible to use the same mesh
library among all these grid maps.
In this scenario, you’ll have the convenience of creating one mesh library to store all similar items –
for example, all the architectural elements – but only use some of the models for the right grid map.
This beats the hard work of creating individual mesh libraries.
176 Designing the Level
Wrapping up
Using grid maps is a convenient way to distribute objects that follow a pattern. The decision to use it
is sometimes an organic process. Most people often start building their level by individually placing
items. This is usually when they aren’t using an already existing level design software. So, the process
of creating a level happens while you are moving stuff around in a natural way, similar to moving
furniture around instead of using a floor planner.
Thus, either you decide early on or feel the need to switch to it, using grid maps will make your life
easier. That being said, grid maps and mesh libraries are full of bugs in the current version of Godot.
For example, adding new models to your mesh library scene, then exporting it as a library, won’t
always update the existing library with new models. Sometimes, the earlier items within a library will
be swapped with the newer models. So, it’s quite inconsistent. Hopefully, the fourth version of Godot
will eradicate all these problems.
We wanted to be comprehensive about different ways to create your levels. So, it felt necessary to
introduce the GridMap node, however broken it might be. This way, when the community gets this tool
implemented bug-free in the future, you know that such a convenient tool will be available and useful.
Summary
This chapter was the first out of many chapters that will help you build a game. To kick things off, we
tackled the level design aspect of the game.
This effort involved placing many elements that make up the environment Clara will experience. For
structures that are next to each other, you learned how to take advantage of the snapping feature, but
you can also decorate your scene carefree if you wish, in the case of distributing props. In the end,
you had a clean scene structure with objects grouped under the relevant nodes in the Scene tree.
Along the way, you noticed that some of the materials were either misconfigured or simply missing.
To fix these issues, you had to dive deeper into the Inspector settings for materials with which you
remedied the transparency issue. Furthermore, you wrote a shader in Godot to simulate a body of water.
Considering what you have learned so far and the likelihood that you might be designing more levels
that have grid patterns, we presented Godot’s GridMap node. To be able to use this handy tool, you also
learned how to create a MeshLibrary. Despite its benefits, this last method is broken at the moment,
but it’s something you can employ in future versions of Godot.
With that, the level is complete to the point that you can start adding a few more elements down the
road as you need them. Despite that, everything looks a bit bland. In the next chapter, we’ll learn how
to make the level look fancier with lights, shadows, and environmental effects.
Further reading 177
Further reading
Level design doesn’t always involve placing physical elements inside the game world. Sometimes, it
means enticing sound design, hiding cute or interesting lore elements pertinent to the world and story,
and adding non-player characters your players can relate to or simply hate. There is a whole layer
of psychological factors to designing good levels so that you can evoke the emotions you desire in
your players. If you want to elevate your knowledge in this domain, you are going to have to examine
resources that are not necessarily game engine-specific. So, broaden your horizons! Here are a few
resources that will get you started:
• https://www.worldofleveldesign.com
• https://www.pluralsight.com/courses/fundamentals-professionallevel-design
• https://www.cgmasteracademy.com/courses/46-level-design-forgames/
• https://www.edx.org/course/introduction-to-level-design-2
You had to write a water shader in this chapter. Working with shaders is often described as the least
entertaining or the most confusing experience among game developers. We’ll give you two links so
that you can familiarize yourself with this topic. The former is the official Godot documentation,
which should help you produce more direct results in your projects, while the latter should be useful
for more long-term needs:
• https://docs.godotengine.org/en/stable/tutorials/shaders/
• https://thebookofshaders.com/

10
Making Things Look Better
with Lights and Shadows
We have a simple and clean-looking level design, but it could use a good makeover. For example, the
sconces on the walls and the candles on the floor are just sitting there without adding much interest
to the scene. Also, there is the slight issue of having this level as an underground environment since
this is a cave. We must find a way to simulate the light from the exterior since Clara sailed her boat
in. Overall, we will have the level be lit just enough for the players to perceive things.
In this chapter, we’ll introduce lights and shadows to our workflow so that our scene looks visually
appealing. We covered lights earlier in Chapter 4, Adjusting Cameras and Lights, but we did that in the
context of Blender. While generic concepts still apply, we’ll have a chance to do things from a game
development perspective this time instead of taking an artistic render in Blender.
Shadows are not automatically available in Godot. Therefore, we’ll show you how to turn them on and
discover some of the shadow settings that balance quality and performance. Besides placing light objects
and enabling shadows, and altering their qualities, we will present a higher-level concept, creating
a WorldEnvironment. This is also referred to as post-processing and it’s a great tool to improve the
look and feel of your scenes.
Although we’ll be improving the level with each new addition of the topics we have listed so far, to tie
this all together, we’ll also tackle a somewhat advanced topic, global illumination, which will add a
realistic touch to the scene.
We have many steps to take before we will have created a handsome-looking level. In this chapter, we
will cover the following topics:
• Adding different types of light
• Enabling and adjusting shadows
• Creating post-processing effects
• Using global illumination
180 Making Things Look Better with Lights and Shadows
Even though the purpose of this chapter is to understand how the lighting system works, we’ll introduce
a few complementary Godot topics along the way.
By the end of this chapter, you’ll be able to utilize lights and enable shadows, as well as to take advantage
of global illumination and post-processing effects that will further enhance the atmosphere in the level.
Technical requirements
We’ll add and change things from where we left off. You have two options at this point – you can
either keep working on your copy from the previous chapter or use the Finish folder mentioned
in Chapter 9, Designing the Level, which is available in this book’s GitHub repository: https://
github.com/PacktPublishing/Game-Development-with-Blender-and-Godot.
Adding different types of light
In Chapter 4, Adjusting Cameras and Lights, we discussed how different types of light worked – more
importantly, the kind of effect they bring to a scene. In this chapter, we’ll revisit the same topic but
pursue the effort in the context of Godot.
Blender uses four light types: Sun, Point, Spot, and Area. However, Godot has only three lights,
as follows:
• DirectionalLight: This is the equivalent of the Sun light in Blender. We stated directionality
in the Sun light’s description. The angle of this light type is the most important since it’s an
infinitely distant light source, so all its rays are considered to flow parallel to each other. So, in
Godot, this concept is part of the node’s name, hence making it easier to remember.
We’ll not be using this type of light in our scene since it’s an indoor environment. Despite
that, it may still be tempting to utilize it to give an overall light effect, but this light source
would overwhelm the whole scene. We need something else that can be fine-tuned as we go.
Therefore, we’ll focus on the two other light types.
• OmniLight: This is what the Point light is in Blender. Lightbulbs and, yes, the sconces on the
walls, are the right kind of objects for which this type of light is good. As a reminder, omni
means in every direction.
• SpotLight: This one is self-evident – it’s the Spot light in Blender. It’s good for simulating car
lights, flashlights, and any other light source that has a beam-like quality. We’ll be using this
light to simulate the exterior light creeping into the cave.
So, where is the Area light in Godot? It simply doesn’t exist. There are different mechanisms in
Godot that you can use to simulate the effect of an Area light in Blender. Often, this kind of light is
for mimicking the light coming in from a window, and it can be simulated with emissive materials.
Speaking of using different types of light, let’s start by lighting those candles.
Adding different types of light 181
Lighting candles
For this type of exercise, the OmniLight type is the right choice, but how many are we supposed
to have? If you look closely at the candle model, you’ll see that the model is composed of multiple
candles; some short, some tall. Does it make sense to place one OmniLight above each wick? It’s
entirely possible but it’s also an artistic decision to make, and we leave it to you.
In our case, we’ll assume that the overall light coming from this object could be reduced to a point
over the candles’ wicks. Thus, it’s perfectly fine to place one OmniLight for the whole model. It’s time
to demonstrate how this can be done:
1. Double-click Candles_1.glb in FileSystem to create a New Inherited scene. Save it as
Candles_1.tscn in its original folder (Models/Candles/).
2. Add an OmniLight to the Scene tree.
3. Adjust its Y position to 0.8, for example, so that it’s slightly over the wicks.
This will place a point light in your candle scene. Right now, with the default settings, it’s hard to see
the impact. If you get close to the light object and adjust your camera angle so that you no longer see
the horizon and the sky, you can get a better view. Perhaps turn the visibility of OmniLight on and
off in the Scene tree to see the light’s contribution.
We’ll leave most of the settings in the Inspector panel untouched for now, but you can change the
light’s color to, for example, d6d58e. This can be found under the Light section in the Inspector
panel. The result is as follows:
Figure 10.1 – An OmniLight with a yellow color right over the candles
182 Making Things Look Better with Lights and Shadows
Let’s take a moment to discuss why we’ve added a light to a scene that we are constructing out of a
model instead of directly adding it to the level scene. After all, we already had several Spatial nodes
to hold items that were similar, such as walls, columns, and more. We could have created a Spatial
node called Lights and stuck a bunch of OmniLight nodes in there.
By introducing a light node to the model scene instead of the main level, you can utilize this candle
scene in other scenes as well. Hence, you don’t have to create more light objects and position them
over all the candles in the level. When you are decorating a level, and when you need candles, they
will arrive as a full-service package.
Overcoming the jagged edges
After adding lights to the scene, you may notice that some objects look jagged around the edges
since the details are popping up more. To eliminate this, you can turn on the anti-aliasing setting.
The hard edges will be smoothed out, objects will blend more seamlessly, and everything will
look easier on the eyes. To enable it, set the Msaa value to 2x. This setting can be found under
the Quality subsection of Rendering in Project Settings.
So far, so good, but will the lights always be on? It seems so, for now. Let’s see how we can complete
the full-service aspect of the candles by introducing a mechanism that will switch the lights off. To
do this, we need to add a short script:
1. Right-click the root node (Candle_1) and choose Attach Script.
2. Keep everything the same in the upcoming pop-up screen, but change the path so that it
shows /Models/Candles/Candles.gd.
3. Your script file should contain the following lines of code:
extends Spatial
export(bool) var is_lit = false setget switch
func switch(condition):
 is_lit = condition
func _process(_delta: float) -> void:
 $OmniLight.visible = is_lit
This will create a toggle state for OmniLight, and it’ll start its life off by default. Only when the player,
or you as a developer, change the value of is_lit will the light become visible again.
Adding different types of light 183
To test this without running the game, you can add the tool keyword at the beginning of the script
and see your changes live while you are still working on the level. Observe how the light’s visibility
changes in the Scene panel when you toggle the state of is_lit in the Inspector panel.
We have another candle model, Candles_2.glb, that could also benefit from all this. Instead of
starting from scratch, this is what we suggest you do:
1. In the Candles_1 scene, right-click the OmniLight node in the Scene tree and choose Copy.
2. Create a scene out of Candles_2.glb and save it in its original folder.
3. Right-click the root node of this new scene and choose Paste.
4. Select the root node and attach Candles.gd to the Script property in the Inspector panel.
This will minimize the number of steps you have to take to add an OmniLight, position it, then write
pretty much the same script for controlling it. Here, we are using the same script for both scenes since
the node references in the scene are the same. After making our most recent changes, the Godot editor
will look as follows:
Figure 10.2 – A new candle scene using the same script for switch functionality
Although we have been working on a smart way to add lights via attaching light objects to the candle
models, we haven’t made any changes to the level itself. We will discuss this next and share a few words
about workflow improvements that you can make in your future projects.
Introducing candles to the level
In Chapter 9, Designing the Level, we instructed you to instance glTF files directly to the level, which
kept the filesystem clean without creating redundant .tscn files. Otherwise, you’d have had one scene
file per model with no purpose at all. A simple workflow such as only adding the models to a scene is
often enough, especially in cases where you don’t have prior knowledge of where your project is headed.
On the other hand, in certain cases, such as where you have candles and sconces, you will most likely
have a light node beside a MeshInstance node, as well as a script attached to control the light’s behavior.
In that case, it pays off to convert the model into a scene and build up from there.
184 Making Things Look Better with Lights and Shadows
The Scene tree for the level still holds the raw candle models. In Chapter 9, Designing the Level, we used
two types of candles but three models in total to decorate the level. It’s perfectly alright to remove these
models from the level so that you can instance the new candle scenes. You would have to reposition
these new items though. So, we’ll follow a different path to keep the position information:
1. Select Candles_1 in the Scene tree.
2. Instance Candles_1.tscn, which will result in a nested node.
3. Drag this nested node out of its parent and make it a sibling of its parent.
By nesting the candle scene inside the old model instance, we are appropriating the position. If you
added the candle scene directly into the Props node, you’d have to find the position of the model
instance and apply it to the new item.
You can repeat this process for the other two candles, which will eventually double the number of
visible candles in the level. That being said, our initial three candle model instances are no longer
necessary, so you can delete them. Also, notice how a script icon appears in the Scene tree when you
bring the candle scene versus keeping just the model itself. The following screenshot shows the result:
 Figure 10.3 – The new candles in the Scene tree have script icons
The preceding screenshot shows not only the more advanced candles that have been added to the level
but also the fact that you can turn these candles on and off via the Is Lit property in the Inspector
panel. Similar to what you’ve done for the candles, you can continue practicing point lights by creating
a scene out of the sconce model. In that case, the light object’s position in the scene will most likely
be higher since the model is taller, but the concept is the same. You can even bind the same script to
the root of this sconce scene.
This creates a bit of a dilemma though. So far, we have kept everything related to candles in their own
folder, with the script included. However, the light switch script is so generic that it could be used
within any scene that has a similar structure. Although it’s also possible to attach the Candles.gd
script inside the Candles folder to a scene in a different folder, if you want to generalize things, you
can move the script file into a separate Scripts folder at the root of the project.
Adding different types of light 185
This is one of many project management conundrums you’ll face, so it’s up to you how you want to go
with it. We’ve decided to keep things as generic as possible. Hence, the Finish folder of this chapter
will have both the candles and the sconce share the light script from the Scripts folder.
After swapping the sconce models with the sconce scenes, the level will have a bit more character, as
shown here:
Figure 10.4 – Three candles and four sconces are illuminating the level
We have the basic lights covered, but we still don’t have the kind of light effect you may see inside
a cave. The idea is that Clara used an opening to enter this structure, so it makes sense to get some
sunlight into the general area. We’ll achieve this by using a SpotLight node.
Mimicking the sunlight
The narrative in our game is that the dock area Clara secured her boat to wasn’t too far off from the
entrance. Hence, it makes sense to get some sunlight from the exterior. An easy way to get an effect
like this is to use a SpotLight node. Let’s also discuss an alternative.
Using a DirectionalLight node seems tempting at first, but that would brighten the whole scene. Also,
we want this cave to look as dark as possible, and only to be illuminated with artificial lights such as
candles and sconces. To achieve both goals, you’d have to position planes over the level, pretending
that they’re the cave’s ceiling, to block most of the light. So, since that kind of effort feels counterproductive, we’ll try to light what we need instead of blocking the light.
Therefore, using a SpotLight node seems to be the best choice we have. We’ll describe the process we
used to place the light over the level so that it highlights the boat and a portion of the pier. Here we go:
1. Select the root node of the level (Level-01).
2. Add a SpotLight node and position it over the boat seven units or so in the Y direction.
3. Rotate it -70 degrees in the X and Y directions (hint: use Rotation Degrees under Transform
in the Inspector panel).
186 Making Things Look Better with Lights and Shadows
4. Change its color to d6d58e.
5. Expand the Spot section in the Inspector panel and set the following values:
I. Set Range to 20.
II. Set Angle to 55.
We’ll provide you with a screenshot right after we explain what the intention with the light’s placement
is and give a disclaimer about the screenshot itself. Since the default environment settings in your
Godot project will result in a scene that’s too bright for you to see the impact of what you are doing, we
temporarily tweaked some settings to better highlight the contribution of the light you are working with.
We’ll study environment effects in the Creating post-processing effects section after we finish exploring
lights and shadows. For now, we still owe you an explanation about the settings of the SpotLight node.
Even when you’ve been following a similar layout, the coordinates you have picked for your floor tiles
might be so different that there is no easy way to ask you to place the light in a certain position. Hence,
we are giving you a mix of general and precise directions. This is what we have got so far:
Figure 10.5 – The SpotLight node simulating the sun in the cave
Enabling and adjusting shadows 187
The preceding screenshot shows the SpotLight node right above the boat’s back. We chose the top-down
view for you to see how far the light goes from this object. The Range and Angle properties you set in
the Inspector panel will configure this light source so that it reaches far and wide enough to illuminate
the entrance partially. Thus, if your layout necessitates different values so that you have an area lit just
enough, as shown in the reference picture, you may have to alter the rotation and position values.
If you fancy, you could create another SpotLight node and alter its values as if there is a secondary
opening in the rock formation that is letting more light through. Once you figure out the technical
parts, it’s up to you to push the envelope for an artistic result that pleases you.
So far, we’ve been analyzing different types of light and their impact on our level. With light, we usually
expect shadows. These are not enabled by default, so we’ll discover how to turn them on, as well as
adjusting a few settings in the context of our project.
Enabling and adjusting shadows
In some situations, such as in stage arts, engineers work hard to illuminate parts of a stage with lights
by casting their beams from so many angles that shadows can be eliminated. That’s an extreme case.
Normally, a shadow is something that occurs naturally when there is a nearby light source.
Despite this natural phenomenon, simulating shadows doesn’t automatically happen in computer
simulations just because there is a light object. The GPU has to know where the light is coming from
and how strong it is. So, it can create an area, starting from the base of the object the light is turned
to, and stretch this area out gradually in the opposite direction to the light by blending it into the
surface the object is standing on. This is approximately how shadows are calculated and simulated
by computers.
In Godot Engine, a light source is responsible for its own shadow. This means the shadow settings are
part of a light object, but since the effort is resource-intensive, Godot has this property turned off by
default. Let’s look at an example and see how we can enable it:
1. Double-click the Candles_1.tscn item in FileSystem to open it.
2. Select the OmniLight node and expand its Shadow section in the Inspector panel.
3. Turn the Enabled property on.
188 Making Things Look Better with Lights and Shadows
The color of the shadow is irrelevant at this point, but it might be something you can tweak in your
projects to get the dramatic effect you wish. At this point, we advise you to open the Candles_2 and
Sconce scenes to enable the shadow for the OmniLight nodes they have. When you save all these
three files and go back to the Level-01 scene, you should see something similar to the following:
Figure 10.6 – Let there be shadows, and shadows you shall have
Notice how enabling shadows elevates the experience overall. The column, the crates, and the other
objects have started to come to life. There is one big missing piece in this picture, though: we still
haven’t enabled the shadows for the light source we are using to simulate the sun’s effect. Go ahead
and turn its shadow on; you’ll make the pier pop up, as shown here:
Figure 10.7 – The pier and the boat look more realistic thanks to the sun’s shadow effect
Creating post-processing effects 189
We are slowly improving the visual quality of the level. Our last effort introduced shadows. They are
nice and all, but sometimes, they can also create a few defects. Now, let’s talk about some of the settings
you can find in the Shadow section of light nodes in the Inspector panel:
• Bias: Some names you come across in game development will sound technical, and won’t always
give you a quick idea about what they control. This one certainly sounds like one of those. In
simple terms, this property controls where the shadows are going to start in comparison to an
object’s volume. A picture is worth a thousand words, so please refer to the following diagram
to see what different Bias values will lead to:
Figure 10.8 – Different bias values and their effects
• Contact: When you have a high Bias value, and it creates a gap between the shadow and the
object (as shown in the preceding diagram), this property will try to fill in that gap.
So, if you happen to have visual glitches due to enabling shadows, which may result in shadows not
always meeting an object or self-shadowing issues, as shown in the preceding diagram, we suggest
you explore using a combination of the Bias and Contact properties for your lights.
The level is starting to look like there is more life to it, thanks to lights and shadows. Still, everything
looks a bit too bright. If only we could dim the overall brightness… We certainly can, and that’s what
we are going to explore next.
Creating post-processing effects
Since we are pretending that Clara is visiting a cave that’s got some human traffic in its past that led
to having a pier built and sconces hung on the walls, it’s only normal to expect some areas of it to be
really dark. We have been placing lights and turning on shadows to improve the visual fidelity of our
scene, but we are fighting against the environment; it’s just too bright.
190 Making Things Look Better with Lights and Shadows
In this section, we’ll study an interesting Godot node that will control the environment or world settings
so that you have a much better hold on how your world looks. This kind of process is also referred
to as post-processing since its effects are applied after the directly placed elements such as lights,
shadows, reflections, and others have been processed. It comes with a lot of settings, and hopefully,
this will be clearer after we explore some.
A node for everything
If you are coming from Unity, then the node system Godot uses might be confusing. In Unity,
you attach scripts to game objects to add or control the behavior of systems. Nodes are analogous
to scripts in Unity, but nodes are much more practical since you can also attach scripts to Godot
nodes. This is convenient since you can nest nodes and compose bigger node structures. In
Godot, you’ll most likely find a node that will do a crucial job. One such node is what we are
discussing in this chapter. Also, you can find more about the process behind using nodes in
the Godot’s design philosophy section at https://docs.godotengine.org/en/3.4/
getting_started/introduction/.
Godot has a nifty node, WorldEnvironment, that is responsible for the overall atmosphere in your
scenes. Although the node’s name is quirky, introducing it to the level is no different than adding
other nodes:
1. Open the Level-01.tscn scene.
2. Add a WorldEnvironment node to the Scene tree. For its Environment property, use
default_env.tres from FileSystem.
3. Double-click default_env.tres in FileSystem to populate the Inspector panel with
its properties.
Chances are nothing has changed, but we have effectively created a WorldEnvironment node and
attached an environment resource to it. When you create a new Godot project, it comes with a default
environment resource. Instead of creating a new resource, we are repurposing the default environment
resource that’s been sitting in the project folder all this time.
This opens up different possibilities for you. Your game may have different levels where you would
like to have the visual clues support the characteristics of a particular level. In a situation like that,
your project folder could store multiple environment resources and use them accordingly in the
WorldEnvironment node.
Although the WorldEnvironment node’s purpose may sound self-evident by its name, to fully take
advantage of it, it would be best if you practice using its properties. You can do this by looking at the
properties of the resource it’s using. There are quite a few and we’ll discover the ones that are relevant
to our goal.
Creating post-processing effects 191
Background
This part of the environment’s settings is responsible for simulating the background. Currently, the
mode is set to Sky, so the background is painted as if there is a dark ground portion that goes out far
enough to meet the sky. In this mode, you can further customize the properties of the sky you want
to depict. We won’t cover this since we are working with an indoor scene.
Thus, start by changing the mode to Custom Color. This will pick a black color by default, so the whole
background of your scene will be pitch black. This will surely accentuate the candles and the sconces.
If you would like to use Godot Engine to take in-game renders of your models, then you can set the
background to Clear Color, which will create a transparent color. We’re not using it in our case since
having a completely dark background suits our artistic needs better and also, the body of water looks
a bit awkward with transparency underneath. We’d need another similarly sized dark plane under it
to hide the effect of transparency.
Therefore, we’ll stick with a custom background color. This will result in the following output:
Figure 10.9 – The cave is starting to look more ominous
Just a quick discussion about the Ambient Light section before we move on to ToneMap. The arched
door seems to be hidden right now because there aren’t enough lights in the scene. So, to remedy this,
you could pick a lighter ambient color. However, this will make the overall scene brighter again, and
you’ll have some of the dark areas more lit. There is a much more judicious way to keep darker areas
still dark but have the effects of light sources spread out further. We’ll look into achieving this kind
of getting the best of both worlds later, in the Using global illumination section.
192 Making Things Look Better with Lights and Shadows
ToneMap
This is something you can use as a quick solution for blending lights into darker areas, which will
make everything look a bit more homogeneous. It comes with a few properties of its own:
• Mode: The default mode is Linear, and this is what you’ve been experiencing all along. We
leave it to your taste, but we suggest you change it to Filmic or ACES Fitted. It’ll remap the
tones of the whole scene to the point that things will start to look more realistic.
• Exposure: Compared to Linear mode, the other modes may make your scene look really dark.
Changing Exposure will brighten the scene while still applying the tone mapping.
• White: Digital cameras have a setting similar to this one. You designate a tone as white so that
the other colors can be calculated according to this new baseline. Smaller values will blow out
the whole scene because it’ll start considering a lot more colors as white. Naturally, higher
values will exclude more colors, and make the scene darker.
We won’t mess with the Exposure and White values in our exercise, but this is what we have after
choosing ACES Fitted for ToneMap:
Figure 10.10 – Everything looks more pronounced thanks to tone mapping
Since we’ve touched on the concept of exposure, a quick word about enabling Auto Exposure. We
won’t use it in our work, but it is a helpful option for mitigating some of the problems you may face
when the camera transitions between indoor and outdoor areas.
Creating post-processing effects 193
Screen Space Reflections (SSR)
When some objects have reflective qualities due to their material settings, such as Metallic, Specular,
and Roughness, turning this environment setting on will create a more realistic effect.
To appreciate the impact of SSR, the level must have more light, so it may not look like much is
changing when you turn it on. The body of the statue has a reflective material. Thus, if you zoom
into that area, you should be able to see some reflection where the feet of the stag meet the pedestal.
Reflections will be more pronounced when there are more lights nearby. When we work on the player
character’s involvement in Chapter 12, Interacting with the World through Camera and Character
Controllers, and Clara walks by the statue with a torch in her hand, you may notice the effect even
better. Until then, we’ll simply have this feature enabled.
Ambient Occlusion (SSAO)
This isn’t the first time we have come across this term. We first got to know it in Chapter 4, Adjusting
Cameras and Lights, when we wanted to emphasize the edges of the objects where they connected.
Similarly, we’ll turn this setting on in Godot too, but we have to tweak a few properties:
• Light Affect: You won’t see the effect of Ambient Occlusion without the contribution of this
property, so we are describing it first. It’s for adjusting the role of light sources in the occlusion.
We’ll set it to 1.0.
It seems as if we are using it as an on/off switch in our current situation. However, since it
can be any value between 0.0 and 1.0, you can use it as a useful scale by controlling the
value with scripts. This works in cases where you don’t want to fully turn off the occlusions
but gradually decrease them.
• Radius: When objects are close to each other, the contact points will look occluded. This
setting is for adjusting the area that will be considered in the calculation for creating the correct
amount of occlusion. We picked 0.4 as our value, but you can set it to any value, depending
on your taste.
Additionally, the Intensity property can be used with Radius to create more accurate
occlusions. Also, with the help of a secondary set of radius and intensity, you can overlay
more details.
194 Making Things Look Better with Lights and Shadows
As with most things in game development, adjusting the correct amount of Ambient Occlusion is
often an artistic endeavor. With the suggested values, the result will be as follows:
Figure 10.11 – The level after Ambient Occlusion has been turned on
The preceding screenshot may not be doing what we have achieved much justice. However, if you
compare the previous two screenshots, you can see the occlusion in between the bricks, and also where
the crates are making contact with the floor.
Glow
This feature is often referred to as the bloom effect in other applications. It’s used to exaggerate the
effect of colors, and especially light sources. While it has many properties, we’ll only focus on a couple:
• Bloom: A value such as 0.2 will be enough to accentuate the effect of the sconces and the
candles. In essence, while dark areas will stay relatively dark, lit areas will be glowing.
• Blend Mode: To increase the impact further, we suggest that you set this to Additive. It’ll give
the lights in the scene a real nice cozy effect since the light sources are open fires.
Creating post-processing effects 195
We won’t touch the rest of the settings. The following screenshot shows the final state of the level:
Figure 10.12 – Our light sources glow in the dark
In the Glow settings, there is a particular section called Levels. You can expand that area and decide
how far out the bloom and blur effect will emanate. It’s useful when you want to adjust the detail of
the bloom that’s engulfing an object.
Adjustments
While applying different environmental effects, some of the features will be competing against each
other. Even though we have more oomph for the lights, and more defined contours and shadows for
the models, after a while, you may end up with a scene that looks a bit washed out. You will employ
two properties of the Adjustments feature that will give your scene a decent touch:
• Brightness: Our main tool to remedy the washed-out look is increasing the contrast. However,
turning up brightness alongside contrast works better. Feel free to adjust it the way you like it,
but a value such as 1.1 or 1.2 might be enough.
• Contrast: This will tidy up the dull look and give the whole scene a more vibrant look. Using
a value such as 1.1 will make things look better in tandem with more brightness.
We could go on forever while changing so many of these settings. Depending on your taste, you may
prefer different effects. However, we are content with what we have so far.
196 Making Things Look Better with Lights and Shadows
Wrapping up
Our level’s look has changed drastically since we first started laying out the floor and wall pieces.
Ordinary-looking brick surfaces now have character, and the scene looks more ominous, thanks to
lights, shadows, and finally, the environment settings. This can be seen here:
Figure 10.13 – The post-processing effects are all in place and working together
Depending on the atmosphere you want to create for your game, you can come up with a different
combination of post-processing effects. Also, you can adjust their values programmatically during a
game session to entice the player even more.
When one is too many
Post-processing effects are nice. You may feel like a kid in a candy store. However, keep in mind
that some effects will enhance each other, and some will outdo each other. At the end of the
day, you may end up having too many effects in play that are a burden on your computer. You
can hear the cost of it when your GPU is vehemently trying to cool off.
Despite our efforts to improve the look of our level, there is room for improvement. While we have
noticeably enhanced dark and bright areas, the scene is still missing another real-life quality that is
often referred to as global illumination in the industry.
Using global illumination
If you’ve ever used a digital camera, you may already be familiar with the concept we are going to
present in this section. Our brains, through expectation and familiarity with a similar environment, will
blend in the light with darker areas, and fill in the missing parts. A camera, on the other hand, doesn’t
have prior knowledge of how places must look, and it can’t process dark areas as well as our brains.
In other words, the human brain approximates the missing parts and paints a more complete picture.
Using global illumination 197
The rendering engine has worked like a camera so far. If you look at the level now, you’ll see that the
arched door is in the dark. It would be nice to have certain areas look more like what we would expect
them to look like. If we increased the intensity of the light sources, it would cast the light farther away.
However, we’d still end up with some areas darker than others. We need something that extends the
effects of the existing light sources similar to the way our brains process light.
To that end, we’ll introduce global illumination to achieve a more realistic look. Via this method, the
area near the arched door will look like it’s getting more light from nearby candles and sconces. If you
haven’t guessed it already, there is a node for this job. Let’s add it to our scene:
1. Select the root node of the level.
2. Add a GIProbe node.
3. Adjust Extents in the Inspector panel so that x is 12, y is 5, and z is 15.
4. Turn its Interior setting on.
5. Position this probe in your level so that it engulfs everything like an envelope.
GIProbe will resemble a green wireframe cube initially. After you place it so that it wraps around the
level, the Godot interface will look as follows:
Figure 10.14 – GIProbe is in place but it’s not functional yet
This node will probe the light sources in its volume. Then, it will interpolate this information to
darker areas so that the light can be distributed more evenly, just as our eyes would expect. Although
the probe is ready, we need to take care of two important things before we trigger the calculations.
198 Making Things Look Better with Lights and Shadows
Turning on Light Baking
We have already seen some of the import settings relevant to 3D models. For example, we saw that
materials are imported automatically because it’s the default setting in the Import panel. Also, using the
Animation section in that panel, we were able to extract the actions from a model into the filesystem.
All this was covered in Chapter 7, Importing Blender Assets into Godot.
We’ll revisit the Import panel for a different need this time. We want some of the models to receive
more light. So, by turning Light Baking on, some models will receive extra lighting information
that’s been sent by GIProbe. As the name suggests, this technique will bake some of the light in the
scene into a model’s material once. Then, it’ll get updates as needed when the light conditions change.
So, we’ll pick a list of models that look like they could benefit from light baking since they have large,
uninterrupted surfaces:
• Wall (Wall_Hole)
• Curve
• Floor_Standard (Floor_Standard_Curved_1 and Floor_Standard_Curved_4)
• Column_Round
Smaller objects such as props are usually not good candidates for light baking, but technically, you
can turn the setting on for any model you import. For now, we’ll select the wall model and enable
light baking for it:
1. Select Wall.glb in FileSystem.
2. Bring up the Import panel and scroll down to find the Light Baking option (hint: this is the
last option in the Meshes section).
3. Change its value to Enable.
4. Click the Reimport button.
5. Repeat this process for the other aforementioned models.
Generally speaking, we are enabling light baking for the architectural models in the scene. This is one
part of the equation. Now that we have configured the models to accept light baking, we have to tell
the renderer how much light should be baked into the materials for these models. We’ll do that by
adjusting the energy levels of the light sources we have used so far.
Adjusting Indirect Energy
The second most important thing in having proper global illumination is to adjust the energy levels
of the light sources. Although this section’s title indicates that we’ll be adjusting indirect energy levels,
it would also be useful to talk about what direct energy means.
Using global illumination 199
In Blender, you changed the direct energy level for lights by adjusting their Power properties, which
were measured in Watts. That meant you could have typed in real-life lightbulb values to get an accurate
result. Godot’s energy values for lights don’t follow a unit system. So, it’s more of an artistic value you
can adjust based on your scene and liking.
While the Energy property, also known as direct energy, defines how intense the light will be, its
Indirect Energy value is used to calculate the natural effect we described earlier in the opening lines of
the Using global illumination section, where we made a comparison between human sight and cameras.
There is a simple way to observe this effect at home when it’s sufficiently dark. You can light a candle
and observe that there is going to be an adequately lit area near it. Then, the light will drop off gradually
into the distance, but you’ll still be able to notice some faraway objects. Their details won’t be quite
clear, but their most characteristic shapes will be apparent to the eye. It’s possible to simulate this kind
of effect with indirect energy using GIProbe.
For this effort, we have to adjust some of the OmniLight nodes we have used so far:
1. Open Sconce.tscn and select its OmniLight node.
2. Change its Indirect Energy to 2.5 under the Light section.
3. Change its Range to 8 under the Omni section.
This will increase the range of the light that’s emanating from the sconces so that it’ll reach farther.
The energy level of 1.0 has already been used, hence we’re only adjusting the indirect energy since we
want it to contribute to global illumination.
Let’s repeat this effort for the candles with different values:
1. Open Candles_1.tscn and Candles_2.tscn and select their OmniLight nodes.
2. Change Indirect Energy to 1.5 and Range to 3.
Compared to sconces, candles shouldn’t emit that much light. So, it makes sense to have lower values.
However, since there isn’t one candle but a group of candles, the values aren’t too far off. This is
something you may have to balance in your work too: artistic concerns versus realism.
We’ve been settings things up for GIProbe to do its job. It seems like we have increased the overall
light in the scene. We need it to be that way since some of this extra light will go toward calculating
a better light distribution. All there is left to do is trigger GIProbe:
1. Select GIProbe in the Scene tree.
2. Click the Bake GI Probe button in the header just above the 3D view.
200 Making Things Look Better with Lights and Shadows
Godot Engine will calculate how light bounces off the surfaces of the models for which you have
enabled light baking. Depending on the intensity, range, and indirect energy of the lights, the darker
areas will receive more light. This will result in a more even distribution and give a more realistic look
that meets our expectations. Figure 10.15 shows the before and after of what global illumination does
for the area near the arched door:
Figure 10.15 – The door has become more noticeable thanks to more evenly distributed light
Depending on the size and layout of your levels, you may need to place multiple GIProbe nodes. For
example, if you were designing a dungeon with many rooms and hallways, it might be a better idea
to consider each room and hallway as a unique GIProbe node since the distribution of lights will be
achieved more accurately.
Also, when you have a level where an outdoor environment is connecting to an indoor environment,
it’s a good idea to create one GIProbe for each area and adjust the Interior settings accordingly.
Using one major node that encompasses the whole level will do an injustice to either environment,
so introduce as few and, sometimes, as many as necessary.
With that, we have improved the look of our level. Let’s summarize the steps we have taken to get here.
Summary
The level we took over from the previous chapter looked complete, and yet uninteresting. To give it
more life, we introduced a few instruments in this chapter.
First, we introduced two types of light nodes, OmniLight and SpotLight, to simulate candles, sconces,
and the sun’s effect in the cave. While accomplishing this, you also saw the reason why creating a scene
for a model might be useful, as well as necessary, compared to instancing the models directly in the
level. This effort was followed by adding a small script that can help you switch the lights if needed.
We’ll utilize this functionality later in this book.
Further reading 201
Though lights were an obvious tool for improving the visuals, we also investigated shadows. They
are resource-intensive, so you may want to turn them on for the lights that will have an important
impact on your scenes.
To truly appreciate the effect of lights and shadows, we applied a bunch of environment settings.
Although this helped the visuals a great deal, to elevate the realism to the next level, you’ve been
introduced to global illumination. By carefully choosing which models should receive more indirect
light and adjusting the setting of the lights in the scene, you’ve shed more light on certain areas, which
resulted in a more accurate representation.
In the next chapter, we’ll work on a different kind of visual system. It’s a useful mechanism with which
players can interact with the world: user interfaces.
Further reading
Out of all the topics we have presented in this chapter, global illumination is the most technical one.
Simulating real-life light is a challenging task, and professionals out there are still actively working
toward this goal. If you want to get a taste of it, here are a few links that should give you a better idea
about what it involves:
• https://ohiostate.pressbooks.pub/graphicshistory/chapter/19-5-
global-illumination/
• https://www.scratchapixel.com/lessons/3d-basic-rendering/globalillumination-path-tracing
• https://developer.nvidia.com/gpugems/gpugems2/part-v-imageoriented-computing/chapter-38-high-quality-global-illumination
On a more practical note, the official Godot documentation might be useful if you wish to learn more
about what we have covered in this chapter:
• https://docs.godotengine.org/en/3.4/tutorials/3d/lights_and_
shadows.html
• https://docs.godotengine.org/en/3.4/tutorials/3d/environment_
and_post_processing.html
• https://docs.godotengine.org/en/3.4/tutorials/3d/gi_probes.html

11
Creating the User Interface
To start this chapter, let’s begin by asking a simple question: what was the first multiplayer game
you played?
If you are thinking of a PC or a console game, try thinking another way. Imagine a bunch of kids
holding their arms out, pretending to shoot and take down the bad guys invading their neighborhood.
Perhaps there was an evocative action movie the night before on TV. Now, these kids are bringing to
life what they think is possible within the realm of physics, mixed with a bit of fantasy and what they
remember from the movie. Some kids will even pretend they have been harmed along the way. Fallen
comrades will be avenged in the end, and good will once again prevail against evil. Who’s keeping the
score here – that is, who has how many hit points?
How about the servers, internet speed, and likewise? Did the kids even need a user interface (UI) to
play their game? No, because it was still easy for them to keep track of what was happening. But when
the number of things people need to pay attention to gets beyond a certain point, it gets overwhelming.
In other words, a UI is needed when using a system without one becomes impractical.
This is not unique to video games. In the real world, you use an ATM to access your bank accounts.
The information and functions you need will be presented in a clear, concise manner; checking your
accounts, sending e-transfers, and accessing the current interest rates are quick and easy to do all from
one place, thanks to a well-designed UI.
In our game, despite what Clara expected, her uncle was not there but had left a note on the pier. We
need a way for the player to access this information. Thus, in this chapter, we’ll present a few of the UI
components Godot has in its arsenal to convey this message. We’ll start with a simple Button node,
followed by a Panel component. In this panel, we will display some text via the Label component.
While you are adding more and more UI elements to the game, you’ll also learn how to apply styles
to these so that they look more like they belong to the game world. After all, the default ones have
that default gray look, which might be better suited for prototyping.
Styling Godot nodes may feel tiresome after you do it more than a few times, especially if you are
doing it for the same kind of button with different text. As a solution, we’ll demonstrate how to take
advantage of themes, which is a powerful tool that will help you in your styling efforts.
204 Creating the User Interface
As usual, we’ll be discussing a few relevant side topics that are pertinent to the creation of UIs. With
that in mind, in this chapter, we will cover the following topics:
• Creating a simple button
• Wrapping in a panel
• Filling the panel with more control nodes
• Taking advantage of themes
By the end of this chapter, you’ll have learned how to exploit UI nodes to help the player read the note
that Clara’s uncle had left for her.
Technical requirements
If you think you don’t have enough artistic talent to create UIs, then rest assured for two reasons. First,
we’ll mainly focus on utilizing the UI components in Godot. Therefore, the graphic design aspect won’t
be our concern. Second, we are providing you with the necessary assets in the Resources folder
in Chapter 11 of this book’s GitHub repository. Inside it, you’ll find two folders: Fonts and UI.
Simply merge these two folders into your Godot project folder.
This book’s GitHub repository, https://github.com/PacktPublishing/GameDevelopment-with-Blender-and-Godot, contains all the assets you need. Lastly, you can
either continue your work from the previous chapter or utilize the Finish folder from Chapter 10.
Creating a simple button
A UI is a collection of components you lay out in a coherent manner around the core visuals of your
game. The most essential UI component to start with may have been a Label node if we wanted it to
be similar to printing “Hello, world!” when we are learning a new programming language. However,
we’ll start with a Button node since the former case is so trivial, and we can also learn how to style a
Button during this effort.
Before we start throwing around a bunch of UI nodes willy-nilly, we should first mention the right
kind of structure to hold our UI nodes. We can use CanvasLayer similar to using a Spatial node to
nest other nodes such as MeshInstance, AnimationPlayer, and others.
We’ve already been creating scenes mainly to display 3D models. Let’s follow similar steps for the
sake of creating the UI:
1. Create a blank scene and save it as UI.tscn in the Scenes folder.
2. Choose CanvasLayer for its root node and rename it UI.
3. Attach a Button node to the root and rename it Close.
4. Type Close for its Text value in the Inspector panel.
Creating a simple button 205
There’s nothing fancy going on so far, but we now have a button aligned, by default, to the top left
of the viewport. The width of this button also expanded when you were typing the text it displays.
Control versus CanvasLayer
We mentioned that a Spatial node would be the root node for 3D nodes. So, for the sake of
keeping things familiar, we could have used a Control node to hold the Button node. Rest
assured, you could still inject a Control node inside a CanvasLayer. The real reason we used a
CanvasLayer as the root is for its Layer property in the Inspector panel. By changing the value
of this, you can change the draw order, which means you can decide which CanvasLayer will
render first. This is a useful mechanism when you have multiple UI structures that need to be
layered on top of each other in a precise order.
The button we have just added looks boring. It doesn’t quite fit the world we are creating. Now, let’s
use a custom graphic asset to style our button:
1. Expand the Styles subsection in the Theme Overrides section of the Inspector panel.
2. Using the dropdown for the Normal property, select the New StyleBoxTexture option.
3. Click the StyleBoxTexture title as it will populate the Inspector panel with its properties.
4. Drag button_normal.png from UI into the FileSystem panel and drop it in the
Texture property.
5. Expand the Margin section and type 8 for all the margin values.
6. Press F6 to launch the UI.tscn scene and try to interact with the button.
You have taken quite a few steps to style a simple button, so let’s break down what’s happened.
In step 1, you told Godot that you wanted to override the default theme, which was giving that gray
look to the button. Without user interaction, the button will be in its normal state; so, that’s what you
intend to change in step 2. We’ll discover how to change the other states very soon.
Step 3 was about defining the properties of this Normal state. For this, you used an aptly named
texture file in step 4. Then, in step 5, you adjusted the margin values so that the texture permitted
the text to have enough room without snapping to the edges. For example, try to change the text of
the Close button to Lorem ipsum dolor sit amet. Notice how the button is getting wider
without looking stretched and keeping the rounded corners intact. This needs a proper explanation.
Setting margins involves doing more than just accommodating text. Carefully selected values will
make sure the texture will enlarge or shrink as needed without losing some of its qualities, such as
rounded corners. When the asset has rounded corners, if the texture is stretched, you will end up
with a distorted look. The practice of conserving the core features of a texture and allowing it to
be resized properly without distortion is called 9-slice scaling. You can learn more about it here:
https://en.wikipedia.org/wiki/9-slice_scaling.
206 Creating the User Interface
When you launched the UI.tscn scene in step 6, the button must have shown its normal state as a
brown texture. If you move your mouse over it, you’ll see that the button will show the default look
again because you haven’t set the hover state yet. This can be seen in the following screenshot:
Figure 11.1 – The button only has its normal state styled
Similar to the way you assigned a texture to the normal state of the button, you can do so for the other
states. Let’s do this for the hover state:
1. Select the Close button in the Scene tree.
2. Assign a New StyleBoxTexture to the Hover state in the Styles subsection under Theme
Overrides and click this StyleBoxTexture to set its properties.
3. Drag button_hover.png from the UI folder and set the margins to 8.
4. Press F6 and move your mouse over the button.
We’ll repeat this effort for the pressed and disabled states as well. We won’t use disabled buttons in
our game, but why not be thorough? Also, in most scenarios, you can repurpose the pressed state for
the focus state. The different results are shown in the following screenshot:
Figure 11.2 – The normal, hover, pressed, and disabled states of a button with a custom texture
Before we move on to introducing more UI nodes, we suggest that you change the text of that button
back to Close since we’ll use this button to close a panel that will simulate a note from Clara’s uncle.
Speaking of which, it’s time to learn what was written in that note.
Wrapping in a panel
So far, we have created a button and styled it. However, it would be nice if it served some purpose,
especially since we gave it a meaningful label. We’ll write some code so that this button can close a
panel near the end of the Filling the panel with more control nodes section. Before we get to that point,
though, we need the panel.
As we are introducing more UI nodes, let’s remember why we are doing this within the game’s context.
Clara’s uncle had left a note. We’ll simulate that note with a combination of UI nodes in Godot so
that it looks as follows:
Wrapping in a panel 207
Figure 11.3 – Clara’s note
We’ve already taken care of the button, but it is currently sitting in the middle of nowhere. We’ll wrap
it in a Panel node in this section after we give a short disclaimer.
A Panel node is just another Control node in Godot that usually holds other components. There is
a similarly named node, PanelContainer, which might be confusing for beginners. The Panel node
derives from the Control class, whereas the PanelContainer node inherits from the Container
class. Also, the Container class inherits from the Control class. This kind of technical detail might
be important when you are doing more advanced work. We won’t, so either one would work fine for
our intents and purposes in this book. Therefore, we’ll stick with the Panel node.
At this point, we are ready to add a Panel node and style it:
1. Add a Panel node under the root UI node in the Scene tree.
2. Expand the Rect section in the Inspector panel.
3. For the Min Size property, set the following values:
I. Type 600 for X.
II. Type 400 for Y.
4. Assign a New StyleBoxTexture to the Panel property in the Styles subsection under
Theme Overrides.
5. Drag the Close button over the Panel node in the Scene panel so that the Close button is nested.
208 Creating the User Interface
At this point, you should have the following output:
Figure 11.4 – The paper texture has been simulated with the help of a Panel node
We are getting closer and closer to the desired design we imagined for the note. The button in the panel
is still aligned to the top left. You can drag it to a position that makes sense, but it might be easier to
decide on that if you have some text within the panel. That’s what we’ll take care of next.
Filling the panel with more control nodes
The uncle’s note is slowly taking shape. We’ll introduce a Label node in this section for the text portion.
Additionally, we’ll have to figure out how to position all these elements so that the note resembles
the layout we’d like to have. Lastly, we’ll discuss a few complementary Control nodes you may want
to use in some other scenarios.
After all, we will still employ the most basic UI node: Label. If we had used it at the beginning, it
would have looked unimpressive with its default style and color. Since we now have a proper texture
over which this Label node can go, things will look more interesting. Follow these steps to do this:
1. Select the Panel node in the Scene panel.
2. Add a Label node and turn its Autowrap property on in the Inspector panel.
Filling the panel with more control nodes 209
3. Set its Text to the following:
My dear Clara,
A close friend of mine is in dire need of help. I must leave
immediately.
Check out the backpack by the decrepit cart. Inside, you will
find a key to upstairs. Make yourself at home.
Your uncle, Bert
Our last effort will result in an awkwardly tall text block. To remedy this, we could manually give
some width and height to the Label node we have just inserted. While we are doing that, we could
also change its position to make it look centered and have some margins off each edge. However, we
can do something smarter: we can wrap this Label inside a MarginContainer that will set margins
and automatically resize the text for us.
Adding a MarginContainer
At this point, adding new nodes to the Scene panel must be a common task for you. Nevertheless,
there are times, such as now, when deciding where to add a new node and what to nest in it might not
be obvious. The question is, where can we add MarginContainer? Outside the Panel node or inside?
A MarginContainer is a specialized container that’s responsible for introducing margins so that its
children look like they have padding. If we wrap the Panel node inside a MarginContainer, since the
Panel node is holding the text, the whole structure, including the button, will be padded. That’s not
good since we would like the text to have some space between its edges and the borders of the texture
that constitutes the Panel node. Thus, this is what you need to do to only pad the text:
1. Add a MarginContainer node inside the Panel node and nest Label inside this MarginContainer
node.
2. Set the following values in the Inspector panel for MarginContainer:
I. In the Anchor section, set both Left and Top to 0 and both Right and Bottom to1.
II. In the Margin section, set all its properties to 0.
III. In the Constants subsection under the Theme Override section, set both Margin Right
and Margin Left to 60.
210 Creating the User Interface
We touched on a lot of terms in the preceding operation. The first two sets of actions, where we alter
the values of anchor and margin, are not specific to a MarginContainer. They exist for every type of
Control node. You can also see this fact as these properties were listed under the Control header in
the Inspector panel.
The anchor and margin values we chose are such special values that we could have used a shortcut to
achieve the same result. It would be selecting the Full Rect option in the expanded menu after you
click the Layout button in the header section of the 3D viewport. This Layout button is visible in the
following screenshot, just above the top-right corner of the paper texture.
We’ll use another option under that menu when we adjust the location of the Close button later. For
now, compare your work to what you can see in the following screenshot:
Figure 11.5 – The text now has padding, although it’s hard to read
What was essential in the properties of that MarginContainer was adjusting its content margin
values in the Constants subsection. That gave the text some room and positioned it correctly over
the paper texture.
It’s a bit difficult to read the text, though. So, let’s see how we can make it legible and, even better,
make it look like Figure 11.3.
Styling the Label node
Although MarginContainer is now occupying as much space as the Panel node, and it’s providing
margins to the text it’s holding, the text itself is hardly legible since it’s small and white over a lightly
colored surface. Also, the font choice is wrong because it’s using the default font provided by Godot
Engine. We’ll learn how we can fix all these issues in this section.
Filling the panel with more control nodes 211
Let’s start by selecting the Label node in the Scene panel so that we can make some changes under
Theme Overrides:
1. Turn on the Font Color option in the Colors subsection. The color can be left black.
2. Choose the New DynamicFont option for the Font property in the Fonts subsection and
expand this option’s properties right away by clicking its title. We need to edit the subsections:
I. Drag Kefario.otf from FileSystem to the Font Data property in the Font subsection.
II. Change Size to 28 in the Settings subsection.
We’ll discuss what’s happened shortly, but here is what we have done so far:
Figure 11.6 – The Label node now looks more like handwritten text
The default black color for the text seems to be fine, but you could pick a different color if you wish.
A much more drastic change happened when we introduced a font type. We did this in two steps.
First, we picked a DynamicFont type, which is slower than the other option, BitmapFont, but it lets
you change the properties of the font at runtime. However, this is not enough to render a font since
it works like a wrapper. So, you need to assign the font you would like to render. That’s what we did
when we assigned a font file to the FontData property.
212 Creating the User Interface
There is an important caveat we think you should be aware of with fonts since they are made of
individual elements called glyphs. You can think of them as the letters in an alphabet. Not every
font supports the full spectrum of an alphabet. For example, in the note UI that we designed, if you
replace the text you will with its shortened form, you’ll, the apostrophe won’t render because
it doesn’t exist as a glyph in the font. Usually, paid fonts come with a bigger set of glyphs. Otherwise,
keep searching for free options with a more complete set.
Pixels versus points
When we chose 28 as the font size, that number was measured in pixels. In some graphics or
text editors, you’ll often find fonts measured in points. This is something you have to be cautious
about because if you transfer the numbers verbatim to Godot, your font will be rendered quite
differently. So, mind your units.
In the real world, a note from Clara’s uncle would only contain the text portion. Thus, it would be
absurd to expect a close button on top of an actual piece of paper. However, this is a game, and we’ve
already discussed how UIs mix reality with functionality. To complete the UI for the note, it’s time
we positioned that button.
Positioning the Close button
We used a nice trick to position the text concerning the piece of paper it’s on. Can we replicate this
for the Close button? Since a button can’t be considered a wide structure, we can’t stick it inside
MarginContainer. However, we can still position it relative to the Panel node.
In the Adding a MarginContainer section, we used a longer method to adjust the dimensions of that
component. We also mentioned that we would use a shortcut. This is how you can use it after selecting
the Close button in the Scene panel:
1. Expand the Layout menu and select the Bottom Right option.
2. Hold down Shift and press the left and up arrow keys on your keyboard four times for each.
This will position the Close button at the bottom right corner, then pull it up and move it left just
enough that it stays there. We mean it when we claim that it’ll be staying there. For example, select
the Panel node, then try to resize it using the handles in the viewport. Does the button stay nicely
tucked in that bottom right corner? Good! How about the Label node? Does the text flow to occupy
the extra space? Neat!
Filling the panel with more control nodes 213
Our efforts to develop what you saw in Figure 11.3 are coming to fruition, as shown here:
Figure 11.7 – Everything in the UI is positioned carefully
If you want to test your scene, go ahead and press F6. Depending on your setup, you may notice
that the Close button will not be functional since it’s behind MarginContainer. So, try to resort the
nodes in the Scene panel by dragging the nodes up and down. When you have the Close button after
MarginContainer, everything should be functional.
Speaking of functionality, we haven’t wired anything up for the Close button. Ideally, that
button should turn the visibility of the Panel off so that the note looks as if it’s been closed. Let’s do
that next.
Adding the close functionality
There are multiple ways we can attack this problem. We are going to show you one for brevity’s
sake so that you can see what’s involved. You may have to apply similar principles differently in your
future projects.
For example, the way we are treating the UI.tscn scene so far is to have one big Panel node as a
direct child. Your games may need a lot more UIs with elements permanently visible on the screen,
more notes to open and close, inventory screens with expanding parts to reveal more details, and
likewise. There are many possibilities, which is why there are different types of architectures you can
construct. There will always be a tradeoff between these different options, so we suggest you experiment
with the benefits of different UI structures if you have some spare time.
Without further ado, our suggestion for implementing the closing functionality is to add a small script
to the Close button. Select it and do the following:
1. Attach a script to the Close button and save it as ButtonClose.gd in the Scripts folder.
214 Creating the User Interface
2. Make this script file look as follows:
extends Button
func _ready():
 connect("pressed", self, "on_pressed")

func on_pressed():
 get_parent().visible = false
This architecture assumes that the button will always be the direct child of a node, so once it’s pressed,
it will make its parent invisible. Ouch!
The benefit of this kind of simple structure is the convenience that the button doesn’t need to know
the node structure it’s in. There is also a more conventional way of attaching the pressed behavior by
using the Node panel and binding a signal. Either way is fine.
Constructing and improving UI elements may easily turn into a project by itself. You might be tempted
to create that perfect setup for all future possible scenarios but keep in mind that overoptimization
is a thing. Later, you may realize that you didn’t need all that preparation in the first place. We’ll talk
about a similar situation next, where the note might be longer.
Wrapping up
We now have a fully functional UI for displaying the note from Clara’s uncle, Bert. What if Bert had
more to say? For example, let’s say the message had an extra line after his name, as shown here:
Your uncle, Bert
P.S. I think I might have left my pet snake unattended. It might be
wandering around, so be careful!
If you were to add this extra text to the end of the Label node, the text would get uncomfortably close
to the top and bottom of the paper texture. Similarly, imagine that this text block needed to be even
longer, which is the case in some types of games where exposition is important. For instance, it is very
common when displaying the details of a quest or an item in role-playing games.
Currently, we can make do by adjusting the font size of the text or making the margins narrower to
allow more room for the new text. However, in more extreme situations, it might be better to use a
ScrollContainer node. Just like you wrapped the Label node inside MarginContainer, you can wrap
a ScrollContainer around the Label node, and tweak a few things to have a scrollable text block.
Coming up with the correct level of nestedness and deciding on the type and order of UI components
is sometimes an effort of trial and error. Consequently, there aren’t any set formulas. Therefore, you
may find yourself practicing and seeing what works best in your use case.
Taking advantage of themes 215
That being said, generalizing your efforts to maintain a consistent look and feel across your many UI
nodes might be helpful. We’ll tackle themes next to accomplish this.
Taking advantage of themes
Using or, more specifically, creating themes in your projects is smart on many accounts. First, we’ll
discuss their usefulness, show you a few visual examples, and then create one for practicing. Let’s start
with the reasons why you should use themes.
Firstly, using themes will save you from manually applying overrides to the components the way you’ve
done so far. It’s still possible to keep adding manual touches here and there, but what would happen if
you wanted to change a button’s artistic direction completely? This would trigger a chain reaction to
change the look of other components too. So, you’d have to restart the manual editing. Furthermore,
the ultimate worst-case scenario would be to revert your changes because, you know, we are human
and we kind of tend to stick with our first choices more often than not.
Secondly, you could have multiple themes at the ready in your game. Although a button is still just a
button, you could assign it one theme out of many. This will make that button look like it belongs to
a family of components. Thus, your UI elements will have a consistent style.
Lastly, changing themes at runtime is a possibility. This means that if, in your game or the application
you are building with Godot, you would like to swap themes for special occasions such as Christmas,
this is entirely possible. Also, more and more desktop applications are being built with Godot. These
could also benefit from theme swapping to offer their user the best choice. Godot Engine itself allows
you to change themes. You can access the existing themes by opening Editor Settings and trying out
a few themes. For example, try out the Solarized (Light) theme. Are you getting Unity vibes?
Changing a theme is not always about changing the colors of buttons or font sizes. For example,
https://365psd.com/psd/ui-kit-54589 and https://365psd.com/day/3-180 are
two UI kits we picked to show how drastically different your Godot UI nodes could look. Figure 11.8
presents these two UI kits side by side:
Figure 11.8 – Two distinct UI kits that are good candidates for themes
216 Creating the User Interface
Since we have already seen how to change the look and feel of three types of nodes, Button, Panel,
and Label, we’ll focus on other types of Control nodes. We’ll accomplish this in the context of creating
a new theme.
Creating a new theme
Since game development is an iterative process, planning every single thing ahead of time may not
always be possible, and even be fruitless. That’s why it’s typical if you start by changing the UI nodes
manually. Still, starting with a new theme and changing the properties of this theme may also be a
good idea. Why? Because if your experiments for individually modifying the components yield a
successful result, you won’t have to repeat what you have done in the theme. By creating a theme at
the beginning, you’re building up as you go.
Also, creating a theme is like creating any other type of resource in Godot. We can do this by following
a few simple steps:
1. Right-click the UI folder in the FileSystem panel, choose New Folder, and type Themes
as its name.
2. Right-click Themes in FileSystem and select the New Resource option.
3. Choose Theme as the resource type and save it as Dark.tres.
This will create a Theme resource in your project. It should also enable a new panel in the bottom area
that will show the preview of this new theme. As you make changes to your theme, updates can be
previewed in this area since it might be faster to monitor your progress this way rather than adding
and removing test components to/from your scene.
If the preview area looks small, it’s possible to enlarge it by clicking an icon next to Godot’s version
number. This icon will look like two upward-facing arrows with a horizontal line above them. Press
that and the theme preview will occupy the viewport. In the end, your editor will look as follows:
Taking advantage of themes 217
Figure 11.9 – The theme preview has been expanded
By the way, the preview area is not static. You can interact with those UI components. It’s like a Godot
scene running inside Godot. Now, we will modify the theme for the CheckButton, CheckBox, and
VSlider components. We’ll also show a special state of the CheckBox node, also known as a radio
button, in web development. However, our first candidate is CheckButton.
Styling a CheckButton
The graphics assets we’ll be using to construct the new theme is the Dark UI Kit, which you can find
at https://365psd.com/psd/dark-ui-kit-psd-54778. We’ve already exported the
necessary parts into the UI folder for you.
The theme we created is still the default theme, so it still shows the default components. We’ll have to
pick the one we would like to change. This is how we do it:
1. Press the button with the plus (+) icon in it. This is in between the Manage Items and Override
All buttons in the top-right corner of the Theme preview area.
2. Select CheckButton in the upcoming pop-up menu. By doing this, you will see a list of this
component’s relevant properties separated by tabs on the right-hand side of the theme preview.
3. Switch to the fourth tab, which looks like a polaroid icon with a mountain in it. Press the plus
(+) icons for the off and on properties.
218 Creating the User Interface
4. From the FileSystem panel, drag dark-ui-checkbutton-off.png to the off slot and,
similarly, drag dark-ui-checkbutton-on.png to the on slot.
5. Interact with CheckButton in the theme’s preview.
This will effectively change the look of CheckButton. Your Theme panel will look as follows:
Figure 11.10 – We have changed the look of the CheckButton component with custom assets
CheckButton is a simple component with two main states: on and off. We were not interested in
altering the disabled versions of its two states, simply because the UI kit does not have the assets for
that permutation. If you think you’ll never have this component in a disabled state, then you don’t
have to create and assign art either.
Let’s attack a different component this time. Although its name is similar, and it comes with states
similar to CheckButton, a somewhat disguised property of this node makes it function as two distinct
components. Enter CheckBox.
Changing a CheckBox and discovering radio buttons
This is going to be a similar effort, but we’ll utilize more assets and fill out more properties. Let’s keep
the momentum going and add a new item to the theme:
1. Using the plus (+) icon button again, choose CheckBox from the upcoming item list.
2. The fourth tab may still be active. If not, switch to it and do the following:
I. Assign dark-ui-checkbox-off.png to the unchecked property.
Taking advantage of themes 219
II. Assign dark-ui-checkbox-on.png to the checked property.
III. Assign dark-ui-radio-off.png to the radio_unchecked property.
IV. Assign dark-ui-radio-on.png to the radio_checked property.
When you prepare your assets, pick filenames that are close enough to the state the assets will be
assigned to. So, associating these files between the FileSystem and Theme panels would feel easy.
After making these changes, this is what we have:
Figure 11.11 – CheckBox is the latest item we have customized for our Dark theme
The preview area has the CheckBox component for you to test, but no radio button. There is no
RadioButton component in Godot. Despite adding the assets for it, we can’t simulate it yet. Nevertheless,
we can tweak a CheckBox component so that it acts like a radio button.
Since we need to physically place a CheckBox component in the scene, you can toggle off the button
that maximized the Theme panel. Alternatively, you can press Shift + F12, and follow these steps to
add a few components to the UI.tscn scene:
1. Turn the visibility off for the Panel node by clicking its eye icon in the Scene panel.
220 Creating the User Interface
2. Select the root node, then add an HBoxContainer node. Select this new node right away so
that you can do the following:
I. Add a VBoxContainer, VSeparator, and another VBoxContainer to it.
II. Add two CheckBox nodes inside these two VBoxContainer nodes.
III. For the first two CheckBox nodes, change their text properties in the Inspector panel
to Multiple Choice 1 and Multiple Choice 2, respectively.
IV. For the last two CheckBox nodes, change their text properties in the Inspector panel to
Single Choice 1 and Single Choice 2, respectively.
We’re not done yet, but the following screenshot shows what’s happened so far:
Figure 11.12 – Four checkboxes organized in a questionnaire fashion
We are a few steps closer to turning two of those checkboxes into radio buttons – specifically, the last
two since we gave them some text that mentions a single choice. Thus, while you have CheckBox2 in
the VboxContainer2 node selected, do the following:
1. Assign a New ButtonGroup to its Group property in the Inspector panel.
2. Click the down arrow in that Group slot to expand a dropdown menu and select Copy.
3. Select the Checkbox node in VBoxContainer2 and choose the Paste option by expanding
its Group options. This will link the two checkboxes because they will be sharing the same
button group.
Taking advantage of themes 221
You should notice a drastic change between the two sets of checkboxes. Whereas the first two still look
like checkboxes, the last two have circular icons next to them, as shown in the following screenshot:
Figure 11.13 – Two checkboxes have been converted into radio buttons
By sharing the same button group, checkboxes turn into radio buttons. In this exercise, it was sufficient
to create and assign a generic ButtonGroup object. However, if you want to have a group of radio
buttons in one area of your application, then another collection somewhere else that governs a different
set of radio buttons, you may have to create named ButtonGroup objects and assign them accordingly.
We won’t cover that kind of scenario since we seem to be missing something more important that
we have wanted for a while. Neither the checkboxes nor the radio buttons we worked so hard for
are reflecting the artistic direction we defined in our theme. Let’s see how we can utilize our theme.
Attaching a theme
Previously, we mentioned that using themes would help you style components faster. It’s true, but
we haven’t tested this claim yet. Since we’ve already prepared the styles for the checkboxes and radio
buttons, all there is left to do is assign the theme to these components:
1. Select the HBoxContainer node in the Scene panel and expand the Theme section in the
Inspector panel.
2. Drag Dark.tres from FileSystem to fill the empty Theme slot.
There you have it! We didn’t even have to select each component and assign the themes one by one. A
higher-level structure such as HBoxContainer was enough to assign the theme to so that its children
could use the relevant parts.
Do you see the real potential here? Assigning a theme to a root element will be enough most of the
time. That being said, since each component can be assigned its own theme, but it doesn’t have to,
you can have all sorts of permutations. In its simplest form, assigning a theme to a root node will be
enough in most scenarios.
So far, we’ve been styling relatively simple UI nodes, such as CheckButton and CheckBox. Maybe we
could tackle another node that has a few moving parts, such as a VSlider.
222 Creating the User Interface
Altering a vertical slider component
A vertical slider component, VSlider, is useful when you want to give your players an easy way to
adjust the ratio or quantity of things, such as tradeable items during a game session, music volume,
or the brightness level in the game’s settings. Likewise, you can use an HSlider node, which is the
horizontal version, but both accomplish similar tasks.
Since we only have the graphic assets for a VSlider, we’ll only cover this styling. If you desire, it’s
possible to convert the existing assets that are compatible with an HSlider. You’ll have to rotate each
part 90 degrees and save them accordingly. To do so, you must follow these steps:
1. Add VSeparator and VSlider nodes to HBoxContainer in the Scene panel.
2. Using the Inspector panel, type 75 for the Value property for VSlider.
3. Double-click Dark.tres in FileSystem to bring up its details. Add VSlider as a new type
using the good old button with the plus (+) icon.
4. Activate the fourth tab in this new type’s custom properties and assign dark-ui-vslidergrabber.png to both grabber and grabber_highlight.
5. Switch to the fifth tab, which looks like a square rainbow.
6. Attach a New StyleBoxTexture to the grabber_area property. Click the slot to see its details
and do the following:
I. Assign dark-ui-vslider-grabber-area.png to the Texture property.
II. Expand the Margin section and type 6 for the Bottom property.
7. Bring up the theme preview again by double-clicking Dark.tres or switching to the Theme
panel at the bottom.
8. Instead of repeating the same effort for the grabber_area_highlight property, click the plus (+)
button near its slot, then grab and drop the grabber_area property’s style onto the grabber_
area_highlight slot. Alternatively, you can copy the slot from grabber_area and paste it into
grabber_area_highlight using the dropdown menus.
9. Attach a New StyleBoxTexture to the slider property. Click the slot to view its details and do
the following:
I. Assign dark-ui-vslider-slider.png to the Texture property.
II. Expand the Margin section and type 6 for the Bottom and Top properties.
III. Make the Expand Margin section visible and type 1 for all its properties.
10. Press F6 and admire your hard work.
We took many steps here, but there were only one or two new things. First, we repurposed one of
the styles to be used for a different property by dragging and dropping it. This is a shortcut method
Taking advantage of themes 223
instead of copying and pasting between slots. It’s useful when both slots are near each other. If you
are copying elements where the slots are on different panels, then you still have to resort to the copy
and paste method in dropdown menus.
Secondly, we adjusted a different type of margin, Expand Margin. The slider has two separate parts
that constitute its track where the scrolling occurs, so we had to adjust this special margin so that it
fits the blue part inside the outer part. Take a look at the following screenshot; you will see that there
is a blue filler under the grabber inside the track of VSlider:
Figure 11.14 – It took a few more steps but the VSlider component has been thematized
It’s easier to see the effect live than reading it. So, when you launch the UI.tscn scene, try to interact
with the grabber and see how the component fills its track with blue, depending on the position of
the grabber.
Wrapping up
This concludes our work in setting up a theme. Although we have styled only a handful of nodes,
feel free to practice with the rest of the same UI kit or pick another one from the website to try it on
other Control nodes.
All in all, working with themes or individually styling components entails two things. Primarily, you
can either assign textures directly to some of the properties or indirectly into the appropriate slot
by creating a StyleBoxTexture. Secondly, there are some numerical properties you can tweak. We
haven’t covered this latter case. For example, you can adjust the line height of components that deal
with text rendering. These cases are easy to comprehend and test. So, we opted to show you more
head-scratching cases.
Hopefully, by practicing what we have shown so far and discovering more on your own, you will be
able to apply beautiful graphic designs to your game.
224 Creating the User Interface
Summary
We started this chapter by debating what UIs are. We did this via a brief philosophical and theoretical
explanation.
Assuming your games will require UIs, we investigated a practical use case such as constructing a
note left by Clara’s uncle. This work necessitated us to work with multiple Control nodes – that is,
the Button, Panel, and Label nodes.
During this effort, not only did we employ the components we needed, but we also styled them to
match a specific artistic style.
For the sake of not repeating ourselves and taking the styling to the next level, we presented how
using themes might be a time saver. To that end, we showed you how to utilize UI kits you could find
online by assigning these kits’ individually exported graphics assets to the properties of Control nodes.
UIs are, in a way, a tool for the player to interact with the game. That being said, in the next chapter,
we’ll discover a more direct way to interact with the game world without the help of UIs.
Further reading
In the introduction, we talked about when a UI is necessary. However, there are situations when the
best interface is no interface at all. There is an app – sorry, a book – for that by Golden Krishna: The
Best Interface Is No Interface: The simple path to brilliant technology. He talks about how introducing
more steps and elements disguised as a UI is nothing but interference.
We’ve already discussed the possibility of having games without a UI, but we’ll rest that argument for
now. It might be better for you to be exposed to as much information and examples as possible at this
point. So, the following are a few technical and practical resources:
• https://www.toptal.com/designers/gui/game-ui
• https://webdesign.tutsplus.com/articles/figma-ui-kits-fordesigners--cms-35706
• https://ilikeinterfaces.com/
• https://www.gameuidatabase.com/
This chapter also showed you how to assign fonts to components. There are a lot of freely available
fonts out there but be careful and read their licenses. They might be downloadable but some of them
can’t be used in commercial work. The same kind of warning goes for anything else too, especially
graphics assets.
12
Interacting with the
World through Camera and
Character Controllers
You have been preparing little bits and pieces for the game world, especially in the last two chapters.
In Chapter 10, Making Things Look Better with Lights and Shadows, you added Light objects to sconces
and candles. You even placed a script to adjust these objects’ lit state. Then, in Chapter 11, Creating
the User Interface, you built a new scene by introducing Control nodes. This effort was for simulating
a note from Clara’s uncle, Bert.
Although we’ve been taking steps to make things more sophisticated, pretty much everything feels
static. In this chapter, we’ll show you a collection of practices that will build a connection between
game objects and the player. This will make the project look live and feel more like a game.
The first thing we’ll look at is the Camera node and its settings. Godot’s viewport has been letting
you see different scenes via a temporary construct so that you could work with the software. Such a
transitory concept won’t be enough, so we’ll work with our camera system.
Next, we’ll focus on building a connection between some of the game objects in the world and the
player. This involves detecting mouse events on a 2D surface and projecting these events into a 3D
space. There might be different interactions such as hovering, clicking, pressing, and likewise, so we’ll
look into ways to detect the action we want. For example, we will click a parchment left on the pier
to bring up the note we worked on in the previous chapter.
Similarly, if the click happens to be on one of the areas where we would want to move Clara, we need a
system that can do the pathfinding for us. To that end, we’ll investigate new Godot nodes, Navigation
and NavigationMeshInstance.
226 Interacting with the World through Camera and Character Controllers
Lastly, why not add a bit of animation? After we discover how to move a game object between two
points in the world, we could instruct this object to trigger the appropriate animation cycle. In our
case, Clara will switch between her idle state to her walking state. As a result, we’ll revisit some of the
notions we got to know in the Importing animations section of Chapter 7, Importing Blender Assets
into Godot.
As you can see, we are going to utilize a lot of the topics we have already visited, yet there is still a lot
of new stuff to discover and learn. If we could enumerate it, it would look like this:
• Understanding the camera system
• Detecting user input
• Moving the player around
• Triggering animations
By the end of this chapter, you’ll have a much better understanding of camera settings in general, and
you’ll be able to detect your player’s intentions and relate them to actions in the game. Thanks to an
easy method of pathfinding, you’ll move Clara around the level to a location you want, and—finally—
trigger the appropriate action to simulate her walking.
Technical requirements
We’ll continue where we left off in the previous chapter. This means you can keep working on your
existing copy. Alternatively, you can start with the Finish folder of Chapter 12 in this book’s
GitHub repo: https://github.com/PacktPublishing/Game-Developmentwith-Blender-and-Godot.
We have several new assets that are necessary to do the work in this chapter. These assets are in the
Resources folder next to the Finish folder. As usual, merge these with your project files.
Understanding the camera system
In Chapter 4, Adjusting Cameras and Lights, we briefly touched on the concept of a camera in Blender.
We learned that we couldn’t render a scene without one. Although we took a render in the end by
introducing a camera, we never talked about the different settings a camera can have. That was
done intentionally because the know-how we would attain in Blender would not directly transfer to
Godot. Fortunately, now is the right time to study in detail what a camera can do for enhancing the
gameplay experience.
Not only are we going to get to know how to set up a camera that suits our game, but we are also going
to discover different types of cameras Godot has in its inventory. As usual, or as it is something you
might hear as a joke on internet forums and memes, there must be a node for this type of thing in Godot.
Understanding the camera system 227
Yes, there is. In fact, there are four camera nodes, as outlined here:
• Camera: This is the core class that serves as the base for all the other camera types. Even though
you can have multiple Camera nodes in your scene, there can only be one active camera. And,
similar to Blender, no camera means nothing to see here.
• InterpolatedCamera: This is an enhanced version of the Camera node. It comes with three
extra properties that turn a regular Camera node into a mechanism that tracks and follows a
target. It’s quite handy if you are developing a game with an over-the-shoulder camera look. If
the game character is the target, when the target moves, the camera will catch up.
Unfortunately, this node will be removed in Godot 4. Luckily, it’s not difficult to recreate its
functionality by attaching a short script to a Camera node. In other words, if you remove the
fancy bits of an InterpolatedCamera node, you get the Camera node, hence the decision to
drop it in future versions.
• ClippedCamera: This is another type of special Camera node, and fortunately, it will be kept
in Godot 4 since it’s an advanced camera system. Our game is currently not using PhysicsBody
nodes that are responsible for determining which objects can pass through each other or bump
and bounce back when the bodies in motion connect with a colliding surface. For that reason,
we won’t investigate this type of camera, but you might want to check this one out if you don’t
want your cameras to travel through walls. It will behave like an object respecting physics rules.
• ARVRCamera: You might have guessed it: this is used for virtual reality (VR) projects. It isn’t
something you’d utilize as a standalone node since it depends on a lot of other nodes that have
augmented reality/virtual reality (ARVR) at the beginning of their names. Building a VR
project is an advanced topic that deserves probably a whole book dedicated to the subject. For
that reason, we’ll skip this node too.
Besides the camera nodes for 3D workflows, there is also the Camera2D node that is used in 2D
projects. Thus, there are five types of cameras in total.
Out of all these types we presented, the most promising candidate is the InterpolatedCamera node.
Why? Because an InterpolatedCamera node is essentially a Camera node with extra pizazz such as
target and track functionality. So, in your Godot 3 projects, you can start with InterpolatedCamera
and treat it like a Camera node until you need that extra functionality.
Since we are continuing our work from the previous chapter, it makes sense to tidy up some loose
ends. Let’s start with that first, then we can move on to introducing camera settings.
228 Interacting with the World through Camera and Character Controllers
Tidying things up for interactivity
The last thing we did in the UI.tscn scene was skinning UI components. During that effort, we
had already turned off the visibility of the Panel node that was responsible for displaying the note
from Clara’s uncle. Then, we introduced a series of UI nodes, all grouped under an HBoxContainer
node. We’ll turn that container off too, but let’s run the project first by pressing F5. You might see
something like this:
Figure 12.1 – The first run of our game
The UI decisions we have made are visible in the top-left corner of the game. We don’t need those for
the moment. So, bring up the UI.tscn if you have it closed, turn off the HBoxContainer node,
and run the game again. We’ll look into some UI concerns in the Detecting user input section soon.
Perhaps you’ve already noticed from the screenshots we have used in previous chapters or simply by
looking at the project files that there has already been a Game.tscn scene configured as the main
scene for the project. That’s why Godot did not ask you to pick the main scene when you pressed F5
since we had already assigned one to the project for you.
Open Game.tscn, and let’s see how this scene is structured. Everything might look self-evident,
but there is the root node labeled as Game, then two child nodes labeled as Camera and Level-01.
Evidently, the level we created in Chapter 9, Designing the Level, is a child node in Game.tscn. The
other node, Camera, will be our main study area in this chapter.
Understanding the camera system 229
We’ll split the rest of our efforts in understanding how cameras work mainly into two distinct areas.
The most important topic is the projection type, which fundamentally changes the whole experience.
We suggest this be something you decide early on in your own projects since any other tweaking can
be done after this choice has been made. So, before we tackle individual camera settings, let’s see what
kinds of projections there are.
Deciding on a type of projection
If you took an art class on learning how to draw architecture, this might be a topic you are already
familiar with. The Godot version we are using comes with three types of projections. Although we will
mainly focus on the first two, we’ll give a brief definition of all projection types, as follows:
• Perspective: This is the default camera projection where the farther objects are from the camera,
the smaller they will look. Hence, two objects of the exact same dimensions will look like they
are differently sized when one of these objects is placed away from the camera. This is also how
human beings perceive the world, so if you don’t, get a check-up.
• Orthogonal: Also known as Orthographic, this type of projection renders objects of the same
dimensions without altering their size, regardless of the distance to the camera. This type could
give your game the dramatic look it needs. Also, there are some types of games—roleplaying
(Fallout series) and Explore, Expand, Exploit, Exterminate (4X) (Civilization)—where this
kind of projection is preferred.
• Frustum: This is a relatively new type of projection that has its uses in some types of games—for
example, to get that 2.5D look some old-school games used to have where the visuals looked
stretched. If you want to know more, https://zdoom.org/wiki/Y-shearing has
some information about this topic.
In most cases, the first two projections we listed here will be enough. Maybe it would be better if we
investigated their differences by experimenting. Since we’ve already seen the Perspective projection
type, it makes sense to try the Orthogonal projection type, so follow these next steps:
1. Select the Camera node in the Game.tscn scene.
2. Change its Projection setting to Orthogonal and set its Size value to 6.
3. Press F5 to run the game and notice a different artistic style.
230 Interacting with the World through Camera and Character Controllers
After we make these changes, this is what we have:
Figure 12.2 – Orthographic camera view from the same location
We picked a Size value that would make the render look close enough to the example we had in
Perspective projection. The Size property is an interesting one because it takes into account many
factors. For example, if you change the Keep Aspect value from Keep Height to Keep Width, you
will have to double the Size value to 12. Most PC monitors, however, follow a landscape orientation.
That’s why Keep Height is the default option, but if you are working on a mobile game, you might
want to mix and match the correct Size value with the Keep Width option selected.
Camera-specific environment
While we are looking at different properties of the Camera node in the Inspector panel, now
might be a good time to get a refresher on the Environment topic. In the Creating post-processing
effects section of Chapter 10, Making Things Look Better with Lights and Shadows, we discovered
how to create an environment that changed the look of the level. If you want to override some
of the environment settings, you can do so by assigning a separate Environment object to the
camera. The effects of both the level-wide and camera-specific environments will be combined.
No matter which values you pick for the right platform, one thing is obvious. Even though we didn’t
move the camera’s position and rotation in the world, the effect we get is utterly different. Whereas we
used to see the door in the back of the cave in the Perspective projection as depicted in Figure 12.1,
the Orthographic view doesn’t permit us to see that far, as seen in Figure 12.2. When you compare
both screenshots, the near elements are pretty much the same, but the Orthographic view simulates
a more top-down look to the scene than looking far ahead.
Understanding the camera system 231
Altering stuff in the Inspector panel and hitting F5 to see your changes in effect might get tiring
quickly. While the Camera node is still selected, if you turn on the Preview checkbox, as seen in the
following screenshot, you can speed up your workflow when you are editing your camera’s attributes:
Figure 12.3 – Previewing what your camera sees is handy, and it’s one checkbox away
This will let you preview what your camera is seeing while you are still adjusting its settings. Mind
you, during preview, you cannot move around your scene freely. In fact, you can’t even select objects.
So, remember to turn it off when you want to go back to editing your scene.
In light of what we have presented so far, what kind of projection type should we choose? We’re
going to go with the Perspective mode. So, for now, revert your Camera node’s Projection setting
to its default value. Since Godot decorates the Inspector panel with the relevant properties, the Size
property will be replaced with the Fov property.
Let’s focus on this new property and some of the other changes we want to apply to the Camera node
in the next section.
Adjusting the camera settings for our game
In this section, we are going to discuss a new term you have just been introduced to, Fov, and show
which other settings we should apply to the camera. If you have been working on your own level design
since the beginning, then the position and rotation of the camera we mention here will be meaningless.
That’s why we’ll give you general directions to convey the spirit of the exercise. Also, hopefully, the
screenshots you’ll see will help you align our level’s conditions to yours better.
First, a quick definition of the new term. Field of view (fov) is the angle, measured in degrees, through
which a device perceives the world. Actually, if you consider your eyes as the device, your eyes also
have a fov value. This is a highly technical domain, so we’ll offer you a few links in the Further reading
section to discover it on your own.
For the time being, we’re much more interested in the practical applications of this subject since it’s
pertinent to whether your game is running in portrait or landscape mode, or whether the game is
for PC or consoles. The default value, 70, that Godot uses is a decent average value that will suit most
cases. However, this default value also assumes you are going to run your game in landscape mode as
it’s dictated by the Keep Aspect property, which is set to Keep Height.
232 Interacting with the World through Camera and Character Controllers
Since players might have different monitor sizes and resolutions, the application has to pick either the
height or the width as the source of truth (SOT) and then apply the other necessary transformations
accordingly for the sake of not distorting the visuals. Sometimes, this practice will yield a result such
as having a black band above and below the visuals. This method, known as letterboxing, is also used
in the cinema industry for converting movies shot with a squarer aspect ratio to modern wider (from
4:3 to 16:9 or 16:10 ratio) screens.
If you hover over the Fov property in the Inspector panel and read the tooltip, you’ll see that there are
multiple values you can set for this property depending on the aspect ratio your game will use. Thus,
we’ll let you choose the best value for your condition. Nevertheless, we’re providing the following
screenshot to demonstrate the permutations of different Keep Aspect and Fov values:
Figure 12.4 – Same camera position with different aspect-ratio constraints and fov values
What a big difference! Without changing a single thing for the camera, different permutations will
yield lots of distinct results. Let’s wrap up the Fov topic by discussing what higher and lower values
for Fov means so that you can make better decisions in your own projects.
At the end of the day, the Fov value you should pick will depend on the player’s viewing distance,
which isn’t something you can really know ahead of time. However, there are conventions you can
follow. For example, console games use a lower Fov value since it provides a zoomed-in-like view that
compensates for the distance between the screen and the player. Most typically, a console game player
will be sitting on a couch a few meters away from a screen that is usually large.
On the other hand, a PC player is usually less than one meter away from a monitor, thus it might be
better to use higher Fov values. This increases immersion since players feel they get to see more of
the world by virtue of having this view a bit zoomed out compared to lower Fov values. That being
said, it’s known that really high Fov values also create motion sickness. When your brain is forced
to process too much of the world, you get that churning stomach feeling, especially in first-person
shooter (FPS) games.
Understanding the camera system 233
Fov calculator
There is a handy calculator for finding ideal Fov values: https://themetalmuncher.
github.io/fov-calc/. Select the aspect ratio and orientation of your screen, and the
calculator will eliminate some of the guesswork. Obviously, if you let your players change their
screen resolution in the game’s settings, you’ve got to programmatically update the Fov value
the game uses.
To finish off this section, we’ll stick with the value of 97 for Fov and choose Keep Width for the
aspect ratio since it works out better artistically. Also, since this level is so small, having the camera
follow the game character won’t be necessary. Still, we could try to pick the best angle and position
of the Camera node to see most of the scene. As already mentioned, our values won’t mean much.
However, try to change the Translation and Rotation Degrees values for the Camera node to match
what you see here:
Figure 12.5 – The camera’s final resting position
What this view will give us are a few things. First, it covers the most crucial angles. Clara can only
walk to certain spots on this level. Also, not every walkable location is important. Still, there doesn’t
seem to be anything significant left out from this perspective.
Second, referring to her uncle’s note, there is a backpack behind the broken cart. It’s hard to see it from
here because the sconce’s light in that corner is not enough to make the backpack all that obvious. All
of this is intentional because we’ll want Clara to hold a torch in her hand, so that extra bit of light will
be enough for her or the player to notice an important object.
Eventually, we expect the player to see and interact with the objects in the world, especially the backpack
since it holds the key to the upstairs. A common instrument game designers use for player-to-world
interaction is mouse events, which is what we’ll discover next.
234 Interacting with the World through Camera and Character Controllers
Detecting user input
Mouse events are one of the many types of user input you can detect in a video game. Other most
common types are keyboard or game controller events, which won’t be covered in this book. Still, the
principles in detecting what the mouse is doing are similar to how you can treat other types of events.
The reason why we are focusing more on mouse events is that there is an extra layer of complexity
you’ve got to deal with, which is what this section will be about. Let’s dive right in.
In a conventional desktop application such as text- or video-editing software, the interface is usually
populated with a lot of buttons, menus, and likewise. The natural behavior you’d expect from the users
of such software is to click these designated spots, which is something the creators of the application
anticipate and prepare for you. How would you go about this in a 3D game, though?
See, when you click anywhere on your screen, you are essentially clicking on a 2D surface. Thus,
it originally makes sense to define the click’s coordinates based on the x and y axes. Let’s make the
case even simpler. We are not clicking anything fancy but just the middle of the screen. By knowing
the monitor’s resolution, we can do the calculation and come up with coordinates that are half the
resolution in both axes.
Let’s imagine, in this special case where we keep clicking right in the middle of the screen, we have the
game world we see in Figure 12.5. Where does that click correspond in our level? Even more interestingly,
if you implemented a camera that moved elsewhere, perhaps even rotated due to gameplay reasons,
how do you map the same x and y coordinates to a different position in the 3D space?
This is a challenging topic that is not always straightforward to resolve, but let’s see which techniques
we can use to discern mouse events.
Knowing where the player interacts
There is a common technique in the industry for detecting where the player is pointing in a 3D world.
It’s called raycasting, and YouTube is awash with tutorials dedicated to this particular topic, not just
for Godot Engine but for other game engines as well. It assumes that you are casting a ray from where
you clicked on your screen to a position in the 3D world. Since the game engine is already capable
of rendering the game by considering the game objects’ positions in relation to the camera, which
happens to be your screen, then the calculations are already done for you, to a certain extent.
Although this technique puts you in the right direction, you still have no idea which object in the
path of that ray is the one you want to select. Perhaps an unfortunate analogy for a ray might be a
strong enough bullet that’s traversing through all objects it connects with. So, if raycasting brings up
many results, you’ve got to eliminate the ones you don’t want. Fortunately, there is a more direct way.
Detecting user input 235
It would be convenient to only assign detection logic to the objects we want. For example, we can
introduce a new model to our scene—a parchment, to be specific—right on the wooden slats of the
pier. Once the player clicks this object, we’ll trigger the note currently hidden in the UI.tscn scene.
Via this effort, you will also practice some of the methods you used in earlier chapters too. Here are
the steps to take:
1. Make a new scene out of Parchment.glb and save it as Parchment.tscn in the
same folder.
2. Since there is a default environment in effect, the scene will be dark, and it will be hard to follow
the succeeding steps. To disable it, open Project Settings and clear the Default Environment
field in the Environment section under the Rendering header. Close Project Settings to go
back to Parchment.tscn.
3. Add a StaticBody node under the root node.
4. Add a CollisionShape node under this last node you introduced and assign a New BoxShape
to its Shape field in the Inspector panel.
5. Expand this new shape by clicking it. Type 0.15, 0.14, and 0.06 in the Extents section’s
X, Y, and Z fields respectively. This shape should encapsulate the model.
6. Still for the CollisionShape node, expand its Transform header, then type 0.05 in the Z field
under its Translation section.
We are not done yet with the parchment scene, but let’s take a break and explain what’s happened.
We have added our first PhysicsBody type of node to our workflow with a StaticBody node. There
are other types too, such as KinematicBody, RigidBody, and likewise, if you would like to offer
physics-based gameplay. Since the parchment object we will place in the world won’t go anywhere,
we chose StaticBody.
Then, we assigned a collision shape to the StaticBody node. Adding collision to game objects is
necessary if you want the engine to detect when your objects collide with each other. By doing so, the
game engine can determine these objects’ future trajectory and speed.
One type of collision the game engine can detect is when players interact with objects using input
devices. For instance, the player might move the mouse over an object, click this object, or even want
to drag and move it somewhere else. Out of all these possibilities, we are only interested in detecting
when the player clicks the parchment model. We’ll learn how to distinguish the exact event we want
in the next section.
236 Interacting with the World through Camera and Character Controllers
Distinguishing useful mouse events
We’ve constructed all the necessary mechanisms to start detecting collisions. The basic shape we
wrapped the parchment model in will act like a sensor to know if collisions are occurring. Out of so
many different types of collisions, we are mainly interested in listening to mouse events, and—more
specifically—detecting mouse clicks.
We’ll treat this click on the parchment as a precursor to bringing up the currently hidden Panel node
inside the UI.tscn scene. Ultimately, we will build a communication line between the parchment
and the UI.tscn scene. First, let’s see how we capture a collision and filter out the right type so that
we can later trigger the chain of events we want. Here’s what to do:
1. Attach a script to the root node in Parchment.tscn and save it as Parchment.gd.
2. Select the StaticBody node and turn on the Node panel.
3. Double-click the input_event entry under the CollisionObject header.
4. Press the Connect button in the pop-up menu. This will add a few lines of temporary code, so
change the Parchment.gd script to what you see here:
extends Spatial
signal show_note
func _on_StaticBody_input_event(camera, event, position,
normal, shape_idx):
 if event is InputEventMouseButton and
 event.pressed:
 emit_signal("show_note")
We’re now, in theory, tracking the input event on the StaticBody node. However, in practice, since
the collision shape for generating this event is positioned precisely over the parchment, our setup will
behave as though you are detecting clicks on the parchment itself. The following screenshot shows
our progress in the editor:
Figure 12.6 – We are attaching input events to the parchment object
Detecting user input 237
The input event we are capturing is generic enough, but we are filtering it out so that it will be valid only
in mouse-click conditions. Then, we transformed the meaning of this click by emitting a show_note
signal, but who is listening to this call? Some construct out there could make sense of this signal—
more specifically, the Panel node inside the UI.tscn scene. Let’s connect them next, as follows:
1. Open UI.tscn and attach a script to the root. Save it as UI.gd and add the following line
of code:
export(NodePath) onready var note_trigger = get_
node(note_trigger) as Node
2. Open Level-01.tscn and create an instance of Parchment.tscn in the Props group.
Position this new node on the wooden slats of the pier so that it sits relatively close to the boat.
3. Select the UI node in the Scene panel. There is going to be a Note Trigger field for this node
in the Inspector panel. Press Assign… and select Parchment among the options that come
up in the pop-up menu.
4. Go back to the UI.gd script and add the following lines of code:
func _ready():
 note_trigger.connect("show_note", self,
 "on_show_note")
func on_show_note():
 $Panel.visible = true
There is a lot going on here with a few lines of basic code. First, we prepared a field for the
UI node to accept another object as a trigger so that we could assign the Parchment node
using the Inspector panel. Then, we instructed the UI node to listen to a specific event—the
show_note signal—so that it could trigger the on_show_note function. When this
function runs as a result of the player’s click on the parchment, the Panel node, which is
essentially Bert’s note, will become visible.
238 Interacting with the World through Camera and Character Controllers
When you were building the UI in Chapter 11, Creating the User Interface, if you didn’t center the
Panel perfectly, you can do so now by using the Layout button in the header of the 3D viewport. If
you prefer, you can position the Panel anywhere you want. Ultimately, when you press F5 and run
the game, after you click the parchment on the pier, you will see something like this:
Figure 12.7 – Bert’s note to Clara was opened when the player clicked the parchment
Remember that the Close button is already wired, so it’ll close the note when you press it. If you do
so, you can open the note again by clicking the parchment. Who knew that a simple mouse click could
mean different things? In one context, it’s pressing on a flat surface that translates to clicking a 3D
object, which then triggers other game systems. In another, it’s pressing a UI element like a button.
Sconces and candles
If the player is able to click the parchment, can’t they click the sconces and candles around the
level? They can, but they won’t get a reaction out of it right now since you have to construct
a collision structure, just as we did for the parchment. This is something you can work on as
an exercise.
We’re not planning to have an inventory system in our game. However, in games that employ that
kind of functionality, it’s common to see that parchment disappear from the world and find a place
for itself in the player’s inventory. Then, the player can later click an icon that represents the note in
their inventory to bring up the note UI again. In this extra case, your UI structure would also have to
listen to a show_note signal emitted from a different structure, but it’s a similar principle.
Not having an inventory system is not a real detriment to our workflow at this point since we have
more pressing issues such as helping the player move around. Although we have a level where there
is a solid floor, we have no game character that can stand on it. We’ll look at how to introduce one
and move it in the upcoming section.
Moving the player around 239
Moving the player around
You might have heard that context is important in real life because context can make an ordinary
word or statement look especially bad or fun. This is consistently true in most technical areas—more
specifically when we try to describe visual or artistic aspects. Sometimes, it’s alright to use words
interchangeably, but making a distinction might be crucial—even necessary every now and then. For
example, at the end of the last section, we claimed that we’d move a character. It might be an absurd
attempt to do mind-reading via the pages of a book, but would we be wrong if you imagined a biped
creature such as Clara walking around using her legs and swinging her arms?
Chances are you did think about it that way, but you’ll have to wait for that at this moment since we
haven’t even moved an object between two spots on the level. Referring to the analogy of context, not
every move has to involve a fully-fledged animation. Clara’s model, or an ordinary cube for that matter,
could also move by following a path. Therefore, it might be more appropriate to think of movement
and animation as two distinct topics. That’s why we will introduce animation into moving objects later
in the Triggering animations section after we first tackle movement in this section.
Now that you know there is a difference between an object traversing a scene and doing so with an
animation, the big question is: How to detect where to move an object? Let’s be more specific in terms of
our level design. We have a pier where we have just recently placed a parchment. The basic expectation
is that our player character will be standing right by this parchment. Once the player is done reading
the note, we expect them to reach the backpack to acquire a key to unlock the door that leads upstairs.
Therefore, we need a mechanism to do the following:
• Detect clicks
• Find a possible path
• Move the player to their desired spot
Before we can start working on these items, we first need two vital ingredients: Navigation and
NavigationMeshInstance. These two nodes work hand in hand to designate some areas in the level
to be walkable. After all, we wouldn’t want the player to walk everywhere or through objects, hence
the importance of some of the props we placed around the level.
Interchangeability for the sake of brevity
Although we’ve pointed out a major difference between movement and animation and claimed
that we can’t use these two concepts interchangeably, we are in luck when it comes to the
two nodes we are going to peruse in this section. You’ll soon see that a Navigation node is
practically incapable of doing its work without depending on NavigationMeshInstance. We’ll
use Navigation as a general concept (unless otherwise specified) to talk about navigation,
while technically, we might be describing the attributes of the NavigationMeshInstance node.
With that said, let’s create areas that are traversable by the player.
240 Interacting with the World through Camera and Character Controllers
Creating walkable areas with a Navigation node
The level we started to design in Chapter 9, Designing the Level has some nice, but also troubling features.
From a visual perspective, the props and their placement in the world look organic. Even bulkier
objects such as the broken cart and the stag statue are out of the way but still in the line of sight when
a person walks between the pier and the door. There is an element of usefulness mixed with clutter.
Speaking of clutter, when we introduce a Navigation node and ask Godot to calculate traversable areas,
the location of the objects in your level may gain bigger importance. You may get a hint as to why this
is after we make changes to the level, so open Level-01.tscn and follow along with these steps:
1. Add a Navigation node in the root node. Then, add a NavigationMeshInstance node right
under this last node you’ve introduced.
2. Drag and drop the Floor, Columns, Rails, Props, and Dock groups under the
NavigationMeshInstance node.
3. Select the NavigationMeshInstance node and assign a New NavigationMesh to its Navmesh
field in the Inspector panel.
4. Click and expand this new property so that you can do the following:
I. Type 0.18 in the Size field and 0.1 in the Height field under its Cell section.
II. Type 0.4 in the Radius field and 0.2 in the Max Climb field under its Agent section.
III. Turn on the Ledge Spans option under its Filter section.
5. Press 7 on your numeric keypad to switch to the Top Orthogonal view.
6. Press the Bake NavMesh button at the top part of the 3D viewport.
If your level design is different than ours, please try to follow the steps we have presented in the spirit
they are given. This is especially important if you directly transfer our values to your system, which
might not fit. In the end, you’ll see something similar to this:
Moving the player around 241
Figure 12.8 – We have introduced a NavigationMeshInstance node and configured it
Notice the light-blue overlay introduced by the Navigation node. That is all walkable as far as the
engine is concerned. There is something awkward going on, though. When you dragged the Dock
group into the Navigation node, the Water node came with it. So, it was also considered a candidate.
If this were a Dungeons & Dragons game, your player might know the Water Walk spell and be able
to walk on the water mesh. There is no such spell in Clara’s world, but it’s something you might want
to consider if your game allows for such a mechanism and flavor. Therefore, instead of removing the
water altogether, it’s best if we changed its place in the hierarchy by doing the following:
1. Move the Water node somewhere other than the NavigationMeshInstance node—for example,
above the SpotLight node.
2. Similarly, drag and drop Parchment out of the Props group.
3. Select the NavigationMeshInstance node and press the Bake NavMesh button again.
242 Interacting with the World through Camera and Character Controllers
With a different hierarchy, the newly baked traversable area should look like this:
Figure 12.9 – The water is no longer walkable thanks to being in a different hierarchy
By determining which areas should be included in the NavigationMeshInstance node and adjusting
values in the Inspector panel, you can come up with a more precise layout. Ultimately, if you can
throw a few obstacles in the player’s way before they reach important places instead of following a
perfectly straight line, you will create more engaging gameplay.
If the layout in your level doesn’t look traversable in some key areas, such as the backpack near the
cart, then move some of those props around and bake a new map. This is going to be important when
we introduce movement logic.
You might want to rotate the view to Perspective if you want to get a better feeling of which areas are
reachable. Speaking of which, who is going to walk these areas? Next, we should introduce the most
basic player character before we get into more advanced character models such as Clara.
Introducing a basic player character
Earlier in this chapter, in the Knowing where the player interacts section when we were inquiring
about how the player could interact with the parchment, we introduced a StaticBody node because
the object wasn’t going anywhere. We also mentioned that StaticBody was one of many PhysicsBody
options available to you besides two other commonly used nodes, as described here:
• RigidBody: Bodies that don’t have control over themselves fall under this category. The word
rigid might be confusing at first since it conveys a feeling of how strong or flexible an object is.
On the contrary, you can use a RigidBody node for simulating the motion of a soccer ball or
a cannonball. You usually apply forces to objects that have this node, which will instruct how
the physics engine will calculate their trajectory, collisions, and likewise.
Moving the player around 243
• KinematicBody: Bodies that actually have control over how they will behave in the world fall
into this category. Most typically, player characters use this node, but any system that creates
its own motion—such as an actual engine or rocket—needs to use this.
Consequently, the best option we have is to use a KinematicBody node to simulate a player character.
We’ll now follow the next steps to create a very simple one:
1. Create a new scene and save it as Player.tscn under the Scenes folder.
2. Start with a KinematicBody node as its root. Then, add a CollisionShape node and a MeshInstance
node under the root.
3. Select the MeshInstance node and do the following:
I. Assign a New CapsuleMesh to its Mesh field. Expand this new field and type 0.4 for
its Radius property.
II. Type 90 in the X field in Rotation Degrees under the Transform section.
4. Select the CollisionShape node and do the following:
I. Assign a New CapsuleShape to its Shape field. Expand this new field and type 0.4 for
its Radius property.
II. Type 90 in the X field in Rotation Degrees under the Transform section.
5. Select the KinematicBody node and type 0.9 in the Y field in Translation under the Transform
section. Rename this KinematicBody node Player.
This will create a capsule shape, which is a quick way to simulate player characters. Also, we picked a
collision shape that would go well with the mesh we created. Since there isn’t much to look at in the
Player.tscn scene, it may be best if we show you where to place it in the world. Create an instance
of it in Level-01.tscn, and position it as shown in the following screenshot:
Figure 12.10 – An upright pill-shaped player character
244 Interacting with the World through Camera and Character Controllers
The player character, although it looks like a pill standing up right now, is now part of the world and
ready to move around. It just needs to be told where to go. How can we give it instructions before
even we know where it’s supposed to go? To solve this mystery, we will have to prepare a structure
to catch clicks. All this will eventually lead us to revisit a topic we dismissed earlier in the Detecting
user input section: raycasting. After all, it will help us know where the player clicked in the world.
Preparing a clickable area for raycasting
When you know exactly which objects should be interactive and receive mouse events, the method
we applied in the Distinguishing useful mouse events section is still valid. It entails anticipation on the
game designer’s end, so the essential bindings could be done early on, as we saw. However, what if it
wasn’t always possible to foresee this, or how viable would that method be on a larger scale?
For example, if we were to add a StaticBody node to each floor model we have used so far, we could
certainly detect mouse clicks. That being said, sometimes, it’s a bit too late for that. Right now, our
level has all the floor pieces as model instances instead of scene instances because, back then, it was
convenient to drop the models and be done with the level design. We could still try to create a scene
out of a floor model, but you’d still have to swap all the floor assets in the level. It’s a lot of work.
Since we already know that a StaticBody node is necessary to initiate an input response, we may yet
use it to our advantage. Instead of attaching it to every single floor piece, we could designate an area as
large as what all the floor pieces occupy, and detect the clicks on this large piece. Here’s how to do this:
1. Add a StaticBody node to the level and place a CollisionShape node inside this StaticBody node.
2. Assign a New BoxShape to the Shape field in the Inspector panel.
3. Expand this new property and adjust its Extents setting. We used values such as 9, 1, and 8
but you might want to adjust these values after you finish the next step.
4. Position the StaticBody node in the level so that the following applies:
I. Its Y coordinate is roughly -1.05. Adjust it to a value so that its top almost aligns with
the floor but just below the parchment. We’ll discuss this after we finish moving the player.
II. Its X and Z values are at a point where its child, CollisionShape, encompasses the floor
pieces and the walkable areas on the pier.
It might be easier to decide on the measurements if you switch to the Top Orthographic view. The
blue square in the following screenshot represents the area we want to use as a click detector:
Moving the player around 245
Figure 12.11 – The StaticBody node covers all walkable areas
You might be wondering if we overdid it with the detection area since Figure 12.11 clearly shows it
is way larger than the walkable areas. A short explanation is that when you click on areas outside the
traversable field, the pathfinding algorithm will take the player to a nearby spot but never to the exact
position the player clicked. For example, if you click in the water, then the player character will move
to the clicked spot as close as possible but still stay within the limits.
When you get to see the code, things might make more sense from a technical point of view. With
that said, let’s attach some code to the player character so that it can move around, as follows:
1. Open Player.tscn and select the root node.
2. Attach Player.gd from the Scripts folder to the Script field in the Inspector panel.
Let’s explain the most important parts of the code we have just applied. You can refer to this code
block at https://github.com/PacktPublishing/Game-Development-withBlender-and-Godot/blob/main/Chapter%2012/Resources/Scripts/Player.
gd. The first 10 lines are for storing some of the startup values and structures we are going to use.
Three of those variables are worth a thorough explanation since the rest is self-explanatory. Let’s look
at them in more detail here:
• camera: The player scene has no Camera node, but it needs to access a camera to do the
raycasting. So, we appropriate the currently used camera as a workaround.
• space_state: This is our entryway to Godot’s PhysicsServer node that monitors which
objects collide or intersect with each other. We’re going to use this variable to know if a click
connects with the floor.
246 Interacting with the World through Camera and Character Controllers
• nav: Since the Player node will be part of the Level-01.tscn scene that also holds the
Navigation node, we use a mechanism like this to inject the Navigation node into the Player
node. This way, the Player node can query the Navigation node to find a possible path.
The rest of the script consists of four functions. Despite that, two of those functions are doing the
heavy lifting because the _input and _physics_process methods are essentially offloading
their tasks to two other functions: find_path and move_along respectively. We could have
ignored these latter functions, but when you are able to separate distinct functionality into their own
functions, you should do this to keep your code clean.
All of this was done so that we could do a raycasting that is implemented in the find_path function,
which is what we are going to study next.
Using Navigation node for pathfinding
The large StaticBody node we’ve added to the scene is still not enough to know at which point on the
floor the click happened. Having just that will only let us know that the player clicked somewhere in
that area. So, in the end, we are still going to use raycasting for finding the precise location so that we
can begin constructing a path toward this position.
To that end, the find_path function in the Player.gd script is going to use the following
two techniques:
• First is raycasting, to know exactly where the player clicked
• Second is whether there is a possible path toward that position
The first three lines of code in the find_path function, as shown here, are what raycasting is about:
var from = camera.project_ray_origin(event.position)
var to = from + camera.project_ray_normal(event.position) * 100
var result = space_state.intersect_ray(from, to)
Firstly, we ask the camera system to tell us from where the ray is going to originate. Hence, we store
it in the from variable. This happens to be where the mouse event happened. Keep in mind, though
that this event is still on our monitor’s 2D surface. There is still no notion of where we are clicking
in the 3D world.
Secondly, we ask the camera system to let us know where a ray would go if we projected it 100 units
from into the world. Now, we know where to stretch the ray. Still, there is no guarantee that this ray
will hit anything. Thus, we check if anything is intersecting the ray, and store it in the result variable.
So, in just three lines of code, we determined a line between where we clicked on our screen and a
position in the world. The result of this raycasting might be empty, so it would be prudent to check if
there is an object colliding with our ray. Only then can we proceed with finding a path.
Moving the player around 247
This is where the nav variable comes into play. Since it’s a reference to the Navigation node in the
level that knows the player’s position and where the player wants to go next, it calculates a simple
path between these two spots. Ultimately, a series of 3D coordinates are stored in the path array.
Separation issues
In a situation such as the pathfinding operation requiring a raycasting done in the find_path
function—in other words, when two systems are closely related to each other—it might be okay
not to separate the raycasting logic into its own function. We’ll revisit this concept later when
we work on a more advanced game character in the Triggering animations section.
Sooner or later, you’ll have a walkable path, although this doesn’t automatically make the player
character follow a path. We’ll need several more lines of code to do that.
Moving the player to their desired spot
We have used raycasting to detect a spot where the player wants to go and queried the Navigation
node to find the closest path to this desired spot. We are now ready to instruct the Player node to
move between different points along the path.
The move_along function in the Player.gd script receives a path and processes it one step at a
time. Since it’s unlikely to have a straightforward path between the start and end points, the path will
be composed of a series of midpoints before the player reaches their last stop. It’s like walking in real
life where you make course corrections before you arrive at your destination. Naturally, if the path is
empty or all of its steps have been processed, we terminate the function early.
Otherwise, we move the player between two stops by checking if the distance to the next step is within
a certain threshold. Speaking of this threshold, this might be a good moment to talk about a caveat.
During the writing and testing of this code, we had moments where the threshold value should have
been 3, or sometimes, 1. You might want to experiment with a different value if you notice the player
character is behaving awkwardly. This is something that will be remedied in later versions of Godot,
as is noted in the official documentation:
The current navigation system has many known issues and will not always return
optimal paths as expected. These issues will be fixed in Godot 4.0.
After all this hard work, we are now one step away from having the player character move around,
so let’s carry on with this, as follows:
1. Switch to Level-01.tscn and select the Player node.
2. Using the Inspector panel, click the Assign… button in its Nav field to select the Navigation
node in the upcoming pop-up screen.
3. Press F5 and click on different spots in the level.
248 Interacting with the World through Camera and Character Controllers
When we test the scene and move the character away from the pier, this is what it looks like:
Figure 12.12 – The player character can now move in the world
You now must be able to move the player character around by pressing on the floor or even in the
water. The nearest spot will be picked as a destination. Also, while you are moving around, try to click
the parchment on the pier. If it is placed just so it’s below the catch-all StaticBody node, then you
won’t be able to trigger the note. If that’s the case, either adjust the Y position you set in the Preparing
a clickable area for raycasting section for the StaticBody node or move the Parchment node up in
the Y direction.
As long as the clicks are not competing, the parchment will trigger the note. If the player character is
away, it will then move near the parchment as soon as the note is open. You might notice odd behavior
at this point if you click the Close button. The note will close as expected, but the player character
will suddenly move just under where the Close button was. It’s as if the note UI is letting some of our
clicks through and the pathfinding logic picks up that call.
Fortunately, there is a quick fix for this kind of behavior. If you replace the _input function with
_unhandled_input, then all will be well. If these two look alike and unclear, you might want to
find their nuances in the manual: https://docs.godotengine.org/en/3.4/classes/
class_node.html. It might be worth remembering its use for quickly fixing a lot of UI headaches.
Wrapping up
If you have been developing video games for a while, you might already be familiar with the notion
of iterative and incremental workflow. For example, it’s been okay to have indestructible crates so far.
Let’s examine a scenario where you now want these crates to be destructible.
Triggering animations 249
Not only do you have to account for certain conditions to happen, such as if the player has the right
item to break the said crates, but you will also have to prepare animations to be triggered at the moment
of destruction. These are both programmatical and artistic changes, and they can definitely be done
with ease to a certain extent. When you baked the walkable areas, the Navigation node believed
the crates were solid obstacles. However, in this new dynamic situation, you also have to update the
NavigationMeshInstance node with the new conditions.
If a crate the player has just destroyed is no longer part of the world, and that particular area should
indeed be walkable, you have to update the walkable areas by baking a new map. Fortunately, it’s
possible to create multiple NavigationMeshInstance resources and save them on the disk so that you
can swap them to accommodate dynamic cases as needed.
Sometimes, it makes more sense to move ahead with prototypes. For instance, it was good enough
to have our player character look like a capsule to test movement logic. It would be nice to have our
avatar look more like a person than a white pill. Let’s see how we can accomplish that next.
Triggering animations
In Chapter 5, Setting Up Animation and Rigging, we tackled the creation of animations in Blender.
Then, in Chapter 7, Importing Blender Assets into Godot, we saw how to import a model into Godot
Engine and use the AnimationPlayer node to test the model’s different actions. The steps we’ll present
in this section should be enough to introduce Clara to the game, but if you need a reminder on how
to create and import animations, you might want to seek out those two chapters.
Since we are done with the player’s movement, what is missing is to introduce Clara to our workflow
and play the proper actions, such as idling while she’s standing and walking while she is moving around.
We’ve already created a basic player character when we constructed Player.tscn and attached a
script to this scene. It’s primitive but the scene structure is a good starting point. Follow these steps:
1. Click Clara.glb in FileSystem, then bring up the Import panel.
2. Select Files (.anim) in the Storage dropdown under the Animation header. Refer to the
Separating actions section from Chapter 7, Importing Blender Assets into Godot, to remember
the need for this step.
3. Press Reimport to set up Clara’s dependencies properly. Switch to the Scene panel.
4. Open Player.tscn and delete the MeshInstance node.
5. Drag Clara.glb from FileSystem onto the Player node. Thus, the old MeshInstance node
will be replaced with a Clara node.
6. Click the root node and zero its Translation values since the values that applied to the basic
capsule-shaped player are no longer valid.
7. Adjust the CollisionShape node’s Shape field in the Inspector panel so that it encapsulates
Clara. We haven’t changed the Radius setting but set its Height value to 1.2.
250 Interacting with the World through Camera and Character Controllers
The main goal here is to replace the old MeshInstance node with Clara and adjust the CollisionShape
node so that collision detection is done correctly. The editor should now look like this:
Figure 12.13 – Clara has replaced the boring MeshInstance node
With this method, you can easily test your code for a player character, and then replace the test model
with the actual model later. This might be useful if you are the main developer and you are still waiting
for the artwork from your colleagues.
Improving the looks of the avatar was a good step forward. It’s looking much more appealing. We will
do the same for its movement because you might notice odd behavior if you run the game now. Clara
will be moving around like the old capsule mesh because it’s missing two major qualities, as follows:
• Looking in the direction it’s currently moving
• Showing signs of walking instead of looking like a stick sliding on surfaces
There is also another problem but it’s so minor you can fix it without needing much discussion and
explanation. The Player node, which used to hold the simple MeshInstance node, had to be moved
slightly higher in the world. You can lower this new Player node to the level of the pier so that Clara’s
feet are connecting with it. If you don’t make any changes, Clara will look like she’s hovering and then
moving diagonally as soon as her movement logic kicks in.
For the other two major concerns, we’ll have to dig deeper than just changing an object’s position. We’ve
got to first update the script we are using for the Player node, though, so here’s what we need to do:
1. Select the root node in Player.tscn.
2. Swap its script with Clara.gd from the Scripts folder.
3. Press F5 and enjoy seeing Clara walking around as a normal person should.
Rejoice—she’s walking!
Triggering animations 251
How did it happen so quickly? We will devote the rest of this section to discovering which changes
the Player.gd script has received to accommodate the new behavior we are experiencing and—
undoubtedly—enjoying.
Understanding how Clara looks around
An incremental and iterative workflow is the short and non-technical answer to understanding how
Clara looks around, and it’s something we advise you to keep in mind when tasks seem monumentally
big at first. For example, we were initially concerned with basic movement, which was achieved within
the Player.gd script. At some point, when you know basic test systems are working, it’s time to
take things to the next level. That’s what happened with the Clara.gd script.
We’ll now explain the steps we have taken to turn the basic sliding movement into a more elaborate
walking animation. As far as having new variables is concerned, we are using a simple flag: is_moving.
We keep track of this flag in order to understand whether Clara is moving or not. The use of this new
variable will soon be discussed in the context of some other changes we have made.
New term – flag
In the programming world, a flag is a variable that means a certain condition has been satisfied.
It’s often used to determine a system’s behavior, like an electric switch with a false/true or off/
on states, hence they are often called Boolean flags. However, it is possible for a flag to have
different kinds of predetermined values.
A natural behavior for Clara would be to look in the direction the mouse cursor is. Let us remind
you, once more, that although the cursor is moving over our monitor’s 2D surface, we need to do
essential projections into the 3D space to find the proper direction. We were already doing that in the
find_path function inside the Player.gd script. Since we now want a similar raycasting done
for determining where Clara is supposed to look, we extracted those common lines from find_path
to its own function, get_destination.
Hence, the more common uses and repetitions you can find in your code, the better it is to separate
them into their own functions. This was something we intentionally ignored in the Player.gd
case for simplicity’s sake. However, we now have both the find_path and turn_to functions
depending on get_destination.
Just as find_path is piggybacking on the _unhandled_input function, the turn_to
function is also using the same mouse event. Speaking of the turn_to function, let’s take a closer
look at it here:
func turn_to(event):
 if is_moving:
252 Interacting with the World through Camera and Character Controllers
 return

 var direction:Vector3 = get_destination(event) *
 Vector3(1,0,1) + Vector3(0, global_transform.origin.y,
 0)
 look_at(direction, Vector3.UP)
First of all, although we haven’t yet seen where the moving flag is set, if Clara is moving, we wouldn’t
want her to keep looking around. So, we have an early return statement to terminate the turning
behavior. Then, once we determine a suitable direction via the get_destination function, we
trigger Godot’s built-in look_at method.
The logic is simple, but the math to determine the direction vector in turn_to might need
a bit more explanation. Normally, the value from get_destination would have been enough,
but we seem to be multiplying the return value with another vector and then adding it to another
vector. This is because the destination given by get_destination also includes the y axis in
the 3D space. We want Clara to keep her posture the same; in other words, we don’t want her to look
up or down. Those two vector operations are required so that she doesn’t rotate in an awkward way.
You can see the weird behavior yourself by removing the vector operations and only keeping the
get_destination function. When you move your mouse cursor near Clara’s body, she may
suddenly pivot around her feet and sometimes even flip upside down or sideways. The intricacies
due to projections between 2D and 3D are something you’ll have to account for in the future, and it’s
a common occurrence in controlling game characters.
It’s nice that Clara is facing where the mouse cursor is. It’s also a separate mechanism because she can
do so without moving, as you may have already tested with the preceding code block. It would be nice
if she kept looking where she was going while walking. This will be done in the enhanced version of
the move_along function. Let’s see how we improved it in this new version.
Adding a looking behavior to moving functionality
It is nice to see Clara looking around while she’s standing still, but we will also want her to face the
destination she’s walking to. For example, if you click near the crates by the wall (more like the righthand side of the screen), she should walk straight until she clears the pier, then turn and look right,
and then keep walking. Similarly, while she’s in this new spot, if you click somewhere far away such
as near the stag statue or the pier again, she should turn around and walk back in a natural way.
This kind of behavior can easily be added inside the move_along function. The way it is, that
function already determines how many steps there are left along the path Clara should take. As she’s
walking toward the point on the path, she may as well look at where she is going. That’s why we have
a simple look_at function call after move_and_slide in the move_along function.
Triggering animations 253
Other useful KinematicBody functions
We have been using the built-in move_and_slide function of the KinematicBody class.
There is a useful function in the same class that might be helpful in levels where the player would
like to reach an elevated location by following a slope: move_and_slide_with_snap.
Similarly, you might want to check whether the player should perform the next move. If that
is the case, the test_move method might be handy.
Also, the fate of is_moving gets decided in the following lines of code:
if !path or path_index == path.size():
 is_moving = false
 $Clara/AnimationPlayer.play("Idle")
 return
is_moving = true
Notice that, similar to how we do it in Player.gd, the if block checks whether there are steps left
along the path. It’s exactly at this point we can set the state of the is_moving flag. Consequently,
unlike the original version, the new move_along function’s if block is making sure the moving
logic is turned off when there is no path left for Clara to walk.
If the player clicks a different spot and there is a new path determined, then we turn on the moving flag.
As long as there are midpoints for Clara to follow, she’ll follow the same steps we’ve described—face
the right direction, walk the necessary distance, face the next direction, walk, rinse, and repeat—until
she no longer has any more steps to take.
Besides deciding on the state of the is_moving flag, there is something else going on in that if
block in regard to animations. Let’s focus on that in the next part.
Playing the right action for Clara
We’ve already seen how actions are related to animations in the Separating actions section of Chapter
7, Importing Blender Assets into Godot. They are like what atoms are to molecules. So, when we want
to trigger an animation for a model, we actually mean to trigger a particular action. We’ll finally utilize
this notion and put Clara in action.
We have seen how the improvements we made to the Player.gd script have added extra flavor to
Clara’s behavior. That being said, she could also benefit from a touch-up in the animation department.
That’s precisely what’s also happening inside the move_along function.
254 Interacting with the World through Camera and Character Controllers
We already know how to determine whether Clara should move or not, and we are keeping track of
that with the is_moving flag. Subsequently, that’s the right moment to trigger the required action
for her. Thus, when she’s no longer supposed to move, we trigger her Idle action. Conversely, the Walk
action is activated when is_moving is set to true.
When we made Clara.glb part of the Player.tscn scene, and it turned into a Clara node,
an AnimationPlayer node already came within it with all of Clara’s actions set up. The code we have
written so far is aware of exactly where this AnimationPlayer node is in the internal structure. Should
you import a different model with a different Scene tree, then you might have to alter your code to
find the right path to the AnimationPlayer node.
It’s hard to convey an animation via the static pages of a book, but when we move Clara near the
column approaching our camera, this is what it looks like:
Figure 12.14 – Clara can now move around the level
Also, notice how the light conditions in the scene are affecting her model when she walks in darker
and brighter spots. In the next chapter, we’ll turn off some of the light sources. So, as she or the player
is walking around, we can use the torch she’s holding to illuminate the scene.
We couldn’t finish the animation topic without mentioning an advanced subject: blending animations.
We will not cover it in great detail, but it is worth mentioning it for more advanced cases of animations
you would like to use in your projects.
Blending animations or actions
After a while, the names that are used in most computer-related things may start to seem like they
have something to do with each other. We used Blender in the first several chapters to build assets,
textures, animations, and likewise. The blending we are now going to talk about has nothing to do
with Blender itself.
Summary 255
Our point-and-click adventure game is very simple so far. Clara plays the Idle action while she’s standing
still, and she uses the Walk action when she’s moving. Although her model contains other actions
such as Death, Run, and likewise, we aren’t going to use those. If you want to take this project and
move it further, you can accommodate different needs a player may have by improving the Clara.
gd script and incorporate these other actions.
At some point, when you have a much more complex system where the actions you are triggering
come to an end to give room to another action, you may notice that these actions abruptly start and
end. Then, imagine how the crossfade functionality in an audio player makes the whole experience
more pleasant when a song track changes to another. What if you had a way to transition the end of
an action smoothly to the beginning of the next action? You can easily achieve that for animations
with the AnimationTree node.
Unfortunately, the page count is limited for us to cover such an advanced topic. That being said, the
official documentation has a nice and long tutorial page dedicated to this very subject. It also comes
with plenty of animated GIFs that you can’t possibly experience on the static pages of a book. So, in
the end, you might be better off exploring how to blend animations by following the instructions at
https://docs.godotengine.org/en/3.4/tutorials/animation/animation_
tree.html.
Blending animations is heavily used in high-pace action games when transitioning between different
attack and run states should look more seamless. In our current situation, we are not missing out
much by not having this kind of functionality.
We have made great strides so far in our point-and-click adventure game. Let’s wrap up and count
our victories.
Summary
This chapter finally covered the long-due camera topic we’ve been waiting to tackle since Chapter 4,
Adjusting Cameras and Lights. You now have multiple options to choose from, from a simple Camera
type to an InterpolatedCamera type that follows a target. Should you want to get fancy and dip your
toes in VR, you also have ARVRCamera at your disposal.
As you now had a proper camera showing you the game world as opposed to seeing things within
the editor, it was the right time to investigate how to interact with the world itself. To that end, we
presented raycasting as a possible solution but quickly dismissed it in favor of using collision detection,
which provides more flexibility and precision. We used this technique to detect a click on a specific
game object: a parchment. During this effort, you used signals as a way of interpreting the player’s
click as a trigger to turn on the note.
256 Interacting with the World through Camera and Character Controllers
Next, you looked into creating a simple game character and moving it around the level. Sometimes,
the game design is missing key elements, and other times, the level might need some more help. Once
you, as a solo developer or as a team, are happy with the direction the game is going, then you can up
the ante by introducing more complex systems.
That’s exactly what happened in between testing Player.gd and improving it with the more
advanced Clara.gd script. In the end, you were able to find a suitable position in the world for
Clara to move and do this by using the proper animation cycle. Since you’ve covered the essentials,
it’s now up to you to enhance the script if you want to use more actions and special conditions for
player interaction with the world.
In the next chapter, we’ll introduce a few more tools that will add to the interactivity we have been
building, such as playing sounds, conditionally triggering certain events, and switching to another level.
Further reading
Although we taught you how to technically set up a camera, there is a whole other artistic side to
picking the best camera settings. You might want to check out online courses and books that cover
topics such as composition and storytelling. A few examples are provided here:
• https://www.udemy.com/course/composition-and-perspectivefor-stunning-visual-art/
• https://www.learnsquared.com/courses/visual-storytelling
• https://www.learnsquared.com/courses/production-concept-art
• https://www.cgmasteracademy.com/courses/93-composition-forconcept-art-and-illustration/
If the code in the Player.gd and Clara.gd files look very similar, and if it’s hard to compare
line by line, there is an online tool you can use that can help you see and highlight the differences:
http://www.tareeinternet.com/scripts/comparison-tool/.
Our game doesn’t involve enemy characters that follow our player, but it will follow a similar approach.
For example, once the enemy detects the player, it will also have to do pathfinding for finding the
player’s position and moving toward it. A lot of video-game AI books cover player detection and
seeking topics such as the example we gave. So, since most AI topics are generally universal, don’t shy
away from reading a wide variety of material. You can always apply the insight you gain elsewhere
later in your Godot projects.
13
Finishing with Sound
and Animation
We’re in the home stretch. The effort we started back in Chapter 9, Designing the Level, was resumed
by making the level look more exciting in Chapter 10, Making Things Look Better with Lights and
Shadows, which led us to implement a basic user interface in Chapter 11, Creating the User Interface.
We built new mechanics in Chapter 12, Interacting with the World through Camera and Character
Controllers, so we could interact with the world we have created. As a result, Clara is now able to press
the parchment left by her uncle, and she can also walk around. This is all very nice, and we can take
it a step further by refining some rough edges.
It’s all quiet in here! As she’s walking, we should trigger an audio file that will simulate her footsteps.
While we are at it, we will also add background music and effects that will better reflect the qualities
of the environment Clara is in.
You must have noticed that, as Clara walks around, sconces and candles around the level illuminate
her. Can she do the same with the torch she is holding in her hand? Of course! It might help her see
the backpack behind the cart. In fact, she’s going to have to use her torch to see better because we’ll
turn off all of the light sources in this chapter.
We’ll discover a new node in Godot to know whether a player character entered an area. Via this
method, game designers usually trigger in-game events such as traps, a conversation with a quest
giver, and so on. Our event choice will be Clara lighting the sconces and candles as she goes near them.
Eventually, she’ll reach the backpack where she’ll pick up the key. We are not concerned with an
inventory system in this game, yet we will consider this key object as a requirement for opening the
door. So, once the condition is satisfied, we need that door to open for us. However, the door did not
come into Godot with its animation set up in Blender. This is our chance to see how basic animations
can be created inside Godot.
258 Finishing with Sound and Animation
When all of the conditions are in place, including the door opening that simulates a clear path upstairs,
we’ll swap our current level with another one. That particular moment will signify the conclusion of
our little game, but you can take it wherever you want to take it.
This is going to be another chapter with lots of distinct topics used together. Speaking of which, the
following are the titles under which you’ll find us executing the plan we’ve presented so far:
• Playing music and sound effects
• Creating reaction spots
• Building simple animations in Godot
• Loading another level
By the end of this chapter, you’ll have finished the core mechanics of our point-and-click adventure
game. Not only will you construct and work with new systems, but you’ll also make these systems
conditional on world or character events.
Good luck and enjoy!
Technical requirements
It’s perfectly fine if you would like to continue where you left off in the previous chapter. However, there
are some extra resources you will need to finish the work in this chapter. You can merge these assets
with the rest of your project files. They are in the Resources folder next to the Finish folder in
this book’s repository that can be found at https://github.com/PacktPublishing/
Game-Development-with-Blender-and-Godot.
Playing music and sound effects
Music and sound effects sometimes can make or break the enjoyment people get out of movies, theatre
plays, and of course, video games. When done right, they will definitely add to the immersion. In this
section, we’ll tackle the use of music and sound effects from a technical point of view. In your own
free time, we suggest you investigate the artistic aspects of sound design in multimedia for which we’ll
mention a few resources later on in the Further reading section.
In Chapter 8, Adding Sound Assets, we discussed different nodes Godot uses to play sound in different
dimensions, as follows:
• AudioStreamPlayer3D for conveying 3D positional information to the player. It’s most
commonly used in FPS games where not only front and back directions matter, but an audio
stream coming from an elevated place is important as well.
Playing music and sound effects 259
• AudioStreamPlayer2D for games in which the direction the sound is coming from doesn’t
need to have depth information. Most platformer games are a good example of this kind.
• AudioStreamPlayer for background music since it may be considered one-dimensional.
Out of these three, two types seem to be the right candidates for our purposes. We want to play
background music, so we will use AudioStreamPlayer. Then, when Clara is walking around, it makes
sense to use AudioStreamPlayer3D.
The latter case may not seem obvious, and we can certainly use the regular AudioStreamPlayer as
well for the footsteps, but we will cross that bridge when we come to it. Our most immediate concern
is to set up the ambient music.
Setting background music
In the Understanding the camera system section of Chapter 12, Interacting with the World through
Camera and Character Controllers, we showed the use of an outer scene structure, such as Game.
tscn, to hold the level we built in Chapter 9, Designing the Level. A wrapper structure such as ours
is also a good place to place more global-scale constructs, such as audio streamers. Yet, we would like
to discuss an alternative before we move on with our initial plan.
Although a player character is part of the game world, we decided to place it inside the level via a
Player node. It was convenient to do so because we could easily see where to position Player inside
the coordinate system of the Level-01.tscn scene. If you place it inside Game.tscn, for the
sake of keeping things separate and sanitized, then you will have to figure out a way to connect both
the Player and the Level-01 nodes inside Game.tscn. This would not be impossible, but it would
make things less convenient.
Similarly, where should you place the node that will play the background music? Although we may
want every level to play its own thematic music, and this would guide us in the direction of using
an AudioStreamPlayer node inside each level, we’ll still place it in Game.tscn. When we attack
the topic of loading different levels in the Loading another level section, hopefully, the scheme we are
suggesting will make more sense.
Let’s see how we can execute the original plan. Open the Game.tscn scene and perform the
following steps:
1. Add an AudioStreamPlayer node to the root and rename it as BackgroundMusic.
2. Drag Native Dream.mp3 from FileSystem to the Stream property of this new node.
3. Turn on the Autoplay option in the Inspector panel.
4. Press F5 and relax.
260 Finishing with Sound and Animation
The piece of music we are using is about 2 minutes long and it will be automatically looped by Godot.
Thus, it won’t feel too repetitive while Clara or the player is discovering the level.
Speaking of placing a background music structure at a higher level, there is one more approach
you can use: singletons, also known as AutoLoad. For absolute beginners, these are the ultimate
top-level structures you can use in your project. These will always be present when you launch
your game and loaded in the order you define them in the AutoLoad tab of Project Settings. Via
this method, you can use a dedicated scene as a single source of music. You can read more about
it at https://docs.godotengine.org/en/3.4/tutorials/scripting/
singletons_autoload.html.
Some players turn off game music for the sake of focusing on sound effects. In the following section,
we’ll introduce our first sound effect. We expect Clara’s walking to trigger a suitable sound effect,
namely footsteps.
Conditionally playing a sound
Let’s see how we can play a sound file conditionally in this section. There is actually nothing magical
nor special in the way of achieving this goal. It’s similar to knowing when Clara walks or stands idly.
In the Playing the right action for Clara section of Chapter 12, Interacting with the World through
Camera and Character Controllers, we implemented two extra lines of code inside the move_along
function to trigger the correct actions for Clara to show, animation-wise, the state she is currently in.
We could still take advantage of the same function by enabling the execution of the sound file for her
footsteps. That being said, now might be a good moment to discuss some of our practices. It would
seem that we are overloading the meaning of the move_along function. You might consider our
current efforts still a phase of building a prototype similar to, as is often said during a writing exercise,
writing a draft, then focusing on edits later.
Sometimes, good architecture might be deduced before you start the bulk of the work, perhaps because
you’ve done something similar before. Often, though, this may not be the case, and your discoveries,
thus your decisions into coming up with an efficient architecture, might have to wait for later. As
soon as you notice there are common parts you can extract out of the current structures, you should.
However, concerning yourself with the fine details of creating the most efficient code structure and
information flow might not be the best use of your time while you are still deciding on gameplay.
So, for now, we’ll add the footsteps sound as an extra element inside the move_along function
until we need a much more efficient way, as follows:
1. Open the Player.tscn scene and add AudioStreamPlayer3D under the root node. Rename
it as FootSteps.
Playing music and sound effects 261
2. Select FootSteps.wav and switch to the Import panel. Then do as follows:
I. Turn on both the Loop and Normalize options.
II. Press Reimport.
3. Drag Footsteps.wav from FileSystem to the Stream field in the Inspector panel.
4. Turn on both the Autoplay and Stream Paused properties.
5. In the Clara.gd script, do as follows:
I. Type $FootSteps.stream_paused = false after you trigger her walk action.
II. Type $FootSteps.stream_paused = true after you trigger her idle action.
The method we are using here was discussed in the Playing a sound effect on demand section of
Chapter 8, Adding Sound Assets, when repeatedly triggering a sound file in a loop might sound like
the sound is jammed.
Additionally, we turned on the loop feature and normalized the volume. The loop is self-explanatory
since we will want her footsteps to repeat ceaselessly as long as she’s walking. The Normalize option
deserves a few more words, though. The sound files we are using in this project have been collected
from multiple sources. This makes it hard to have all these files have a similar level of volume. Some
will be louder, some will be quieter. The feature we turned on adjusts the volume of the sound file, so
it would be at a similar level to the other files.
When you run the game now, you’ll hear the background music as usual. Then, click around and wait
for Clara to walk to the desired spot. Do you hear her footsteps? Most likely just barely. We’ll look into
adjusting audio volume later in the Understanding the volume through decibels section.
For the time being, it might be better if we presented a handy feature in Godot. There might come a
time when you would like to apply special effects to some of the sound files you are playing. Godot
offers multiple audio channels, also known as an audio bus, via which you can decide which files will
play on a specific channel so you can apply a particular effect only on select channels.
We’ll now pretend that there is a situation like this and play the footsteps sound in its own audio
channel. Let’s see how it is done as follows:
1. Expand the Audio panel at the bottom section of Godot Engine. Click on the Add Bus button
in the top right corner of the Audio panel.
2. Rename this New Bus as SFX.
3. Select the FootSteps node and choose the SFX option in the drop-down options for Bus.
262 Finishing with Sound and Animation
The footsteps sound will now be played on a different audio channel in Godot. The interface that’s
reflecting the changes we have made is shown in Figure 13.1.
Figure 13.1 – We are playing the sound effect on its own bus
Via this method, a dedicated audio channel will play the sound you want. As you can see at the bottom
of the SFX bus in the Audio panel in Figure 13.1, the audio is sent to the Master channel. When all
the audio sources are merged and processed, it’s delivered to Speakers. Furthermore, by using the
Add Effect dropdown for an audio bus, you can apply and stack effects that go through this channel.
Although you hear both pieces of audio, they might be competing volume-wise. In the following
section, we’ll get a bit technical about how audio volume works.
Understanding the volume through decibels
Every vocation has its trade secrets and unique practices, and this is also true for sound engineers.
When they talk about volume as how loud a sound is, they use a unit called decibel, marked as dB.
If you are used to the metric system, this is one-tenth of a bel, similar to a decimeter as one-tenth of
a meter. However, what exactly is a bel?
Wikipedia has a page that provides a decent amount of technical information for the decibel. Therefore,
we’ll provide you with the practical aspects and/or pitfalls of working with decibels in your projects.
Similar to how earthquake magnitude is measured, a decibel is a relative scale where every time you
increase the sound level by 6 dB, you double the amplitude of the sound. Consequently, -6 dB means
you are halving the amplitude. As far as values go, 0 dB is the maximum amplitude a digital audio
system will use. Anything above this value, which means positive values, will be clipped. So, you might
still hear something above 0 dB, but it will be distorted the higher you go in decibels. Thus, you’ll be
using the negative range when it comes to picking values.
Creating reaction spots 263
Moreover, there are physical limits to human hearing. Sound is no longer audible between -60 dB and
-80 dB. So, in the end, you have from -60 dB to 0 dB as a workable range. If all of this is confusing,
there is perhaps one important fact you might want to keep in mind about decibels. 0 dB denotes
the normal amplitude of the sound when it was exported from an audio application. If the base level
at 0 dB is too quiet, you might have to fix it at the source rather than messing with it by choosing a
higher dB value in Godot.
That being said, we can decrease the amplitude easily. This is indeed what we are going to do with the
background music as follows:
1. Open Game.tscn and select the BackgroundMusic node.
2. Adjust Volume Db in the Inspector panel to -12, or even -18.
Since you are now able to discern the footsteps from the background music better, did you notice how
Clara’s footsteps get louder as she approaches the camera and quieter as she walks toward the end of
the cave? This is thanks to the AudioStreamPlayer3D node’s behavior of processing audio in 3D. If
you want to perceive this effect more clearly, feel free to temporarily turn off the background music
and focus on the directionality of Clara’s footsteps.
Who is listening?
The Camera node has a built-in Listener construct that makes it possible for us to identify
from which direction the sound is coming. In some cases, we may want the camera to be in
one corner of the world and the listener in another corner. Thus, creating a separate Listener
node is not only possible, but it will also be beneficial when you want to simulate a situation
where a microphone is placed away from the camera.
If you would like to practice more on playing sound files, we suggest you add a sound effect to the
Close button we used in the note user interface. You already know when the button is clicked since
we wait for that moment to close the interface. That is the right moment to play a sound effect such
as ButtonPress.wav in the Audio folder.
It seems the world is reacting to our actions by playing animations and sound files, which is nice. In
all of these efforts, we’ve had a direct involvement mainly by a mouse click. In the following section,
we’ll discover how the world can react to our player character without the player’s direct intervention.
Creating reaction spots
When the player clicks on the parchment, the game shows the content written on that parchment
via a user interface. When the player clicks on a particular location in the world, Clara walks to that
spot by playing a walking animation and playing a footsteps sound. These are all direct interactions
at the player’s end, which brings us to discuss cases when the game should react to indirect events.
264 Finishing with Sound and Animation
Although not lit, Clara is holding a torch. You already know how to use the Light nodes in Godot.
So, it’s easy to place OmniLight near the torch mesh inside the Clara node. Our basic expectation is
that, when she walks by the candles on the floor and the sconces on the walls, she’ll be lighting those
up using her torch. Thus, the game needs to know when she’s near some objects.
Let’s first give Clara a torch she can carry around, then we can proceed to discuss how this torch can
affect other objects in the level, as follows:
1. Create a scene out of Clara.glb and place an OmniLight node under Torch002.
2. Position OmniLight according to the torch so it’s slightly above. 0.75 on the Y axis might
be enough.
3. Select d6d58e for Color and turn on Enable in the Shadow section.
Since OmniLight is a child of the torch mesh, whenever the AnimationPlayer node controls the torch,
the light will follow along. This is also a nice example of taking Blender animations and enhancing
them with Godot nodes.
We have a dedicated Clara.tscn scene, but the Player.tscn scene is still unaware of this
new development. It’s still using the old model reference. Therefore, you must delete the Clara node
in Player.tscn and instance Clara.tscn instead. The Scene panel won’t look that much
different but it’s now going to have Clara holding a lit torch. Test your scene and have Clara walk
around, especially near the door. The torchlight will synchronize with her walking cycle.
Clara seems to be carrying the right tool in her hand to light those candles and sconces. It’s time we
added the trigger zones so that the world can react to her presence. That’s what’s coming up next.
Placing trigger points in the world
We made use of a StaticBody node to detect user clicks in the Preparing a clickable area for raycasting
section of Chapter 12, Interacting with the World through Camera and Character Controllers, so we
could deduce where to move Clara. This is useful when you know that an agent, most likely the player,
will directly trigger a system. There are cases when game objects act freely on their own and they
should also initiate a response from systems that are waiting to be triggered. This section will cover
this kind of situation.
By now, you may have noticed an odd behavior regarding pathfinding and the player’s destination.
StaticBody that we set up goes as far as where the floor pieces meet the wall pieces. Therefore, it
successfully captures the clicks on the floor tiles. However, if you click anywhere far away or along the
walls, the pathfinding may give you an unexpected result. If you extend StaticBody further out, similar
to how it covers the water, it will be alright. You can refer to Figure 12.11 of Chapter 12, Interacting
with the World through Camera and Character Controllers, to observe the placement of StaticBody
and adjust it to account for extra space to catch faraway clicks.
Creating reaction spots 265
Once the destination is determined, Clara will move toward it by getting closer to the props. Some of
these objects are good candidates to trigger certain events. For this, we’ll use the Area node, which
is inheriting from the same internal structure as StaticBody. These are similar nodes since they both
originate from the same place but provide different results.
Although we could place and position an Area node per trigger zone in the level just as we did with
many other nodes, keeping in mind that we want to do this for lighting the sconces and candles, it
makes more sense to open the dedicated scenes we already have for these. To that end, you will do
as follows:
1. Open Candles_1.tscn and place an Area node under the root.
2. Bring up the Node panel and double-click the body_entered(body: Node) item.
3. Press the Connect button right away, which will automatically add an event handler to the
LightSwitch.gd script. Change it as follows:
func _on_Area_body_entered(body):
 print(body)
4. Place a CollisionShape node under the Area node you have just added.
5. Define New BoxShape for the Shape property in the Inspector panel.
The number from the print statement might look different in your machine, but you’ll see something
like StaticBody:[StaticBody:2025] in the Output panel when you run the game. We’ve just got a
collision result from the Area node we’ve added, but what is it that it hit? It is detecting the catch-all
area that covered all of the floor pieces and some portion of the water.
We need to exclude all unwanted candidates so that this trigger zone only responds to our player’s
activities. There are multiple ways to do this. We’ll explain an elaborate version right after we present
a very simple method. For now, swap the function you just saw with the following code:
func _on_Area_body_entered(body):
 if body.name == "Player":
 print("Hello, Clara!")
266 Finishing with Sound and Animation
The changes we are making are in Candles_1.tscn, which holds the candle group by the barrel
when Clara turns right after she clears the docking area. So, press F5 to run the game and move her
near the candles as described. You’ll see the Output area display the print message only when she
enters the space of those candles. Figure 13.2 will help you see what’s expected.
Figure 13.2 – It’s as if the candles sensed Clara coming nearby and welcomed her
With this method, we are only interested in knowing whether name of the body that entered the Area
node’s space is equal to Player. If so, we can trigger the next chain of events. However, before we
start tackling our initial intentions, the following are a few words about a more advanced detection
method we mentioned.
Getting to know a better collision detection method
Godot’s PhysicsServer, a system that’s responsible for undertaking all of the calculations for the
objects that should be affected by physical rules (such as gravity, collision, intersection, and so on)
uses a layer system to keep track of where objects reside. This is not a visual layer as you might see
in a graphics editing application such as Adobe Photoshop. Nevertheless, it’s similar because if the
objects are on separate layers, then you can define how these layers will interact with each other. Aptly
so, the structure that allows this kind of functionality is called Layer in Godot.
Moreover, if all objects are always in the same layer, then you would have to resort to solutions such
as name checking. It’s simple and effective, but it could easily get unwieldy because who would want
to pick a unique name for each game object? Unquestionably, that if block we wrote earlier would
get longer and longer to filter which particular object entered the area. To eliminate such situations,
Godot has another construct that is called Mask.
Creating reaction spots 267
Through a clever way of creating multiple Layer and Mask options, and defining their relationship,
you can reduce the load of writing unnecessarily long and inconvenient if blocks where you check
what’s colliding with what. In a way, that sort of check will be done for you in PhysicsServer, so you
can only account for completely necessary if checks for controlling other less trivial cases.
The following figure shows where you can find the Layer and Mask options for the Area node we are
currently configuring:
Figure 13.3 – Using collision layers might be another detection method
While this method is effective and valuable, setting it up in our current situation and explaining it
via the pages of this book would be inefficient. Instead, we will use the available space to present
other practical applications. Still, it is a vital architectural choice you might have to rely on in your
future projects. So, we suggest you read about this by visiting the Collision layers and masks section
at https://docs.godotengine.org/en/3.4/tutorials/physics/physics_
introduction.html.
Our more immediate concern is what we do when Clara goes near those candles. Let’s see her influence
on the world.
Lighting the candles and sconces
We’ve been laying the groundwork for Clara to interact with the world around her. Our latest effort
involved proximity detection by Candles_1.tscn through the use of an Area node. The reaction
is not useful at this point since it’s just a silly print statement, but we are at a good spot to make it
more interesting.
268 Finishing with Sound and Animation
To truly appreciate Clara’s impact on the world, we should start by turning off some of the lights on
the level. Switch to the Level-01.tscn scene and perform the following steps:
1. Select all instances of Candles_1.tscn and Candles_2.tscn.
2. Turn off the Is Lit property in the Inspector panel.
3. Repeat the first two steps for all sconces in the level.
4. Press F5 to run the game and move Clara around.
Atmospheric, isn’t it? When Clara goes to the same spot that triggered the message in the Output
panel, the level will look like the following:
Figure 13.4 – Clara is depending on the torch she’s holding in her hand
The torch she’s holding is enough for her to see where she’s going. However, it would be nice to light
those candles she’s just standing by. We’ve already done the hard work in Candles_1.tscn so all
there is left to do is to turn on OmniLight internally as follows:
1. Open the LightSwitch.gd script.
2. Replace the print statement in the _on_Area_body_entered function by typing
is_lit = true. The function will look like the following example after your changes:
func _on_Area_body_entered(body):
 if body.name == "Player":
 is_lit = true
3. Press F5 to run the game and move Clara first to the same area, then to a different location.
Creating reaction spots 269
When Clara goes near the same candles this time, those candles will be lit. It might be a bit difficult to
see the effect depending on exactly where she’s standing. So, when she walks away from those candles,
you’ll truly feel her mark on the world, as seen in Figure 13.5:
Figure 13.5 – Clara is getting some help from those candles she just lit
This was just one candle game object Clara interacted with. We have another candle scene, Candles_2.
tscn, and a separate scene for the sconces, Sconce.tscn. We could easily replicate what we have
done to this point for these other scenes, as follows:
1. Open Candles_1.tscn first, then right-click the Area node, and select Copy in the
context menu.
2. Open Candles_2.tscn next, then right-click the root node, and select Paste in the
context menu.
3. Bring up the Node panel and then do as follows:
I. Right-click the body_entered item in the list and select the Disconnect All option. Press
the OK button on the upcoming confirmation screen.
II. Double-click the body_entered item in the list. Press the Connect button on the
upcoming screen.
Normally, we shouldn’t have to do the third step. When you copy and paste nodes between scenes,
the signals are not transferred. So, we had to manually remove what seemed to be an active signal and
rebind it. Luckily, both candle scenes are using the same script and we already have the event handler.
That’s why we didn’t have to write the programming parts. When you transfer nodes between scenes
as we did, keep in mind to reconnect the signals. Godot 4 might have a fix for this behavior.
270 Finishing with Sound and Animation
So, run the game and have Clara walk by all of the candles. They will be lit one after another as she
gets close, and the following is what you’ll experience when she does so:
Figure 13.6 – All of the candles were lit after Clara walked by them
We suggest you apply the same procedure to the Sconce.tscn scene. This time around though,
alter the Z axis of BoxShape for the CollisionShape node to simulate the extra distance the sconces
must have between the walls and Clara. We chose a value of 2, but you might want to adjust it to
something that suits your conditions. Alternatively, you could move the whole Area node a bit forward
to line it up with the two extensions of the sconce that connect to a wall. As long as there is enough
area extended out of sconces, Clara will trigger it.
So, where else can you take this idea? A simple case might be to introduce traps or enemies reacting to
the player’s position. In the case of enemies, they can also take advantage of pathfinding via the same
Navigation node we placed in the level. Also, it’s common, in a case like this, when enemies give up
after following the player for a certain period of time. If the distance is not getting any shorter and
the player is getting away fast enough, the enemy will usually return to their designated patrol zone
instead of trying to catch up with the player.
We aren’t going to introduce such mechanics in this game. However, it might be something you can
pursue as a more advanced game feature. If you are really interested in enemy versus player behavior,
then we suggest you read a few artificial intelligence books on game development. There are a plethora
of options out there and we’ll give you a brief list in the Further reading section.
There are two more trigger zones we should create. One is for the backpack behind the cart when
Clara goes near that area. The other one is when she approaches the door that leads upstairs. Let’s
start with the backpack.
Creating reaction spots 271
Adding the trigger for the backpack
This effort will be similar to the way we did it for the candles and sconces. Since you already know
that by using an Area node you can introduce interactivity, we’ll present something slightly new.
When players interact with the world, more specifically with the game objects, they feel that they have
agency over these items. For example, players have just discovered that walking near candles will light
them. This is part of the fun besides the narrative and story elements a game can have. At this point,
it’s up to the game designer to interweave another layer of complexity. Perhaps, being close to the
candles is only a precondition and the player is also expected to click on the candles.
Regardless of the conditions a game designer will expect the player to satisfy, giving feedback to
the player is quintessential. When players try things on their own, they will get negative or positive
feedback. This kind of harmless trial and error could easily be used in lieu of a tutorial. An easy and
reliable way to provide feedback is something we’ve already looked at. It is playing sound.
For the backpack exercise, we’ll combine both playing an audio file and reacting to an area effect.
Once Clara approaches the backpack as she did with the candles, the backpack will play a sound file
that will inform the player that she picked up the key. The following steps show you how you do it:
1. Create a scene out of Backpack.glb and save it as Backpack.tscn in its original folder.
2. Place an AudioStreamPlayer node under the root. Assign CollectItem.wav to its
Stream field.
3. Add an Area node with CollisionShape under the root, similar to how you did it for the candles.
Position it at -2 on both the X and Z axes. You may want to pick values that make sense in
your scene. As long as there is ample room for Clara to reach this zone, things should be fine.
Use Figure 13.7 as a reference.
4. Create a Backpack.gd script for the root node and save it in the same folder. Activate the
body_entered signal for the Area node, which will add a boilerplate function to the script.
Then, change the script as follows:
extends Spatial
signal key_collected
func _on_Area_body_entered(body):
 if body.name == "Player":
 $AudioStreamPlayer.play()
 emit_signal("key_collected")
5. Swap the Backpack node in Level-01.tscn with an instance of Backpack.tscn.
272 Finishing with Sound and Animation
We are following the same principles we used in player detection for the candles. This time, instead of
enabling lights, we are playing a short sound effect. We chose the AudioStreamPlayer node instead
of its 3D version because we don’t want this sound effect to be affected by its distance to the camera.
However, this is a perfect situation for you to swap and try both to see the difference.
The sound effect command is followed by the emission of a custom signal. In simple terms, we have
converted the body_entered signal into a key_collected signal, which will be used in a more advanced
scenario in the Playing the door animation on a condition section.
As mentioned in the third step, Figure 13.7 shows the relative position of the Area node.
Figure 13.7 – The trigger area for the backpack is offset so Clara can reach it
As they are now, the sconces and candles don’t play a sound effect when they are lit. This might be
a short and nice exercise for which you can use the TorchWhoosh.ogg file. By default, the file’s
Loop feature will be on. So, remember to press the Reimport button after you turn the loop off in
the Import panel.
Last on the list of making some of the game objects interactive is the arched door. Our workflow will
be similar but additionally accounts for that key_collected signal we defined in this section.
Interacting with the door
You’ve been using the Area node quite liberally for a while. So, you must be used to it by now. In this
section, you will use it one last time to complete the topic of interactivity. It will be for the door where
you’ll also make use of that custom signal we have recently created.
Creating reaction spots 273
Since some of the steps will be so similar, we will give shorter instructions for the sake of focusing on
the unique parts, as follows:
1. Create a scene out of Doors_RoundArch.glb and save it in its original folder.
2. Attach the Doors_RoundArch.gd script from the Scripts folder to the root node.
3. Add two AudioStreamPlayer nodes under the root. Rename them as LockFiddling
and OpenDoor. For these two nodes, use LockFiddling.wav and OpenDoor.wav,
respectively, for their Stream property.
4. Add an Area node to the root with its dependencies and requirements, such as its collision,
signal, and position. Figure 13.8 should be helpful to show where we are placing Area.
5. Swap the existing door asset in the Level-01.tscn scene with this new scene. Also, assign
the backpack asset to the Backpack property in Inspector.
6. Press F5 and have Clara walk directly to the door.
We’ll pay closer attention to the script this new scene is using after you see how things look in the
editor with our most recent changes.
Figure 13.8 – This should be enough space in front of the door for Clara
The scene layout is pretty similar to the other examples you have created, but instead of one, there
are two audio stream nodes. Their names indicate the kind of functionality we are trying to achieve.
This time around, Clara standing in front of the door won’t be enough by itself because we expect her
to have found the key first.
274 Finishing with Sound and Animation
Let’s analyze the Doors_RoundArch.gd script and see how we are working it out. You can refer to
this code block at https://github.com/PacktPublishing/Game-Developmentwith-Blender-and-Godot/blob/main/Chapter%2013/Resources/Scripts/
Doors_RoundArch.gd.
We have a flag variable to keep track of whether the key has been collected. The value of this variable
becomes true only when the on_key_collected function is run. All of this relies on whether
the backpack variable emits the appropriate event, which is set up in the _ready function. That’s
why you are binding the backpack object to the door using the Inspector panel so that these two
can communicate.
In the body_entered function, we check whether the intruding object is the player. This is where the
flag variable comes into play. If the condition to open the door is satisfied, then we request the door
opening sound. Otherwise, the game engine will play a sound file that indicates Clara fiddling with
the lock.
One type of solution may not always cut it
The solutions we show you throughout this book may not always be ideal if your level or game
structure is different. Even the game we are building right now might benefit from a drastically
and much more efficient architecture. The concept of architecture means the hierarchy of game
objects you lay out in your scenes, how scripts share common variables, and ultimately how
your systems talk to each other. There is no golden solution, rather best practices that come
with more exposure to coding, perusing forums, and attending conferences where seasoned
developers share their battle scars.
We suggest you try both cases where Clara walks directly to the door to hear the no-go sound. Then,
have her pick up the key, which is already notifying the player with its pickup sound. Lastly, she can
go in front of the door again to hear the door creaking. That door sure needs some greasing!
Even though the squeaking sound makes us think the door is opening with some protest, we don’t see
it yet. So far, we’ve successfully mixed different disciplines we learned in the Playing music and sound
effects and Creating reaction spots sections. It’s time we added the missing animation component to
our workflow.
Building simple animations in Godot
Back in Chapter 5, Setting Up Animation and Rigging, we discussed variances between Blender and
Godot Engine for animation needs. In summary, we claimed that you’d be better off with Blender for
animating anything more complex than bouncing balls and simple rotating objects. To drive the point
home, we rigged and animated a snake model. Similarly, we have been using a humanoid character,
Clara, done in Blender as well.
Building simple animations in Godot 275
However, there comes a time when it might be suitable to animate some of the models in the game
engine. The topic we have at hand is the opening animation of the arched door Clara is standing in
front of. If you prefer so, you could still open the model in Blender, implement the necessary steps
that represent the opening of the door, and reimport your work in Godot. It’ll be no different than
any other imported model that came with its animation.
For such a simple task, it’s a bit of an overkill, though. We’ll still use AnimationPlayer, but instead of
triggering imported actions, we’ll create our own by manually placing keyframes in the timeline to
match the creaking sound we play when the door opens.
Creating the door animation
Before you start tackling any kind of manual animation in Godot, we suggest you take a closer look
at the MeshInstance nodes the model uses. In our case, we are fortunate that there are only two.
However, this might also be a problem too.
The model’s mesh shows metal rings for grabbing and pulling to open such a heavy door. Sadly, they
are part of the same MeshInstance nodes. This means that they can’t be individually animated. To
be able to do it, you’d have to go to Blender and separate those pieces and reexport the model. Then,
you’ll have more MeshInstance nodes you can work with. Keep in mind, though, that any one of these
options is fine but comes with a trade-off. More individual objects often signal freedom, but they also
clutter the Scene panel if you don’t need them in the first place.
We’re not concerned about the rings on the door for the time being. Our goal here is to learn the basics
of animation in Godot, which starts by opening the Doors_RoundArch.tscn scene. After that,
you will perform the following steps:
1. Place an AnimationPlayer node under the root. This will automatically bring up the Animation
panel at the bottom. If not, press the Animation button in the bottom menu.
2. Press the Animation button in this panel’s top area to bring a context menu and select New
in the options. As a reminder, you used the Load option in that context menu in Chapter 5,
Setting Up Animation and Rigging.
3. Type Open and press the OK button to confirm.
4. Set the animation length to 2.3 by typing it in the area between the clock and loop icons on
the right side of the panel.
276 Finishing with Sound and Animation
There are a lot of similar named buttons or options in the last set of steps. Thus, Figure 13.9 will help
you see what the editor will look like after your latest effort.
Figure 13.9 – Scaffolding for the open animation is done
The animation track is empty, but the groundwork is done. We need to tell AnimationPlayer how a
specific property of an object is changing over time. To that end, you should do as follows:
1. Select the Doors_RoundArch_L node in the Scene panel.
2. Expand the Transform section in the Inspector panel. Press the key icon for the Rotation
Degrees property. A confirmation popup will appear.
3. Press the Create button to accept the proposed changes.
4. Click and drag your mouse over the numbers in the timeline of the Animation panel. We want
to set the time to the end of the animation, which is 2.3. Alternatively, you can type it in the
area above the timeline to move the time marker.
5. Change the Y value in Rotation Degrees to -60 and press the key icon again. There won’t be
a confirmation popup this time.
If you scrub the timeline back and forth as you did to move the time marker, you’ll now see the door
pivot around its hinges. Speaking of which, this was covered in the Setting origin points section of
Chapter 6, Exporting Blender Assets.
Also, feel free to use the forward and backward play buttons to test the Open action. We’ll trigger
it programmatically soon, but we should take care of the other portion of the door first as follows:
1. Select the Doors_RoundArch_R node in the Scene panel.
2. Reset the time marker to 0 in the Animation panel.
3. Follow steps 2–5 from the preceding set of instructions with only one difference. Mark the Y
value as positive 60 this time since the directions are reversed.
Building simple animations in Godot 277
After the two sets of changes, the editor will resemble what you see in Figure 13.10:
Figure 13.10 – Two sections of the door model have been keyframed, hence animated
This will add the necessary keyframes to the timeline at points where changes occur. Since we want
the door to open in one go without any slowing down or stuck effect, we are not introducing more
keyframes other than those we are using. If you fancy more complex scenarios, you can position the
time marker along the track to where you want to introduce more keyframes.
The Open animation you have just created should run on a condition. We’ve already discussed and
even implemented the necessary condition to a certain extent. However, we didn’t really place the
animation part in the door script. Let’s do that right away.
Playing the door animation on a condition
Earlier in the Interacting with the door section, we attached a script to the door scene. This script had
all of the necessary rules to check whether the player satisfied the conditions to open this door. We’ve
also done a whole bunch of other things since then. So, let’s summarize what we’ve got so far.
The arched door scene has an Area node that reacts to the player’s presence. The door provides an
auditory effect either way, but if Clara has already claimed the key, we expect the door to open with
a creaking sound effect. Aptly named, we should trigger the Open animation. The change is simple
enough, and it requires you to do as follows:
1. Open the Doors_RoundArch.gd script.
2. Replace print(“Open Sesame!”) with $AnimationPlayer.play(“Open”).
3. Press F5 to run the game. Have Clara first go for the key and then stand in front of the door.
Voila! A big obstacle in the way of going upstairs has been eliminated.
278 Finishing with Sound and Animation
Although it’s not possible to convey sound and visual effects via a still image, nevertheless, the following
is the fruit of your hard work in Figure 13.11:
Figure 13.11 – Clara opened the door only after she collected the key from the backpack
If you move Clara away and come back near the door, the animation and sound will trigger over and
over. Coming up with the necessary conditions to execute an event is important. However, it might
sometimes be equally important to stop it from happening again. You might have already noticed a
similar, and maybe annoying, repeating behavior with the candles as well. Some effects should only
fire once.
We still have quite a few things to do in this chapter. That’s why we will give you a quick guideline
for eliminating this kind of repeating behavior. By nesting or combining if blocks, not only can you
make sure the condition has been met just then, but also that it has been met before. For this, you
might want to take advantage of simple Boolean variables. If the solution doesn’t come to you, you
can always check the GitHub repository for the finished work.
What’s left for Clara to do at this point? Well, she’s currently standing there waiting to go upstairs.
In this context, upstairs means loading another level, which we will discover in the Loading another
level section later. For the time being, we still don’t know exactly when we are supposed to load the
next level. Let’s see how we can determine that.
Waiting for the door animation to trigger an event
It’s tempting to load the next level when we start opening the door. That being said, you’ve worked hard
to keep track of what Clara has been doing as a precondition to start the door’s opening animation.
If you switch to a new level right away, the animation will be for naught.
Building simple animations in Godot 279
Instead, we should wait for the Open animation to finish. Only after that does it make more sense to
switch things up. There are two common but equally awkward ways to do this. We’ll discuss both, so
you get to know them before we dismiss them for the sake of a better alternative, and they are as follows:
• yield: You can add yield($AnimationPlayer, “animation_finished”)
after you trigger the Open animation. Whatever comes after the yield line, such as loading
a new level, will have to wait for the animation to be finished. This is, in a way, like holding
the line. Nothing else will happen unless, well, the program yields. This concept will change in
Godot 4 in favor of the await command, which is a more permissive architectural choice than
blocking things during the execution of your code.
• Timer: An alternative to yield where you are still letting things run is introducing a Timer
node to your Scene tree. This is just like any other node you could add. Its Wait Time field
in the Inspector panel could be set to when you want it to go off, in our case, 2.3 seconds,
since that’s the length of our Open animation. Then, once the time is out, this node will fire a
timeout signal for which you can write a listener.
This method’s usage in our situation would be to start the timer as soon as you initiate the
Open animation. Since the timer’s Wait Time would be synced with the action you are
playing, it would look like loading a new level right after the action is finished.
We will not use either of these methods because why would you make your life more complicated
when there is already a way to accomplish something with the toolset you are familiar with? Instead
of switching gears, we’ll see how AnimationPlayer can still help us as follows:
1. Add the following function somewhere in the Doors_RoundArch.gd script:
func load_level():
 print("What level?")
2. Select the AnimationPlayer node and expand a context menu by pressing the Add Track button.
3. Choose Call Method Track among the options. You’ll be presented with a list of nodes to pick
from. So, select the root node, Doors_RoundArch, on the upcoming screen.
4. Move the timeline marker to 2.3 seconds. Right-click where the blue timeline marker meets
Functions for the Doors_RoundArch entry in the animation tracks. To get a better idea, refer
to Figure 13.12 to see the location we are talking about.
5. Search and choose load_level from the upcoming list. Press F5 to run the game and follow the
necessary steps as before to open the door.
280 Finishing with Sound and Animation
Everything will be exactly the same, except when the door animation is finished playing the Open
sequence, the load_level function will run too. Since showing the door animation won’t make
sense, we’d rather show you the editor’s status as mentioned in the fourth step:
Figure 13.12 – The load_level function will be triggered when the timeline arrives at the keyframe we set
The last frame of the Open action is where we are firing the function responsible for loading the next
level. For now, it’s printing only a statement. We’ll be looking into swapping our current level with a
new one later in the Loading another level section.
While we are still working on building simple animations, we could take care of the light sources that
kind of look static.
Let there be flickering lights
The work we did with the sconces and candles for introducing the Light nodes to our game in Chapter
10 , Making Things Look Better with Lights and Shadows, didn’t include animations. Nevertheless, we’ve
been gradually improving everything else ever since.
Consequently, it would be nice to add some oomph to our light sources as follows:
1. Open Sconce.tscn and add an AnimationPlayer node to the root.
2. Introduce a new action. Choose Flicker for its name.
3. Set the length to 2 seconds. Also, turn on Animation Looping and Autoplay on Load.
4. Press the Add Track button and choose Property Track. Select OmniLight from the list that
pops up. This will display another list to pick from.
5. Pick omni_range. Right-click the track in the Animation panel at 0.0, 0.4, 1.3, and 1.9
seconds to open a context menu and select Insert Key.
Building simple animations in Godot 281
6. Select each one of these keyframes and enter 8, 6, 7, and 5, respectively, in their Value property
in the Inspector panel.
7. Press F5 and have Clara light the sconces. They should start to flicker.
Before we discuss a more refined and advanced version of what we have done, the following is what
we have in the Animation panel:
Figure 13.13 – The Flicker action has been defined for OmniLight in sconces
Things now must look more organic when you light the first sconce. Then, perhaps after the second
or the third one, the cozy flickering effect will look disturbingly repetitive, won’t it? If only there was
a delay between different sconces so they wouldn’t all fire the Flicker action at the same time.
Achieving that will be relatively easy, but we suggest you first copy the AnimationPlayer node inside
Sconce.tscn and paste it into both the Candles_01.tscn and Candles_02.tscn scenes.
It’ll be easier to notice the effect of randomness when we use the animation everywhere.
When all of the light sources are lit, the whole level will look like it’s pulsing. Let’s see how we can
break the unanimity and introduce some randomness to what we have, as follows:
1. Turn off AutoPlay on Load in AnimationPlayer for all of the three scenes you are using it for.
2. Open the LightSwitch.gd script and alter the _process function as follows:
func _process(_delta: float) -> void:
 $OmniLight.visible = is_lit
 if is_lit:
 yield(get_tree().create_timer(randf()*2.0),
 "timeout")
 $AnimationPlayer.play("Flicker")
282 Finishing with Sound and Animation
All our light sources share this script. So, the changes will apply to all instances. While we were not
in favor of using the yield command, it was relatively harmless to do so in this case. The last three
lines tell the engine to create Timer on the fly and it randomly picks Wait Time for it between 0 and
2 seconds. When this timer goes off, the Flicker action plays.
Although you copied and pasted the same AnimationPlayer node that forced the light sources to
share the same length and keyframes with exactly the same values, since the Flicker action for each
light starts with a delay thanks to our latest change, it will induce enough visual differences.
Additionally, if you want to be really fancy, you could add another track such as light_energy to vary
the brightness of the light sources.
Wrapping up
Slowly but surely, you will have a more complete and believable feeling game by introducing small
variations here and there, either by placing them in the world in a non-repeating pattern or by animating
some of the game objects’ key features.
Sometimes the method to do this will be completely different. For example, the shader we are using
to simulate the body of water doesn’t use a node such as AnimationPlayer, but we still have motion.
That being said, it’s disillusive to have that boat look so still while the water is in motion. With the
knowledge you have gained in this section, we suggest you turn the boat model into a scene and
animate it to show an oscillating motion like a boat would do.
While you should feel confident that you know how to animate the basic properties of game objects,
you have left out something important: Clara was supposed to head upstairs. Let’s help her do that.
Loading another level
Before we started to animate the light sources in the Let there be flickering lights section, we were ready
to move Clara upstairs. To that end, we used a nifty feature of the AnimationPlayer node to fire the
load_level function, which printed a statement to the Output panel, a substitution for the real
thing. In this section, we’ll investigate how to swap the existing level with another.
Let us remind you that our current level, Level-01.tscn, is instanced inside the Game.tscn
scene, which is holding a Camera and an AudioStreamPlayer type of nodes. Godot has a built-in
function, change_scene, that can change the current scene to another scene. However, this might
be dangerous since it’ll replace the entire structure. In our case, this is not Level-01.tscn but
everything in Game.tscn because that’s the main scene.
The solution we’ll offer is a process that’s operational at a higher level than Level-01.tscn itself.
Ideally, your scenes should notify a higher authority of the changes they would like to introduce to
the overall system. As it happens, this could very well be the Game.tscn scene via which not only
can you use it to load a new level, but you could also be taking care of other stuff in your game such
as keeping a log file, contacting a database to store important changes, or even reaching to a thirdparty service to show ads.
Loading another level 283
Now that we’ve established the importance of the Game.tscn taking over the task of loading a new
level, how are we going to let it know when to do it? You have used signals before to facilitate a way
between different game objects to know each other. This involved placing a reference of an object
inside another by exposing a script variable to the Inspector panel. Although we could still try this,
there is a better way.
Using an event bus
When we expose variables to the Inspector panel so that scripts can recognize other game objects to
be able to connect to their signals, we are coupling things, in a sense. When the number of objects
and signals grows, this method will be difficult to maintain. There is an alternative, a concept called
event bus, that might be helpful in an ever-growing list of dependencies.
We’ll revisit this concept in more detail in the Further reading section since the notion is part of a
much bigger family of options available to you. For the time being, we’ll be satisfied with a practical
application of it. This is what it entails:
1. Create an EventBus.gd script in the Scripts folder. Add the following line to it:
signal change_level(level)
2. Open Project Settings and switch to the AutoLoad tab.
3. Use the button with the folder icon to find the EventBus.gd script.
4. Press the Add button to add this script to the list underneath.
Figure 13.14 shows what the editor will look like.
Figure 13.14 – Our first singleton is set up and ready to use
284 Finishing with Sound and Animation
We have just added a script to the AutoLoad list. A singleton is also another common name that
is used in the industry for this concept. It means that there can only be one instance of the script.
Besides the conventional description, in a Godot-specific context, as soon as you introduce it to the
AutoLoad tab, there will always be one and only copy of this script; it will also be loaded for you and
be made available to all of the constructs in your project.
So, who’s going to make use of this new script since it doesn’t seem to be attached to anything? After
all, it just exists there, but since AutoLoad makes it accessible at all times, we can use it when the
door animation is finished.
Let’s reassess our work from the Waiting for the door animation to trigger an event section. When we
run and wait for the Open action in the Doors_RoundArch.tscn scene, AnimationPlayer
eventually triggers the load_level function. There is currently a line of placeholder code in the
body of that function in the form of printing a short statement: What level?
That’s where we originally intended to load the next level. However, in light of the discussion we had
in the opening lines of the Loading another level section, we now want to delegate this to the Game.
tscn scene. To that end, we have created an EventBus.gd script that will communicate our
request to the relevant recipient. Therefore, you will have to make the following change:
1. Open the Doors_RoundArch.tscn scene.
2. Update the load_level function as follows:
func load_level():
 EventBus.emit_signal("change_level",
 "Level-02.tscn")
In our earlier efforts, game objects were directly using the emit_signal command. For example,
the backpack was emitting a key_collected signal. Here, we generalize the idea. We no longer
care about knowing which object is emitting. We use a high-level construct such as EventBus to
do this for us. Figure 13.15 shows a diagram of the new architecture we are proposing.
Figure 13.15 – We no longer need to couple structures anymore thanks to EventBus
Loading another level 285
In the backpack example, the emitted signal was directly captured by the door so that the game could
decide whether the player has completed a necessary condition. So, similar to how communication
works in real life, there are two main parts to an event: an emitter and a receiver. We’ve made updates
to the emitting situation. Let’s see what we can improve at the receiver’s end.
Listening to the EventBus signal
Going back to the relationship the door and the backpack objects had, the backpack wasn’t aware of
the door, but the door had a field we set in the Inspector field to reference the backpack. So, when
the backpack emitted an event, the door was already keeping an eye on the backpack in a manner.
We are now trying to stay away from this type of architecture. Instead of directly using an object to
emit an event, we tell the EventBus to do it for us. However, who is the door in our new example?
In other words, who is listening to our event and how? The short answer is the Game.tscn scene.
Let’s implement some code first. Sometimes, it serves the purpose of showing instead of telling. Then,
we’ll explain the rationale behind it. The following steps show what you should do after you open
Game.tscn:
1. Create a new Spatial node under the root node. Rename it as Level.
2. Drag the Level-01 node into this new Level node.
3. Make a new script as Game.gd and attach it to the root node. You can save it alongside the
scene file. Then, you type in the following code:
extends Node
func _ready():
 EventBus.connect("change_level", self,
 "change_level")
func change_level(level:String):
 var new_level = load("res://Scenes/" +
 level).instance()

 $Level.remove_child($Level.get_child(0))
 $Level.add_child(new_level)
Do you see that _ready function where we make use of the EventBus architecture? That’s the
sweet part. This way, neither Game.tscn nor Doors_RoundArch.tscn need to know anything
about each other. They share and deal with their responsibilities through EventBus.
286 Finishing with Sound and Animation
Somewhere, at some point, a structure may fire a change_level signal. That is all we care for, and
after we express our interest in it, we also prepare ourselves for what to do with it, in case the event
comes to fruition. If that’s the case, we handle it inside the change_level function.
Naming conventions
Some people keep their signal and event handler (function) names the same for the sake of
treating the function as an extension of the signal. Godot’s signal bindings will add an _on_
prefix, though. Keeping your own event handlers’ names the same as the signal name might help
you distinguish them from Godot’s own bindings. However, you could always follow Godot’s
naming convention in your bindings too.
Let’s now analyze what’s going on in the change_level event handler. When we fired the signal
in the arched door scene, EventBus was passed a parameter in the form of a string: Level-02.
tscn. The first line in the change_level function looks up and loads this string in the project’s
Scenes folder. After finding a match and creating an instance of it, we want to store this new scene
because we still have some work to do with the current scene. We should dispose of it before we add
the new scene.
Since we’ve made some changes to the Scene tree, the current level, Level-01, is now inside a Level
node that acts like a receptacle. Thus, we are instructing it to first find then remove its only child with
$Level.remove_child($Level.get_child(0)). Only after that do we add the new level.
There is only one thing left for you to do. Press F5 and have Clara go through all of the steps necessary
to trigger the door’s opening. As soon as the door is open, the game will take you upstairs to a new
level. You should expect to see what Figure 13.16 shows.
Figure 13.16 – Welcome to our new level
Loading another level 287
Congratulations! You have guided Clara to find her way in the darkness to collect a key that unlocked
the door to this new level. She can continue her adventures from here. Is that a chest over there?
There is a trapdoor right in front of it though, so watch out for that. Using the tools that we have
shown you, you can go on and create new conditions and obstacles for the player to tackle. It’s up to
your imagination.
We’ll now dedicate the rest of this chapter to discussing some of the choices you’ve made by following
our guidelines and what you could also do differently.
Discussing some of the choices we can all make
Our goal in this book is to teach you just the necessary parts of Godot Engine to build a simple pointand-click adventure game. It’s a simple statement, and yet it entails two separate efforts. On one hand,
we should teach you as much as possible about the game engine without making it look like you are
reading documentation.
On the other hand, the game we planned to build must be advanced enough but also simple to the
point that you can easily follow its progress by reading as little as possible. Also, the fact is that there
are only so many pages in a book. Thus, some of the choices we made during the production of the
game were limited by these factors.
You might also face similar but different limitations and conundrums in your own projects. An early
plan, even the worst one, might often be better than not having a plan at all. Even then, some cases
might be really hard to nail and prepare beforehand, such as making your gameplay fun or achieving
a decent user experience.
For example, the level switch is technically done. However, the change is happening so abruptly that
the player might want to feel a moment of respite to collect their thoughts and savor their journey
throughout the level. You can easily achieve this by extending the animation length and pushing the
load_level function to later frames. It might look like there is a healthy pause between the door
animation and the loading of the next level.
Even better, having the screen fade out before the switch actually happens might be a good idea. In
fact, this might even be useful from a technical point of view. Our second level is so small, thus it’s
easy to load it from the disk. However, in more ambitious projects, your levels might be chuck-full of
game objects waiting to be loaded.
Furthermore, if your game loads previous sessions, you will have to reset your game objects’ states to
their last known values. A generic loading screen in between switching levels or loading a previous
game session might be a much better architecture. By following this practice, you’ll most likely find
yourself abstracting more and more systems from more directly implemented systems.
Thus, this is perhaps the most valuable piece of advice we can offer you: if you are feeling stuck or
unsure of how to tackle a topic, first focus on the special case and its implementation, then try to
generalize it if possible and necessary.
288 Finishing with Sound and Animation
Summary
This was another chapter with a lot of moving parts that incorporated so many different aspects of
the game engine. Let’s break down some of your activities that helped to add the finishing touches on
so many things we carried over from the previous chapters.
First, you tackled background music and sound effects. You had already seen the usage of sound in
Chapter 8, Adding Sound Assets, which covered simple scenarios. In this chapter, you’ve learned how
to use sound assets in a proper context.
Next, you reexamined a topic you saw in Chapter 12, Interacting with the World through Camera
and Character Controllers – player detection. This time, you used Area nodes as trigger zones since
there would not be direct player interaction, such as mouse clicks and motion. Instead, Clara triggers
predetermined events when she’s in the right zone.
You were also able to communicate information between game objects, essentially separate and distant
systems, when an Area node was actively used. For instance, when the player reached the backpack,
the condition to open the door was satisfied. The backpack let the door know what was going on
through the use of a custom signal.
You symbolized the pickup of the key with a sound effect. Perhaps, a short piece of animation would
have been used to display a 3D key moving up and fading out. Sometimes, an icon appears at the
bottom of your monitor and finds its place in what’s called a quickbar in some games. Both approaches
are fine, but we didn’t want to do either one of them.
Since this chapter was supposed to teach the creation of animations in Godot, we wanted to show off
cases that were sufficiently complex, such as flickering light sources or opening two sections of an
arched door, rather than simply moving a key up in the game world. We believe our effort has a more
didactic value that you can transfer to other simple use cases.
After finishing simple animations, particularly the door’s opening action, it was time for Clara to
go upstairs. To achieve that, you looked into swapping the current level with a new one. Although
you could have achieved this by letting game objects pass information between each other, you were
introduced to a more generic way of doing this via an EventBus architecture.
Even though there is still one more chapter, this is the moment you should pat yourself on the back.
You have built a fully functional, however small, point-and-click adventure game. The following chapter
will show you how to export your game. We’ll also discuss what other options you can consider on
your game development journey.
Further reading 289
Further reading
As promised, we want to share with you a few words on the artistic aspects of sound management.
Sometimes, a piece of music will have a high tempo. It means it’ll have a higher value of beats per
minute (BPM). Depending on the game or the level you are building, you might want to select or
create your music with the most appropriate BPM value to convey the best emotions.
There are also situations where gameplay will ask for a mix between a higher and lower tempo. This
is common in role-playing or action games where players would like to feel they are under tension
when they get involved in a sticky situation. For example, it would absolutely break the immersion if
your burly, gun-toting player character is hiding behind a cover under heavy enemy fire when classic
or chillout music is playing in the background. Likewise, when all is supposed to look calm between
two action zones, if the game is playing a piece of high-tempo music, you will needlessly stress out
and confuse your players.
Luckily, there are plenty of courses on this topic on Udemy. Giving a list of courses here would do
injustice to all of the others we couldn’t mention since the list is long. We suggest you look it up on
their website by using the music for games keywords.
Last in the sound management topic is the use of supplemental technologies. Either of the following
two will help you create on-the-fly solutions to ever-changing circumstances if your game can’t make
use of prearranged sound assets:
• FMOD
• Wwise
We also briefly mentioned artificial intelligence in this chapter. This is a vast topic, but a pertinent list
of books would be the following:
• AI for Games by Ian Millington
• Behavioral Mathematics for Game AI by Dave Mark
• The Game AI Pro 360 series by Steve Rabin:
 Game AI Pro 360: Guide to Character Behavior
 Game AI Pro 360: Guide to Movement and Pathfinding
 Game AI Pro 360: Guide to Architecture
 Game AI Pro 360: Guide to Tactics and Strategy
290 Finishing with Sound and Animation
The EventBus solution we presented in this chapter is frequently utilized in many programming
circles. It’s sometimes called a Publish/Subscribe model or an Observer pattern. Referring to Figure
13.15, imagine you replaced EventBus with the post office. When a magazine you are subscribed
to has its latest issue coming out, the publisher will notify the post office and you’ll be delivered your
subscription.
Since the inception of computer science, and more particularly software programming, developers
have noticed problems that exhibited a particular behavior or nature. Solutions to these common
problems are called design patterns. There are a lot of resources out there that deal with this topic
in the framework of classic software. However, game developers have also gotten some love in recent
years. Regardless of domain specificity, a few examples are the following:
• https://gameprogrammingpatterns.com
• https://www.udemy.com/course/design-patterns-for-gameprogramming/
• Head First Design Patterns: Building Extensible and Maintainable Object-Oriented Software by
Eric Freeman
• Learn Design Patterns with Game Programming by Philippe-Henri Gosselin
14
Conclusion
Congratulations!
You have built a point-and-click adventure game that utilizes 3D assets, incorporates camera and
character controllers that respond to player inputs, triggers visual and sound effects for feedback,
follows player progress, and loads a new level.
This chapter will cover a topic that is usually covered when you come to the finish line. We will show
you how to export your game so that you can share it with the rest of the world. That being said, we’ll
also discuss reasons why you might want to export more frequently than just waiting until the end.
After that, we’ll be fully done with the technical parts of the engine. Hence, we’ll present a few pieces
of advice, more like guidelines you can follow in your development cycle to be efficient either before
you start your projects or during them.
Lastly, you will look at a few game genres for which you can use Godot Engine. Every game engine
is usually built around at least one strong and a few core needs. That being said, most engines worth
their salt also support the most expected features. You’ll see how some of the knowledge you have
gained throughout the book could be expanded upon in new areas.
This is going to be a relatively short and, most definitely, less technical chapter. Nevertheless, we still
have the following topics to tackle:
• Exporting your game
• Offering different gameplay experiences
• Discovering different genres
By the end of this chapter, you’ll have learned how to export your creation, evaluate different options you
can offer to your players, and – finally – find a list of genres you can consider using Godot Engine for.
292 Conclusion
Technical requirements
There won’t be any new resources in this chapter. If you prefer, you can continue your own work from
the previous chapter or peruse the content we keep in this book’s repository at https://github.
com/PacktPublishing/Game-Development-with-Blender-and-Godot.
Exporting your game
So, you have a game. What now? You can keep running the game in the editor, as you’ve been doing
all along. At some point, though, you’ll most likely want to show it to your friends and family or even
deploy it somewhere public for everybody to look at it. This section will teach you how to export your
game so that you can share your creation with the rest of the world.
Although we’ll only cover how to do it for Windows, Godot Engine is also capable of exporting your
game to the following platforms:
• Android
• iOS
• HTML
• Linux
• macOS
• Universal Windows Platform (UWP)
Although exporting is usually a simple process, it would be wise to check the documentation since
updates that platforms receive sometimes change the steps you must take. You can find the most
comprehensive list of instructions here: https://docs.godotengine.org/en/3.4/
tutorials/export/.
What about consoles?
Consoles are not part of the aforementioned list because they lie in a somewhat gray area due to
licensing. As a developer, you need to be in touch with a console producer and sign agreements
to have access to their tools and kits. In essence, although there is still some technical aspect
to this, it also has some moving parts in the legal department.
Before we start tackling Windows-specific export settings, we need to add or change a few things in
our project.
Exporting your game 293
Preparing your project for export
By default, Godot doesn’t launch your games in Fullscreen mode even though it’s something most
games use. While in the end, we will make our game cover the whole screen, it’s worth discussing
a few other options you will see when you open Project Settings. More specifically, you’ll see two
features when you visit the Window section under the Display group, as follows:
• Resizable: This option makes your game screen resizable, just as you would be able to resize
any other application that’s not in Fullscreen mode. This is on right off the bat, so turn it off.
• Borderless: When your game is not running in Fullscreen mode, it will have to have borders
defined by your operating system. Having this option on will remove those borders and the
header of the window. By the way, most modern desktop applications—such as Slack, Discord,
and likewise—use this feature these days.
We suggest you turn on the Fullscreen option and the other two that we just talked about off. After
that, this is what our Project Settings screen looks like:
Figure 14.1 – The project settings we are using before we export our game
So far, we’ve focused only on building the game itself without worrying about the intro, game settings,
or credits screens. These can be constructed just like any other Godot scene. Then, once you figure
out the flow between these scenes, you can use the change_scene function to transition to the
one the player is asking for. Alternatively, you can keep some of these screens as hidden scenes inside
the Game.tscn file and turn their visibility on as requested.
Since our game will now run in Fullscreen mode, you won’t be able to terminate it by using the
operating system’s buttons. In Windows, pressing the Alt + F4 key combination will exit the window.
We need to provide a far better way for the player to quit the game.
294 Conclusion
Creating a mechanism for turning the game off
Movies end with the production companies’ logos and actors’ names on a theater screen. Unless you
are really intent on looking at the credits, you will consider this moment as your cue to get up and
leave the theater. Either this way or if you want to terminate your movie experience early on at any
moment you want, you have the freedom to leave the premises.
A similar situation would happen with the click of a button if you were consuming a movie with a
video player on your computer. When we run our little game in Fullscreen mode, since there won’t
be any button around to click, this is something you have to present to your players in different forms.
This is usually done by pressing Esc on the keyboard to reveal a screen—sometimes blocking the game
screen and sometimes as an overlay—so that the player can either go into the game’s settings or load
a different game session and obviously quit the game.
We will implement only the Esc press part in this section and treat it as the player’s desire to quit. To
that end, we suggest you open the Game.gd script and add the following lines of code to it:
func _input(event):
 if event.is_action_pressed("ui_cancel"):
 get_tree().quit()
You might have been expecting to see Esc in that if block. It’s there but as an identifier. If you go to
Project Settings and bring up the Input Map tab, you will see a list of shortcuts that are mapped to
easily comprehensible names. The following screenshot shows a portion of Input Map:
Figure 14.2 – The Input Map tab is part of Project Settings
Exporting your game 295
If you’re building games that allow your players to use multiple input devices, then configuring Input
Map will be tremendously helpful. For example, you could set it so that a game controller or a joystick’s
button press means the same thing if the player wishes to exert the same behavior with a keyboard.
It’s a neat way of consolidating different inputs under one name you can easily follow in your code.
We took care of screen sizes and letting the player quit the game, so we should be all set for exporting
our game.
Configuring Windows export settings
Godot’s download size is extremely small compared to other game engines. One of the reasons for
this is that it doesn’t come loaded with export packages. Platform requirements sometimes change
and Godot’s specific functionalities must conform to their guidelines, so it makes sense to download
and get updates on export packages as you go.
Since we’ve never exported a game, there is no export package in our setup. To get one, press the Editor
button in the top menu to access the Manage Export Templates setting. When you bring it up, you
will see an interface with which you can download and install the right package for the version you
are using. The following screenshot shows the current state of export templates:
Figure 14.3 – This screen will help us download export templates
You should press the Download and Install button and wait. Once that’s done, you could press the
Close button in that interface. Next in our export efforts is to work with the Export settings, so follow
these steps:
1. Press the Project button in the top menu and select Export among the options.
2. Press the Add button and choose Windows Desktop among the options.
3. Fill out the Export Path option by using the button with the folder icon. We chose to export
it to a Build folder outside the project files, so we defined it as ../Build/Clara.exe.
296 Conclusion
4. Press the Export Project button in the bottom part of the Export interface.
5. Turn off the Export With Debug option near the bottom. Confirm your file path and press Save.
Before we move on to explaining things, here is a visual representation of some of the steps you had
to take for exporting:
Figure 14.4 – Some of the export settings for Windows
These steps, assuming your Windows is running on a 64-bit machine, will export your game to the
folder you defined. When you run the executable, you should be playing the game just as you were
while you were developing it in Godot. Pressing Esc will terminate the program and take you back
to the operating system.
You might have noticed an extra file with a PCK extension besides Clara.exe. If you want to keep
those two together, you can turn on the Embed PCK option in the Export settings, yet keeping things
separate might be a good idea too. Godot keeps your game’s resources in a separate package file and
uses it when you run the executable.
Why or when would this be useful? If you want to enhance your game with more content, you can
create only content packages and instruct the game executable to pull them in. Your next DLC might
be just around the corner, and this is a useful mechanism toward that goal.
Not only do you have a finished game, but you can also ship it! Exciting, indeed. Although we have
provided mostly technical instructions, we feel it would also be valuable to share a few words about
different gameplay experiences you can offer to your players.
Offering different gameplay experiences 297
Offering different gameplay experiences
Sometimes, it’s OK to use prototype assets or another artist’s creations so that you can focus on fun.
We are saying this with a word of caution because we’ll always advise you to be sure of the license of
the assets you are using. That being said, the topic we want to discuss is what you do with the assets
once you have access to them.
The Models folder contains extra assets that we didn’t use throughout the book. When you were
constructing the first level in Chapter 9, Designing the Level, we mentioned that you could use some of
those other assets. Maybe you did and had to follow the instructions in later chapters based on your
own conditions, especially with input detection, pathfinding, and likewise.
At some point, as with right now in the last pages of this book, you might find yourself at a loss for
coming up with what more to add to your game.
Having an iterative creation process
Some people find it much more empowering to have visual assets laid right in front of them. The
creative juices start flowing when they look at different objects’ size-and-shape relationships. Then,
there are others who find this inconvenient and getting in the way of drawing out a proper plan. If
they figure out what needs to be done, they can start altering assets or looking for new ones. Finally,
a mix of both of these approaches might work.
In the end—specifically, if you want to go commercial with your work—you’ve got to keep the player
in the center of your workflow. Quick iterations followed by early and frequent playtesting might be
what you need. The ramifications of some of your choices mixed with players’ expectations from the
game might create a lot of stress, so be aware of this. We’ll give you an example by using the assets
and layout of the second level.
There are currently two bookcases on that level: an upright one and a knocked-down one. This is a
relatively cheap and effective storytelling method. Why is one bookcase on the floor? Perhaps there
was a calamity, but we don’t know. Is it going to be moved out of the way? If you, as a developer, want
it or the playtesting shows it’s a strong request, then you have to spend more time in Blender or Godot
to come up with an animation plan for the bookcase. Clara will most likely need another action that
shows her lifting up and moving the bookcase. If she shouldn’t because it’s unlikely that she can lift
up such a heavy object, then you either need a tool or a companion that can help her.
One simple change or request, and you will be inundated with a series of tasks. Unfortunately, not all
these changes will be visual either. You’ll have to account for the programming parts where you have
to keep the state of the bookcase still on the floor or moved out of the way.
Ultimately, as the creator, you’ve got to ask yourself where this effort might be leading. If you could
take this idea to have Clara access another level or a secret used in the game—in other words, mix it
with something that already exists as a mechanic—you can replicate it with the minimum number
of steps; it might be worth it.
298 Conclusion
So, it’s always a trade-off. As much as you should honor fun and your players’ requests, you should
approach it carefully and also consider what works best for you.
As we are wrapping up our book, let us discuss which other things you can do with Godot.
Discovering different genres
Even though Godot Engine is known for creating quality 2D games and other well-known engines
are preferred for building 3D games, you have seen that Godot is actually quite capable of building a
3D game. This is going to change for the better when Godot 4 comes out.
Until then, what else can you do with Godot? You can build any kind of game with it, to be honest.
There has also been a recent trend to build desktop applications using Godot Engine. However, we
will consider these cases as extraordinary and instead focus on some more commonly known genres
that employ 3D features, as follows:
• Simulation and strategy games: When you used raycasting to detect user input, it was done
so that Clara could move to a particular spot with pathfinding. In a simulation or strategy
game, either on a grid or free-move structure, your selected unit or units could move to their
designated destination in a similar way. You could even combine a turn-based feature on top
of this where you keep track of which side’s units have already moved.
• Racing games: Godot already has a VehicleBody node to simulate the behavior of a car. Isn’t
that nice! By appropriately placing a Camera node inside a MeshInstance node and combining
the mechanics of a VehicleBody node, you could be building the next awesome racing game.
Start your engine, Godot Engine, and vroom!
• First-person shooters: A classic example that could definitely be built with Godot Engine. You’ll
be using raycasting a lot in this type of game where you detect whether bullets connect with
objects. If they do, maybe a good mix of technical and creative problems lies ahead of you.
Should bullets penetrate or destroy every object the same way?
• Role-playing games: This is similar to First-person shooters, so it could be done. In this genre,
you generally have a lengthy narrative to present to your player. Also, you’ve got to keep track
of where the player is in the story and whether they have met some of the conditions to reveal
the following parts of the story or the outcome of a puzzle. We haven’t discovered this in this
book, but it would be wise to check out Resource as a useful Godot mechanism to facilitate
content-heavy games.
• Multiplayer/Co-op: This is not a genre by itself, since any genre can be made multiplayer or co-op.
However, there are some games where the experience won’t be the same without networking,
so we had to mention this separately. Godot has networking parts you can use to connect to
third-party services or have two computers in the same network connect to each other.
Summary 299
These are some of the genres that can most definitely be made with Godot. You can also include some
other genres such as puzzles or sports games, or any other subgenre that uses 3D assets.
Summary
As we are concluding our book in this chapter, your game project is also coming to an end. Hence, we
opened it by showing you the necessary steps for exporting your game. Even though it might seem
like you’d tackle this phase once your game is built, as was mentioned in the Iterative creation process
section, it might be wise to export your game often and share it with others for frequent feedback.
The rest of the chapter was dedicated to discussing different approaches you can take in your game
development efforts, best practices, general guidelines, and—finally—getting to know different genres
you can target.
You’ve come a long way in your game development journey. It started with Blender in the first five
chapters and continued with a few transitional chapters until you fully switched to building a game
with Godot Engine. Hopefully, you now have a much better opinion about how things work in both
applications. Also, if you have some prior experience, we hope that this book has increased your
confidence level in some areas.
As we are leaving you, we wish you the very best in your future efforts, and may your code compile
the first time!
Further reading
You might have noticed that the exported game is using Godot’s icon. It would be nice to have your
own custom icon. There are several moving parts to this, but it’s possible. The instructions are listed
at https://docs.godotengine.org/en/3.4/tutorials/export/changing_
application_icon_for_windows.html.
If you would like to deploy your game for feedback purposes instead of sending files over emails or
chat applications, you can use the following platforms:
• https://itch.io
• https://gotm.io
The latter URL is especially useful in our situation because that platform also hosts Godot game jams.
For PC games, Steam is a big marketplace, but the aforementioned places might work faster than
signing up and going through the application process on Steam