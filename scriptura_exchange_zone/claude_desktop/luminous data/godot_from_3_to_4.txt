Evolution of GDScript from Godot 3.x to Godot 4.4
Godot 3.x (GDScript 1.x) gradually introduced optional static typing and other minor improvements, but Godot 4.x (GDScript 2.0) delivered a major overhaul to the scripting language. Below is a structured comparison of GDScript changes from Godot 3.0–3.5 (and 3.6 LTS) to Godot 4.4, focusing on syntax, deprecated features, new functionalities, performance, and API usage. These changes highlight the new best practices that developers should adopt when moving to Godot 4.
GDScript Language Changes (Godot 3.x vs 4.x)
Language Aspect	Godot 3.x (GDScript 1)	Godot 4.x (GDScript 2.0)
Tool Scripts & Annotations	Use keywords for special script modes:
- tool (run in editor) at top of script
- remote/master/puppet before RPC functions
- export keyword for inspector vars
- onready var for deferred init	Use annotations (prefixed with @) instead of those keywords:
- @tool at top enables editor run
shaggydev.com

- @rpc replaces remote, etc. for networking (with parameters for mode)
godotengine.org

- @export (and variants) replaces export for inspector properties
godotengine.org
shaggydev.com

- @onready replaces the onready keyword for deferred initialization
shaggydev.com

*(Also new: @icon annotation to set a script’s icon, instead of adding it after class_name)
godotengine.org
.
Exported Variables	export var x: int = 5 or export(int, 1,10) var x (range, enums etc. as parameters)	Annotations with type hints make exports clearer. E.g.:
- @export var x: int = 5 (type is given after colon)
shaggydev.com

- @export_range(1, 10) var x: float for ranged values (replaces export(float,1,10))
shaggydev.com

- @export_enum("Red", "Green") var color_choice: int for limited options.
(Multiple @export_* variants exist for common hints like ranges, flags, files, enums, etc.
godotengine.org
.)
Instancing Scenes	Use PackedScene.instance() to spawn a scene instance	Renamed to PackedScene.instantiate() in Godot 4
gist.github.com
. Example: var enemy = enemyScene.instantiate() (old instance() is deprecated).
Changing Scenes	get_tree().change_scene("path") (by file path) and change_scene_to(packed_scene) for PackedScene resource	Clearer method names:
- change_scene_to_file("res://level2.tscn") for scene by path
shaggydev.com

- change_scene_to_packed(packedSceneRes) for a preloaded PackedScene
shaggydev.com
.
Signal Connection (by code)	Connect by string names and target object:
button.connect("pressed", self, "_on_Button_pressed", [args])	Signals are first-class properties now. Connect by referencing the signal and a callable:
button.pressed.connect(_on_Button_pressed)
shaggydev.com
. Extra arguments are bound via Callable.bind() instead of an array – e.g. _on_Button_pressed.bind(extra_arg)
shaggydev.com
. (The old string-based connect() still works for dynamic connections, but the new syntax is recommended
shaggydev.com
.)
Awaiting Signals (Coroutines)	Use yield(object, "signal_name") to pause until a signal is emitted
shaggydev.com
. Also used yield(func_call(), TIME) for time delays.	await keyword replaces yield. You wait on a signal by writing await object.signal_name (no quotes)
shaggydev.com
. For example: await $AnimationPlayer.animation_finished will suspend the function until the signal emits. Similarly, await get_tree().create_timer(1.0).timeout replaces yield(get_tree().create_timer(1.0), "timeout") for delays
gdscript.com
gdscript.com
. (The new await is more in line with async/await patterns in other languages
reddit.com
.)
Function References	Use the Funcref class or call_deferred() hacks to pass functions around (no literal lambda). For example, var f = Funcref(self, "my_func") then f.call_func(arg).	First-class functions (Callables): You can directly reference a function by name to get a Callable. For example, var func_ref = some_function directly stores a reference
shaggydev.com
, and you call it with func_ref.call(args). Lambdas are now supported as inline functions: e.g. var lam = func(x, y): return x + y creates an anonymous function (optionally named for debugging)
docs.godotengine.org
. These callables/lambdas make passing callbacks and signals easier. (In Godot 3, this required the cumbersome Funcref; in Godot 4, simply doing var f = print_message and then f.call("Hello") works
shaggydev.com
shaggydev.com
.)
Calling Base Class Methods	To call a superclass’s method that you’ve overridden, GDScript 3 used a quirky syntax: prepend a dot, e.g. .my_function() calls the parent class’s my_function
shaggydev.com
.	Use the new super keyword. Inside an override, super.my_function() calls the base class version
shaggydev.com
. You can even call super() with no name to invoke the superclass’s version of the current function
shaggydev.com
. This is more readable and conventional than the old “dot” syntax.
Setters and Getters	Define property setters/getters with setget and separate functions. E.g. var health setget set_health, get_health. Inside the class, setting the variable did not invoke the setter.	New property syntax replaces setget. You declare getters and setters inline with the variable:
```gdscript
var health: int:		

kotlin
Copy
Edit
get: return _health
set(value): _health = max(value, 0)
python
Copy
Edit
:contentReference[oaicite:27]{index=27}. These **always** call the setter/getter even from inside the class itself:contentReference[oaicite:28]{index=28}, providing consistent behavior. (The old `setget` keyword is removed.) |
| **Static Class Members**     | Not supported in GDScript 1.x. Only constants (`const`) were shared, and all functions were instance methods. | **Static variables and functions** are supported. You can declare `static var counter := 0` to share a variable across all instances of a class:contentReference[oaicite:29]{index=29}:contentReference[oaicite:30]{index=30}. Static functions (`static func`) have no `self` and can only access static members:contentReference[oaicite:31]{index=31}. You can even define a `static func _static_init():` as a static constructor that runs when the script is loaded:contentReference[oaicite:32]{index=32}. *(This feature was introduced in Godot 4.1 to allow truly class-level state:contentReference[oaicite:33]{index=33}.)* |
| **Typing System**            | Optional static typing (since Godot 3.1). Basic type hints (`var x: Type`) and checks, but with limitations: no generics for arrays/dicts and **cyclic type dependencies** could cause errors. Enums had to be treated as ints. | **Gradual typing is more powerful:** The type system was revamped for Godot 4. GDScript 2.0 supports **generic containers** – e.g. `Array[int]` or `Dictionary[String, int]` – with editor checks:contentReference[oaicite:34]{index=34}. **Enums can be used as types** (not just ints) to catch invalid values: assigning a wrong enum type is a compile error:contentReference[oaicite:35]{index=35}. The new type checker also resolved cyclic dependencies (no more “cyclic dependency” errors when scripts reference each other’s types):contentReference[oaicite:36]{index=36}. In short, the static typing is more robust and catches more errors at compile time. |
| **Miscellaneous**            | - **No built-in doc comments** (could only use `#` comments, no auto documentation).<br>- **Array/Dictionary equality**: in 3.x, `==` compared arrays by value but dictionaries by reference identity (leading to inconsistency).<br>- **Built-in containers**: Used classes like `PoolByteArray`, `PoolIntArray` for typed arrays. | - **Documentation comments**: Use `##` (double-hash) to document scripts and members. Godot 4’s editor will show these in tooltips and the help panel:contentReference[oaicite:37]{index=37}:contentReference[oaicite:38]{index=38} – useful for auto-generating documentation.<br>- **Value equality**: In 4.x, `==` on Dictionaries is now *value-based* (like Arrays) – i.e. two dictionaries with same content are equal:contentReference[oaicite:39]{index=39}. A new `is_same()` method checks if two variables are the exact same object (reference):contentReference[oaicite:40]{index=40}. This is a subtle change that can affect logic when upgrading.<br>- **Packed Arrays**: The old `PoolVector2Array`, `PoolIntArray`, etc. are renamed to `PackedVector2Array`, `PackedInt32Array`, etc.:contentReference[oaicite:41]{index=41}. They function similarly, just with new names (and some 64-bit variants). |

**Note:** Godot 3.6 (released as an LTS after 4.0) did **not** introduce new GDScript language features – it primarily backported engine fixes and a few conveniences for projects staying on 3.x. For example, the **Tween** improvements from 4.0 were backported: Godot 3.5/3.6 offers a new Tween API alongside the old one:contentReference[oaicite:42]{index=42}. But fundamental language changes (await, Callables, `super`, new typing, etc.) remained exclusive to Godot 4+. In practice, moving to Godot 4.4 means embracing GDScript 2.0’s new syntax and capabilities described above.

## Practical Examples of Deprecated vs Current Usage

Below are some **practical “before vs after” examples** illustrating the transition from older Godot 3 practices to the updated Godot 4 approach. Developers should update their code accordingly:

- **Instancing Scenes:** In Godot 3, you’d create an instance of a PackedScene with `scene.instance()`. In Godot 4, use `scene.instantiate()`:contentReference[oaicite:43]{index=43}. This method was renamed for clarity – for example:  
  ```gdscript
  # Godot 3.x
  var enemy = EnemyScene.instance()
  add_child(enemy)
  # Godot 4.x
  var enemy = EnemyScene.instantiate()
  add_child(enemy)
Signal Connections: Instead of string-based connections in Godot 3 (node.connect("signal", self, "method")), Godot 4 lets you call node.signal.connect(func). For example:
gdscript
Copy
Edit
# Godot 3 signal connection
button.connect("pressed", self, "_on_Button_pressed")
# Godot 4 signal connection (callable)
button.pressed.connect(_on_Button_pressed)  # signal is a property:contentReference[oaicite:44]{index=44}
If you need to pass additional data to the handler, Godot 3 would use an array of arguments in connect(). In Godot 4, you bind extra arguments to the Callable. For instance:
gdscript
Copy
Edit
# Godot 3: passing extra parameter via array
button.connect("pressed", self, "_on_Button_pressed", [button])
# Godot 4: bind extra parameter to the function reference
button.pressed.connect(_on_Button_pressed.bind(button)):contentReference[oaicite:45]{index=45}
Waiting for Signals (Coroutines): The old yield usage is replaced by await. For example, to wait for an animation to finish:
gdscript
Copy
Edit
# Godot 3
$AnimationPlayer.play("explode")
yield($AnimationPlayer, "animation_finished")
print("Done!")
# Godot 4
$AnimationPlayer.play("explode")
await $AnimationPlayer.animation_finished  # suspend until signal:contentReference[oaicite:46]{index=46}
print("Done!")
Godot 4’s await is more intuitive and avoids string arguments – it directly uses the signal member.
RPC Functions: In Godot 3, you’d mark networked functions with keywords like remote, master, etc. For example: remote func do_something(): .... In Godot 4, you attach an @rpc annotation to the function. You can specify RPC mode parameters in the annotation as needed (e.g. @rpc(any_peer, reliable) to mimic a certain remote mode)
godotengine.org
. For example:
gdscript
Copy
Edit
@rpc(remote)  # Godot 4, equivalent to `remote` keyword
func do_something():
    # ...
Setter/Getters: Instead of using setget, define properties inline. For example, a clamped health value:
gdscript
Copy
Edit
# Godot 3
var health setget set_health
func set_health(value): 
    health = max(value, 0)

# Godot 4
var health: int:
    set(value):
        health = max(value, 0)  # setter logic inline
In Godot 4, writing self.health = -5 will trigger the setter (which was not the case in Godot 3’s setget)
godotengine.org
.
Function References & Lambdas: In Godot 3, to store a function callback you had to use Funcref. In Godot 4, you simply assign the function to a variable. For example:
gdscript
Copy
Edit
# Godot 3
var callback = Funcref(self, "print_message")
callback.call_func("Hello")
# Godot 4
var callback = print_message  # Callable created automatically:contentReference[oaicite:49]{index=49}
callback.call("Hello")        # Invoke the function:contentReference[oaicite:50]{index=50}
Godot 4 also allows lambda functions (anonymous functions). For instance: var doubler = func(x): return x * 2 creates a lambda that you can call with doubler.call(5).
Calling Superclass Methods: In Godot 3, inside an overridden method you’d call the base method via .method_name(). In Godot 4, you use super:
gdscript
Copy
Edit
func _ready():
    ._ready()  # Godot 3: call base _ready
    print("Child ready")

func _ready():
    super()    # Godot 4: calls base class _ready:contentReference[oaicite:51]{index=51}
    print("Child ready")
The new syntax super() without a method name calls the same function in the base class
shaggydev.com
, and you can also do super.foo() to call a specific parent method.
Performance Improvements in GDScript 4
Beyond syntax and API changes, Godot 4’s GDScript 2.0 offers significant performance gains. The entire GDScript engine was rewritten by the Godot team (led by George Marques) for speed and stability
godotengine.org
. Key improvements include:
Faster bytecode execution: Godot 4’s GDScript uses typed instructions to take advantage of static types at runtime. Operations on typed variables and function calls on known types are much faster than in Godot 3. In benchmarks, typed arithmetic operations ran ~25–50% faster, and calling methods on engine objects with pre-validated argument types became 120–150% faster (over 2× speedup) compared to Godot 3’s untyped calls
godotengine.org
. Iterating over arrays or dictionaries is also 10–50% faster when types are known
godotengine.org
.
Better memory and stability: The new GDScript engine in 4.x is more stable and avoids certain memory issues from 3.x. The cyclic dependency fixes mean you can organize code with fewer worries of script load-order problems. The runtime no longer throws cyclic reference errors for cross-referencing scripts
godotengine.org
.
In practice, projects ported to Godot 4 often see script logic run more smoothly. GDScript is still not as fast as C# or C++ for heavy computation, but the gap has narrowed with 4.x. The Godot team notes that despite adding many features, “the GDScript runtime is much faster and more stable in Godot 4” thanks to the complete rewrite
godotengine.org
. Therefore, developers are encouraged to leverage static typing in GDScript 4 to get the most performance benefit from these optimizations
godotengine.org
godotengine.org
.
Summary of Key Changes to Adopt
Godot 4.4’s GDScript introduces a host of changes that modernize and streamline scripting. To summarize the practical steps for developers upgrading from 3.x to 4.x:
Use the new syntax: Replace yield() with await, .method() with super, and setget with inline property setters/getters. Adopt the @export, @onready, @tool, and @rpc annotations (the old keywords will either no longer work or are discouraged)
shaggydev.com
.
Update API calls: Rename methods like instance() -> instantiate()
gist.github.com
, change_scene() -> change_scene_to_file()
shaggydev.com
, etc., according to the official migration guide. Many Node and Resource methods were renamed for clarity in 4.x; refer to the documentation for a full list.
Use Callables and signals: Simplify your signal connections by dropping string names in favor of first-class signal objects and Callables
shaggydev.com
. This not only makes code cleaner but also prevents errors (since method names are checked by the editor, not just strings).
Leverage static typing: Take advantage of typed arrays (Array[T]), and use enums as types for safer code
shaggydev.com
shaggydev.com
. This will also grant you performance boosts at runtime due to GDScript’s optimized instructions
godotengine.org
.
Prepare for removals: Some 3.x features are gone – e.g. the old Tween node is removed in 4.x (tweens are created via code now)
gist.github.com
. Plan to replace any deprecated patterns with their Godot 4 equivalents (the official Godot 4 upgrade guide and community resources detail many of these changes).
By understanding these differences, developers can smoothly transition their GDScript code from Godot 3 to Godot 4.4, taking full advantage of the new language features, cleaner syntax, and improved performance. Embracing GDScript’s evolution – from the gradual tweaks in 3.x to the sweeping changes in 4.x – will ensure your code is idiomatic and efficient in the latest engine version. The result is more robust, readable, and faster GDScript code going forward
godotengine.org
godotengine.org
. Sources: Official Godot documentation and migration guides, Godot 4.0 release notes and blog posts, and community guides summarizing GDScript 2.0 changes
shaggydev.com
gist.github.com
shaggydev.com
shaggydev.com
godotengine.org
, among others. All referenced changes have been verified against Godot’s official 4.4 documentation and development updates.