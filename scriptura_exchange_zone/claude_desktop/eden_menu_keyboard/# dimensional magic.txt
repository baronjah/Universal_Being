# dimensional magic
## these functions can be called from any script to main script, to call them and add them to queue to be done tasks


func first_dimensional_magic(type_of_action_to_do : String, datapoint_node : Node, additional_node : Node = null):
	var first_dimensional_data_array : Array = []
	first_dimensional_data_array.append(type_of_action_to_do)
	first_dimensional_data_array.append(datapoint_node)
	first_dimensional_data_array.append(additional_node)
	mutex_actions.lock()
	actions_to_be_called.append(first_dimensional_data_array)
	mutex_actions.unlock()

func the_fourth_dimensional_magic(type_of_operation : String, node : Node, data_of_movement):
	var data_for_movement : Array = []

	data_for_movement.append(type_of_operation)
	data_for_movement.append(node)
	data_for_movement.append(data_of_movement)
	movmentes_mutex.lock()
	things_to_be_moved.append(data_for_movement)
	movmentes_mutex.unlock()

func fifth_dimensional_magic(type_of_unloading : String, node_path_for_unload : String):
	var data_for_unloading : Array = []
	data_for_unloading.append(type_of_unloading)
	data_for_unloading.append(node_path_for_unload)
	mutex_for_unloading_nodes.lock()
	nodes_to_be_unloaded.append(data_for_unloading)
	mutex_for_unloading_nodes.unlock()

func sixth_dimensional_magic(type_of_function, node_to_call, function_name : String, additional_data = null):
	var data_for_function_call : Array = []
	data_for_function_call.append(type_of_function)
	data_for_function_call.append(node_to_call)
	data_for_function_call.append(function_name)
	if additional_data != null:
		data_for_function_call.append(additional_data)
	mutex_function_call.lock()
	functions_to_be_called.append(data_for_function_call)
	mutex_function_call.unlock()

func seventh_dimensional_magic(type_of_action : String, kind_of_action : String, amount_of_actions : int):
	var data_for_additionals : Array = []
	data_for_additionals.append(type_of_action)
	data_for_additionals.append(kind_of_action)
	data_for_additionals.append(amount_of_actions)
	mutex_additionals_call.lock()
	additionals_to_be_called.append(data_for_additionals)
	mutex_additionals_call.unlock()
	print(" seventh dimensional magic : " , data_for_additionals)

func check_magical_array(path_of_the_node):
	var name_parts = path_of_the_node.split("_")  
	var modifiable_parts = Array(name_parts) 
	modifiable_parts.pop_back()  
	var new_name = "_".join(modifiable_parts)
	print(" magical we must learn abortion hehe ", new_name) 
	mutex_additionals_call.lock()
	for current_sets_to_create in additionals_to_be_called:
		print("we must learn abortion hehe current_sets_to_create ", current_sets_to_create)
		if current_sets_to_create[1] == path_of_the_node:
			current_sets_to_create[2] = 0
			mutex_additionals_call.unlock()
			return false
		elif current_sets_to_create[0].begins_with(new_name):
			current_sets_to_create[2] = 0
			mutex_additionals_call.unlock()
			return false
	mutex_additionals_call.unlock()
	return true

func eight_dimensional_magic(type_of_message : String, message_now, receiver_name : String):
	print(" we got magic to do ", type_of_message)
	var divine_messenger_of_space_and_time : Array = []
	divine_messenger_of_space_and_time.append(type_of_message)
	divine_messenger_of_space_and_time.append(message_now)
	divine_messenger_of_space_and_time.append(receiver_name)
	print(" we got magic to do ", type_of_message)
	mutex_messages_call.lock()
	messages_to_be_called.append(divine_messenger_of_space_and_time)
	mutex_messages_call.unlock()
	print(" we got magic to do ", type_of_message)

var texture_storage = {} # Add this as a global variable

func ninth_dimensional_magic(operation, path, texture = null):
	match operation:
		"store_texture":
			texture_storage[path] = texture
			print("Texture stored for " + path)
			
		#"apply_texture":
			#var node = jsh_tree_get_node(path)
			#if node and node is MeshInstance3D and texture_storage.has(path):
				#var material = node.material_override
				#if material:
					#var textured_material = material.duplicate()
					#textured_material.albedo_texture = texture_storage[path]
					#
					#node.set_meta("material_plain", material)
					#node.set_meta("material_textured", textured_material)
					#
					#if is_textures_enabled():
						#node.material_override = textured_material
					#
					#node.add_to_group("texturable")
					#print("Texture applied to " + path)
					#
		#"toggle_textures":
			#textures_enabled = !textures_enabled
			#var objects = get_tree().get_nodes_in_group("texturable")
			#for obj in objects:
				#if obj is MeshInstance3D and obj.has_meta("material_plain") and obj.has_meta("material_textured"):
					#obj.material_override = obj.get_meta("material_textured") if textures_enabled else obj.get_meta("material_plain")
			#print("Textures " + ("enabled" if textures_enabled else "disabled"))
#