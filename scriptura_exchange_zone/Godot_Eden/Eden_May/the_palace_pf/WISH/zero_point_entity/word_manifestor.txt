class_name WordManifestor
extends Node

# ----- CONSTANTS -----
const MAX_WORD_HISTORY = 100
const WORD_DB_FILE = "user://word_database.json"
const CONCEPT_MAP_FILE = "user://concept_map.json"

# ----- DICTIONARIES AND MAPS -----
var word_properties = {}      # Known properties of words
var concept_relationships = {} # How concepts connect to each other
var word_history = []         # Recently used words

# ----- UNIVERSAL ENTITY REFERENCE -----
var universal_entity_scene = preload("res://scenes/universal_entity.tscn")

# ----- SCENE REFERENCES -----
var map_system: DynamicMapSystem
var player_node: Node3D

# ----- SIGNALS -----
signal word_manifested(word, entity)
signal concept_discovered(concept, properties)
signal word_combination_created(words, result)

# ----- INITIALIZATION -----
func _ready():
	load_word_database()
	load_concept_map()

func initialize(p_map_system: DynamicMapSystem, p_player: Node3D):
	map_system = p_map_system
	player_node = p_player

# ----- CORE MANIFESTATION SYSTEM -----
func manifest_word(word: String, position = null, extra_properties = {}) -> UniversalEntity:
	"""
	Create a universal entity from a word
	"""
	# Clean the word
	word = word.strip_edges().to_lower()
	
	if word.is_empty():
		return null
	
	# Add to history
	_add_to_word_history(word)
	
	# Get properties for this word
	var properties = analyze_word(word)
	
	# Merge with extra properties
	for key in extra_properties:
		properties[key] = extra_properties[key]
	
	# Determine position
	var spawn_position: Vector3
	if position is Vector3:
		spawn_position = position
	elif player_node:
		# Default to in front of player
		var forward = -player_node.global_transform.basis.z
		spawn_position = player_node.global_position + forward * 2.0
	else:
		spawn_position = Vector3.ZERO
	
	# Create the universal entity
	var entity = universal_entity_scene.instantiate()
	entity.manifest_from_word(word, 1.0)  # Full manifestation
	
	# Add to world via map system
	if map_system:
		map_system.add_entity_to_world(entity, spawn_position)
	else:
		# Fallback if no map system
		add_child(entity)
		entity.global_position = spawn_position
	
	# Save this word's properties for future use
	_learn_word_properties(word, properties)
	
	emit_signal("word_manifested", word, entity)
	return entity

func manifest_word_sequence(sequence: String, start_position: Vector3, spacing: float = 1.5) -> Array:
	"""
	Create multiple entities from a sequence of words
	"""
	var words = sequence.split(" ", false)
	var entities = []
	var position = start_position
	
	for word in words:
		if word.strip_edges().is_empty():
			continue
			
		var entity = manifest_word(word, position)
		if entity:
			entities.append(entity)
			
			# Move position forward
			if player_node:
				var right = player_node.global_transform.basis.x
				position += right * spacing
	
	return entities

func combine_words(words: Array, position = null) -> UniversalEntity:
	"""
	Combine multiple words to create a more complex entity
	"""
	if words.size() < 2:
		return null
	
	# Combine the properties of all words
	var combined_properties = {}
	var combined_word = ""
	
	for word in words:
		word = word.strip_edges().to_lower()
		if word.is_empty():
			continue
			
		combined_word += word + "_"
		
		var word_props = analyze_word(word)
		for key in word_props:
			if key in combined_properties:
				# For numeric properties, take the average
				if word_props[key] is float or word_props[key] is int:
					combined_properties[key] = (combined_properties[key] + word_props[key]) / 2.0
				# For string properties, combine them
				elif word_props[key] is String:
					combined_properties[key] = combined_properties[key] + "_" + word_props[key]
				# For dictionaries, merge them
				elif word_props[key] is Dictionary:
					for subkey in word_props[key]:
						if subkey in combined_properties[key]:
							combined_properties[key][subkey] = (combined_properties[key][subkey] + word_props[key][subkey]) / 2.0
						else:
							combined_properties[key][subkey] = word_props[key][subkey]
			else:
				combined_properties[key] = word_props[key]
	
	# Remove trailing underscore
	combined_word = combined_word.rstrip("_")
	
	# Add combination bonus
	combined_properties["complexity"] = combined_properties.get("complexity", 0.5) * 1.5
	combined_properties["manifestation_bonus"] = 0.2 * words.size()
	
	# Create the entity with combined properties
	var entity = manifest_word(combined_word, position, combined_properties)
	
	# Record this combination
	_add_word_combination(words, combined_word)
	
	emit_signal("word_combination_created", words, combined_word)
	return entity

# ----- WORD ANALYSIS -----
func analyze_word(word: String) -> Dictionary:
	"""
	Convert a word into entity properties
	"""
	word = word.strip_edges().to_lower()
	
	# Check if we already know this word
	if word_properties.has(word):
		return word_properties[word].duplicate()
	
	# Analyze the word to derive properties
	var props = {}
	
	# 1. Check for known elements
	var elements = {
		"fire": 0.0, "flame": 0.0, "burn": 0.0, "heat": 0.0,
		"water": 0.0, "liquid": 0.0, "fluid": 0.0, "ice": 0.0,
		"earth": 0.0, "stone": 0.0, "rock": 0.0, "mountain": 0.0,
		"air": 0.0, "wind": 0.0, "breeze": 0.0, "sky": 0.0,
		"metal": 0.0, "iron": 0.0, "steel": 0.0, "gold": 0.0,
		"wood": 0.0, "tree": 0.0, "plant": 0.0, "forest": 0.0,
		"light": 0.0, "sun": 0.0, "bright": 0.0, "shine": 0.0,
		"dark": 0.0, "shadow": 0.0, "night": 0.0, "void": 0.0
	}
	
	var element_types = {}
	for element in elements:
		if word.find(element) >= 0:
			elements[element] = 1.0
			
			# Group by primary element
			var primary_element = element
			if element in ["flame", "burn", "heat"]:
				primary_element = "fire"
			elif element in ["liquid", "fluid", "ice"]:
				primary_element = "water"
			elif element in ["stone", "rock", "mountain"]:
				primary_element = "earth"
			elif element in ["wind", "breeze", "sky"]:
				primary_element = "air"
			elif element in ["iron", "steel", "gold"]:
				primary_element = "metal"
			elif element in ["tree", "plant", "forest"]:
				primary_element = "wood"
			elif element in ["sun", "bright", "shine"]:
				primary_element = "light"
			elif element in ["shadow", "night", "void"]:
				primary_element = "dark"
			
			element_types[primary_element] = element_types.get(primary_element, 0.0) + 1.0
	
	props["elements"] = element_types
	
	# 2. Analyze vowel/consonant patterns
	var vowel_count = 0
	var consonant_count = 0
	
	for c in word:
		if c.to_lower() in "aeiou":
			vowel_count += 1
		elif c.to_lower() in "bcdfghjklmnpqrstvwxyz":
			consonant_count += 1
	
	var vowel_ratio = float(vowel_count) / max(1, word.length())
	props["fluidity"] = vowel_ratio
	props["stability"] = 1.0 - vowel_ratio
	
	# 3. Word length influences complexity
	props["complexity"] = min(1.0, word.length() / 15.0)
	
	# 4. First letter influences initial energy
	var first_char = word.substr(0, 1).to_lower()
	var alphabet = "abcdefghijklmnopqrstuvwxyz"
	var first_char_position = alphabet.find(first_char)
	
	if first_char_position >= 0:
		props["initial_energy"] = float(first_char_position) / alphabet.length()
	else:
		props["initial_energy"] = 0.5
	
	# 5. Repetition of letters indicates resonance
	var char_counts = {}
	var max_repeats = 0
	
	for c in word:
		if not char_counts.has(c):
			char_counts[c] = 0
		char_counts[c] += 1
		max_repeats = max(max_repeats, char_counts[c])
	
	props["resonance"] = float(max_repeats) / word.length()
	
	# 6. Check for concept matches
	var matched_concepts = _match_concepts(word)
	if not matched_concepts.is_empty():
		props["concepts"] = matched_concepts
	
	return props

func _match_concepts(word: String) -> Dictionary:
	"""
	Match a word against known concepts
	"""
	var matched = {}
	
	# Simple concept matching
	var concepts = {
		"life": ["life", "living", "alive", "birth", "grow"],
		"death": ["death", "dead", "dying", "decay", "rot"],
		"creation": ["create", "make", "build", "craft", "form"],
		"destruction": ["destroy", "break", "ruin", "shatter", "demolish"],
		"movement": ["move", "run", "flow", "travel", "journey"],
		"stillness": ["still", "stop", "frozen", "stationary", "fixed"],
		"power": ["power", "energy", "force", "strength", "might"],
		"wisdom": ["wise", "know", "learn", "understand", "comprehend"],
		"time": ["time", "moment", "second", "minute", "hour", "day"],
		"space": ["space", "distance", "area", "volume", "dimension"]
	}
	
	for concept in concepts:
		for term in concepts[concept]:
			if word.find(term) >= 0:
				matched[concept] = 1.0
				break
	
	return matched

# ----- LEARNING SYSTEM -----
func _learn_word_properties(word: String, properties: Dictionary):
	"""
	Store the properties of a word for future use
	"""
	word_properties[word] = properties.duplicate()
	save_word_database()

func _add_word_combination(words: Array, result: String):
	"""
	Record a successful word combination
	"""
	if not concept_relationships.has("combinations"):
		concept_relationships["combinations"] = {}
	
	var combo_key = PoolStringArray(words).join("+")
	concept_relationships.combinations[combo_key] = result
	
	save_concept_map()

func _add_to_word_history(word: String):
	"""
	Add a word to the history, maintaining max size
	"""
	word_history.push_front(word)
	
	if word_history.size() > MAX_WORD_HISTORY:
		word_history.pop_back()

# ----- SAVING AND LOADING -----
func save_word_database():
	"""
	Save the word properties database to file
	"""
	var file = FileAccess.open(WORD_DB_FILE, FileAccess.WRITE)
	if file:
		file.store_string(JSON.stringify(word_properties))
	else:
		print("Error saving word database: ", FileAccess.get_open_error())

func load_word_database():
	"""
	Load the word properties database from file
	"""
	var file = FileAccess.open(WORD_DB_FILE, FileAccess.READ)
	if file:
		var text = file.get_as_text()
		var parsed = JSON.parse_string(text)
		
		if parsed != null:
			word_properties = parsed
		else:
			print("Error parsing word database JSON")
	else:
		print("Word database not found, creating new one")
		# Initialize with some basic words
		_initialize_starter_words()

func save_concept_map():
	"""
	Save the concept relationship map to file
	"""
	var file = FileAccess.open(CONCEPT_MAP_FILE, FileAccess.WRITE)
	if file:
		file.store_string(JSON.stringify(concept_relationships))
	else:
		print("Error saving concept map: ", FileAccess.get_open_error())

func load_concept_map():
	"""
	Load the concept relationship map from file
	"""
	var file = FileAccess.open(CONCEPT_MAP_FILE, FileAccess.READ)
	if file:
		var text = file.get_as_text()
		var parsed = JSON.parse_string(text)
		
		if parsed != null:
			concept_relationships = parsed
		else:
			print("Error parsing concept map JSON")
	else:
		print("Concept map not found, creating new one")
		concept_relationships = {
			"opposites": {
				"fire": "water",
				"earth": "air",
				"light": "dark",
				"life": "death",
				"creation": "destruction",
				"movement": "stillness"
			},
			"combinations": {}
		}

func _initialize_starter_words():
	"""
	Initialize the database with some basic words
	"""
	# Define starter elemental words
	var starters = ["fire", "water", "earth", "air", "light", "dark", "wood", "metal"]
	
	for word in starters:
		var props = analyze_word(word)
		_learn_word_properties(word, props)
	
	# Add some pre-defined combinations
	var combinations = {
		"fire+water": "steam",
		"earth+water": "mud",
		"fire+earth": "lava",
		"air+water": "mist",
		"light+water": "rainbow",
		"fire+air": "smoke"
	}
	
	for combo in combinations:
		var result = combinations[combo]
		var words = combo.split("+")
		var props = {}
		
		for word in words:
			var word_props = analyze_word(word)
			for key in word_props:
				if not props.has(key):
					props[key] = word_props[key]
				elif props[key] is float:
					props[key] = (props[key] + word_props[key]) / 2.0
		
		props["complexity"] = props.get("complexity", 0.5) * 1.5
		_learn_word_properties(result, props)
	
	# Save the initialized database
	save_word_database()

# ----- PUBLIC UTILITY FUNCTIONS -----
func get_opposite_concept(concept: String) -> String:
	"""
	Get the opposite of a concept if known
	"""
	if concept_relationships.has("opposites") and concept_relationships.opposites.has(concept):
		return concept_relationships.opposites[concept]
	
	return ""

func get_related_words(word: String, max_results: int = 5) -> Array:
	"""
	Find words related to the given word
	"""
	word = word.strip_edges().to_lower()
	
	var related = []
	var word_props = analyze_word(word)
	
	# Find words with similar properties
	var similarity_scores = {}
	
	for other_word in word_properties:
		if other_word == word:
			continue
			
		var other_props = word_properties[other_word]
		var score = _calculate_word_similarity(word_props, other_props)
		
		similarity_scores[other_word] = score
	
	# Sort by similarity score
	var sorted_words = similarity_scores.keys()
	sorted_words.sort_custom(Callable(self, "_sort_by_similarity_score"), similarity_scores)
	
	# Return top results
	for i in min(max_results, sorted_words.size()):
		related.append(sorted_words[i])
	
	return related

func _sort_by_similarity_score(a, b, scores):
	return scores[a] > scores[b]

func _calculate_word_similarity(props_a: Dictionary, props_b: Dictionary) -> float:
	"""
	Calculate how similar two word property sets are
	"""
	var score = 0.0
	var num_comparisons = 0
	
	# Compare float properties
	for key in props_a:
		if props_b.has(key):
			if props_a[key] is float and props_b[key] is float:
				score += 1.0 - abs(props_a[key] - props_b[key])
				num_comparisons += 1
			elif props_a[key] is Dictionary and props_b[key] is Dictionary:
				# For dictionaries like elements, compare each value
				for subkey in props_a[key]:
					if props_b[key].has(subkey) and props_a[key][subkey] is float and props_b[key][subkey] is float:
						score += 1.0 - abs(props_a[key][subkey] - props_b[key][subkey])
						num_comparisons += 1
	
	if num_comparisons > 0:
		return score / num_comparisons
	else:
		return 0.0

# ----- CONSOLE INTERFACE -----
func process_command(command: String) -> Dictionary:
	"""
	Process a text command for creating, combining, or evolving entities
	"""
	command = command.strip_edges()
	
	# Split into command parts
	var parts = command.split(" ", false, 1)
	var action = parts[0].to_lower()
	var params = parts[1] if parts.size() > 1 else ""
	
	var result = {
		"success": false,
		"message": "",
		"entity": null
	}
	
	match action:
		"create", "manifest":
			var entity = manifest_word(params)
			if entity:
				result.success = true
				result.message = "Created entity from word: " + params
				result.entity = entity
			else:
				result.message = "Failed to create entity from: " + params
		
		"combine":
			var words = params.split(" ", false)
			if words.size() >= 2:
				var entity = combine_words(words)
				if entity:
					result.success = true
					result.message = "Combined words into: " + entity.source_word
					result.entity = entity
				else:
					result.message = "Failed to combine words"
			else:
				result.message = "Need at least 2 words to combine"
		
		"evolve":
			# Find entities by word
			var entity = _find_entity_by_word(params)
			if entity:
				entity.evolve()
				result.success = true
				result.message = "Evolved entity: " + params
				result.entity = entity
			else:
				result.message = "No entity found with word: " + params
		
		"transform":
			var word_parts = params.split(" to ", false)
			if word_parts.size() == 2:
				var source_word = word_parts[0].strip_edges()
				var target_form = word_parts[1].strip_edges()
				
				var entity = _find_entity_by_word(source_word)
				if entity:
					entity.transform_to(target_form)
					result.success = true
					result.message = "Transformed " + source_word + " to " + target_form
					result.entity = entity
				else:
					result.message = "No entity found with word: " + source_word
			else:
				result.message = "Invalid transform command. Use 'transform X to Y'"
		
		"connect":
			var word_parts = params.split(" to ", false)
			if word_parts.size() == 2:
				var source_word = word_parts[0].strip_edges()
				var target_word = word_parts[1].strip_edges()
				
				var source_entity = _find_entity_by_word(source_word)
				var target_entity = _find_entity_by_word(target_word)
				
				if source_entity and target_entity:
					source_entity.connect_to(target_entity)
					result.success = true
					result.message = "Connected " + source_word + " to " + target_word
					result.entity = source_entity
				else:
					result.message = "Could not find one or both entities"
			else:
				result.message = "Invalid connect command. Use 'connect X to Y'"
		
		"help":
			result.success = true
			result.message = "Available commands:\n" + \
							"create/manifest [word] - Create an entity\n" + \
							"combine [word1] [word2] ... - Combine words\n" + \
							"evolve [word] - Evolve an entity\n" + \
							"transform [word] to [form] - Transform entity\n" + \
							"connect [word1] to [word2] - Connect entities"
		
		_:
			# Default to creating an entity from the entire command
			var entity = manifest_word(command)
			if entity:
				result.success = true
				result.message = "Created entity from: " + command
				result.entity = entity
			else:
				result.message = "Unknown command or failed to create entity"
	
	return result

func _find_entity_by_word(word: String) -> UniversalEntity:
	"""
	Find an entity with the given source word
	"""
	# This is a naive implementation that searches all cells
	if not map_system:
		return null
	
	for cell_coords in map_system.cells:
		var cell = map_system.cells[cell_coords]
		for entity in cell.get_entities():
			if entity is UniversalEntity and entity.source_word == word:
				return entity
	
	return null