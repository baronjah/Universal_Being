# Space to Element Transition System

## Overview
This document outlines the implementation of a seamless transition system between the space (galaxies, stars, planets) and element (fire, water, wood, ash) systems in the Eden project.

## Conceptual Framework

### Scale Levels
1. **Universal Scale** - Galaxies visible as points
2. **Galactic Scale** - Stars visible within a galaxy
3. **Solar System Scale** - Planets orbiting a star
4. **Planetary Scale** - Planet surface visible
5. **Element Scale** - Individual elements visible

### Transition Mechanics
The transition between scales should be:
- Visually seamless
- Physics-consistent
- Performance-optimized
- Conceptually coherent

## Implementation Components

### 1. UniverseController

```gdscript
class_name UniverseController
extends Node3D

# Scale management
var current_scale_level = 2  # Start at Solar System scale
var target_scale_level = 2
var transition_progress = 0.0
var is_transitioning = false

# Scale references
var scale_managers = {
    0: null,  # Universe manager
    1: null,  # Galaxy manager
    2: null,  # Solar system manager
    3: null,  # Planet manager
    4: null   # Element manager
}

# Camera control
var camera: Camera3D
var camera_target: Node3D
var zoom_speed = 1.0

# Transition focal point
var transition_focus: Vector3

func _ready():
    # Set up managers for each scale
    scale_managers[0] = $UniverseManager
    scale_managers[1] = $GalaxyManager
    scale_managers[2] = $SolarSystemManager
    scale_managers[3] = $PlanetManager
    scale_managers[4] = $ElementManager
    
    # Set up camera
    camera = $Camera3D
    
    # Initialize starting scale
    activate_scale(current_scale_level)

func _process(delta):
    # Handle scale transitions
    if is_transitioning:
        process_transition(delta)
        
    # Update active scale
    update_active_scale(delta)

func begin_transition_to(scale_level, focus_position = null):
    if scale_level == current_scale_level:
        return
        
    target_scale_level = scale_level
    is_transitioning = true
    transition_progress = 0.0
    
    # Set focus position for zoom
    if focus_position:
        transition_focus = focus_position
    else:
        # Default to camera's current focus point
        transition_focus = camera.project_position(get_viewport().size / 2, 100)
    
    # Prepare the target scale for activation
    prepare_scale(target_scale_level, transition_focus)

func process_transition(delta):
    # Progress the transition
    transition_progress += delta * zoom_speed
    
    if transition_progress >= 1.0:
        # Transition complete
        complete_transition()
        return
    
    # Calculate transition parameters
    var curve = ease(transition_progress, 0.5)  # Smooth easing
    
    # Update camera settings for transition
    var start_fov = 75 - (current_scale_level * 10)
    var end_fov = 75 - (target_scale_level * 10)
    camera.fov = lerp(start_fov, end_fov, curve)
    
    # Update visual effects for transition
    var blur_amount = sin(transition_progress * PI) * 2.0
    apply_transition_effects(blur_amount)
    
    # Handle object crossfading
    update_scale_visibility(curve)

func complete_transition():
    is_transitioning = false
    transition_progress = 0.0
    
    # Fully activate new scale
    deactivate_scale(current_scale_level)
    current_scale_level = target_scale_level
    activate_scale(current_scale_level)
    
    # Reset camera effects
    apply_transition_effects(0.0)

func prepare_scale(scale_level, focus_position):
    # Tell the target scale manager to prepare for activation
    if scale_managers[scale_level]:
        scale_managers[scale_level].prepare_activation(focus_position)

func activate_scale(scale_level):
    # Fully activate a scale manager
    if scale_managers[scale_level]:
        scale_managers[scale_level].activate()
        
    # Update camera parameters for this scale
    update_camera_for_scale(scale_level)

func deactivate_scale(scale_level):
    # Deactivate a scale manager
    if scale_managers[scale_level]:
        scale_managers[scale_level].deactivate()

func update_scale_visibility(transition_amount):
    # Crossfade between scales during transition
    if scale_managers[current_scale_level]:
        scale_managers[current_scale_level].set_visibility(1.0 - transition_amount)
        
    if scale_managers[target_scale_level]:
        scale_managers[target_scale_level].set_visibility(transition_amount)

func update_active_scale(delta):
    # Update the currently active scale
    if scale_managers[current_scale_level]:
        scale_managers[current_scale_level].update(delta)
    
    # If transitioning, also update the target scale
    if is_transitioning and scale_managers[target_scale_level]:
        scale_managers[target_scale_level].update(delta)

func update_camera_for_scale(scale_level):
    # Update camera parameters based on scale
    match scale_level:
        0:  # Universe scale
            camera.far = 1000000.0
            camera.near = 1.0
            camera.fov = 75
        1:  # Galaxy scale
            camera.far = 100000.0
            camera.near = 0.1
            camera.fov = 65
        2:  # Solar system scale
            camera.far = 10000.0
            camera.near = 0.1
            camera.fov = 55
        3:  # Planet scale
            camera.far = 1000.0
            camera.near = 0.1
            camera.fov = 45
        4:  # Element scale
            camera.far = 100.0
            camera.near = 0.01
            camera.fov = 35

func apply_transition_effects(amount):
    # Apply visual effects during transition
    var material = $TransitionEffects.material
    material.set_shader_parameter("blur_amount", amount)
    material.set_shader_parameter("distortion", amount * 0.3)
    
    # Apply audio effects too
    var audio_scale = 1.0 - (amount * 0.5)
    AudioServer.set_bus_effect_enabled(0, 0, amount > 0.05)
    AudioServer.set_bus_volume_db(0, linear_to_db(audio_scale))
```

### 2. Scale Manager Interface

Each scale needs a manager that implements this interface:

```gdscript
class_name ScaleManager
extends Node

signal transition_ready(scale_level)

# Scale properties
var scale_level: int
var is_active: bool = false
var visibility: float = 0.0

# Resource management
var resource_manager
var object_pool = {}

# Scale-specific parameters
var scale_specific_params = {}

func _ready():
    # Initialize common elements
    pass

func prepare_activation(focus_position: Vector3):
    # Prepare this scale to become active
    # Generate/load content around focus position
    # Initialize required resources
    # Signal when ready
    emit_signal("transition_ready", scale_level)

func activate():
    # Fully activate this scale
    is_active = true
    visibility = 1.0
    
    # Enable full physics processing
    process_mode = Node.PROCESS_MODE_INHERIT
    
    # Start all scale systems
    initialize_scale_systems()

func deactivate():
    # Deactivate this scale
    is_active = false
    visibility = 0.0
    
    # Disable full processing
    process_mode = Node.PROCESS_MODE_DISABLED
    
    # Stop or pause scale systems
    cleanup_scale_systems()

func update(delta: float):
    # Update scale-specific logic
    if is_active:
        update_active(delta)
    else:
        update_inactive(delta)

func update_active(delta: float):
    # Full update when scale is active
    pass

func update_inactive(delta: float):
    # Minimal updates when scale is inactive but visible (during transitions)
    pass

func set_visibility(value: float):
    # Set visibility for transition effects
    visibility = clamp(value, 0.0, 1.0)
    update_visual_components()

func update_visual_components():
    # Update materials and visibility based on transition state
    pass

func initialize_scale_systems():
    # Start all systems needed for this scale
    pass

func cleanup_scale_systems():
    # Clean up or pause systems when deactivating
    pass

func get_focus_object(position: Vector3):
    # Find suitable object near position to focus on when zooming
    pass
```

### 3. ElementManager Implementation

Extending the existing ElementManager to implement the ScaleManager interface:

```gdscript
# element_manager.gd - Extended with ScaleManager functionality
extends Node3D
class_name ElementManager

# Original ElementManager code here...

# ScaleManager interface implementation
var scale_level = 4  # Element scale
var is_active = false
var visibility = 0.0

func prepare_activation(focus_position):
    # Prepare element system at the given position
    clear_all_elements()
    
    # Create initial elements around focus position
    var settings = {
        "world_size": Vector3(100, 100, 100),
        "initial_elements": {
            "fire": 20,
            "water": 20,
            "wood": 20,
            "ash": 10
        },
        "focus_position": focus_position
    }
    
    # Generate world without activating yet
    pre_generate_world(settings)
    
    # Signal ready
    emit_signal("transition_ready", scale_level)

func pre_generate_world(settings):
    # Create elements but don't start simulation
    # Similar to generate_world but doesn't set is_world_active
    
    # Apply settings
    physics_intensity = settings.get("physics_intensity", 1.0)
    
    # Create initial elements around focus position
    var world_size = settings.get("world_size", Vector3(100, 100, 100))
    var initial_elements = settings.get("initial_elements", {})
    var focus = settings.get("focus_position", Vector3.ZERO)
    
    for type in initial_elements:
        var count = initial_elements[type]
        for i in range(count):
            var pos = focus + Vector3(
                randf_range(-world_size.x/4, world_size.x/4),
                randf_range(-world_size.y/4, world_size.y/4),
                randf_range(-world_size.z/4, world_size.z/4)
            )
            create_element(type, pos)

func activate():
    # Activate element world
    is_active = true
    visibility = 1.0
    is_world_active = true
    
    # Ensure camera is properly set
    update_camera_position()
    
    # Make elements visible
    for type in active_elements:
        for element in active_elements[type]:
            if element and is_instance_valid(element):
                element.visible = true

func deactivate():
    # Deactivate element world
    is_active = false
    visibility = 0.0
    is_world_active = false
    
    # Optionally pause all elements
    for type in active_elements:
        for element in active_elements[type]:
            if element and is_instance_valid(element):
                element.visible = false

func update_active(delta):
    # Already handled by original _process
    pass

func update_inactive(delta):
    # Minimal updates during transition
    update_camera_position()

func set_visibility(value):
    visibility = clamp(value, 0.0, 1.0)
    
    # Update element visibility during transition
    for type in active_elements:
        for element in active_elements[type]:
            if element and is_instance_valid(element):
                # Set opacity based on visibility
                var mesh = element.get_node_or_null("MeshInstance3D")
                if mesh and mesh.material_override:
                    var material = mesh.material_override
                    if material is StandardMaterial3D:
                        material.albedo_color.a = visibility
                    elif material is ShaderMaterial:
                        material.set_shader_parameter("alpha", visibility)
                
                # If using instancing, update instance visibility
                if element.has_method("set_transition_visibility"):
                    element.set_transition_visibility(visibility)
```

### 4. PlanetManager Implementation

For handling the planetary scale:

```gdscript
class_name PlanetManager
extends Node3D

# ScaleManager interface
var scale_level = 3  # Planet scale
var is_active = false
var visibility = 0.0

# Planet properties
var current_planet = null
var surface_features = []
var atmosphere_particles = null
var weather_system = null

signal transition_ready(scale_level)

func _ready():
    # Initialize components
    atmosphere_particles = $AtmosphereParticles
    weather_system = $WeatherSystem

func prepare_activation(focus_position):
    # Find or create planet at focus position
    var universe = get_parent()
    current_planet = universe.find_celestial_body_at(focus_position)
    
    if current_planet:
        # Position planet properly
        position = Vector3.ZERO
        current_planet.position = Vector3.ZERO
        
        # Generate surface features
        generate_surface_features(current_planet)
        
        # Setup atmosphere
        setup_atmosphere(current_planet)
        
        # Setup weather if applicable
        if current_planet.has_atmosphere:
            weather_system.initialize(current_planet)
    
    # Signal ready
    emit_signal("transition_ready", scale_level)

func generate_surface_features(planet):
    # Clear old features
    for feature in surface_features:
        feature.queue_free()
    surface_features.clear()
    
    # Generate new features based on planet type
    match planet.planet_type:
        "rocky":
            add_surface_feature("mountains", 20)
            add_surface_feature("craters", 15)
            add_surface_feature("canyons", 5)
        "gas":
            add_surface_feature("storm_systems", 8)
            add_surface_feature("cloud_layers", 5)
        "ocean":
            add_surface_feature("oceans", 1)
            add_surface_feature("islands", 12)
            add_surface_feature("clouds", 8)
        "lava":
            add_surface_feature("lava_flows", 15)
            add_surface_feature("volcanoes", 10)
            add_surface_feature("ash_clouds", 6)

func add_surface_feature(type, count):
    for i in range(count):
        var feature = create_feature(type)
        if feature:
            # Position on planet surface
            var angle1 = randf() * TAU
            var angle2 = randf() * TAU
            var radius = current_planet.radius
            
            var x = cos(angle1) * sin(angle2) * radius
            var y = sin(angle1) * sin(angle2) * radius
            var z = cos(angle2) * radius
            
            feature.position = Vector3(x, y, z)
            add_child(feature)
            surface_features.append(feature)

func create_feature(type):
    # Create appropriate feature based on type
    var feature
    match type:
        "mountains":
            feature = load("res://scenes/planet_features/Mountains.tscn").instantiate()
        "oceans":
            feature = load("res://scenes/planet_features/Ocean.tscn").instantiate()
        # Add other feature types...
        
    return feature

func setup_atmosphere(planet):
    if planet.has_atmosphere:
        atmosphere_particles.visible = true
        
        # Set up atmosphere properties
        var color = Color(0.5, 0.7, 1.0)  # Default blue
        var density = 1.0
        
        match planet.atmosphere_type:
            "earth_like":
                color = Color(0.5, 0.7, 1.0)
                density = 1.0
            "thick":
                color = Color(0.7, 0.5, 0.2)
                density = 2.0
            "thin":
                color = Color(0.8, 0.9, 1.0)
                density = 0.5
                
        atmosphere_particles.process_material.color = color
        atmosphere_particles.amount = int(100 * density)
    else:
        atmosphere_particles.visible = false

func activate():
    is_active = true
    visibility = 1.0
    
    # Enable physics and interactions
    if current_planet:
        current_planet.active = true

func deactivate():
    is_active = false
    visibility = 0.0
    
    # Disable detailed processing
    if current_planet:
        current_planet.active = false

func update(delta):
    if is_active:
        update_active(delta)
    else:
        update_inactive(delta)

func update_active(delta):
    # Update planet rotation
    if current_planet:
        current_planet.rotate_y(current_planet.rotation_speed * delta)
        
    # Update weather if applicable
    if current_planet and current_planet.has_atmosphere:
        weather_system.update(delta)
        
    # Update surface features
    for feature in surface_features:
        if feature.has_method("update"):
            feature.update(delta)

func update_inactive(delta):
    # Minimal updates for transition
    if current_planet:
        current_planet.rotate_y(current_planet.rotation_speed * delta * 0.1)

func set_visibility(value):
    visibility = clamp(value, 0.0, 1.0)
    
    # Update visuals for transition
    if current_planet:
        # Adjust planet material
        var material = current_planet.get_node("MeshInstance3D").material_override
        material.set_shader_parameter("transition_alpha", visibility)
        
    # Update atmosphere visibility
    if atmosphere_particles:
        var material = atmosphere_particles.process_material
        var original_color = material.color
        material.color = Color(original_color.r, original_color.g, original_color.b, visibility)
        
    # Update feature visibility
    for feature in surface_features:
        if feature is MeshInstance3D:
            var material = feature.material_override
            if material:
                material.albedo_color.a = visibility
```

### 5. Transition Bridge - Element to Planet

This component handles the specific translation between element scale and planet scale:

```gdscript
class_name ElementPlanetBridge
extends Node

var element_manager
var planet_manager

# Element-planet mapping
var element_seeds = {
    "earth": {
        "fire": 30,
        "water": 40,
        "wood": 30,
        "ash": 10
    },
    "mars": {
        "fire": 10,
        "water": 5,
        "wood": 0,
        "ash": 50
    },
    "gas_giant": {
        "fire": 50,
        "water": 20,
        "wood": 0,
        "ash": 0
    }
}

func _ready():
    # Get references
    element_manager = $"../ElementManager"
    planet_manager = $"../PlanetManager"

func translate_planet_to_elements(planet, focus_position):
    # Create elements based on planet properties
    var element_distribution = {}
    
    # Get base template for planet type
    if planet.planet_type in element_seeds:
        element_distribution = element_seeds[planet.planet_type].duplicate()
    else:
        # Default distribution
        element_distribution = {
            "fire": 20,
            "water": 20,
            "wood": 20,
            "ash": 20
        }
    
    # Modify based on planet properties
    if planet.temperature > 500:  # Hot planet
        element_distribution["fire"] *= 2
        element_distribution["water"] *= 0.5
    elif planet.temperature < 200:  # Cold planet
        element_distribution["fire"] *= 0.5
        element_distribution["water"] *= 1.5
        
    if planet.has_life:
        element_distribution["wood"] *= 2
    
    if planet.atmosphere_density > 1.5:
        # Dense atmosphere - more water
        element_distribution["water"] *= 1.5
    
    # Apply planet's gravity to element system
    element_manager.apply_global_gravity(Vector3(0, -planet.gravity, 0))
    
    # Apply planet's atmospheric effects
    if planet.has_atmosphere:
        var atmosphere = {}
        atmosphere.density = planet.atmosphere_density
        atmosphere.composition = planet.atmosphere_composition
        element_manager.apply_atmospheric_conditions(atmosphere)
    
    # Return the distribution for element manager
    return {
        "world_size": Vector3(100, 100, 100),
        "initial_elements": element_distribution,
        "physics_intensity": planet.gravity / 9.8,
        "focus_position": focus_position
    }

func translate_elements_to_planet_features(elements):
    # Analyze element distribution and state
    var element_counts = {}
    var element_clusters = {}
    
    # Count elements by type
    for type in element_manager.active_elements:
        element_counts[type] = element_manager.active_elements[type].size()
        
    # Identify clusters (simplified)
    element_clusters = find_element_clusters()
    
    # Create planet features based on elements
    var features = []
    
    # Fire clusters become volcanoes
    for cluster in element_clusters.fire:
        if cluster.size > 5:
            features.append({
                "type": "volcano",
                "position": cluster.center,
                "size": cluster.size / 10.0
            })
    
    # Water clusters become oceans/lakes
    for cluster in element_clusters.water:
        if cluster.size > 8:
            features.append({
                "type": "ocean",
                "position": cluster.center,
                "size": cluster.size / 8.0
            })
        elif cluster.size > 3:
            features.append({
                "type": "lake",
                "position": cluster.center,
                "size": cluster.size / 5.0
            })
    
    # Wood clusters become forests
    for cluster in element_clusters.wood:
        if cluster.size > 4:
            features.append({
                "type": "forest",
                "position": cluster.center,
                "size": cluster.size / 6.0
            })
    
    return features

func find_element_clusters():
    # Simplified clustering algorithm
    var clusters = {
        "fire": [],
        "water": [],
        "wood": [],
        "ash": []
    }
    
    # For each element type
    for type in element_manager.active_elements:
        var elements = element_manager.active_elements[type]
        var processed = []
        
        # For each unprocessed element
        for element in elements:
            if element in processed:
                continue
                
            # Start a new cluster
            var cluster = {
                "elements": [element],
                "center": element.global_position,
                "size": 1
            }
            
            # Find connected elements
            find_connected_elements(element, cluster, processed)
            
            # Update cluster center
            if cluster.elements.size() > 0:
                var center = Vector3.ZERO
                for e in cluster.elements:
                    center += e.global_position
                cluster.center = center / cluster.elements.size()
                
            cluster.size = cluster.elements.size()
            
            # Add to clusters if significant
            if cluster.size >= 3:
                clusters[type].append(cluster)
    
    return clusters

func find_connected_elements(element, cluster, processed):
    # Mark as processed
    processed.append(element)
    
    # Check connections
    for connected in element.connections:
        if connected.element_type == element.element_type and not connected in processed:
            cluster.elements.append(connected)
            cluster.size += 1
            find_connected_elements(connected, cluster, processed)
```

### 6. Camera Controller for Scale Transitions

A specialized camera controller for handling scale transitions:

```gdscript
class_name ScaleTransitionCamera
extends Camera3D

# Movement properties
var target_position = Vector3.ZERO
var current_velocity = Vector3.ZERO
var rotation_speed = 0.5
var move_speed = 10.0
var zoom_speed = 1.0
var smoothing = 0.1

# Transition properties
var transition_target = null
var transition_start_position = Vector3.ZERO
var transition_end_position = Vector3.ZERO
var transition_progress = 0.0
var is_transitioning = false

# Focus object
var focus_object = null
var orbit_distance = 10.0
var orbit_height = 3.0
var orbit_angle = 0.0

# Original camera parameters
var original_fov
var original_near
var original_far

func _ready():
    # Store original camera parameters
    original_fov = fov
    original_near = near
    original_far = far

func _process(delta):
    if is_transitioning:
        process_transition(delta)
    elif focus_object and is_instance_valid(focus_object):
        update_focus_orbit(delta)
    else:
        process_free_camera(delta)

func process_free_camera(delta):
    # Handle free camera movement
    var input_dir = get_input_direction()
    
    # Smoothly move camera
    if input_dir.length_squared() > 0.1:
        current_velocity = current_velocity.lerp(input_dir * move_speed, delta * 5.0)
    else:
        current_velocity = current_velocity.lerp(Vector3.ZERO, delta * 3.0)
    
    # Apply movement
    global_position += current_velocity * delta
    
    # Handle rotation
    if Input.is_action_pressed("camera_rotate"):
        var mouse_motion = Input.get_last_mouse_velocity() * delta * rotation_speed
        rotate_y(-mouse_motion.x * 0.01)
        rotate_object_local(Vector3.RIGHT, -mouse_motion.y * 0.01)
        
    # Handle zooming
    var zoom_input = Input.get_axis("zoom_out", "zoom_in")
    if abs(zoom_input) > 0.1:
        fov = clamp(fov - zoom_input * zoom_speed, 30, 90)

func update_focus_orbit(delta):
    # Orbit around focus object
    if Input.is_action_pressed("orbit_rotate"):
        orbit_angle += Input.get_last_mouse_velocity().x * delta * 0.01
        orbit_height += Input.get_last_mouse_velocity().y * delta * 0.1
        orbit_height = clamp(orbit_height, -5.0, 10.0)
    
    # Calculate orbit position
    var orbit_position = Vector3(
        cos(orbit_angle) * orbit_distance,
        orbit_height,
        sin(orbit_angle) * orbit_distance
    )
    
    # Update camera position and look at target
    global_position = focus_object.global_position + orbit_position
    look_at(focus_object.global_position, Vector3.UP)
    
    # Handle zooming which affects orbit distance
    var zoom_input = Input.get_axis("zoom_out", "zoom_in")
    if abs(zoom_input) > 0.1:
        orbit_distance = clamp(orbit_distance - zoom_input * zoom_speed * delta * 10.0, 2.0, 100.0)

func begin_scale_transition(target_obj, end_scale):
    # Start transition to target object
    transition_target = target_obj
    is_transitioning = true
    transition_progress = 0.0
    
    # Store start and calculate end positions
    transition_start_position = global_position
    
    # Calculate appropriate end position based on scale
    var target_distance
    match end_scale:
        0:  # Universe scale
            target_distance = 1000.0
        1:  # Galaxy scale  
            target_distance = 100.0
        2:  # Solar system scale
            target_distance = 20.0
        3:  # Planet scale
            target_distance = 5.0
        4:  # Element scale  
            target_distance = 1.0
    
    # Calculate direction from target to camera
    var direction = global_position - target_obj.global_position
    direction = direction.normalized()
    
    # Set end position
    transition_end_position = target_obj.global_position + (direction * target_distance)
    
    # Store original camera parameters
    original_fov = fov
    original_near = near
    original_far = far

func process_transition(delta):
    # Progress the transition
    transition_progress += delta * zoom_speed
    
    if transition_progress >= 1.0:
        # Transition complete
        complete_transition()
        return
    
    # Use smooth easing
    var t = ease(transition_progress, 0.5)
    
    # Update position
    global_position = transition_start_position.lerp(transition_end_position, t)
    
    # Keep looking at target
    if transition_target and is_instance_valid(transition_target):
        look_at(transition_target.global_position, Vector3.UP)
    
    # Adjust camera parameters
    fov = lerp(original_fov, original_fov * 0.8, sin(transition_progress * PI))
    
    # Apply visual effects via environment
    var environment = get_environment()
    if environment:
        environment.dof_blur_far_enabled = transition_progress > 0.1 and transition_progress < 0.9
        environment.dof_blur_far_distance = lerp(100.0, 10.0, transition_progress)
        environment.dof_blur_far_amount = sin(transition_progress * PI) * 0.5

func complete_transition():
    is_transitioning = false
    transition_progress = 0.0
    
    # Set focus object to target
    focus_object = transition_target
    orbit_distance = global_position.distance_to(focus_object.global_position)
    
    # Calculate current orbit angle
    var dir = global_position - focus_object.global_position
    orbit_angle = atan2(dir.z, dir.x)
    
    # Calculate orbit height
    orbit_height = dir.y
    
    # Reset camera effects
    var environment = get_environment()
    if environment:
        environment.dof_blur_far_enabled = false

func get_input_direction():
    var direction = Vector3.ZERO
    
    # Forward/backward
    if Input.is_action_pressed("move_forward"):
        direction -= transform.basis.z
    if Input.is_action_pressed("move_backward"):
        direction += transform.basis.z
        
    # Left/right
    if Input.is_action_pressed("move_left"):
        direction -= transform.basis.x
    if Input.is_action_pressed("move_right"):
        direction += transform.basis.x
        
    # Up/down
    if Input.is_action_pressed("move_up"):
        direction += transform.basis.y
    if Input.is_action_pressed("move_down"):
        direction -= transform.basis.y
        
    return direction.normalized()
```

## Visual Effects for Transition

### 1. Scale Transition Shader

This shader creates visual effects during scale transitions:

```gdscript
shader_type canvas_item;

uniform float blur_amount : hint_range(0.0, 5.0) = 0.0;
uniform float distortion : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D screen_texture : hint_screen_texture;

void fragment() {
    // Calculate distorted UV
    vec2 uv = SCREEN_UV;
    float center_distance = length(uv - vec2(0.5, 0.5)) * 2.0;
    
    // Apply radial distortion
    vec2 distorted_uv = uv + (uv - vec2(0.5, 0.5)) * distortion * center_distance;
    
    // Apply blur
    vec4 blurred = textureLod(screen_texture, distorted_uv, blur_amount * 4.0);
    
    // Final color
    COLOR = blurred;
    
    // Add subtle color shift for cosmic/quantum effect 
    if (distortion > 0.1) {
        float shift = sin(TIME * 2.0 + uv.x * 10.0) * 0.02 * distortion;
        COLOR.r += shift;
        COLOR.b -= shift;
    }
}
```

### 2. Element Scale Visual Effects

Special effects applied to elements during transition:

```gdscript
# Add to base_element.gd
func set_transition_visibility(visibility_amount):
    # Apply transition effect to element
    visible = visibility_amount > 0.05
    
    # Update materials
    var mesh_instance = get_node_or_null("MeshInstance3D")
    if mesh_instance and mesh_instance.material_override:
        var material = mesh_instance.material_override
        
        # Set transparency
        if material is StandardMaterial3D:
            var color = material.albedo_color
            material.albedo_color = Color(color.r, color.g, color.b, visibility_amount)
        elif material is ShaderMaterial:
            material.set_shader_parameter("alpha", visibility_amount)
            
        # Add cosmic effect during transition
        if visibility_amount > 0.0 and visibility_amount < 1.0:
            var glow = sin(visibility_amount * PI) * 2.0
            
            if material is StandardMaterial3D:
                material.emission_enabled = true
                material.emission = Color(1.0, 0.8, 0.4) * glow
            elif material is ShaderMaterial:
                material.set_shader_parameter("emission_amount", glow)
                
        # Reset at full visibility  
        elif visibility_amount >= 1.0:
            if material is StandardMaterial3D:
                material.emission_enabled = false
            elif material is ShaderMaterial:
                material.set_shader_parameter("emission_amount", 0.0)
```

## Testing and Implementation Steps

1. **Initial Setup**
   - Create the ScaleTransitionController class
   - Implement basic scale manager interfaces
   - Set up camera system for transitions

2. **Basic Transition**
   - Implement camera-based zoom transitions
   - Add focal point selection
   - Create simple placeholder visuals for scales

3. **Element Integration**
   - Extend ElementManager to implement ScaleManager
   - Add element creation based on planetary conditions
   - Implement element visualization during transitions

4. **Planet Integration**
   - Implement PlanetManager for planetary scale
   - Create surface feature generation system
   - Add atmosphere and environmental effects

5. **Scale Bridging**
   - Implement ElementPlanetBridge
   - Create bidirectional translation between scales
   - Ensure physics consistency between scales

6. **Visual Enhancement**
   - Add transition shaders and effects
   - Implement LOD systems for all scales
   - Create smooth visual transitions between levels

7. **Testing**
   - Test transitions between each scale level
   - Measure performance and optimize
   - Refine focal point selection
   - Test edge cases and transition coherence