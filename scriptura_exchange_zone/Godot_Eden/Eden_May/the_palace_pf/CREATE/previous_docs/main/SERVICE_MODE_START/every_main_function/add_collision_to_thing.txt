func add_collision_to_thing(thing_node, node_type, path_of_thingy, name_of_thingy):
	# First add the regular flat collision
	
	# static_body
	var static_body_name = "collision_" + name_of_thingy 
	var static_body_path = path_of_thingy + "/" + static_body_name
	
	var static_body = StaticBody3D.new()
	static_body.name = static_body_name
	
	# collision_shape
	var shape_name = "shape_" + name_of_thingy 
	var collision_shape_path = static_body_path + "/"  + shape_name
	
	var collision_shape = CollisionShape3D.new()
	collision_shape.name = shape_name
	
	# area
	var area_name = "aura_" + name_of_thingy 
	var area_node_path = path_of_thingy + "/" + area_name
	
	var area = Area3D.new()
	area.name = area_name
	
	# area_collision_shape it trully is aura!
	var collision_area = "collision_aura_" + name_of_thingy
	var collision_area_path = area_node_path + "/" + collision_area
	
	var area_collision_shape = CollisionShape3D.new()
	area_collision_shape.name = collision_area

	# Get mesh data to determine shape size
	var mesh_instance = thing_node as MeshInstance3D
	if mesh_instance and mesh_instance.mesh:
		var aabb = mesh_instance.mesh.get_aabb()
		
		match node_type:
			"flat_shape", "model", "button", "cursor", "screen", "circle":
				# Create flat collision shape for StaticBody
				var flat_shape = ConvexPolygonShape3D.new()
				var vertices = mesh_instance.mesh.get_faces()
				flat_shape.points = vertices
				collision_shape.shape = flat_shape
				
				# Create larger shape for Area3D
				var area_shape = ConvexPolygonShape3D.new()
				var expanded_vertices = PackedVector3Array()
				
				# Create expanded version of vertices for area
				var expansion_distance = 0.2  # Distance to expand in all directions
				# Expand in all directions by adding vertices offset in +/- x, y, z
				for vert in vertices:
					# Positive directions
					expanded_vertices.push_back(vert + Vector3(expansion_distance, expansion_distance, expansion_distance))
					expanded_vertices.push_back(vert + Vector3(expansion_distance, expansion_distance, -expansion_distance))
					expanded_vertices.push_back(vert + Vector3(expansion_distance, -expansion_distance, expansion_distance))
					expanded_vertices.push_back(vert + Vector3(-expansion_distance, expansion_distance, expansion_distance))
					# Negative directions
					expanded_vertices.push_back(vert + Vector3(-expansion_distance, -expansion_distance, -expansion_distance))
					expanded_vertices.push_back(vert + Vector3(-expansion_distance, -expansion_distance, expansion_distance))
					expanded_vertices.push_back(vert + Vector3(-expansion_distance, expansion_distance, -expansion_distance))
					expanded_vertices.push_back(vert + Vector3(expansion_distance, -expansion_distance, -expansion_distance))
				
				area_shape.points = expanded_vertices
				area_collision_shape.shape = area_shape
				
			"heightmap":
				# Create flat collision shape for StaticBody
				var flat_shape = ConvexPolygonShape3D.new()
				var vertices = mesh_instance.mesh.get_faces()
				flat_shape.points = vertices
				collision_shape.shape = flat_shape
				
				# Create larger shape for Area3D
				var area_shape = ConvexPolygonShape3D.new()
				var expanded_vertices = PackedVector3Array()
				
				# Create expanded version of vertices for area
				var expansion_distance = 0.2  # Distance above and below the surface
				for vert in vertices:
					expanded_vertices.push_back(vert + Vector3(0, expansion_distance, 0))
				for vert in vertices:
					expanded_vertices.push_back(vert - Vector3(0, expansion_distance, 0))
				
				area_shape.points = expanded_vertices
				area_collision_shape.shape = area_shape
			_: # Default fallback
				return
	
	# Configure collision properties
	static_body.collision_layer = 1
	static_body.collision_mask = 1
	
	area.collision_layer = 2  # Using different layer for area detection
	area.collision_mask = 2   # Adjust these values based on your needs

	tasked_children(static_body, static_body_path)
	tasked_children(collision_shape, collision_shape_path)
	tasked_children(area, area_node_path)
	tasked_children(area_collision_shape, collision_area_path)