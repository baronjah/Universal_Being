# Space System Enhancement Plan

## Current Status
The space system currently has basic galaxy generation with spiral patterns but needs further development to create a rich, interactive universe.

## 1. Enhanced Galaxy Generation

### Galaxy Type System
```gdscript
# Add to Galaxies.gd
enum GalaxyType {
    SPIRAL,
    ELLIPTICAL,
    IRREGULAR,
    RING,
    DWARF
}

var galaxy_type_params = {
    GalaxyType.SPIRAL: {
        "arm_count_range": [2, 6],
        "arm_width_range": [0.2, 0.5],
        "spiral_factor_range": [0.3, 0.7],
        "star_density_range": [0.3, 1.0],
        "color_range": ["blue_white", "yellow", "orange_red"]
    },
    GalaxyType.ELLIPTICAL: {
        "shape_factor_range": [0.6, 1.2],
        "density_falloff_range": [0.3, 0.8],
        "star_density_range": [0.4, 1.2],
        "color_range": ["yellow", "orange", "red"]
    },
    GalaxyType.IRREGULAR: {
        "chaos_factor_range": [0.4, 0.9],
        "density_clusters_range": [3, 8],
        "star_density_range": [0.2, 0.8],
        "color_range": ["blue", "white", "mixed"]
    },
    GalaxyType.RING: {
        "ring_width_range": [0.1, 0.3],
        "ring_radius_range": [0.6, 0.9],
        "star_density_range": [0.3, 0.7],
        "color_range": ["blue_white", "white"]
    },
    GalaxyType.DWARF: {
        "size_factor_range": [0.2, 0.5],
        "density_range": [0.8, 1.5],
        "star_density_range": [0.4, 0.9],
        "color_range": ["red", "orange"]
    }
}

func determine_galaxy_type(seed_value):
    var rng = RandomNumberGenerator.new()
    rng.seed = seed_value
    
    # Distribution of galaxy types
    var roll = rng.randf()
    if roll < 0.5:
        return GalaxyType.SPIRAL  # 50% chance
    elif roll < 0.75:
        return GalaxyType.ELLIPTICAL  # 25% chance
    elif roll < 0.85:
        return GalaxyType.IRREGULAR  # 10% chance
    elif roll < 0.95:
        return GalaxyType.RING  # 10% chance
    else:
        return GalaxyType.DWARF  # 5% chance

func generate_galaxy_parameters(galaxy_type, seed_value):
    var rng = RandomNumberGenerator.new()
    rng.seed = seed_value
    
    var params = {}
    var type_params = galaxy_type_params[galaxy_type]
    
    # Common parameters for all galaxy types
    params.size = rng.randf_range(80.0, 120.0)
    params.star_count = int(rng.randf_range(500, 2000))
    
    # Type-specific parameters
    match galaxy_type:
        GalaxyType.SPIRAL:
            params.arm_count = rng.randi_range(2, 6)
            params.arm_width = rng.randf_range(type_params.arm_width_range[0], type_params.arm_width_range[1])
            params.spiral_factor = rng.randf_range(type_params.spiral_factor_range[0], type_params.spiral_factor_range[1])
        GalaxyType.ELLIPTICAL:
            params.shape_factor = rng.randf_range(type_params.shape_factor_range[0], type_params.shape_factor_range[1])
            params.density_falloff = rng.randf_range(type_params.density_falloff_range[0], type_params.density_falloff_range[1])
        # Handle other types...
    
    # Choose color scheme
    var color_options = type_params.color_range
    params.color_scheme = color_options[rng.randi() % color_options.size()]
    
    return params
```

### Visual Improvements
- Add emission maps for galaxy glow
- Implement dust clouds with particle systems
- Create nebula effects with shader-based volumetrics
- Add galaxy rotation animation

### Galaxy Data Structure
```gdscript
# Add to galaxy_data.gd
class_name GalaxyData

var id: int
var seed_value: int
var galaxy_type: int
var position: Vector3
var rotation: Vector3
var size: float
var parameters: Dictionary
var star_systems: Dictionary
var resources: Dictionary
var name: String

func _init(p_seed: int, p_position: Vector3):
    seed_value = p_seed
    position = p_position
    
    # Generate unique ID
    id = seed_value + int(position.x * 1000) + int(position.y * 1000000) + int(position.z * 1000000000)
    
    # Generate name
    name = GalaxyNameGenerator.generate_name(seed_value)
    
    # Create empty containers
    star_systems = {}
    resources = {}
    
# Additional functions for serialization, star system access, etc.
```

## 2. Star System Generation

### Star Types
```gdscript
# Add to star_system.gd
enum StarType {
    O_TYPE,    # Blue, extremely hot and bright
    B_TYPE,    # Blue-white, very hot
    A_TYPE,    # White, hot
    F_TYPE,    # Yellow-white
    G_TYPE,    # Yellow (like our Sun)
    K_TYPE,    # Orange
    M_TYPE,    # Red, cool
    RED_GIANT,
    WHITE_DWARF,
    NEUTRON,
    BLACK_HOLE
}

var star_type_params = {
    StarType.O_TYPE: {
        "temperature_range": [30000, 50000],
        "size_range": [15.0, 90.0],
        "color": Color(0.5, 0.5, 1.0),
        "habitable_zone": [50.0, 100.0],
        "planets_range": [0, 3],
        "life_chance": 0.01
    },
    StarType.B_TYPE: {
        "temperature_range": [10000, 30000],
        "size_range": [4.0, 15.0],
        "color": Color(0.6, 0.6, 1.0),
        "habitable_zone": [30.0, 60.0],
        "planets_range": [0, 5],
        "life_chance": 0.05
    },
    # Additional star types...
    StarType.G_TYPE: {
        "temperature_range": [5000, 6000],
        "size_range": [0.8, 1.2],
        "color": Color(1.0, 1.0, 0.8),
        "habitable_zone": [0.8, 1.5],
        "planets_range": [4, 12],
        "life_chance": 0.4
    }
}

func determine_star_type(seed_value):
    var rng = RandomNumberGenerator.new()
    rng.seed = seed_value
    
    # Distribution of star types (approximate real distribution)
    var roll = rng.randf()
    if roll < 0.00003:
        return StarType.O_TYPE      # 0.003%
    elif roll < 0.0013:
        return StarType.B_TYPE      # 0.13%
    elif roll < 0.0073:
        return StarType.A_TYPE      # 0.6%
    elif roll < 0.0373:
        return StarType.F_TYPE      # 3%
    elif roll < 0.1133:
        return StarType.G_TYPE      # 7.6%
    elif roll < 0.2333:
        return StarType.K_TYPE      # 12%
    else:
        return StarType.M_TYPE      # 76.45%
```

### Star System Builder
```gdscript
# Add to star_system_generator.gd
func generate_star_system(seed_value, galaxy_position, distances_from_center):
    var rng = RandomNumberGenerator.new()
    rng.seed = seed_value
    
    # Create star data
    var star_type = determine_star_type(seed_value)
    var star_data = create_star(star_type, seed_value)
    
    # Determine number of planets
    var params = star_type_params[star_type]
    var planet_count = rng.randi_range(params.planets_range[0], params.planets_range[1])
    
    # Generate planets
    var planets = []
    for i in range(planet_count):
        var planet_seed = seed_value + i + 1
        var distance = calculate_orbit_distance(i, star_type)
        var planet = generate_planet(planet_seed, star_type, distance)
        planets.append(planet)
    
    # Create star system data
    var system = {
        "id": seed_value,
        "position": calculate_position_in_galaxy(galaxy_position, distances_from_center, seed_value),
        "star": star_data,
        "planets": planets,
        "name": StarNameGenerator.generate_name(seed_value)
    }
    
    return system

func calculate_orbit_distance(planet_index, star_type):
    # Implement orbital distance calculation
    # Could use Titus-Bode law or another algorithm
    pass

func generate_planet(seed, star_type, orbit_distance):
    # Generate planet based on distance from star and star type
    pass
```

### Star Visualization
- Create star material with emission
- Implement corona effect with shader
- Add lens flare for bright stars
- Create star rotation and pulsation effects

## 3. Planetary System Implementation

### Planet Types
```gdscript
# Add to planet_system.gd
enum PlanetType {
    ROCKY,
    GAS_GIANT,
    ICE_GIANT,
    WATER_WORLD,
    LAVA_WORLD,
    TERRESTRIAL,
    DESERT,
    BARREN
}

var planet_type_params = {
    PlanetType.ROCKY: {
        "size_range": [0.3, 1.0],
        "atmosphere_chance": 0.3,
        "color_palette": ["brown", "gray", "red"],
        "resource_types": ["minerals", "metals"],
        "elements": {
            "fire": 30,
            "water": 10, 
            "wood": 5,
            "ash": 40
        }
    },
    PlanetType.TERRESTRIAL: {
        "size_range": [0.8, 1.3],
        "atmosphere_chance": 0.95,
        "color_palette": ["blue", "green", "white"],
        "resource_types": ["water", "life", "gases"],
        "elements": {
            "fire": 20,
            "water": 40,
            "wood": 30,
            "ash": 10
        }
    },
    # Additional planet types...
}

func determine_planet_type(seed_value, distance_from_star, star_type):
    var rng = RandomNumberGenerator.new()
    rng.seed = seed_value
    
    # Calculate temperature based on star type and distance
    var star_temp = star_type_params[star_type].temperature_range[0]
    var temp_factor = star_temp / (distance_from_star * distance_from_star)
    
    # Determine planet type based on temperature and random factors
    if temp_factor > 100:
        return PlanetType.LAVA_WORLD
    elif temp_factor > 50:
        return rng.randf() < 0.7 ? PlanetType.ROCKY : PlanetType.DESERT
    elif temp_factor > 20:
        return rng.randf() < 0.5 ? PlanetType.TERRESTRIAL : PlanetType.ROCKY
    elif temp_factor > 5:
        return rng.randf() < 0.7 ? PlanetType.WATER_WORLD : PlanetType.TERRESTRIAL
    elif temp_factor > 1:
        return rng.randf() < 0.6 ? PlanetType.ICE_GIANT : PlanetType.ROCKY
    else:
        return rng.randf() < 0.7 ? PlanetType.GAS_GIANT : PlanetType.ICE_GIANT
```

### Orbital Mechanics
- Implement proper Keplerian orbits
- Add orbital period calculation
- Create visualization for orbits
- Add planet rotation with proper axis tilt

## 4. Camera and Selection System

### Camera Controller
```gdscript
# Add to space_camera_controller.gd
class_name SpaceCameraController
extends Camera3D

# Camera states
enum CameraState {
    FREE,
    FOLLOW,
    TRANSITION,
    ORBIT
}

# Camera properties
var move_speed = 10.0
var zoom_speed = 1.0
var rotation_speed = 0.5
var current_state = CameraState.FREE
var follow_target = null
var orbit_distance = 10.0
var orbit_height = 3.0
var orbit_angle = 0.0
var smooth_factor = 0.1

# Transition properties
var transition_start_pos = Vector3.ZERO
var transition_end_pos = Vector3.ZERO
var transition_start_rot = Quaternion.IDENTITY
var transition_end_rot = Quaternion.IDENTITY
var transition_progress = 0.0
var transition_duration = 1.0
var is_transitioning = false

func _process(delta):
    match current_state:
        CameraState.FREE:
            process_free_camera(delta)
        CameraState.FOLLOW:
            process_follow_camera(delta)
        CameraState.TRANSITION:
            process_transition(delta)
        CameraState.ORBIT:
            process_orbit_camera(delta)

func process_free_camera(delta):
    # Handle direct camera movement with input
    var input_dir = get_input_direction()
    
    if input_dir.length_squared() > 0.1:
        # Apply movement in camera's local space
        global_position += global_transform.basis * input_dir * move_speed * delta
    
    # Handle rotation with right mouse button
    if Input.is_action_pressed("orbit_rotate"):
        var mouse_motion = Input.get_last_mouse_velocity() * delta * rotation_speed
        rotate_y(-mouse_motion.x * 0.01)
        rotate_object_local(Vector3.RIGHT, -mouse_motion.y * 0.01)
        
    # Handle zooming with mouse wheel
    var zoom_input = Input.get_axis("zoom_out", "zoom_in")
    if abs(zoom_input) > 0.1:
        # Adjust FOV for zoom effect
        fov = clamp(fov - zoom_input * zoom_speed * 10.0, 30, 90)

func begin_transition_to(target_pos, target_rot, duration = 1.0):
    transition_start_pos = global_position
    transition_end_pos = target_pos
    transition_start_rot = Quaternion(global_transform.basis)
    transition_end_rot = Quaternion(target_rot)
    transition_progress = 0.0
    transition_duration = duration
    current_state = CameraState.TRANSITION
    is_transitioning = true

func process_transition(delta):
    if !is_transitioning:
        return
        
    transition_progress += delta / transition_duration
    
    if transition_progress >= 1.0:
        # Transition complete
        global_position = transition_end_pos
        global_transform.basis = Basis(transition_end_rot)
        is_transitioning = false
        
        # Return to appropriate state
        if follow_target:
            current_state = CameraState.FOLLOW
        else:
            current_state = CameraState.FREE
        return
    
    # Apply smooth transition
    var t = ease(transition_progress, 0.5)  # Smooth easing
    global_position = transition_start_pos.lerp(transition_end_pos, t)
    
    # Spherical interpolation for rotation
    var current_rot = transition_start_rot.slerp(transition_end_rot, t)
    global_transform.basis = Basis(current_rot)

# Additional functions for other camera states...
```

### Object Selection System
```gdscript
# Add to space_selection_system.gd
class_name SpaceSelectionSystem
extends Node

signal object_selected(object)
signal object_hovered(object)
signal selection_cleared

# Selection properties
var current_selection = null
var hover_object = null
var selection_mask = 0  # Will be set based on current scale
var max_selection_distance = 1000.0
var camera = null

# Scale-specific masks
var scale_masks = {
    "universe": 1,  # Galaxies
    "galaxy": 2,    # Stars
    "star_system": 4,  # Planets
    "planet": 8     # Surface features
}

func _ready():
    # Find camera
    await get_tree().process_frame
    camera = get_viewport().get_camera_3d()

func _process(_delta):
    # Check for selection via raycast each frame
    if camera and Input.is_action_just_pressed("select"):
        select_object_under_cursor()
    
    # Update hover object
    update_hover_object()

func select_object_under_cursor():
    var object = get_object_under_cursor()
    
    if object:
        select_object(object)
    else:
        clear_selection()

func get_object_under_cursor():
    var mouse_pos = get_viewport().get_mouse_position()
    var from = camera.project_ray_origin(mouse_pos)
    var to = from + camera.project_ray_normal(mouse_pos) * max_selection_distance
    
    var space_state = get_world_3d().direct_space_state
    var query = PhysicsRayQueryParameters3D.new()
    query.from = from
    query.to = to
    query.collision_mask = selection_mask
    
    var result = space_state.intersect_ray(query)
    
    if result and result.collider:
        return result.collider
    
    return null

func set_scale_mask(scale_name):
    if scale_masks.has(scale_name):
        selection_mask = scale_masks[scale_name]

# Additional functions for selection handling...
```

## 5. Space Navigation Interfaces

### Navigation Overlay
```gdscript
# Add to space_navigation_ui.gd
class_name SpaceNavigationUI
extends Control

# Reference to controllers
var universe_controller = null
var camera_controller = null
var selection_system = null

# UI components
var minimap: TextureRect
var coordinates_label: Label
var scale_indicator: ProgressBar
var target_info_panel: Panel
var transition_buttons: Dictionary

func _ready():
    # Find controllers
    universe_controller = get_node("/root/SpaceGame/UniverseController")
    camera_controller = get_node("/root/SpaceGame/Camera3D")
    selection_system = get_node("/root/SpaceGame/SelectionSystem")
    
    # Connect signals
    selection_system.connect("object_selected", Callable(self, "_on_object_selected"))
    selection_system.connect("object_hovered", Callable(self, "_on_object_hovered"))
    universe_controller.connect("scale_changed", Callable(self, "_on_scale_changed"))
    
    # Set up UI
    setup_ui_components()

func _process(_delta):
    # Update coordinates
    if camera_controller:
        update_coordinates(camera_controller.global_position)
    
    # Update minimap
    update_minimap()

func setup_ui_components():
    # Create minimap
    minimap = TextureRect.new()
    minimap.texture = create_minimap_texture()
    minimap.anchor_right = 0.2
    minimap.anchor_bottom = 0.2
    add_child(minimap)
    
    # Create coordinates label
    coordinates_label = Label.new()
    coordinates_label.text = "Coordinates: 0, 0, 0"
    coordinates_label.anchor_top = 0.95
    coordinates_label.anchor_right = 1.0
    coordinates_label.anchor_bottom = 1.0
    add_child(coordinates_label)
    
    # Create scale indicator
    scale_indicator = ProgressBar.new()
    scale_indicator.min_value = 0
    scale_indicator.max_value = 4  # 5 scales
    scale_indicator.value = universe_controller.current_scale
    scale_indicator.anchor_left = 0.8
    scale_indicator.anchor_right = 0.95
    scale_indicator.anchor_bottom = 0.05
    add_child(scale_indicator)
    
    # Create target info panel (initially hidden)
    target_info_panel = Panel.new()
    target_info_panel.anchor_left = 0.75
    target_info_panel.anchor_top = 0.75
    target_info_panel.anchor_right = 0.99
    target_info_panel.anchor_bottom = 0.99
    target_info_panel.visible = false
    add_child(target_info_panel)
    
    # Add transition buttons
    add_transition_buttons()

# Additional functions for UI management...
```

### Implementation Timeline

1. **Week 1: Galaxy Enhancement (3 days)**
   - Implement galaxy types system
   - Create improved galaxy visualization
   - Add galaxy data structure

2. **Week 1-2: Star System Generation (4 days)**
   - Implement star types
   - Create star system builder
   - Develop star visualization

3. **Week 2-3: Planetary System (4 days)**
   - Implement planet types
   - Create orbital mechanics system
   - Develop planet visualization

4. **Week 3-4: Camera & Selection (3 days)**
   - Implement camera controller
   - Create selection system
   - Develop transition effects

5. **Week 4: Navigation Interface (3 days)**
   - Create navigation overlay
   - Implement coordinate system
   - Develop targeting interfaces