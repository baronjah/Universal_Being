<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Splitter Visualization - Notepad3D</title>
    <style>
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent-blue: #3b82f6;
            --accent-purple: #8b5cf6;
            --accent-green: #10b981;
            --accent-pink: #ec4899;
            --accent-orange: #f59e0b;
            --border-color: #334155;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
            height: 100vh;
        }

        header {
            background-color: var(--bg-secondary);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--accent-blue);
            margin-right: 1rem;
        }

        .dimensions-panel {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .dimension-btn {
            background-color: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: var(--accent-blue);
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .dimension-btn:hover {
            background-color: rgba(59, 130, 246, 0.2);
        }

        .dimension-btn.active {
            background-color: var(--accent-blue);
            color: white;
        }

        .system-status {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .moon-phase {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #f0f0f0;
            box-shadow: inset -5px 0 rgba(0, 0, 0, 0.2);
            margin-left: 0.5rem;
        }

        .status-indicator {
            display: flex;
            align-items: center;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-connected {
            background-color: var(--accent-green);
        }

        .status-disconnected {
            background-color: #ef4444;
        }

        main {
            display: grid;
            grid-template-columns: 240px 1fr;
            height: calc(100vh - 60px);
        }

        .sidebar {
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            padding: 1rem;
            overflow-y: auto;
        }

        .sidebar h2 {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .stream-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .stream-item {
            background-color: rgba(15, 23, 42, 0.6);
            border-radius: 4px;
            padding: 0.7rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .stream-item:hover {
            background-color: rgba(30, 41, 59, 0.8);
        }

        .stream-item.active {
            border-left-color: var(--accent-blue);
            background-color: rgba(59, 130, 246, 0.1);
        }

        .stream-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.2rem;
        }

        .stream-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .main-content {
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .action-bar {
            display: flex;
            padding: 0.8rem;
            gap: 0.5rem;
            background-color: rgba(15, 23, 42, 0.6);
            border-bottom: 1px solid var(--border-color);
        }

        .button {
            background-color: var(--accent-blue);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .button:hover {
            background-color: #2563eb;
        }

        .button:disabled {
            background-color: #93c5fd;
            cursor: not-allowed;
        }

        .button.green {
            background-color: var(--accent-green);
        }

        .button.green:hover {
            background-color: #059669;
        }

        .button.purple {
            background-color: var(--accent-purple);
        }

        .button.purple:hover {
            background-color: #7c3aed;
        }

        .data-content {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .chunks-container {
            padding: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            overflow-y: auto;
            max-height: 40%;
            min-height: 200px;
        }

        .data-chunk {
            background-color: var(--bg-secondary);
            border-radius: 6px;
            padding: 1rem;
            width: 160px;
            height: 160px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .data-chunk:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .data-chunk.selected {
            box-shadow: 0 0 0 2px var(--accent-blue);
        }

        .chunk-content {
            font-size: 0.8rem;
            overflow: hidden;
            flex-grow: 1;
            word-break: break-word;
        }

        .chunk-footer {
            font-size: 0.7rem;
            color: var(--text-secondary);
            border-top: 1px solid var(--border-color);
            padding-top: 0.5rem;
            margin-top: auto;
        }

        .visualization-container {
            flex-grow: 1;
            padding: 1rem;
            border-top: 1px solid var(--border-color);
            overflow: hidden;
            position: relative;
        }

        .visualization-title {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        #visualization-canvas {
            width: 100%;
            height: calc(100% - 30px);
            background-color: rgba(15, 23, 42, 0.4);
            border-radius: 6px;
            overflow: hidden;
        }

        .visualization-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .reality-selector {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .reality-selector option {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-secondary);
            font-size: 1rem;
        }

        /* Dimension-specific styles */
        body.dimension-1d {
            --bg-primary: #18181b;
        }

        body.dimension-3d {
            --bg-primary: #0f172a;
        }

        body.dimension-5d {
            --bg-primary: #0f172a;
            --bg-secondary: #1e1b4b;
        }

        body.dimension-7d {
            --bg-primary: #0c0a09;
            --bg-secondary: #18181b;
        }

        body.dimension-9d {
            --bg-primary: #0c0a09;
            --bg-secondary: #1e1b4b;
        }

        body.dimension-12d {
            --bg-primary: #030712;
            --bg-secondary: #1e1b4b;
        }

        body.dimension-12d .visualization-container {
            filter: brightness(1.3) contrast(1.2);
        }

        @keyframes glow {
            0% { filter: brightness(1) blur(0); }
            50% { filter: brightness(1.2) blur(1px); }
            100% { filter: brightness(1) blur(0); }
        }

        body.dimension-5d .visualization-container {
            animation: glow 8s infinite;
        }
    </style>
</head>
<body class="dimension-3d">
    <header>
        <div class="header-left">
            <h1>Data Splitter Visualization</h1>
            <div class="status-indicator">
                <div class="status-dot status-disconnected" id="connection-status"></div>
                <span id="connection-text">Disconnected</span>
            </div>
        </div>
        
        <div class="dimensions-panel">
            <select id="reality-selector" class="reality-selector">
                <option value="physical">Physical</option>
                <option value="digital" selected>Digital</option>
                <option value="astral">Astral</option>
                <option value="quantum">Quantum</option>
                <option value="memory">Memory</option>
                <option value="dream">Dream</option>
            </select>
            
            <div class="dimension-buttons">
                <button class="dimension-btn" data-dimension="1D">1D</button>
                <button class="dimension-btn active" data-dimension="3D">3D</button>
                <button class="dimension-btn" data-dimension="5D">5D</button>
                <button class="dimension-btn" data-dimension="7D">7D</button>
                <button class="dimension-btn" data-dimension="9D">9D</button>
                <button class="dimension-btn" data-dimension="12D">12D</button>
            </div>
            
            <div class="moon-phase" id="moon-phase" title="Moon Phase: 0/7"></div>
        </div>
    </header>
    
    <main>
        <div class="sidebar">
            <h2>Data Streams</h2>
            <div class="stream-list" id="stream-list">
                <div class="loading">Loading streams...</div>
            </div>
            <button id="new-stream-btn" class="button green" style="width: 100%; margin-top: 1rem;">New Stream</button>
        </div>
        
        <div class="main-content">
            <div class="action-bar">
                <button id="split-btn" class="button" disabled>Split Chunk</button>
                <button id="merge-btn" class="button purple" disabled>Merge Chunks</button>
                <button id="flow-btn" class="button green" disabled>Create Flow</button>
            </div>
            
            <div class="data-content">
                <div class="chunks-container" id="chunks-container">
                    <div class="loading">Select a stream to view chunks</div>
                </div>
                
                <div class="visualization-container">
                    <div class="visualization-title">Data Splitter Visualization</div>
                    <div id="visualization-canvas"></div>
                    <div class="visualization-overlay"></div>
                </div>
            </div>
        </div>
    </main>

    <!-- Include Three.js for advanced visualization -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Include Data Splitter Bridge -->
    <script src="data_splitter_browser_bridge.js"></script>
    
    <script>
        // Enhanced visualization with Three.js
        let scene, camera, renderer, controls;
        let visualizationContainer;
        let dataNodes = {};
        let connectionLines = {};
        
        // Initialize Three.js visualization
        function initVisualization() {
            visualizationContainer = document.getElementById('visualization-canvas');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(
                70, 
                visualizationContainer.clientWidth / visualizationContainer.clientHeight, 
                0.1, 
                1000
            );
            camera.position.z = 10;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(visualizationContainer.clientWidth, visualizationContainer.clientHeight);
            visualizationContainer.innerHTML = '';
            visualizationContainer.appendChild(renderer.domElement);
            
            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
        }
        
        function onWindowResize() {
            camera.aspect = visualizationContainer.clientWidth / visualizationContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(visualizationContainer.clientWidth, visualizationContainer.clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Create a node for data visualization
        function createDataNode(id, data, position) {
            if (dataNodes[id]) {
                scene.remove(dataNodes[id].group);
            }
            
            // Create group to hold node elements
            const group = new THREE.Group();
            
            // Determine colors based on data type
            let color;
            if (data.type === 'text') {
                color = 0x10b981; // Green
            } else if (data.type === 'binary') {
                color = 0x3b82f6; // Blue
            } else if (data.type === 'image') {
                color = 0x8b5cf6; // Purple
            } else {
                color = 0xf59e0b; // Orange
            }
            
            // Create geometry based on data type
            let geometry;
            if (data.type === 'text') {
                geometry = new THREE.BoxGeometry(1, 1, 1);
            } else if (data.type === 'binary') {
                geometry = new THREE.SphereGeometry(0.7, 16, 16);
            } else if (data.type === 'image') {
                geometry = new THREE.CylinderGeometry(0.7, 0.7, 1, 16);
            } else {
                geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
            }
            
            // Create material
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.2,
                shininess: 30
            });
            
            // Create mesh
            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);
            
            // Add text label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.font = '24px Arial';
            context.textAlign = 'center';
            context.fillText(id.substring(0, 12) + '...', 128, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.y = 1;
            sprite.scale.set(2, 1, 1);
            group.add(sprite);
            
            // Position the group
            group.position.set(
                position.x !== undefined ? position.x : (Math.random() * 10 - 5), 
                position.y !== undefined ? position.y : (Math.random() * 10 - 5), 
                position.z !== undefined ? position.z : (Math.random() * 10 - 5)
            );
            
            // Add to scene
            scene.add(group);
            
            // Store for future reference
            dataNodes[id] = {
                group: group,
                data: data,
                position: group.position.clone()
            };
            
            return group;
        }
        
        // Create a connection line between nodes
        function createConnection(sourceId, targetId, type = 'default') {
            const connectionId = `${sourceId}->${targetId}`;
            
            // Remove existing connection if any
            if (connectionLines[connectionId]) {
                scene.remove(connectionLines[connectionId]);
            }
            
            // Skip if either node doesn't exist
            if (!dataNodes[sourceId] || !dataNodes[targetId]) {
                console.warn(`Cannot create connection: Node not found`);
                return null;
            }
            
            // Determine color based on connection type
            let color;
            switch (type) {
                case 'split':
                    color = 0xf59e0b; // Orange
                    break;
                case 'merge':
                    color = 0xec4899; // Pink
                    break;
                case 'flow':
                    color = 0x10b981; // Green
                    break;
                default:
                    color = 0x94a3b8; // Gray
            }
            
            // Create line geometry
            const points = [
                dataNodes[sourceId].position,
                dataNodes[targetId].position
            ];
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color });
            const line = new THREE.Line(geometry, material);
            
            // Add to scene
            scene.add(line);
            
            // Store for future reference
            connectionLines[connectionId] = line;
            
            return line;
        }
        
        // Update visualization based on current data
        function updateVisualization(selectedStreamId = null) {
            // Clear current visualization
            for (const id in dataNodes) {
                scene.remove(dataNodes[id].group);
            }
            dataNodes = {};
            
            for (const id in connectionLines) {
                scene.remove(connectionLines[id]);
            }
            connectionLines = {};
            
            // Stop here if no stream is selected
            if (!selectedStreamId || !window.DataSplitterBridge) {
                return;
            }
            
            const { STATE } = window.DataSplitterBridge;
            
            // Find the selected stream
            const selectedStream = STATE.dataStreams.find(s => s.id === selectedStreamId);
            if (!selectedStream) return;
            
            // Create nodes for chunks in this stream
            if (selectedStream.chunks && selectedStream.chunks.length > 0) {
                // Layout in circular pattern
                const radius = 5;
                const chunkCount = selectedStream.chunks.length;
                
                selectedStream.chunks.forEach((chunkId, index) => {
                    const chunk = STATE.dataChunks[chunkId];
                    if (!chunk) return;
                    
                    // Calculate position in circle
                    const angle = (index / chunkCount) * Math.PI * 2;
                    const position = {
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius,
                        z: 0
                    };
                    
                    createDataNode(chunkId, chunk, position);
                });
                
                // Create node for stream in center
                createDataNode(selectedStreamId, selectedStream, { x: 0, y: 0, z: 0 });
                
                // Create connections to stream
                selectedStream.chunks.forEach(chunkId => {
                    createConnection(selectedStreamId, chunkId, 'flow');
                });
                
                // Connect any split chunks
                Object.values(STATE.dataSplits).forEach(split => {
                    if (selectedStream.chunks.includes(split.original_chunk)) {
                        split.resulting_chunks.forEach(resultId => {
                            if (selectedStream.chunks.includes(resultId)) {
                                createConnection(split.original_chunk, resultId, 'split');
                            }
                        });
                    }
                });
            }
        }
        
        // UI Event Handlers
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize visualization
            initVisualization();
            
            // Dimension button handlers
            const dimensionButtons = document.querySelectorAll('.dimension-btn');
            dimensionButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Update UI
                    dimensionButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    const dimension = button.dataset.dimension;
                    document.body.className = '';
                    document.body.classList.add(`dimension-${dimension.toLowerCase()}`);
                    
                    // Update system
                    if (window.DataSplitterBridge) {
                        window.DataSplitterBridge.API.sendCommand("change_dimension", { dimension });
                    }
                });
            });
            
            // Reality selector handler
            const realitySelector = document.getElementById('reality-selector');
            realitySelector.addEventListener('change', () => {
                if (window.DataSplitterBridge) {
                    window.DataSplitterBridge.API.changeReality(realitySelector.value);
                }
            });
            
            // Stream list click handler
            document.getElementById('stream-list').addEventListener('click', e => {
                const streamItem = e.target.closest('.stream-item');
                if (!streamItem) return;
                
                // Update UI
                document.querySelectorAll('.stream-item').forEach(item => {
                    item.classList.remove('active');
                });
                streamItem.classList.add('active');
                
                // Load chunks for this stream
                const streamId = streamItem.dataset.streamId;
                loadChunksForStream(streamId);
                
                // Update visualization
                updateVisualization(streamId);
            });
            
            // New stream button handler
            document.getElementById('new-stream-btn').addEventListener('click', () => {
                if (!window.DataSplitterBridge) return;
                
                const streamType = prompt("Enter stream type (binary, text, image, sound):", "binary");
                const size = parseInt(prompt("Enter stream size (bytes):", "1024"));
                
                if (streamType && !isNaN(size)) {
                    window.DataSplitterBridge.API.createStream(streamType, size);
                }
            });
            
            // Split button handler
            document.getElementById('split-btn').addEventListener('click', () => {
                if (!window.DataSplitterBridge) return;
                
                const selectedChunks = getSelectedChunks();
                if (selectedChunks.length !== 1) return;
                
                const splitFactor = parseInt(prompt("Enter split factor (2-5):", "3"));
                if (!isNaN(splitFactor) && splitFactor >= 2 && splitFactor <= 5) {
                    window.DataSplitterBridge.API.createSplit(selectedChunks, splitFactor);
                }
            });
            
            // Merge button handler
            document.getElementById('merge-btn').addEventListener('click', () => {
                if (!window.DataSplitterBridge) return;
                
                const selectedChunks = getSelectedChunks();
                if (selectedChunks.length < 2) return;
                
                const mergeType = prompt("Enter merge type (concatenate, interleave):", "concatenate");
                if (mergeType) {
                    window.DataSplitterBridge.API.mergeChunks(selectedChunks, mergeType);
                }
            });
            
            // Flow button handler
            document.getElementById('flow-btn').addEventListener('click', () => {
                if (!window.DataSplitterBridge) return;
                
                const selectedChunks = getSelectedChunks();
                if (selectedChunks.length !== 2) return;
                
                window.DataSplitterBridge.API.sendCommand("create_flow", {
                    source_id: selectedChunks[0],
                    target_id: selectedChunks[1]
                });
            });
            
            // Check for connection status changes
            setInterval(() => {
                if (!window.DataSplitterBridge) return;
                
                const { STATE } = window.DataSplitterBridge;
                const statusDot = document.getElementById('connection-status');
                const statusText = document.getElementById('connection-text');
                
                if (STATE.connected) {
                    statusDot.className = 'status-dot status-connected';
                    statusText.textContent = 'Connected';
                } else {
                    statusDot.className = 'status-dot status-disconnected';
                    statusText.textContent = STATE.connectionError || 'Disconnected';
                }
                
                // Update moon phase
                updateMoonPhase(STATE.moonPhase);
                
                // Update reality selector
                if (STATE.currentReality) {
                    realitySelector.value = STATE.currentReality;
                }
                
                // Update dimension buttons
                if (STATE.currentDimension) {
                    const dimensionBtn = document.querySelector(`.dimension-btn[data-dimension="${STATE.currentDimension}"]`);
                    if (dimensionBtn && !dimensionBtn.classList.contains('active')) {
                        dimensionButtons.forEach(btn => btn.classList.remove('active'));
                        dimensionBtn.classList.add('active');
                        
                        document.body.className = '';
                        document.body.classList.add(`dimension-${STATE.currentDimension.toLowerCase()}`);
                    }
                }
                
                // Refresh stream list
                updateStreamList();
            }, 1000);
            
            // Initialize with mock data for preview
            initWithMockData();
        });
        
        // Update moon phase visualization
        function updateMoonPhase(phase) {
            const moonEl = document.getElementById('moon-phase');
            if (!moonEl) return;
            
            // Update title
            moonEl.title = `Moon Phase: ${phase}/7`;
            
            // Phase 0 = full moon, phase 4 = new moon
            // Update shadow effect to show phase
            const shadowIntensity = Math.abs(phase - 4) / 4.0;
            const shadowOffset = phase < 4 ? 
                -15 + phase * 7.5 : 
                -45 + phase * 7.5;

            moonEl.style.boxShadow = `inset ${shadowOffset}px 0 rgba(0, 0, 0, ${1 - shadowIntensity})`;
            
            // Adjust colors based on phase
            if (phase <= 1 || phase >= 7) {
                // Full/almost full
                moonEl.style.backgroundColor = '#f0f0f0';
            } else if (phase >= 3 && phase <= 5) {
                // New/almost new
                moonEl.style.backgroundColor = '#737373';
            } else {
                // Quarter
                moonEl.style.backgroundColor = '#b3b3b3';
            }
        }
        
        // Update stream list
        function updateStreamList() {
            if (!window.DataSplitterBridge) return;
            
            const { STATE } = window.DataSplitterBridge;
            const streamList = document.getElementById('stream-list');
            
            if (STATE.dataStreams.length === 0) {
                streamList.innerHTML = '<div class="empty-state">No data streams available</div>';
                return;
            }
            
            // Keep track of active stream
            let activeStreamId = null;
            const activeStream = document.querySelector('.stream-item.active');
            if (activeStream) {
                activeStreamId = activeStream.dataset.streamId;
            }
            
            // Build stream list
            let streamHtml = '';
            STATE.dataStreams.forEach(stream => {
                // Get color for reality type
                const realityType = stream.reality || STATE.currentReality;
                let borderColor = '#3b82f6'; // Default blue
                
                switch (realityType) {
                    case 'physical': borderColor = '#3b82f6'; break; // Blue
                    case 'digital': borderColor = '#10b981'; break; // Green
                    case 'astral': borderColor = '#8b5cf6'; break; // Purple
                    case 'quantum': borderColor = '#ec4899'; break; // Pink
                    case 'memory': borderColor = '#f59e0b'; break; // Orange
                    case 'dream': borderColor = '#6366f1'; break; // Indigo
                }
                
                // Create stream HTML
                streamHtml += `
                    <div class="stream-item ${stream.id === activeStreamId ? 'active' : ''}" 
                         data-stream-id="${stream.id}" 
                         style="border-left-color: ${borderColor}">
                        <div class="stream-title">${stream.id}</div>
                        <div class="stream-meta">
                            Type: ${stream.type || 'binary'}, Size: ${stream.size || '0'} bytes
                        </div>
                        <div class="stream-meta">
                            Chunks: ${stream.chunks ? stream.chunks.length : 0}
                        </div>
                    </div>
                `;
            });
            
            // Update only if changed to avoid layout thrashing
            if (streamList.innerHTML !== streamHtml) {
                streamList.innerHTML = streamHtml;
            }
        }
        
        // Load chunks for a stream
        function loadChunksForStream(streamId) {
            if (!window.DataSplitterBridge) return;
            
            const { STATE } = window.DataSplitterBridge;
            const chunksContainer = document.getElementById('chunks-container');
            
            // Find the stream
            const stream = STATE.dataStreams.find(s => s.id === streamId);
            if (!stream) {
                chunksContainer.innerHTML = '<div class="loading">Stream not found</div>';
                return;
            }
            
            if (!stream.chunks || stream.chunks.length === 0) {
                chunksContainer.innerHTML = '<div class="loading">No chunks in this stream</div>';
                return;
            }
            
            // Get chunks for this stream
            chunksContainer.innerHTML = '';
            
            stream.chunks.forEach(chunkId => {
                const chunk = STATE.dataChunks[chunkId];
                if (!chunk) return;
                
                // Create chunk element
                const chunkEl = document.createElement('div');
                chunkEl.className = 'data-chunk';
                chunkEl.dataset.chunkId = chunkId;
                
                // Determine background color based on type
                let bgColor = '#1e293b'; // Default bg
                switch (chunk.type || 'binary') {
                    case 'text': bgColor = 'rgba(16, 185, 129, 0.2)'; break; // Green
                    case 'binary': bgColor = 'rgba(59, 130, 246, 0.2)'; break; // Blue
                    case 'image': bgColor = 'rgba(139, 92, 246, 0.2)'; break; // Purple
                    case 'sound': bgColor = 'rgba(236, 72, 153, 0.2)'; break; // Pink
                    case 'command': bgColor = 'rgba(245, 158, 11, 0.2)'; break; // Orange
                }
                chunkEl.style.backgroundColor = bgColor;
                
                // Truncate content for display
                let displayContent = chunk.content || '[Binary Data]';
                if (typeof displayContent === 'string' && displayContent.length > 100) {
                    displayContent = displayContent.substring(0, 97) + '...';
                }
                
                chunkEl.innerHTML = `
                    <div class="chunk-content">${displayContent}</div>
                    <div class="chunk-footer">
                        Size: ${chunk.size || '0'} bytes<br>
                        ID: ${chunkId.substring(0, 8)}...
                    </div>
                `;
                
                // Add click handler for selection
                chunkEl.addEventListener('click', e => {
                    if (e.ctrlKey || e.metaKey) {
                        // Multi-select with Ctrl/Cmd
                        chunkEl.classList.toggle('selected');
                    } else {
                        // Single select
                        document.querySelectorAll('.data-chunk').forEach(el => {
                            el.classList.remove('selected');
                        });
                        chunkEl.classList.add('selected');
                    }
                    
                    // Update button states
                    updateButtonStates();
                });
                
                chunksContainer.appendChild(chunkEl);
            });
        }
        
        // Get selected chunk IDs
        function getSelectedChunks() {
            const selectedElements = document.querySelectorAll('.data-chunk.selected');
            return Array.from(selectedElements).map(el => el.dataset.chunkId);
        }
        
        // Update button enabled states based on selection
        function updateButtonStates() {
            const selectedChunks = getSelectedChunks();
            
            const splitBtn = document.getElementById('split-btn');
            const mergeBtn = document.getElementById('merge-btn');
            const flowBtn = document.getElementById('flow-btn');
            
            splitBtn.disabled = selectedChunks.length !== 1;
            mergeBtn.disabled = selectedChunks.length < 2;
            flowBtn.disabled = selectedChunks.length !== 2;
        }
        
        // Initialize with mock data for preview
        function initWithMockData() {
            // Create mock streams
            const mockStreams = [
                { id: 'text_stream_1', type: 'text', size: 1024, reality: 'digital', chunks: ['chunk_1', 'chunk_2', 'chunk_3'] },
                { id: 'binary_stream_1', type: 'binary', size: 2048, reality: 'physical', chunks: ['chunk_4', 'chunk_5'] },
                { id: 'image_stream_1', type: 'image', size: 4096, reality: 'astral', chunks: ['chunk_6', 'chunk_7', 'chunk_8', 'chunk_9'] }
            ];
            
            // Create mock chunks
            const mockChunks = {
                'chunk_1': { id: 'chunk_1', type: 'text', content: 'This is a text chunk with some sample content.', size: 256, parent_stream: 'text_stream_1' },
                'chunk_2': { id: 'chunk_2', type: 'text', content: 'Another text chunk with different content.', size: 320, parent_stream: 'text_stream_1' },
                'chunk_3': { id: 'chunk_3', type: 'text', content: 'Third text chunk that could be split.', size: 448, parent_stream: 'text_stream_1' },
                'chunk_4': { id: 'chunk_4', type: 'binary', content: '[Binary data representation]', size: 1024, parent_stream: 'binary_stream_1' },
                'chunk_5': { id: 'chunk_5', type: 'binary', content: '[Another binary data block]', size: 1024, parent_stream: 'binary_stream_1' },
                'chunk_6': { id: 'chunk_6', type: 'image', content: '[Image data 1]', size: 1024, parent_stream: 'image_stream_1' },
                'chunk_7': { id: 'chunk_7', type: 'image', content: '[Image data 2]', size: 1024, parent_stream: 'image_stream_1' },
                'chunk_8': { id: 'chunk_8', type: 'image', content: '[Image data 3]', size: 1024, parent_stream: 'image_stream_1' },
                'chunk_9': { id: 'chunk_9', type: 'image', content: '[Image data 4]', size: 1024, parent_stream: 'image_stream_1' }
            };
            
            // Create mock splits
            const mockSplits = {
                'split_1': {
                    id: 'split_1',
                    original_chunk: 'chunk_3',
                    resulting_chunks: ['chunk_3_1', 'chunk_3_2', 'chunk_3_3'],
                    factor: 3
                }
            };
            
            // Add split results
            mockChunks['chunk_3_1'] = { id: 'chunk_3_1', type: 'text', content: 'Third text', size: 150, parent_stream: 'text_stream_1' };
            mockChunks['chunk_3_2'] = { id: 'chunk_3_2', type: 'text', content: 'chunk that', size: 150, parent_stream: 'text_stream_1' };
            mockChunks['chunk_3_3'] = { id: 'chunk_3_3', type: 'text', content: 'could be split.', size: 148, parent_stream: 'text_stream_1' };
            
            // Add to stream
            mockStreams[0].chunks.push('chunk_3_1', 'chunk_3_2', 'chunk_3_3');
            
            // Set mock data on bridge
            if (window.DataSplitterBridge) {
                window.DataSplitterBridge.STATE.dataStreams = mockStreams;
                window.DataSplitterBridge.STATE.dataChunks = mockChunks;
                window.DataSplitterBridge.STATE.dataSplits = mockSplits;
                window.DataSplitterBridge.STATE.currentReality = 'digital';
                window.DataSplitterBridge.STATE.currentDimension = '3D';
                window.DataSplitterBridge.STATE.moonPhase = 0;
                window.DataSplitterBridge.STATE.connected = true;
            }
            
            // Update UI
            updateStreamList();
            updateMoonPhase(0);
        }
    </script>
</body>
</html>