#
# JSH Ethereal Engine
#
#      oooo  .oooooo..o ooooo   ooooo 
#      `888 d8P'    `Y8 `888'   `888' 
#       888 Y88bo.       888     888     ┏┓ ┓         ┓  ┏┓    •      ┏┓        
#       888  `"Y8888o.   888ooooo888     ┣ ╋┣┓┏┓┏┓┏┓┏┓┃  ┣ ┏┓┏┓┓┏┓┏┓  ┗┓┓┏┏╋┏┓┏┳┓
#       888      `"Y88b  888     888     ┗┛┗┛┗┗ ┛ ┗ ┗┻┗  ┗┛┛┗┗┫┗┛┗┗   ┗┛┗┫┛┗┗ ┛┗┗
#       888 oo     .d8P  888     888                          ┛          ┛      
#   .o. 88P 8""88888P'  o888o   o888o 
#   `Y888P                            
#
# JSH Ethereal Engine
#

# so me, others me from dreams, and whoever i hear i guess, we work together, through space and time, to make that vidya ive been day dreaming for past 20 years
# cmon
extends Node3D



var first_start_check : String = "pending"
# the last hope to figure out, why a task failed, was started, but didnt quite get anywhere?
var int_of_stuff_started : int = 0
var int_of_stuff_finished : int = 0


# a new jewish hope, for new process frame intel
#signal frame_processed
#var frame_signal_connected := false

# the files, directiories, folders, spaces, places, data
var path = "D:/Eden"
var file_path
var files_content
var folders_content
var directory_existence = false
var folders_existence = false
var files_existence = false

# the scripts, that we apply to datapoints, containers, line for clicky
const DataPointScript = preload("res://scripts/data_point.gd")
const ContainterScript = preload("res://scripts/containter.gd")
const LineScript = preload("res://scripts/line.gd")

# the ready stuff, first container, akashic_records and ray thingy stuff screen, mouse lol
var ray_distance_set = 20.0
var viewport
var mouse_pos
var camera

# the delta idea of turns and moves, so we always have it easy as we spread the tasks
var turn_number_process : int = 0
var delta_turn_0 : int = 0

# the active and cached data, for creation, recreation etc
var active_record_sets: Dictionary = {}
var active_r_s_mut = Mutex.new()



var cached_record_sets: Dictionary = {}
var cached_r_s_mutex = Mutex.new()



# current state of set, being created, its name as string
var list_of_sets_to_create : Array = []
var array_mutex_process = Mutex.new()

# data to be put for my eyes
var max_nodes_added_per_cycle : int = 369
var nodes_to_be_added_int : int = 0
var nodes_to_be_added : Array = []
var mutex_nodes_to_be_added = Mutex.new()

# second impact of creation data
var max_data_send_per_cycle : int = 369
var data_to_be_send : Array = []
var mutex_data_to_send = Mutex.new()




# moving and rotating things
var max_movements_per_cycle : int = 369
var things_to_be_moved : Array = []
var movmentes_mutex = Mutex.new()





# the unloading stuff
var max_nodes_to_unload_per_cycle : int = 369
var nodes_to_be_unloaded : Array = []
var mutex_for_unloading_nodes = Mutex.new()




# the function caller from main thread
var max_functions_called_per_cycle : int = 369
var functions_to_be_called : Array = []
var mutex_function_call = Mutex.new()





# the godot tree, didnt respect my needs, made my own, even signed it
var scene_tree_jsh : Dictionary = {}
var tree_mutex = Mutex.new()




var cached_jsh_tree_branches : Dictionary = {}
var cached_tree_mutex = Mutex.new()









var status_symbol = {
	"active": "●",
	"pending": "○", 
	"disabled": "×"
}

var cache_timestamps: Dictionary = {}
var max_cache_size_mb: int = 8 #50

# like C and D on windows, so drives, maybe some /home or whatever others use
var available_directiories : Array = []

@onready var thread_pool = get_node("/root/thread_pool_autoload")

var curent_queue : Array = [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0]] 

var the_menace_checker : int = 0
var menace_mutex = Mutex.new()






var array_for_counting_finish : Dictionary = {}
var array_counting_mutex = Mutex.new()



# the godly messengers with data, getting them download, and even uploading information
var download_received : Dictionary = {}
var upload_to_send : Dictionary = {}


var current_containers_state : Dictionary = {}
var mutex_for_container_state = Mutex.new()




var menace_tricker_checker : int = -2
var mutex_for_trickery = Mutex.new()



var unload_queue : Dictionary = {}
var unload_queue_mutex = Mutex.new()



var load_queue : Dictionary = {}
var load_queue_mutex = Mutex.new()


# list of containers, group of containers too maybe? lets use both, for shish and giggle

#

var mutex_containers = Mutex.new() # Mutex kurwa, not Metex Mutex Mutex Mutex
var list_of_containers : Dictionary = {}







var mutex_singular_l_u = Mutex.new()


var array_with_no_mutex : Array = []

var dictionary_of_mistakes : Dictionary = {}
var dictionary_of_mistakes_mutex = Mutex.new()

# tree_mutex


var task_timeouts = {}
var max_task_duration = 50000 # 50 seconds


# Should be expanded to:
var task_timestamps = {}
var task_status = {}

#var first_run_check_string : String = ""




# we can add new records, new things to a record, duplicate a record
var creation_can_happen

# something didnt work out as planned, so a real story history of past
var mistakes_of_past

# the is nothing to create, so we can clean now
var deletion_process_can_happen

# nothing is to be added, or deleted
var movement_possible
# kinda the same, just changing text, maybe changing mesh?
var edit_possible

# state of main core features
# first start
var fsc_status = null
# first delta
var fdc_status = null
# first task
var ftc_status = null

enum SystemState {
	UNKNOWN = -1,
	INACTIVE = 0,
	ACTIVE = 1,
	BUSY = 2,
	ERROR = 3
}

# Enum for possible creation states
enum CreationStatus {
	ERROR = -1,
	SUCCESS = 0,
	PENDING = 1,
	INVALID_INPUT = 2,
	LOCKED = 3
}

enum CreationState {
	INACTIVE = -1,
	POSSIBLE = 0,
	IN_PROGRESS = 1,
	LOCKED = 2,
	ERROR = 3
}


# Core system states that need mutex protection
var core_states := {
	"mutex": Mutex.new(),  # Single mutex for all core states
	"states": {
		"creation": SystemState.INACTIVE,
		"deletion": SystemState.INACTIVE,
		"movement": SystemState.INACTIVE,
		"edit": SystemState.INACTIVE
	}
}

# First-time checks (need mutex as they're initialization flags)
var initialization_states := {
	"mutex": Mutex.new(),
	"states": {
		"first_start": null,      # fsc_status
		"first_delta": null,      # fdc_status
		"first_task": null        # ftc_status
	}
}

# History tracking (needs mutex for concurrent access)
var history_tracking := {
	"mutex": Mutex.new(),
	"mistakes": [],  # mistakes_of_past
	"creation_history": [],
	"deletion_history": []
}

# Time tracking (needs mutex for concurrent updates)
var time_tracking := {
	"mutex": Mutex.new(),
	"delta_history": [],
	"godot_timers": {},
	"last_update": Time.get_ticks_msec()
}


# Add properties to track main script memory
var memory_metadata = {
	"arrays": {
		"blimp_of_time": [],
		"stored_delta_memory": [],
		"past_deltas_memories": [],
		"array_with_no_mutex": [],
		"list_of_sets_to_create": []
	},
	"dictionaries": {
		"active_record_sets": {},
		"cached_record_sets": {},
		"scene_tree_jsh": {},
		"current_containers_state": {},
		"dictionary_of_mistakes": {}
	},
	"last_cleanup": Time.get_ticks_msec(),
	"cleanup_thresholds": {
		"array_max": 1000,  # Max array entries
		"dict_max_mb": 50,  # Max dictionary size in MB
		"time_between_cleanups": 30000  # 30 seconds
	}
}


var message_of_delta_start

var array_of_startup_check : Array = []

signal main_node_signal(place)

var timer_system: GodotTimersSystem